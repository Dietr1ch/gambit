diff --git a/include/thermodynamics.h b/include/thermodynamics.h
index 7338af64..022cf6fc 100755
--- a/include/thermodynamics.h
+++ b/include/thermodynamics.h
@@ -64,7 +64,8 @@ enum energy_deposition_function {
   No_deposition, /**< No energy deposition is considered. Useful for pedagogic illustration. */
   Analytical_approximation, /**< Analytical energy deposition treatment, introduced in 1209.0247 and corrected in 1612.05644 */
   DarkAges,  /**< f(z) functions computed in the DarkAges modules following the work by Slatyer, introduced in 1211.0283 and updated in 1506.03812 */
-  function_from_file /**<  File specified by the user with the option "energy deposition function file"*/
+  function_from_file, /**<  File specified by the user with the option "energy deposition function file"*/
+  GAMBIT /**< f(z) will be calculated by Gambit. */
 };
 
 /**
diff --git a/source/input.c b/source/input.c
index 77cf1202..e2bf86f2 100644
--- a/source/input.c
+++ b/source/input.c
@@ -5,6 +5,7 @@
  */
 
 #include "input.h"
+#include <stdint.h> // to get uintptr_t type to convert int to pointer
 
 /**
  * Use this routine to extract initial parameters from files 'xxx.ini'
@@ -792,7 +792,7 @@ int input_read_parameters(
       pba->Omega_ini_dcdm = param1;
     if (flag2 == _TRUE_)
       pba->Omega_ini_dcdm = param2/pba->h/pba->h;
-
+  }
     /* Read Gamma in same units as H0, i.e. km/(s Mpc)*/
     class_call(parser_read_double(pfc,"Gamma_dcdm",&param1,&flag1,errmsg),
                errmsg,
@@ -816,7 +816,6 @@ int input_read_parameters(
       pba->Gamma_dcdm = 1/(param2/(1e9*365*24*3600))/1.02e-3*(1.e3 / _c_); //1 km s^-1 Mpc-^1 = 1.02* 10^-3 Gyr^-1
       pba->tau_dcdm = param2;
     }
-  }
 
   /** - non-cold relics (ncdm) */
   class_read_int("N_ncdm",N_ncdm);
@@ -1601,6 +1601,138 @@
         pth->has_on_the_spot = _FALSE_;
  flag3=_TRUE_;
       }
+      // check if exo-class is used with gambit 
+      if (strcmp(string1,"GAMBIT") == 0) {
+      /* NOTE:
+        This is to read in values stored in a vector/array and pass the entries to a dynamically allocated
+        array in class. 
+        Here: e.g. double* pth->annihil_coef_xe will be set to point to address of newly allocated space which
+            will be filled with entries of passed vector
+
+        Complication: If python wrapper is used all input values are converted to strings, including the pointers
+          to the vectors/arrays to be passed. Therefore memory addresses are converted to uintptr_t, read in as string
+          here, converted to uintptr_t and then back to memory addresses. We have to go through uintptr_t since this
+          type is designed to be long enough to store memory addresses on the current systems. (Int would be too 
+          short, hence, we can not use the class parser_read_int but have to read it in as string first.)
+
+        What is done in the following is:
+          1) Read in pointers to vectors as strings
+          2) Convert strings to uintptr_t, then to memory address & initialise a double pointer pointing to it
+          3) Allocate new space for pth->_some_thermodynamics_double_pointer
+          4) Copy the values of the passed vector to the newly allocated space
+      */
+         // set CLASS parameters to signal that annihilation coefficients will be filled differently
+         pth->energy_deposition_function=GAMBIT;
+         pth->energy_repart_coefficient = no_factorization;
+         pth->has_on_the_spot = _FALSE_;
+         flag3=_TRUE_;
+
+         // initialise flags & chars here -- flag1-flag3 already defined, patch might be easier to maintain if
+         // these definitions happen here within the patched part
+         int flag0,flag4,flag5,flag6,flag7,flag8,flag9; 
+         char addr [_ARGUMENT_LENGTH_MAX_];
+         uintptr_t ul;
+
+         // read in number of entries each vector has
+         class_call(parser_read_int(pfc,"annihil_coef_num_lines",&pth->annihil_coef_num_lines,&flag0,errmsg),
+             errmsg,
+             errmsg);
+
+         // 1) Read in pointers to vector as string
+         class_call(parser_read_string(pfc,"annihil_coef_xe",&addr,&flag4,errmsg),
+             errmsg,
+             errmsg);
+         // 2) Convert string to uintptr_t and then back to memory address;
+         //    initialise a double pointer pointing to it
+         sscanf(addr, "%lu", &ul);
+         double* ptr_xe = (double*) ul;
+
+         class_call(parser_read_string(pfc,"annihil_coef_heat",&addr,&flag5,errmsg),
+             errmsg,
+             errmsg);
+         sscanf(addr, "%lu", &ul);
+         double* ptr_heat = (double*) ul;
+
+         class_call(parser_read_string(pfc,"annihil_coef_lya",&addr,&flag6,errmsg),
+             errmsg,
+             errmsg);
+         sscanf(addr, "%lu", &ul);
+         double* ptr_lya = (double*) ul;
+         
+         class_call(parser_read_string(pfc,"annihil_coef_ionH",&addr,&flag7,errmsg),
+             errmsg,
+             errmsg);
+         sscanf(addr, "%lu", &ul);
+         double* ptr_ionH = (double*) ul;
+         
+
+         class_call(parser_read_string(pfc,"annihil_coef_ionHe",&addr,&flag8,errmsg),
+             errmsg,
+             errmsg);
+         sscanf(addr, "%lu", &ul);
+         double* ptr_ionHe = (double*) ul;
+         
+         class_call(parser_read_string(pfc,"annihil_coef_lowE",&addr,&flag9,errmsg),
+             errmsg,
+             errmsg);
+         sscanf(addr, "%lu", &ul);
+         double* ptr_lowE = (double*) ul;
+         
+         
+         // Check that all values needed for the calculation have been passed. If not throw error
+         class_test(((flag0 == _FALSE_) || (flag4 == _FALSE_) || (flag5 == _FALSE_) || (flag6 == _FALSE_) || (flag7 == _FALSE_)
+                    || (flag8 == _FALSE_) || (flag9 == _FALSE_)),
+                    errmsg,
+                    "You set the parameter energy_deposition_function to GAMBIT, this means you also haveto specify the input values for \n- annihil_coef_num_lines \n- annihil_coef_xe \n- annihil_coef_heat \n- annihil_coef_lya \n- annihil_coef_ionH\n- annihil_coef_ionHe\n- annihil_coef_lowE\n Check that all of them are passed.");
+
+          
+          // just checking if that worked ..
+          /*printf("     CLASS internal \n\n\n");          
+          for (int it = 0; it < pth->annihil_coef_num_lines; it++)
+          {
+             printf("              passed xe coefficients at %i with %e at address %p\n", it, &ptr_xe[it],ptr_xe[it]);
+          }*/
+
+          
+          // 3) allocate new space
+          //    (since this is the begining of a run and we clean all structures before each new point 
+          //    the pointers 'pth->annihil_coef_xe'... are not pointing to anything at the moment
+          //    so we can be sure we want have a 
+
+          class_alloc(pth->annihil_coef_xe   , pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+          class_alloc(pth->annihil_coef_heat , pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+          class_alloc(pth->annihil_coef_lya  , pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+          class_alloc(pth->annihil_coef_ionH , pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+          class_alloc(pth->annihil_coef_ionHe, pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+          class_alloc(pth->annihil_coef_lowE , pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+
+          // 4) Copy the values of the passed vector to the newly allocated space
+          for (int it = 0; it < pth->annihil_coef_num_lines; it++)
+          {
+             pth->annihil_coef_xe[it] = ptr_xe[it];
+             pth->annihil_coef_heat[it] = ptr_heat[it];
+             pth->annihil_coef_lya[it] = ptr_lya[it];
+             pth->annihil_coef_ionH[it] = ptr_ionH[it];
+             pth->annihil_coef_ionHe[it] = ptr_ionHe[it];
+             pth->annihil_coef_lowE[it] = ptr_lowE[it];
+          }
+          
+
+         // check again if it worked .. 
+         /*for (int it = 0; it < pth->annihil_coef_num_lines; it++)
+          {
+            printf("              filled annihil_coef_xe at %i with %e at address %p\n", it, pth->annihil_coef_xe[it],&pth->annihil_coef_xe[it]);
+          }*/        
+
+          // allocate space for the other structure members that have same length as the above arrays
+          // the allocation for these is skipped in the thermodynamics.c routine if the GAMBIT file format is passed
+          class_alloc(pth->annihil_coef_dd_heat , pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+          class_alloc(pth->annihil_coef_dd_lya  , pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+          class_alloc(pth->annihil_coef_dd_ionH , pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+          class_alloc(pth->annihil_coef_dd_ionHe, pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+          class_alloc(pth->annihil_coef_dd_lowE , pth->annihil_coef_num_lines*sizeof(double),pth->error_message);
+      }
+
       if (strcmp(string1,"from_file") == 0) {
  pth->energy_deposition_function=function_from_file;
  class_call(parser_read_string(pfc,"energy deposition function file",&string1,&flag1,errmsg),
diff --git a/source/thermodynamics.c b/source/thermodynamics.c
index ddc40b2e..7d527e74 100755
--- a/source/thermodynamics.c
+++ b/source/thermodynamics.c
@@ -1305,7 +1305,7 @@ int thermodynamics_annihilation_coefficients_init(
      heat, excitation of lyman-alpha level, Hydrogen ionisation, Helium ionisation, photons below 10.2 eV unseeable by the IGM.
 
   */
-
+if (pth->energy_deposition_function != GAMBIT) {
   /* BEGIN: Add switch (1) */
   if (pth->energy_deposition_function == function_from_file || pth->energy_repart_coefficient == GSVI || pth->energy_repart_coefficient == chi_from_file) {
     class_open(fA,ppr->energy_injec_coeff_file, "r",pth->error_message);
@@ -1401,7 +1401,7 @@ int thermodynamics_annihilation_coefficients_init(
     class_test(status != 0., pth->error_message, "The attempt to launch the external command was not successful. Maybe the output of the external command is not in the right format.");
   }
   /* END */
-
+ } else {num_lines = pth->annihil_coef_num_lines;}
   /* spline in one dimension */
   class_call(array_spline_table_lines(pth->annihil_coef_xe,
                                       num_lines,
@@ -2291,7 +2291,7 @@ int thermodynamics_energy_injection(
             // fprintf(stdout, "energy_rate %e preco->f_eff %e\n", result,preco->f_eff);
       }
       // // /***********************************************************************************************************************/
-      else if(preco->energy_deposition_function == DarkAges){
+      else if(preco->energy_deposition_function == DarkAges || preco->energy_deposition_function == GAMBIT){
 
             class_call(thermodynamics_onthespot_energy_injection(ppr,pba,preco,z,&result,error_message),
                       error_message,
@@ -3967,7 +3967,7 @@ int thermodynamics_recombination_with_cosmorec(
         }
   }
   // // /***********************************************************************************************************************/
-  else if(preco->energy_deposition_function == DarkAges){
+  else if(preco->energy_deposition_function == DarkAges || preco->energy_deposition_function == GAMBIT){
       class_call(thermodynamics_annihilation_coefficients_interpolate(ppr,pba,pth,600),
                      pth->error_message,
                      pth->error_message);
@@ -4262,9 +4262,9 @@ class_stop(pth->error_message,
            if(pth->energy_deposition_function==Analytical_approximation) {
              hyrec_data.cosmo->inj_params->energy_deposition_treatment = 0;
            }
-           else if(pth->energy_deposition_function==function_from_file || pth->energy_deposition_function==DarkAges) {
-             hyrec_data.cosmo->inj_params->energy_deposition_treatment = 1;
-           }
+	   else if(pth->energy_deposition_function==function_from_file || pth->energy_deposition_function==DarkAges || preco->energy_deposition_function == GAMBIT) {
+	     hyrec_data.cosmo->inj_params->energy_deposition_treatment = 1;
+	   }
            if(pth->energy_repart_coefficient==no_factorization) hyrec_data.cosmo->inj_params->energy_repart_coefficient = 0;
            else if(pth->energy_repart_coefficient==GSVI || pth->energy_repart_coefficient ==chi_from_file) hyrec_data.cosmo->inj_params->energy_repart_coefficient = 1;
            else if(pth->energy_repart_coefficient==SSCK) hyrec_data.cosmo->inj_params->energy_repart_coefficient = 2;
