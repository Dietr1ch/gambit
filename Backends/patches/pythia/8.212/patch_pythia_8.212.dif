diff -rupN 8.212_original/include/Pythia8/ParticleData.h 8.212/include/Pythia8/ParticleData.h
--- 8.212_original/include/Pythia8/ParticleData.h	2015-09-23 17:34:38.000000000 +0200
+++ 8.212/include/Pythia8/ParticleData.h	2017-04-12 15:27:59.721471853 +0200
@@ -347,6 +347,10 @@ public:
   bool init(string startFile = "../xmldoc/ParticleData.xml") {
     initCommon(); return readXML(startFile);}
 
+  // Read in database from saved file stored in memory
+  bool init(const ParticleData &particleDataIn) {
+    initCommon(); return copyXML(particleDataIn);}
+
   // Overwrite existing database by reading from specific file.
   bool reInit(string startFile, bool xmlFormat = true) { initCommon();
     return (xmlFormat) ? readXML(startFile) : readFF(startFile);}
@@ -354,10 +358,17 @@ public:
   // Initialize pointers, normal Breit-Wigners and special resonances.
   void initWidths(vector<ResonanceWidths*> resonancePtrs);
 
-  // Read or list whole (or part of) database from/to an XML file.
+  // Read and process or list whole (or part of) database from/to an XML file.
   bool readXML(string inFile, bool reset = true) ;
   void listXML(string outFile);
 
+  // Copy and process XML information from another particleData object
+  bool copyXML(const ParticleData &particleDataIn);
+
+  // Auxiliary functions to readXML() and copyXML():
+  bool loadXML(string inFile, bool reset = true) ;
+  bool processXML(bool reset = true) ;
+
   // Read or list whole (or part of) database from/to a free format file.
   bool readFF(string inFile, bool reset = true) ;
   void listFF(string outFile);
@@ -560,6 +571,9 @@ public:
   ParticleDataEntry* particleDataEntryPtr(int idIn) {
     return (isParticle(idIn)) ? &pdt[abs(idIn)] : &pdt[0]; }
 
+  // Check initialisation status.
+  bool getIsInit() {return isInit;}
+  
 private:
 
   // Common data, accessible for the individual particles.
@@ -607,6 +621,9 @@ private:
   int    intAttributeValue(string line, string attribute);
   double doubleAttributeValue(string line, string attribute);
 
+  // Vector of strings containing the readable lines of the XML file
+  vector<string> xmlFileSav;
+  
 };
 
 //==========================================================================
diff -rupN 8.212_original/include/Pythia8/PartonDistributions.h 8.212/include/Pythia8/PartonDistributions.h
--- 8.212_original/include/Pythia8/PartonDistributions.h	2015-09-23 17:34:38.000000000 +0200
+++ 8.212/include/Pythia8/PartonDistributions.h	2017-04-12 15:27:59.721471853 +0200
@@ -156,9 +156,8 @@ class MSTWpdf : public PDF {
 public:
 
   // Constructor.
-  MSTWpdf(int idBeamIn = 2212, int iFitIn = 1,
-    string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-    : PDF(idBeamIn) {init( iFitIn,  xmlPath, infoPtr);}
+  MSTWpdf(int idBeamIn = 2212, int iFitIn = 1, string xmlPath = "../xmldoc/",
+    Info* infoPtr = 0) : PDF(idBeamIn) {init( iFitIn,  xmlPath, infoPtr);}
 
 private:
 
@@ -209,9 +208,8 @@ class CTEQ6pdf : public PDF {
 public:
 
   // Constructor.
-  CTEQ6pdf(int idBeamIn = 2212, int iFitIn = 1,
-    string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-    : PDF(idBeamIn) {init( iFitIn, xmlPath, infoPtr);}
+  CTEQ6pdf(int idBeamIn = 2212, int iFitIn = 1, string xmlPath = "../xmldoc/",
+    Info* infoPtr = 0) : PDF(idBeamIn) {init( iFitIn, xmlPath, infoPtr);}
 
 private:
 
@@ -333,8 +331,8 @@ public:
 
   // Constructor.
  PomH1FitAB(int idBeamIn = 990, int iFit = 1, double rescaleIn = 1.,
-   string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-   : PDF(idBeamIn) {rescale = rescaleIn; init( iFit, xmlPath, infoPtr);}
+   string xmlPath = "../xmldoc/", Info* infoPtr = 0) : PDF(idBeamIn)
+   {rescale = rescaleIn; init( iFit, xmlPath, infoPtr);}
 
 private:
 
@@ -365,8 +363,8 @@ public:
 
   // Constructor.
   PomH1Jets(int idBeamIn = 990,  double rescaleIn = 1.,
-   string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-   : PDF(idBeamIn) {rescale = rescaleIn; init( xmlPath, infoPtr);}
+   string xmlPath = "../xmldoc/", Info* infoPtr = 0) : PDF(idBeamIn)
+   {rescale = rescaleIn; init( xmlPath, infoPtr);}
 
 private:
 
@@ -464,22 +462,14 @@ class NNPDF : public PDF {
 public:
 
   // Constructor.
-  NNPDF(int idBeamIn = 2212, int iFitIn = 1,
-    string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-    : PDF(idBeamIn), fPDFGrid(NULL), fXGrid(NULL), fLogXGrid(NULL),
-    fQ2Grid(NULL), fLogQ2Grid(NULL), fRes(NULL) {
-    init( iFitIn, xmlPath, infoPtr); };
+  NNPDF(int idBeamIn = 2212, int iFitIn = 1, string xmlPath = "../xmldoc/",
+    Info* infoPtr = 0) : PDF(idBeamIn), fPDFGrid(NULL), fXGrid(NULL),
+    fLogXGrid(NULL), fQ2Grid(NULL), fLogQ2Grid(NULL), fRes(NULL){
+      init( iFitIn, xmlPath, infoPtr); };
 
   // Destructor.
   ~NNPDF() {
-    if (fPDFGrid) {
-      for (int i = 0; i < fNFL; i++) {
-        for (int j = 0; j < fNX; j++)
-          if (fPDFGrid[i][j]) delete[] fPDFGrid[i][j];
-        if (fPDFGrid[i]) delete[] fPDFGrid[i];
-      }
-      delete[] fPDFGrid;
-    }
+    if (fPDFGrid) delete[] fPDFGrid;
     if (fXGrid) delete[] fXGrid;
     if (fLogXGrid) delete[] fLogXGrid;
     if (fQ2Grid) delete[] fQ2Grid;
@@ -499,7 +489,7 @@ private:
 
   // Variables to be set during code initialization.
   int iFit, fNX, fNQ2;
-  double ***fPDFGrid;
+  double *fPDFGrid;
   double *fXGrid;
   double *fLogXGrid;
   double *fQ2Grid;
diff -rupN 8.212_original/include/Pythia8/Pythia.h 8.212/include/Pythia8/Pythia.h
--- 8.212_original/include/Pythia8/Pythia.h	2015-09-23 17:34:39.000000000 +0200
+++ 8.212/include/Pythia8/Pythia.h	2017-04-12 15:27:59.725471894 +0200
@@ -56,6 +56,11 @@ public:
   // Constructor. (See Pythia.cc file.)
   Pythia(string xmlDir = "../share/Pythia8/xmldoc", bool printBanner = true);
 
+  // Special constructor to copy settings and particle database from another
+  // Pythia object instead of XML files (to speed up multiple initialisations)
+  Pythia(ParticleData& particleDataIn, Settings& settingsIn,
+         bool printBanner = true);
+  
   // Destructor. (See Pythia.cc file.)
   ~Pythia();
 
@@ -119,7 +124,7 @@ public:
     spacePtr = spacePtrIn; return true;}
 
   // Initialize.
-  bool init();
+  bool init(ostream& os = cout);
 
   // Generate the next event.
   bool next();
diff -rupN 8.212_original/include/Pythia8/Settings.h 8.212/include/Pythia8/Settings.h
--- 8.212_original/include/Pythia8/Settings.h	2015-09-23 17:34:39.000000000 +0200
+++ 8.212/include/Pythia8/Settings.h	2017-04-12 15:27:59.725471894 +0200
@@ -302,6 +302,9 @@ public:
   void resetMVec(string keyIn);
   void resetPVec(string keyIn);
 
+  // Check initialisation status
+  bool getIsInit() {return isInit;}
+  
 private:
 
   // Pointer to various information on the generation.
diff -rupN 8.212_original/include/Pythia8/SusyLesHouches.h 8.212/include/Pythia8/SusyLesHouches.h
--- 8.212_original/include/Pythia8/SusyLesHouches.h	2015-09-23 17:34:40.000000000 +0200
+++ 8.212/include/Pythia8/SusyLesHouches.h	2017-04-12 15:27:59.725471894 +0200
@@ -14,6 +14,9 @@
 #define Pythia8_SLHA_H
 
 #include "Pythia8/PythiaStdlib.h"
+// NOTE: Gambit hack to include slhaea support
+// SLHAea (for SLHA input from an SLHAea object instead of a file)
+#include "SLHAea/slhaea.h"
 
 namespace Pythia8 {
 
@@ -387,11 +390,13 @@ public:
   //Constructor, with and without filename.
   SusyLesHouches(int verboseIn=1) : verboseSav(verboseIn),
     headerPrinted(false), footerPrinted(false), filePrinted(false),
-    slhaRead(false), lhefRead(false), lhefSlha(false), useDecay(true) {};
+    slhaRead(false), lhefRead(false), lhefSlha(false), useDecay(true),
+    slhaeaCollPtr(NULL) {}; // NOTE: <== slhaeaCollPtr is a Gambit hack
   SusyLesHouches(string filename, int verboseIn=1) : verboseSav(verboseIn),
     headerPrinted(false), footerPrinted(false), filePrinted(false),
-    slhaRead(true), lhefRead(false), lhefSlha(false), useDecay(true)
-    {readFile(filename);};
+    slhaRead(true), lhefRead(false), lhefSlha(false), useDecay(true),
+    slhaeaCollPtr(NULL) {readFile(filename);}; // NOTE: <== slhaeaCollPtr is a Gambit hack
+
 
   //***************************** SLHA FILE I/O *****************************//
   // Read and write SLHA files
@@ -400,6 +405,10 @@ public:
   int readFile(istream& ,int verboseIn=1,
     bool useDecayIn=true);
   //int writeFile(string filename): write SLHA file on filename
+// NOTE: Gambit hack to include slhaea support
+  // Read from SLHAea::Coll
+  int readSLHAea(int verboseIn=1, bool useDecayIn=true);
+  void setSLHAea(const SLHAea::Coll* inputSLHAea) { slhaeaCollPtr = inputSLHAea; }
 
   //Output utilities
   void printHeader();   // print Header
@@ -641,6 +650,9 @@ private:
   int verboseSav;
   bool headerPrinted, footerPrinted, filePrinted;
   bool slhaRead, lhefRead, lhefSlha, useDecay;
+// NOTE: Gambit hack to include slhaea support
+  // SLHAea Collection (for SLHA input from a SLHAea::Coll instead of a file)
+  const SLHAea::Coll* slhaeaCollPtr;
 
 };
 
diff -rupN 8.212_original/src/ParticleData.cc 8.212/src/ParticleData.cc
--- 8.212_original/src/ParticleData.cc	2015-09-23 17:35:08.000000000 +0200
+++ 8.212/src/ParticleData.cc	2017-04-12 15:27:59.725471894 +0200
@@ -572,6 +572,8 @@ void ParticleData::initCommon() {
 
 void ParticleData::initWidths( vector<ResonanceWidths*> resonancePtrs) {
 
+  cout<<" initialising widths with size "<<resonancePtrs.size()<<" pdt size "<<pdt.size()<<endl;
+  
   // Initialize some common data.
   initCommon();
 
@@ -776,8 +778,44 @@ void ParticleData::initWidths( vector<Re
 
 bool ParticleData::readXML(string inFile, bool reset) {
 
+  // Load XML file into memory
+  if (!loadXML(inFile,reset)) return false;
+
+  // Process XML file (now stored in memory)
+  if (!processXML(reset)) return false;
+
+  // Done.
+  return true;
+}
+
+  //--------------------------------------------------------------------------
+
+// Read in database from pre-initialised particleData object.
+
+bool ParticleData::copyXML(const ParticleData &particleDataIn) {
+
+  // First Reset everything.
+  pdt.clear();
+  xmlFileSav.clear();
+  isInit = false;
+  xmlFileSav=particleDataIn.xmlFileSav;
+
+  // Process XML file (now stored in memory)
+  if (!processXML(true)) return false;
+
+  // Done.
+  return true;
+}
+  
+  
+//--------------------------------------------------------------------------
+
+// Load a specific XML file into memory (which may refer to others).
+
+bool ParticleData::loadXML(string inFile, bool reset) {
+
   // Normally reset whole database before beginning.
-  if (reset) {pdt.clear(); isInit = false;}
+  if (reset) {pdt.clear(); xmlFileSav.clear(); isInit = false;}
 
   // List of files to be checked.
   vector<string> files;
@@ -805,73 +843,8 @@ bool ParticleData::readXML(string inFile
       string word1;
       getfirst >> word1;
 
-      // Check for occurence of a particle. Add any continuation lines.
-      if (word1 == "<particle") {
-        while (line.find(">") == string::npos) {
-          string addLine;
-          getline(is, addLine);
-          line += addLine;
-        }
-
-        // Read in particle properties.
-        int idTmp          = intAttributeValue( line, "id");
-        string nameTmp     = attributeValue( line, "name");
-        string antiNameTmp = attributeValue( line, "antiName");
-        if (antiNameTmp == "") antiNameTmp = "void";
-        int spinTypeTmp    = intAttributeValue( line, "spinType");
-        int chargeTypeTmp  = intAttributeValue( line, "chargeType");
-        int colTypeTmp     = intAttributeValue( line, "colType");
-        double m0Tmp       = doubleAttributeValue( line, "m0");
-        double mWidthTmp   = doubleAttributeValue( line, "mWidth");
-        double mMinTmp     = doubleAttributeValue( line, "mMin");
-        double mMaxTmp     = doubleAttributeValue( line, "mMax");
-        double tau0Tmp     = doubleAttributeValue( line, "tau0");
-
-        // Erase if particle already exists.
-        if (isParticle(idTmp)) pdt.erase(idTmp);
-
-        // Store new particle. Save pointer, to be used for decay channels.
-        addParticle( idTmp, nameTmp, antiNameTmp, spinTypeTmp, chargeTypeTmp,
-          colTypeTmp, m0Tmp, mWidthTmp, mMinTmp, mMaxTmp, tau0Tmp);
-        particlePtr = particleDataEntryPtr(idTmp);
-
-      // Check for occurence of a decay channel. Add any continuation lines.
-      } else if (word1 == "<channel") {
-        while (line.find(">") == string::npos) {
-          string addLine;
-          getline(is, addLine);
-          line += addLine;
-        }
-
-        // Read in channel properties - products so far only as a string.
-        int onMode      = intAttributeValue( line, "onMode");
-        double bRatio   = doubleAttributeValue( line, "bRatio");
-        int meMode      = intAttributeValue( line, "meMode");
-        string products = attributeValue( line, "products");
-
-        // Read in decay products from stream. Must have at least one.
-        istringstream prodStream(products);
-        int prod0 = 0; int prod1 = 0; int prod2 = 0; int prod3 = 0;
-        int prod4 = 0; int prod5 = 0; int prod6 = 0; int prod7 = 0;
-        prodStream >> prod0 >> prod1 >> prod2 >> prod3 >> prod4 >> prod5
-                   >> prod6 >> prod7;
-        if (prod0 == 0) {
-          infoPtr->errorMsg("Error in ParticleData::readXML:"
-            " incomplete decay channel", line);
-          return false;
-        }
-
-        // Store new channel (if particle already known).
-        if (particlePtr == 0) {
-          infoPtr->errorMsg("Error in ParticleData::readXML:"
-            " orphan decay channel", line);
-          return false;
-        }
-        particlePtr->addChannel(onMode, bRatio, meMode, prod0, prod1,
-          prod2, prod3, prod4, prod5, prod6, prod7);
-
       // Check for occurence of a file also to be read.
-      } else if (word1 == "<file") {
+      if (word1 == "<file") {
         string file = attributeValue(line, "name");
         if (file == "") {
           infoPtr->errorMsg("Error in ParticleData::readXML:"
@@ -879,7 +852,106 @@ bool ParticleData::readXML(string inFile
         } else files.push_back(file);
       }
 
-    // End of loop over lines in input file and loop over files.
+      // Else save line to memory
+      else {
+        xmlFileSav.push_back(line);
+      }
+    }
+  }
+
+  //Done.
+  return true;
+  
+}
+
+//--------------------------------------------------------------------------
+
+// Process XML contents stored in memory
+
+bool ParticleData::processXML(bool reset) {
+
+  // Number of lines saved
+  int nLines = xmlFileSav.size();
+
+  // Process each line sequentially
+  particlePtr = 0;
+  int i=-1;
+  while (++i < nLines) {
+    
+    // Retrieve line
+    string line = xmlFileSav[i];
+
+    // Get first word of a line.
+    istringstream getfirst(line);
+    string word1;
+    getfirst >> word1;
+
+    // Check for occurence of a particle. Add any continuation lines.
+    if (word1 == "<particle") {
+      while (line.find(">") == string::npos) {
+        if (++i >= nLines) break;
+        string addLine = xmlFileSav[i];        
+        line += addLine;
+      }
+      
+      // Read in particle properties.
+      int idTmp          = intAttributeValue( line, "id");
+      string nameTmp     = attributeValue( line, "name");
+      string antiNameTmp = attributeValue( line, "antiName");
+      if (antiNameTmp == "") antiNameTmp = "void";
+      int spinTypeTmp    = intAttributeValue( line, "spinType");
+      int chargeTypeTmp  = intAttributeValue( line, "chargeType");
+      int colTypeTmp     = intAttributeValue( line, "colType");
+      double m0Tmp       = doubleAttributeValue( line, "m0");
+      double mWidthTmp   = doubleAttributeValue( line, "mWidth");
+      double mMinTmp     = doubleAttributeValue( line, "mMin");
+      double mMaxTmp     = doubleAttributeValue( line, "mMax");
+      double tau0Tmp     = doubleAttributeValue( line, "tau0");
+      
+      // Erase if particle already exists.
+      if (isParticle(idTmp)) pdt.erase(idTmp);
+      
+      // Store new particle. Save pointer, to be used for decay channels.
+      addParticle( idTmp, nameTmp, antiNameTmp, spinTypeTmp, chargeTypeTmp,
+                   colTypeTmp, m0Tmp, mWidthTmp, mMinTmp, mMaxTmp, tau0Tmp);
+      particlePtr = particleDataEntryPtr(idTmp);
+      
+      // Check for occurence of a decay channel. Add any continuation lines.
+    } else if (word1 == "<channel") {
+      while (line.find(">") == string::npos) {
+        if (++i >= nLines) break;        
+        string addLine = xmlFileSav[i];
+        line += addLine;
+      }
+      
+      // Read in channel properties - products so far only as a string.
+      int onMode      = intAttributeValue( line, "onMode");
+      double bRatio   = doubleAttributeValue( line, "bRatio");
+      int meMode      = intAttributeValue( line, "meMode");
+      string products = attributeValue( line, "products");
+      
+      // Read in decay products from stream. Must have at least one.
+      istringstream prodStream(products);
+      int prod0 = 0; int prod1 = 0; int prod2 = 0; int prod3 = 0;
+      int prod4 = 0; int prod5 = 0; int prod6 = 0; int prod7 = 0;
+      prodStream >> prod0 >> prod1 >> prod2 >> prod3 >> prod4 >> prod5
+                 >> prod6 >> prod7;
+      if (prod0 == 0) {
+        infoPtr->errorMsg("Error in ParticleData::readXML:"
+                          " incomplete decay channel", line);
+        return false;
+      }
+
+      // Store new channel (if particle already known).
+      if (particlePtr == 0) {
+        infoPtr->errorMsg("Error in ParticleData::readXML:"
+                          " orphan decay channel", line);
+        return false;
+      }
+      particlePtr->addChannel(onMode, bRatio, meMode, prod0, prod1,
+                              prod2, prod3, prod4, prod5, prod6, prod7);
+      
+      // End of loop over lines in input file and loop over files.
     };
   };
 
diff -rupN 8.212_original/src/PartonDistributions.cc 8.212/src/PartonDistributions.cc
--- 8.212_original/src/PartonDistributions.cc	2015-09-23 17:35:08.000000000 +0200
+++ 8.212/src/PartonDistributions.cc	2017-04-12 15:27:59.725471894 +0200
@@ -2133,17 +2133,10 @@ void NNPDF::init(int iFitIn, string xmlP
   for (int iq = 0; iq < fNQ2; iq++) fLogQ2Grid[iq] = log(fQ2Grid[iq]);
 
   // Prepare grid array.
-  fPDFGrid = new double**[fNFL];
-  for (int i = 0; i < fNFL; i++) {
-    fPDFGrid[i] = new double*[fNX];
-    for (int j = 0; j < fNX; j++) {
-      fPDFGrid[i][j] = new double[fNQ2];
-      for (int z = 0; z < fNQ2; z++) fPDFGrid[i][j][z] = 0.0;
-    }
-  }
-
+    fPDFGrid = new double[fNFL*fNX*fNQ2];
+  
   // Check values of number of grid entries.
-  if (fNX<= 0 || fNX>100 || fNQ2<=0 || fNQ2>50) {
+  if (fNX<4 || fNX>100 || fNQ2<2 || fNQ2>50) {
     cout << "Error in NNPDF::init, Invalid grid values" << endl
          << "fNX = " << fNX << endl << "fNQ2 = " << fNQ2 << endl
          << "fNFL = " <<fNFL << endl;
@@ -2156,46 +2149,210 @@ void NNPDF::init(int iFitIn, string xmlP
   for (int ix = 0; ix < fNX; ix++)
     for (int iq = 0; iq < fNQ2; iq++)
       for (int fl = 0; fl < fNFL; fl++)
-        f >> fPDFGrid[fl][ix][iq];
+      {
+        f >> fPDFGrid[(fl*fNX + ix)*fNQ2 + iq];
+      }
   f.close();
 
   // Other vectors.
   fRes = new double[fNFL];
-
+  
 }
 
 //--------------------------------------------------------------------------
 
-void NNPDF::xfUpdate(int , double x, double Q2) {
+ void NNPDF::xfUpdate(int , double x, double Q2) {
+ 
+ // Update using NNPDF routine, within allowed (x, q) range.
+ xfxevolve(x,Q2);
+ 
+ // Then transfer to Pythia8 notation.
+ xg     = fRes[6];
+ xu     = fRes[8];
+ xd     = fRes[7];
+ xubar  = fRes[4];
+ xdbar  = fRes[5];
+ xs     = fRes[9];
+ xsbar  = fRes[3];
+ xc     = fRes[10];
+ xb     = fRes[11];
+ xgamma = fRes[13];
+ 
+ // Subdivision of valence and sea.
+ xuVal  = xu - xubar;
+ xuSea  = xubar;
+ xdVal  = xd - xdbar;
+ xdSea  = xdbar;
+ 
+ // idSav = 9 to indicate that all flavours reset.
+ idSav  = 9;
+ 
+ }
 
-  // Update using NNPDF routine, within allowed (x, q) range.
-  xfxevolve(x,Q2);
+ 
+//--------------------------------------------------------------------------
+/*
+ *  NNPDF::xfxevolve(double x, double Q2) optimized to improve performance by ~2x
+ *
+ *  Modified by Hrayr Matevosyan on 24/06/15.
+ *  2015 CSSM/CoEPP, University of Adelaide.
+ *
+ */
+void NNPDF::xfxevolve(double x, double Q2) {
 
-  // Then transfer to Pythia8 notation.
-  xg     = fRes[6];
-  xu     = fRes[8];
-  xd     = fRes[7];
-  xubar  = fRes[4];
-  xdbar  = fRes[5];
-  xs     = fRes[9];
-  xsbar  = fRes[3];
-  xc     = fRes[10];
-  xb     = fRes[11];
-  xgamma = fRes[13];
-
-  // Subdivision of valence and sea.
-  xuVal  = xu - xubar;
-  xuSea  = xubar;
-  xdVal  = xd - xdbar;
-  xdSea  = xdbar;
+  // Freeze outside x-Q2 grid.
+  if (x < fXMINGRID)
+    x = fXMINGRID;
+  else if (x > fXGrid[fNX-1])
+    x = fXGrid[fNX-1];
+  
+  if (Q2 < fQ2Grid[0])
+    Q2 = fQ2Grid[0];
+  else if (Q2 > fQ2Grid[fNQ2-1])
+    Q2 = fQ2Grid[fNQ2-1];
+  
+  // Find nearest points in the x-Q2 grid.
+  int min = 0;
+  int max = fNX-1;
+  int mid;
+  while (max-min > 1)
+  {
+    mid = (min+max)/2;
+    if (x < fXGrid[mid]) max = mid;
+    else min = mid;
+  };
+  
+  int ix1 = min-1; //ix-1
+  if (ix1 < 0)
+    ix1=0;
+  else if(ix1 > (fNX-4))
+    ix1 = (fNX-4);
+  
+  // Find nearest points in the Q2 grid.
+  min = 0;
+  max = fNQ2-1;
+  while (max-min > 1)
+  {
+    mid = (min+max)/2;
+    if (Q2 < fQ2Grid[mid]) max = mid;
+    else min = mid;
+  };
+    
+  int ix2 = min;
+  if (ix2 > (fNQ2-2))
+    ix2 = (fNQ2-2);
+ 
+  //x grid values used
+  double x1, *x1a;
+  if (x < static_cast<double>(1e-1))
+  {
+    x1 = log(x);
+    x1a = fLogXGrid + ix1;
+  }
+  else
+  {
+    x1 = x;
+    x1a = fXGrid + ix1;
+  }
+  
+  if(
+     (x1a[0] - x1a[1])*
+     (x1a[0] - x1a[2])*
+     (x1a[0] - x1a[3])*
+     (x1a[1] - x1a[2])*
+     (x1a[1] - x1a[3])*
+     (x1a[2] - x1a[3])
+      == 0
+     )
+  {
+    cout << "NNPDF::polint, failure" << endl;
+    return;
+  }
 
-  // idSav = 9 to indicate that all flavours reset.
-  idSav  = 9;
+  //Q2 grid values used
+  double x2 = log(Q2);
+  double* x2a = fLogQ2Grid+ix2;
+  if ( (x2a[0]-x2a[1]) == 0)
+  {
+    cout << "NNPDF::polint, failure" << endl;
+    return;
+  }
+  
+  //Interpolation Variables
+  int iShift= ( abs(x2-x2a[0]) < abs(x2-x2a[1]) ) ? 0 : 1;
+  
+  double denl = (x2a[iShift]-x2)/(x2a[0]-x2a[1]);
+
+  int ns0 =0;
+  double dif = abs(x1-x1a[0]);
+  for (int i = 1; i < 4; i++)
+  {
+    double dift = abs(x1-x1a[i]);
+    if (dift < dif)
+    {
+      ns0 = i;
+      dif = dift;
+    }
+  }
 
+  //Loop over flavor index
+  for (int ipdf = 0; ipdf < fNFL; ipdf++)
+  {
+    //
+    //Interpolation in Q2
+    //
+    
+    double ym[4];
+    int iIndPDF = (ipdf*fNX + ix1)*fNQ2 + ix2;
+    ym[0] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    iIndPDF+=fNQ2;
+    ym[1] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    iIndPDF+=fNQ2;
+    ym[2] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    iIndPDF+=fNQ2;
+    ym[3] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    //
+    //Interpolation in x
+    //
+    double c[4]={ym[0],ym[1],ym[2],ym[3]};
+    
+    int ns = ns0;
+    double y = ym[ns];
+    ns--;
+    double den;
+    for (int m = 1; m < 4; m++)
+    {
+      for (int i = 0; i < 4-m; i++)
+      {
+        den = (c[i+1]-ym[i])/(x1a[i]-x1a[i+m]);
+        c[i]  = (x1a[i]   - x1) * den;
+        ym[i] = (x1a[i+m] - x1) * den;
+      }
+      if (2*ns < 2-m)
+      {
+        y+= c[ns+1];
+      }
+      else
+      {
+        y+= ym[ns];
+        ns--;
+      }
+    }
+ 
+    fRes[ipdf] = y;
+  }
 }
 
-//--------------------------------------------------------------------------
 
+//--------------------------------------------------------------------------
+/*
+ *  NNPDF::xfxevolve(double x, double Q2) original code v8209
+ */
+/*
 void NNPDF::xfxevolve(double x, double Q2) {
 
   // Freeze outside x-Q2 grid.
@@ -2278,6 +2435,7 @@ void NNPDF::xfxevolve(double x, double Q
   }
 
 }
+*/
 
 //--------------------------------------------------------------------------
 
diff -rupN 8.212_original/src/ProcessLevel.cc 8.212/src/ProcessLevel.cc
--- 8.212_original/src/ProcessLevel.cc	2015-09-23 17:35:08.000000000 +0200
+++ 8.212/src/ProcessLevel.cc	2017-04-12 15:27:59.725471894 +0200
@@ -6,6 +6,20 @@
 // Function definitions (not found in the header) for the ProcessLevel class.
 
 #include "Pythia8/ProcessLevel.h"
+// NOTE: Gambit hack to limit infinite loops using threadsafe timers.
+#ifndef BOOST_CHRONO_HEADER_ONLY
+#define BOOST_CHRONO_HEADER_ONLY
+#ifndef BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#define BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#ifndef BOOST_SYSTEM_NO_DEPRECATED
+#define BOOST_SYSTEM_NO_DEPRECATED
+#include <boost/chrono.hpp>
+typedef boost::chrono::milliseconds ms;
+typedef boost::chrono::thread_clock thread_cl;
+typedef boost::chrono::thread_clock::time_point thread_tp;
+#endif // BOOST_SYSTEM_NO_DEPRECATED
+#endif // BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#endif // BOOST_CHRONO_HEADER_ONLY
 
 namespace Pythia8 {
 
@@ -182,9 +196,28 @@ bool ProcessLevel::init( Info* infoPtrIn
       &resonanceDecays, slhaInterfacePtr, userHooksPtr)) ++numberOn;
 
   // Sum maxima for Monte Carlo choice.
+  // NOTE: Gambit hack: Catch nans and infinities while summing up sigmas.
   sigmaMaxSum = 0.;
-  for (int i = 0; i < int(containerPtrs.size()); ++i)
-    sigmaMaxSum += containerPtrs[i]->sigmaMax();
+  bool valid = true;
+  for (int i = 0; i < int(containerPtrs.size()); ++i) {
+    if(std::isfinite(containerPtrs[i]->sigmaMax()))
+      sigmaMaxSum += containerPtrs[i]->sigmaMax();
+    else {
+      std::cerr<<"\n\n\n ERROR: in Pythia8::ProcessLevel::init:\n";
+      std::cerr<<"   Non-finite xsec: "<<containerPtrs[i]->sigmaMax()<<"\n";
+      std::cerr<<"   Process code: "<<containerPtrs[i]->code();
+      std::cerr<<",  Process: "<<containerPtrs[i]->name()<<"\n";
+      std::cerr<<"This model is invalid.\n\n\n";
+      delete containerPtrs[i];
+      containerPtrs.erase(containerPtrs.begin() + i);
+      i--;
+      valid = false;
+    }
+  }
+  if (!valid) {
+    infoPtr->errorMsg("Error in ProcessLevel::init: Non-finite xsecs");
+    return false;
+  }
 
   // Option to pick a second hard interaction: repeat as above.
   int number2On = 0;
@@ -282,12 +315,14 @@ bool ProcessLevel::init( Info* infoPtrIn
        <<"-------------*" << endl;
   }
 
+  /* NOTE: Gambit hack: ColliderBit has its own xsec veto... remove this:
   // If sum of maxima vanishes then refuse to do anything.
   if ( numberOn == 0  || sigmaMaxSum <= 0.) {
     infoPtr->errorMsg("Error in ProcessLevel::init: "
       "all processes have vanishing cross sections");
     return false;
   }
+  *** Gambit hack end */
   if ( doSecondHard && (number2On == 0  || sigma2MaxSum <= 0.) ) {
     infoPtr->errorMsg("Error in ProcessLevel::init: "
       "all second hard processes have vanishing cross sections");
@@ -615,8 +650,15 @@ bool ProcessLevel::nextOne( Event& proce
     physical = true;
 
     // Loop over tries until trial event succeeds.
-    for ( ; ; ) {
-
+    // NOTE: Gambit hack to limit infinite loops using threadsafe timers.
+    // TODO: configurable msTimeLimit...
+    double msTimer=0.;
+    double msTimeLimit = 1000.;
+    ms msDelta;
+    for (thread_tp start = thread_cl::now(); msTimer < msTimeLimit;
+         msDelta = boost::chrono::duration_cast<ms>(thread_cl::now() - start),
+         msTimer = msDelta.count())
+    {
       // Pick one of the subprocesses.
       double sigmaMaxNow = sigmaMaxSum * rndmPtr->flat();
       int iMax = containerPtrs.size() - 1;
@@ -630,6 +672,11 @@ bool ProcessLevel::nextOne( Event& proce
       // Check for end-of-file condition for Les Houches events.
       if (infoPtr->atEndOfFile()) return false;
     }
+    if (msTimer >= msTimeLimit) {
+      std::cerr<<"\n\n\n WARNING: in Pythia8::ProcessLevel::next:\n";
+      std::cerr<<"   Trial event stuck. Aborting event generation\n\n\n";
+      return false;
+    }
 
     // Update sum of maxima if current maximum violated.
     if (containerPtrs[iContainer]->newSigmaMax()) {
diff -rupN 8.212_original/src/Pythia.cc 8.212/src/Pythia.cc
--- 8.212_original/src/Pythia.cc	2015-09-23 17:35:08.000000000 +0200
+++ 8.212/src/Pythia.cc	2017-04-12 15:32:42.924415790 +0200
@@ -113,7 +113,9 @@ Pythia::Pythia(string xmlDir, bool print
     info.errorMsg("Abort from Pythia::Pythia: settings unavailable");
     return;
   }
-
+  // Also save XML path in settings
+  settings.addWord("xmlPath",xmlPath);
+  
   // Check that XML version number matches code version number.
   double versionNumberXML = parm("Pythia:versionNumber");
   isConstructed = (abs(versionNumberXML - VERSIONNUMBERCODE) < 0.0005);
@@ -157,6 +159,112 @@ Pythia::Pythia(string xmlDir, bool print
 
 //--------------------------------------------------------------------------
 
+// Constructor from pre-initialised ParticleData and Settings objects.
+
+Pythia::Pythia(ParticleData& particleDataIn, Settings& settingsIn,
+                 bool printBanner) {
+
+  // Initial values for pointers to PDF's.
+  useNewPdfA      = false;
+  useNewPdfB      = false;
+  useNewPdfHard   = false;
+  useNewPdfPomA   = false;
+  useNewPdfPomB   = false;
+  pdfAPtr         = 0;
+  pdfBPtr         = 0;
+  pdfHardAPtr     = 0;
+  pdfHardBPtr     = 0;
+  pdfPomAPtr      = 0;
+  pdfPomBPtr      = 0;
+
+  // Initial values for pointers to Les Houches Event objects.
+  doLHA           = false;
+  useNewLHA       = false;
+  lhaUpPtr        = 0;
+
+  //Initial value for couplings pointer
+  couplingsPtr    = &couplings;
+
+  // Initial value for pointer to external decay handler.
+  decayHandlePtr  = 0;
+
+  // Initial value for pointer to user hooks.
+  userHooksPtr    = 0;
+
+  // Initial value for pointer to merging hooks.
+  doMerging          = false;
+  hasMergingHooks    = false;
+  hasOwnMergingHooks = false;
+  mergingHooksPtr    = 0;
+
+  // Initial value for pointer to beam shape.
+  useNewBeamShape = false;
+  beamShapePtr    = 0;
+
+  // Initial values for pointers to timelike and spacelike showers.
+  useNewTimesDec  = false;
+  useNewTimes     = false;
+  useNewSpace     = false;
+  timesDecPtr     = 0;
+  timesPtr        = 0;
+  spacePtr        = 0;
+
+  // Copy XML path
+  const string key = "xmlPath";
+  xmlPath = settingsIn.word(key);
+  
+  // Copy settings database
+  settings = settingsIn;
+  // Reset pointers to pertain to this PYTHIA object
+  settings.initPtr( &info);
+  isConstructed = settings.getIsInit();
+  if (!isConstructed) {
+    info.errorMsg("Abort from Pythia::Pythia: settings unavailable");
+    return;
+  }
+
+  // Check that XML version number matches code version number.
+  double versionNumberXML = parm("Pythia:versionNumber");
+  isConstructed = (abs(versionNumberXML - VERSIONNUMBERCODE) < 0.0005);
+  if (!isConstructed) {
+    ostringstream errCode;
+    errCode << fixed << setprecision(3) << ": in code " << VERSIONNUMBERCODE
+            << " but in XML " << versionNumberXML;
+    info.errorMsg("Abort from Pythia::Pythia: unmatched version numbers",
+      errCode.str());
+    return;
+  }
+
+  // Check that header version number matches code version number.
+  isConstructed = (abs(VERSIONNUMBERHEAD - VERSIONNUMBERCODE) < 0.0005);
+  if (!isConstructed) {
+    ostringstream errCode;
+    errCode << fixed << setprecision(3) << ": in code " << VERSIONNUMBERCODE
+            << " but in header " << VERSIONNUMBERHEAD;
+    info.errorMsg("Abort from Pythia::Pythia: unmatched version numbers",
+      errCode.str());
+    return;
+  }
+
+  // Read in files with all particle data.
+  particleData.initPtr( &info, &settings, &rndm, couplingsPtr);
+  isConstructed = particleData.init( particleDataIn);
+  if (!isConstructed) {
+    info.errorMsg("Abort from Pythia::Pythia: particle data unavailable");
+    return;
+  }
+
+  // Write the Pythia banner to output.
+  if (printBanner) banner();
+
+  // Not initialized until at the end of the init() call.
+  isInit = false;
+  info.addCounter(0);
+
+}
+
+//--------------------------------------------------------------------------
+  
 // Destructor.
 
 Pythia::~Pythia() {
@@ -338,7 +446,7 @@ bool Pythia::setPDFPtr( PDF* pdfAPtrIn,
 
 // Routine to initialize with the variable values of the Beams kind.
 
-bool Pythia::init() {
+bool Pythia::init(ostream& os) {  // NOTE: <== os is a Gambit hack
 
   // Check that constructor worked.
   isInit = false;
@@ -677,7 +785,7 @@ bool Pythia::init() {
   // Send info/pointers to process level for initialization.
   if ( doProcessLevel && !processLevel.init( &info, settings, &particleData,
     &rndm, &beamA, &beamB, couplingsPtr, &sigmaTot, doLHA, &slhaInterface,
-    userHooksPtr, sigmaPtrs, phaseSpacePtrs) ) {
+    userHooksPtr, sigmaPtrs, phaseSpacePtrs, os) ) {  // NOTE: <== os is a Gambit hack
     info.errorMsg("Abort from Pythia::init: "
       "processLevel initialization failed");
     return false;
@@ -1618,12 +1726,12 @@ void Pythia::banner(ostream& os) {
      << "ische Physik,                         |  | \n"
      << " |  |     Universitaet Heidelberg, Philosophe"
      << "nweg 16, D-69120 Heidelberg, Germany; |  | \n"
-     << " |  |      e-mail: n.desai@thphys.uni-heidelb"
+     << " |  |      e-mail: n.desai@thuni-heidelb"
      << "erg.de                                |  | \n"
      << " |  |   Philip Ilten;  Massachusetts Institut"
      << "e of Technology,                      |  | \n"
-     << " |  |      stationed at CERN, CH-1211 Geneva "
-     << "23, Switzerland;                      |  | \n"
+     << " |  |      77 Massachusetts Ave, Cambridge, M"
+     << "A 02139, USA;                         |  | \n"
      << " |  |      e-mail: philten@cern.ch           "
      << "                                      |  | \n"
      << " |  |   Stephen Mrenna;  Computing Division, "
diff -rupN 8.212_original/src/ResonanceDecays.cc 8.212/src/ResonanceDecays.cc
--- 8.212_original/src/ResonanceDecays.cc	2015-09-23 17:35:09.000000000 +0200
+++ 8.212/src/ResonanceDecays.cc	2017-04-12 15:27:59.725471894 +0200
@@ -92,6 +92,10 @@ bool ResonanceDecays::next( Event& proce
           idProd.push_back( idNow);
         }
 
+
+        // GAMBIT fix for Pythia bug. (To be fixed in Pythia versions > 8.212)
+        mProd.resize(1);
+
         // Pick masses. Pick new channel if fail.
         if (!pickMasses()) continue;
         foundChannel = true;
diff -rupN 8.212_original/src/SusyLesHouches.cc 8.212/src/SusyLesHouches.cc
--- 8.212_original/src/SusyLesHouches.cc	2015-09-23 17:35:10.000000000 +0200
+++ 8.212/src/SusyLesHouches.cc	2017-04-12 15:27:59.725471894 +0200
@@ -7,6 +7,58 @@
 #include "Pythia8/SusyLesHouches.h"
 #include "Pythia8/Streams.h"
 
+// NOTE: Many macros for the Gambit slhaea hack
+#define FILL_LHBLOCK(LHBLOCK, FILL_TYPE)   \
+      for(SLHAea::Block::const_iterator lineIter = blockIter->begin(); lineIter != blockIter->end(); lineIter++) {  \
+        /* Add line to generic block (carbon copy of input structure) */  \
+        genericBlocks[blockName].set(lineIter->str());  \
+        if(!lineIter->is_data_line()) continue;  \
+        ifail = LHBLOCK.set(SLHAea::to<int>(lineIter->at(0)),  \
+                            SLHAea::to<FILL_TYPE>(lineIter->at(1)));  \
+        if (ifail == 1) {  \
+          message(0,"readSLHAea",blockName+" existing entry overwritten",0);  \
+        }  \
+      }
+
+#define FILL_STRING_LHBLOCK(LHBLOCK)   \
+      for(SLHAea::Block::const_iterator lineIter = blockIter->begin(); lineIter != blockIter->end(); lineIter++) {  \
+        /* Add line to generic block (carbon copy of input structure) */  \
+        genericBlocks[blockName].set(lineIter->str());  \
+        if(!lineIter->is_data_line()) continue;  \
+        ifail = LHBLOCK.set(SLHAea::to<int>(lineIter->at(0)), lineIter->at(1));  \
+        if (ifail == 1) {  \
+          message(0,"readSLHAea",blockName+" existing entry overwritten",0);  \
+        }  \
+      }
+
+#define FILL_LHMATRIXBLOCK(LHMATRIXBLOCK)   \
+      for(SLHAea::Block::const_iterator lineIter = blockIter->begin(); lineIter != blockIter->end(); lineIter++) {  \
+        /* Add line to generic block (carbon copy of input structure) */  \
+        genericBlocks[blockName].set(lineIter->str());  \
+        if(!lineIter->is_data_line()) continue;  \
+        ifail = LHMATRIXBLOCK.set(SLHAea::to<int>(lineIter->at(0)),  \
+                                  SLHAea::to<int>(lineIter->at(1)),  \
+                                  SLHAea::to<double>(lineIter->at(2)));  \
+        if (ifail == -1) {  \
+          message(0,"readSLHAea",blockName+" index out of range for matrix",0);  \
+        }  \
+      }
+
+#define FILL_LHTENSOR3BLOCK(LHTENSOR3BLOCK)   \
+      for(SLHAea::Block::const_iterator lineIter = blockIter->begin(); lineIter != blockIter->end(); lineIter++) {  \
+        /* Add line to generic block (carbon copy of input structure) */  \
+        genericBlocks[blockName].set(lineIter->str());  \
+        if(!lineIter->is_data_line()) continue;  \
+        ifail = LHTENSOR3BLOCK.set(SLHAea::to<int>(lineIter->at(0)),  \
+                                   SLHAea::to<int>(lineIter->at(1)),  \
+                                   SLHAea::to<int>(lineIter->at(2)),  \
+                                   SLHAea::to<double>(lineIter->at(3)));  \
+        if (ifail == -1) {  \
+          message(0,"readSLHAea",blockName+" index out of range for tensor",0);  \
+        }  \
+      }
+
+
 namespace Pythia8 {
 
 //==========================================================================
@@ -20,6 +72,9 @@ namespace Pythia8 {
 int SusyLesHouches::readFile(string slhaFileIn, int verboseIn,
   bool useDecayIn) {
 
+// NOTE: Gambit hack for slhaea support
+  // If the slhaeaCollPtr is set, use readSLHAea instead.
+  if (slhaeaCollPtr) return readSLHAea(verboseIn, useDecayIn);
   slhaFile = slhaFileIn;
   // Check that input file is OK.
   const char* cstring = slhaFile.c_str();
@@ -635,6 +690,703 @@ int SusyLesHouches::readFile(istream& is
     return 102;
   }
   else return iFailFile;
+    
+}
+
+//--------------------------------------------------------------------------
+
+// NOTE: Gambit hack for slhaea support
+// Main routine to read in SLHA data from a SLHAea::Coll object
+
+int SusyLesHouches::readSLHAea(int verboseIn, bool useDecayIn) {
+
+  // Copy inputs to local
+  slhaFile = "SLHAea::Coll instance";
+  verboseSav = verboseIn;
+  useDecay = useDecayIn;
+
+  // Exit if SLHAea::Coll pointer not found.
+  if (!slhaeaCollPtr) {
+    message(2,"readSLHAea","has no SLHAea::Coll pointer",0);
+    return -1;
+    slhaRead=false;
+  }
+
+  if (verboseSav >= 3) {
+    message(0,"readSLHAea","parsing SLHAea::Coll instance",0);
+    filePrinted = true;
+  }
+
+  // Array of particles read in.
+  vector<int> idRead;
+
+  // Array of block names read in.
+  vector<string> processedBlocks;
+  
+  //Initial values for read-in variables.
+  slhaRead=true;
+  lhefRead=false;
+  lhefSlha=false;
+  string newName, newAntiName;
+  int ifail;
+
+  // Read in one block at a time.
+  for (SLHAea::Coll::const_iterator blockIter = slhaeaCollPtr->begin(); blockIter != slhaeaCollPtr->end(); blockIter++) {
+
+    // Print header if not already done
+    if (! headerPrinted) printHeader();
+
+    const SLHAea::Block::const_iterator blockDefIter = blockIter->find_block_def();
+    if (blockDefIter == blockIter->end()) continue; // <-- Skip comment "blocks"
+    string blockName = blockIter->name();
+    string blockType = blockDefIter->at(0);
+    toLower(blockName);
+    toLower(blockType);
+
+    if (blockName == "qnumbers") {    // QNUMBERS blocks (cf. arXiv:0712.3311 [hep-ph])
+      // ID code for new particle is the third entry of the block definition
+      const string pdgString = blockDefIter->at(2);
+      const string comment = blockDefIter->at(3).substr(1, blockDefIter->at(3).length()-1);
+
+      // Create new QNUMBERS LHblock with this code as zero'th entry
+      LHblock<int> newQnumbers;
+      newQnumbers.set(0, SLHAea::to<int>(pdgString));
+
+      // Default name: PDG code
+      ostringstream idStream;
+      idStream << newQnumbers(0);
+      const string defName = idStream.str();
+      const string defAntiName = "-"+defName;
+      newName = defName;
+      newAntiName = defAntiName;
+
+      // Attempt to extract names from comment string
+      if (comment.length() >= 1) {
+        int firstCommentBeg(0), firstCommentEnd(0);
+        if ( comment.find(" ") == 0) firstCommentBeg = 1;
+        if ( comment.find(" ",firstCommentBeg+1) == string::npos)
+          firstCommentEnd = comment.length();
+        else
+          firstCommentEnd = comment.find(" ",firstCommentBeg+1);
+        if (firstCommentEnd > firstCommentBeg)
+          newName = comment.substr(firstCommentBeg,
+                                   firstCommentEnd-firstCommentBeg);
+        // Now see if there is a separate name for antiparticle
+        int secondCommentBeg(firstCommentEnd+1), secondCommentEnd(0);
+        if (secondCommentBeg < int(comment.length())) {
+          if ( comment.find(" ",secondCommentBeg+1) == string::npos)
+            secondCommentEnd = comment.length();
+          else
+            secondCommentEnd = comment.find(" ",secondCommentBeg+1);
+          if (secondCommentEnd > secondCommentBeg)
+            newAntiName = comment.substr(secondCommentBeg,
+                                         secondCommentEnd-secondCommentBeg);
+        }
+      }
+
+      // If name given without specific antiname, set antiname to ""
+      if (newName != defName && newAntiName == defAntiName) newAntiName = "";
+      qnumbersName.push_back(newName);
+      qnumbersAntiName.push_back(newAntiName);
+      if (pdgString != newName) {
+        message(0,"readSLHAea","storing QNUMBERS for id = "+pdgString+" "
+                +newName+" "+newAntiName,0);
+      } else {
+        message(0,"readSLHAea","storing QNUMBERS for id = "+pdgString,0);
+      }
+
+      // Fill in the rest of the QNUMBERS info
+      FILL_LHBLOCK(newQnumbers, int)
+
+      // Add this new QNUMBERS block to the vector member within SusyLesHouches
+      qnumbers.push_back(newQnumbers);
+
+    } else if (blockType == "block") {    // Generic blocks
+      // Skip if several copies of same block 
+      // (facility to use interpolation of different q= not implemented)
+      // only first copy of a given block type is kept
+      bool exists = false;
+      for (int i=0; i<int(processedBlocks.size()); ++i) {
+        if (blockName == processedBlocks[i]) {exists = true; break;}
+      }
+      if (exists) {
+        message(0,"readSLHAea","skipping copy of block "+blockName,0);
+        continue;
+      }
+      processedBlocks.push_back(blockName);
+      // Copy input file as generic blocks (containing strings)
+      // (more will be done with SLHA1 & 2 specific blocks below, this is
+      //  just to make sure we have a complete copy of the input file,
+      //  including also any unknown/user/generic blocks)
+      LHgenericBlock gBlock;
+      genericBlocks[blockName]=gBlock;
+
+      //Find Q=... for DRbar running blocks
+      if (blockDefIter->data_size() > 3) {
+        string qEquals = blockDefIter->at(2);
+        toLower(qEquals);
+        if (qEquals == "q=") {
+          const double q = SLHAea::to<double>(blockDefIter->at(3));
+          // SLHA1 running blocks
+          if (blockName=="hmix") hmix.setq(q);
+          else if (blockName=="yu") yu.setq(q);
+          else if (blockName=="yd") yd.setq(q);
+          else if (blockName=="ye") ye.setq(q);
+          else if (blockName=="au") au.setq(q);
+          else if (blockName=="ad") ad.setq(q);
+          else if (blockName=="ae") ae.setq(q);
+          else if (blockName=="msoft") msoft.setq(q);
+          else if (blockName=="gauge") gauge.setq(q);
+          // SLHA2 running blocks
+          else if (blockName=="vckm") vckm.setq(q);
+          else if (blockName=="upmns") upmns.setq(q);
+          else if (blockName=="msq2") msq2.setq(q);
+          else if (blockName=="msu2") msu2.setq(q);
+          else if (blockName=="msd2") msd2.setq(q);
+          else if (blockName=="msl2") msl2.setq(q);
+          else if (blockName=="mse2") mse2.setq(q);
+          else if (blockName=="tu") tu.setq(q);
+          else if (blockName=="td") td.setq(q);
+          else if (blockName=="te") te.setq(q);
+          else if (blockName=="rvlamlle") rvlamlle.setq(q);
+          else if (blockName=="rvlamlqd") rvlamlqd.setq(q);
+          else if (blockName=="rvlamudd") rvlamudd.setq(q);
+          else if (blockName=="rvtlle") rvtlle.setq(q);
+          else if (blockName=="rvtlqd") rvtlqd.setq(q);
+          else if (blockName=="rvtudd") rvtudd.setq(q);
+          else if (blockName=="rvkappa") rvkappa.setq(q);
+          else if (blockName=="rvd") rvd.setq(q);
+          else if (blockName=="rvm2lh1") rvm2lh1.setq(q);
+          else if (blockName=="rvsnvev") rvsnvev.setq(q);
+          else if (blockName=="imau") imau.setq(q);
+          else if (blockName=="imad") imad.setq(q);
+          else if (blockName=="imae") imae.setq(q);
+          else if (blockName=="imhmix") imhmix.setq(q);
+          else if (blockName=="immsoft") immsoft.setq(q);
+          else if (blockName=="imtu") imtu.setq(q);
+          else if (blockName=="imtd") imtd.setq(q);
+          else if (blockName=="imte") imte.setq(q);
+          else if (blockName=="imvckm") imvckm.setq(q);
+          else if (blockName=="imupmns") imupmns.setq(q);
+          else if (blockName=="immsq2") immsq2.setq(q);
+          else if (blockName=="immsu2") immsu2.setq(q);
+          else if (blockName=="immsd2") immsd2.setq(q);
+          else if (blockName=="immsl2") immsl2.setq(q);
+          else if (blockName=="immse2") immse2.setq(q);
+          else if (blockName=="nmssmrun") nmssmrun.setq(q);
+          else message(0,"readSLHAea",blockName+" ignoring Q scale",0);  \
+        }
+      }
+
+      // MODEL
+      if (blockName == "modsel") {
+        ifail = -1;
+        try {
+          ifail = modsel12.set(0, SLHAea::to<double>(blockIter->at(12).at(1)));
+        } catch (std::out_of_range& e) {}
+
+        try {
+          ifail = modsel21.set(0, SLHAea::to<int>(blockIter->at(21).at(1)));
+        } catch (std::out_of_range& e) {}
+
+        try {
+          ifail = modsel.set(SLHAea::to<int>(blockIter->at(1).at(0)),
+                             SLHAea::to<int>(blockIter->at(1).at(1)));
+        } catch (std::out_of_range& e) {}
+
+        if (ifail == -1) {
+          message(1,"readSLHAea","read error or empty line",0);
+        }
+        if (ifail == 1) {
+          message(0,"readSLHAea",blockName+" existing entry overwritten",0);
+        }
+      }
+
+      // MODEL PARAMETERS
+      else if (blockName == "minpar") {
+        FILL_LHBLOCK(minpar, double)
+      }
+      else if (blockName == "sminputs") {
+        FILL_LHBLOCK(sminputs, double)
+      }
+      else if (blockName == "extpar") {
+        FILL_LHBLOCK(extpar, double)
+      }
+      else if (blockName == "qextpar") {
+        FILL_LHBLOCK(qextpar, double)
+      }
+      //FLV
+      else if (blockName == "vckmin") {
+        FILL_LHBLOCK(vckmin, double)
+      }
+      else if (blockName == "upmnsin") {
+        FILL_LHBLOCK(upmnsin, double)
+      }
+      else if (blockName == "msq2in") {
+        FILL_LHMATRIXBLOCK(msq2in)
+      }
+      else if (blockName == "msu2in") {
+        FILL_LHMATRIXBLOCK(msu2in)
+      }
+      else if (blockName == "msd2in") {
+        FILL_LHMATRIXBLOCK(msd2in)
+      }
+      else if (blockName == "msl2in") {
+        FILL_LHMATRIXBLOCK(msl2in)
+      }
+      else if (blockName == "mse2in") {
+        FILL_LHMATRIXBLOCK(mse2in)
+      }
+      else if (blockName == "tuin") {
+        FILL_LHMATRIXBLOCK(tuin)
+      }
+      else if (blockName == "tdin") {
+        FILL_LHMATRIXBLOCK(tdin)
+      }
+      else if (blockName == "tein") {
+        FILL_LHMATRIXBLOCK(tein)
+      }
+      //RPV
+      else if (blockName == "rvlamllein") {
+        FILL_LHTENSOR3BLOCK(rvlamllein)
+      }
+      else if (blockName == "rvlamlqdin") {
+        FILL_LHTENSOR3BLOCK(rvlamlqdin)
+      }
+      else if (blockName == "rvlamuddin") {
+        FILL_LHTENSOR3BLOCK(rvlamuddin)
+      }
+      else if (blockName == "rvtllein") {
+        FILL_LHTENSOR3BLOCK(rvtllein)
+      }
+      else if (blockName == "rvtlqdin") {
+        FILL_LHTENSOR3BLOCK(rvtlqdin)
+      }
+      else if (blockName == "rvtuddin") {
+        FILL_LHTENSOR3BLOCK(rvtuddin)
+      }
+      else if (blockName == "rvkappain") {
+        FILL_LHBLOCK(rvkappain, double)
+      }
+      else if (blockName == "rvdin") {
+        FILL_LHBLOCK(rvdin, double)
+      }
+      else if (blockName == "rvm2lh1in") {
+        FILL_LHBLOCK(rvm2lh1in, double)
+      }
+      else if (blockName == "rvsnvevin") {
+        FILL_LHBLOCK(rvsnvevin, double)
+      }
+      //CPV
+      else if (blockName == "imminpar") {
+        FILL_LHBLOCK(imminpar, double)
+      }
+      else if (blockName == "imextpar") {
+        FILL_LHBLOCK(imextpar, double)
+      }
+      //CPV +FLV
+      else if (blockName == "immsq2in") {
+        FILL_LHMATRIXBLOCK(immsq2in)
+      }
+      else if (blockName == "immsu2in") {
+        FILL_LHMATRIXBLOCK(immsu2in)
+      }
+      else if (blockName == "immsd2in") {
+        FILL_LHMATRIXBLOCK(immsd2in)
+      }
+      else if (blockName == "immsl2in") {
+        FILL_LHMATRIXBLOCK(immsl2in)
+      }
+      else if (blockName == "immse2in") {
+        FILL_LHMATRIXBLOCK(immse2in)
+      }
+      else if (blockName == "imtuin") {
+        FILL_LHMATRIXBLOCK(imtuin)
+      }
+      else if (blockName == "imtdin") {
+        FILL_LHMATRIXBLOCK(imtdin)
+      }
+      else if (blockName == "imtein") {
+        FILL_LHMATRIXBLOCK(imtein)
+      }
+      //Info:
+      else if (blockName == "spinfo" || blockName=="dcinfo") {
+        const string blockStr = (blockName=="dcinfo") ? "DCY" : "RGE";
+
+        for(SLHAea::Block::const_iterator lineIter = blockIter->begin(); lineIter != blockIter->end(); lineIter++) {
+          /* Add line to generic block (carbon copy of input structure) */
+          genericBlocks[blockName].set(lineIter->str());
+
+          if(!lineIter->is_data_line()) continue;
+          ifail = 0;
+
+          try {
+            const int i = SLHAea::to<int>(lineIter->at(0));
+            string entry = lineIter->at(1);
+
+            if (i == 3) {
+              message(1,"readSLHAea","(from "+blockStr+" program): "+entry,0);
+              if (blockName == "spinfo") spinfo3.set(entry); // type string
+              else dcinfo3.set(entry); // type string
+            } else if (i==4) {
+              message(2,"readSLHAea","(from "+blockStr+" program): "+entry,0);
+              if (blockName == "spinfo") spinfo4.set(entry); // type string
+              else dcinfo4.set(entry); // type string
+            } else {
+              //Rewrite string in uppercase
+              for (unsigned int j=0; j<entry.length(); j++)
+                entry[j] = toupper(entry[j]);
+              ifail = (blockName=="spinfo") ? spinfo.set(i,entry)
+                      : dcinfo.set(i,entry); // type string
+            }
+          } catch (std::bad_cast& e) {
+            ifail=-1;
+          }
+
+          if (ifail == -1) {
+            message(1,"readSLHAea",blockName+" reading error",0);
+          }
+          if (ifail == 1) {
+            message(0,"readSLHAea",blockName+" existing entry overwritten",0);
+          }
+        }
+      }
+      //SPECTRUM
+      //Pole masses
+      else if (blockName == "mass") {
+        FILL_LHBLOCK(mass, double)
+      }
+
+      //Mixing
+      else if (blockName == "alpha") {
+        for(SLHAea::Block::const_iterator lineIter = blockIter->begin(); lineIter != blockIter->end(); lineIter++) {
+          /* Add line to generic block (carbon copy of input structure) */
+          genericBlocks[blockName].set(lineIter->str());
+
+          if(!lineIter->is_data_line()) continue;
+          ifail = alpha.set(0, SLHAea::to<double>(lineIter->at(0)));
+          if (ifail == 1) {
+            message(0,"readSLHAea",blockName+" existing entry overwritten",0);
+          }
+        }
+      }
+      else if (blockName == "stopmix") {
+        FILL_LHMATRIXBLOCK(stopmix)
+      }
+      else if (blockName == "sbotmix") {
+        FILL_LHMATRIXBLOCK(sbotmix)
+      }
+      else if (blockName == "staumix") {
+        FILL_LHMATRIXBLOCK(staumix)
+      }
+      else if (blockName == "nmix") {
+        FILL_LHMATRIXBLOCK(nmix)
+      }
+      else if (blockName == "umix") {
+        FILL_LHMATRIXBLOCK(umix)
+      }
+      else if (blockName == "vmix") {
+        FILL_LHMATRIXBLOCK(vmix)
+      }
+      //FLV
+      else if (blockName == "usqmix") {
+        FILL_LHMATRIXBLOCK(usqmix)
+      }
+      else if (blockName == "dsqmix") {
+        FILL_LHMATRIXBLOCK(dsqmix)
+      }
+      else if (blockName == "selmix") {
+        FILL_LHMATRIXBLOCK(selmix)
+      }
+      else if (blockName == "snumix") {
+        FILL_LHMATRIXBLOCK(snumix)
+      }
+      else if (blockName == "snsmix") {
+        FILL_LHMATRIXBLOCK(snsmix)
+      }
+      else if (blockName == "snamix") {
+        FILL_LHMATRIXBLOCK(snamix)
+      }
+      //RPV
+      else if (blockName == "rvnmix") {
+        FILL_LHMATRIXBLOCK(rvnmix)
+      }
+      else if (blockName == "rvumix") {
+        FILL_LHMATRIXBLOCK(rvumix)
+      }
+      else if (blockName == "rvvmix") {
+        FILL_LHMATRIXBLOCK(rvvmix)
+      }
+      else if (blockName == "rvhmix") {
+        FILL_LHMATRIXBLOCK(rvhmix)
+      }
+      else if (blockName == "rvamix") {
+        FILL_LHMATRIXBLOCK(rvamix)
+      }
+      else if (blockName == "rvlmix") {
+        FILL_LHMATRIXBLOCK(rvlmix)
+      }
+      //CPV
+      else if (blockName == "cvhmix") {
+        FILL_LHMATRIXBLOCK(cvhmix)
+      }
+      else if (blockName == "imcvhmix") {
+        FILL_LHMATRIXBLOCK(imcvhmix)
+      }
+      //CPV + FLV
+      else if (blockName == "imusqmix") {
+        FILL_LHMATRIXBLOCK(imusqmix)
+      }
+      else if (blockName == "imdsqmix") {
+        FILL_LHMATRIXBLOCK(imdsqmix)
+      }
+      else if (blockName == "imselmix") {
+        FILL_LHMATRIXBLOCK(imselmix)
+      }
+      else if (blockName == "imsnumix") {
+        FILL_LHMATRIXBLOCK(imsnumix)
+      }
+      else if (blockName == "imnmix") {
+        FILL_LHMATRIXBLOCK(imnmix)
+      }
+      else if (blockName == "imumix") {
+        FILL_LHMATRIXBLOCK(imumix)
+      }
+      else if (blockName == "imvmix") {
+        FILL_LHMATRIXBLOCK(imvmix)
+      }
+      //NMSSM
+      else if (blockName == "nmhmix") {
+        FILL_LHMATRIXBLOCK(nmhmix)
+      }
+      else if (blockName == "nmamix") {
+        FILL_LHMATRIXBLOCK(nmamix)
+      }
+      else if (blockName == "nmnmix") {
+        FILL_LHMATRIXBLOCK(nmnmix)
+      }
+      
+      //DRbar Lagrangian parameters
+      else if (blockName == "gauge") {
+        FILL_LHBLOCK(gauge, double)
+      }
+      else if (blockName == "yu") {
+        FILL_LHMATRIXBLOCK(yu)
+      }
+      else if (blockName == "yd") {
+        FILL_LHMATRIXBLOCK(yd)
+      }
+      else if (blockName == "ye") {
+        FILL_LHMATRIXBLOCK(ye)
+      }
+      else if (blockName == "au") {
+        FILL_LHMATRIXBLOCK(au)
+      }
+      else if (blockName == "ad") {
+        FILL_LHMATRIXBLOCK(ad)
+      }
+      else if (blockName == "ae") {
+        FILL_LHMATRIXBLOCK(ae)
+      }
+      else if (blockName == "hmix") {
+        FILL_LHBLOCK(hmix, double)
+      }
+      else if (blockName == "msoft") {
+        FILL_LHBLOCK(msoft, double)
+      }
+      //FLV
+      else if (blockName == "vckm") {
+        FILL_LHMATRIXBLOCK(vckm)
+      }
+      else if (blockName == "upmns") {
+        FILL_LHMATRIXBLOCK(upmns)
+      }
+      else if (blockName == "msq2") {
+        FILL_LHMATRIXBLOCK(msq2)
+      }
+      else if (blockName == "msu2") {
+        FILL_LHMATRIXBLOCK(msu2)
+      }
+      else if (blockName == "msd2") {
+        FILL_LHMATRIXBLOCK(msd2)
+      }
+      else if (blockName == "msl2") {
+        FILL_LHMATRIXBLOCK(msl2)
+      }
+      else if (blockName == "mse2") {
+        FILL_LHMATRIXBLOCK(mse2)
+      }
+      else if (blockName == "tu") {
+        FILL_LHMATRIXBLOCK(tu)
+      }
+      else if (blockName == "td") {
+        FILL_LHMATRIXBLOCK(td)
+      }
+      else if (blockName == "te") {
+        FILL_LHMATRIXBLOCK(te)
+      }
+      //RPV
+      else if (blockName == "rvlamlle") {
+        FILL_LHTENSOR3BLOCK(rvlamlle)
+      }
+      else if (blockName == "rvlamlqd") {
+        FILL_LHTENSOR3BLOCK(rvlamlqd)
+      }
+      else if (blockName == "rvlamudd") {
+        FILL_LHTENSOR3BLOCK(rvlamudd)
+      }
+      else if (blockName == "rvtlle") {
+        FILL_LHTENSOR3BLOCK(rvtlle)
+      }
+      else if (blockName == "rvtlqd") {
+        FILL_LHTENSOR3BLOCK(rvtlqd)
+      }
+      else if (blockName == "rvtudd") {
+        FILL_LHTENSOR3BLOCK(rvtudd)
+      }
+      else if (blockName == "rvkappa") {
+        FILL_LHBLOCK(rvkappa, double)
+      }
+      else if (blockName == "rvd") {
+        FILL_LHBLOCK(rvd, double)
+      }
+      else if (blockName == "rvm2lh1") {
+        FILL_LHBLOCK(rvm2lh1, double)
+      }
+      else if (blockName == "rvsnvev") {
+        FILL_LHBLOCK(rvsnvev, double)
+      }
+      //CPV
+      else if (blockName == "imau") {
+        FILL_LHMATRIXBLOCK(imau)
+      }
+      else if (blockName == "imad") {
+        FILL_LHMATRIXBLOCK(imad)
+      }
+      else if (blockName == "imae") {
+        FILL_LHMATRIXBLOCK(imae)
+      }
+      else if (blockName == "imhmix") {
+        FILL_LHBLOCK(imhmix, double)
+      }
+      else if (blockName == "immsoft") {
+        FILL_LHBLOCK(immsoft, double)
+      }
+      //CPV+FLV
+      else if (blockName == "imvckm") {
+        FILL_LHMATRIXBLOCK(imvckm)
+      }
+      else if (blockName == "imupmns") {
+        FILL_LHMATRIXBLOCK(imupmns)
+      }
+      else if (blockName == "immsq2") {
+        FILL_LHMATRIXBLOCK(immsq2)
+      }
+      else if (blockName == "immsu2") {
+        FILL_LHMATRIXBLOCK(immsu2)
+      }
+      else if (blockName == "immsd2") {
+        FILL_LHMATRIXBLOCK(immsd2)
+      }
+      else if (blockName == "immsl2") {
+        FILL_LHMATRIXBLOCK(immsl2)
+      }
+      else if (blockName == "immse2") {
+        FILL_LHMATRIXBLOCK(immse2)
+      }
+      else if (blockName == "imtu") {
+        FILL_LHMATRIXBLOCK(imtu)
+      }
+      else if (blockName == "imtd") {
+        FILL_LHMATRIXBLOCK(imtd)
+      }
+      else if (blockName == "imte") {
+        FILL_LHMATRIXBLOCK(imte)
+      }
+      //NMSSM
+      else if (blockName == "nmssmrun") {
+        FILL_LHBLOCK(nmssmrun, double)
+      }
+      else message(0,"readSLHAea","storing non-SLHA(2) block: "+blockName,0);
+
+
+    } else if (blockType == "decay") {    // Decay blocks
+
+      //Ignore decay if decay table read-in switched off
+      if( !useDecay ) {
+        message(0,"readSLHAea","ignoring DECAY table for "+blockName
+                +" (DECAY read-in switched off)",0);
+        continue;
+      }
+
+      //Extract PDG code and width
+      int idDecay = 0;
+      double width = -1.;
+      try {
+        idDecay = SLHAea::to<int>(blockName);
+        width = SLHAea::to<double>(blockDefIter->at(2));
+      } catch (std::bad_cast& e) {
+        message(0,"readFile",
+                "PDG Code or decay width unreadable. Ignoring this DECAY block",0);
+        continue;
+      }
+
+      //Set PDG code and width
+      if (width <= 0.0) {
+        if (verboseSav >= 2)
+          message(0,"readSLHAea","reading stable particle "+blockName
+                  +"(forced width < 0 to zero)",0);
+        decays.push_back(LHdecayTable(idDecay, 0.0));
+        continue;
+      } else if (blockIter->data_size() == 0) {
+        if (verboseSav >= 2) message(0,"readSLHAea","reading WIDTH for "+blockName
+                +" (but no decay channels found)",0);
+        decays.push_back(LHdecayTable(idDecay, 0.0));
+        continue;
+      } else {
+        decays.push_back(LHdecayTable(idDecay, width));
+      }
+      decayIndices[idDecay] = decays.size() - 1;
+
+      //Print verbosely
+      if (verboseSav >= 2)
+        message(0,"readSLHAea","reading  DECAY table for "+blockName,0);
+
+      //Extract and set the decay channels and branching ratios
+      for(SLHAea::Block::const_iterator lineIter = blockIter->begin(); lineIter != blockIter->end(); lineIter++) {
+        if(!lineIter->is_data_line()) continue;
+        vector<int> idDa;
+        int nDa = 0;
+        double brat = -1.;
+        try {
+          brat = SLHAea::to<double>(lineIter->at(0));
+          nDa = SLHAea::to<int>(lineIter->at(1));
+          for (int i=0; i<nDa; i++) {
+            const int idThis = SLHAea::to<int>(lineIter->at(2+i));
+            idDa.push_back(idThis);
+          }
+        } catch (std::bad_cast& e) {
+          // Stop reading decay line for bad decay data
+          message(1,"readSLHAea","read error... ignoring decay channel",0);
+        }
+
+        if(nDa < 2) {
+          // Stop reading decay line for bad decay data
+          message(1,"readSLHAea","Not enough daughters... ignoring decay channel",0);
+        } else {
+          // Append decay channel.
+          decays[decayIndices[idDecay]].addChannel(brat,nDa,idDa);
+        }
+      }
+    }
+
+  }
+
+
+  //Print footer
+  printFooter();
+
+  return 0;
 
 }
 
@@ -679,6 +1431,13 @@ void SusyLesHouches::printFooter() {
 
 void SusyLesHouches::printSpectrum(int ifail) {
 
+// NOTE: Gambit hack for debugging
+  // Print a debugging message
+  if (ifail == 999) {
+    std::cout<<"\n\n!! SusyLesHouches within libpythia has been touched. !!\n\n";
+    return;
+  }
+
   // Exit if output switched off
   if (verboseSav <= 0) return;
 
