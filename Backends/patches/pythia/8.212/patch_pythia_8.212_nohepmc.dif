diff -rupN pythia_8.212_original/include/Pythia8/ParticleData.h pythia_8.212_patched/include/Pythia8/ParticleData.h
--- pythia_8.212_original/include/Pythia8/ParticleData.h	2015-09-23 16:34:38.000000000 +0100
+++ pythia_8.212_patched/include/Pythia8/ParticleData.h	2019-07-05 23:20:29.938681391 +0100
@@ -347,6 +347,10 @@ public:
   bool init(string startFile = "../xmldoc/ParticleData.xml") {
     initCommon(); return readXML(startFile);}
 
+  // Read in database from saved file stored in memory
+  bool init(const ParticleData &particleDataIn) {
+    initCommon(); return copyXML(particleDataIn);}
+
   // Overwrite existing database by reading from specific file.
   bool reInit(string startFile, bool xmlFormat = true) { initCommon();
     return (xmlFormat) ? readXML(startFile) : readFF(startFile);}
@@ -354,10 +358,17 @@ public:
   // Initialize pointers, normal Breit-Wigners and special resonances.
   void initWidths(vector<ResonanceWidths*> resonancePtrs);
 
-  // Read or list whole (or part of) database from/to an XML file.
+  // Read and process or list whole (or part of) database from/to an XML file.
   bool readXML(string inFile, bool reset = true) ;
   void listXML(string outFile);
 
+  // Copy and process XML information from another particleData object
+  bool copyXML(const ParticleData &particleDataIn);
+
+  // Auxiliary functions to readXML() and copyXML():
+  bool loadXML(string inFile, bool reset = true) ;
+  bool processXML(bool reset = true) ;
+
   // Read or list whole (or part of) database from/to a free format file.
   bool readFF(string inFile, bool reset = true) ;
   void listFF(string outFile);
@@ -560,6 +571,9 @@ public:
   ParticleDataEntry* particleDataEntryPtr(int idIn) {
     return (isParticle(idIn)) ? &pdt[abs(idIn)] : &pdt[0]; }
 
+  // Check initialisation status.
+  bool getIsInit() {return isInit;}
+  
 private:
 
   // Common data, accessible for the individual particles.
@@ -607,6 +621,9 @@ private:
   int    intAttributeValue(string line, string attribute);
   double doubleAttributeValue(string line, string attribute);
 
+  // Vector of strings containing the readable lines of the XML file
+  vector<string> xmlFileSav;
+  
 };
 
 //==========================================================================
diff -rupN pythia_8.212_original/include/Pythia8/PartonDistributions.h pythia_8.212_patched/include/Pythia8/PartonDistributions.h
--- pythia_8.212_original/include/Pythia8/PartonDistributions.h	2015-09-23 16:34:38.000000000 +0100
+++ pythia_8.212_patched/include/Pythia8/PartonDistributions.h	2019-07-05 23:20:29.938681391 +0100
@@ -156,9 +156,8 @@ class MSTWpdf : public PDF {
 public:
 
   // Constructor.
-  MSTWpdf(int idBeamIn = 2212, int iFitIn = 1,
-    string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-    : PDF(idBeamIn) {init( iFitIn,  xmlPath, infoPtr);}
+  MSTWpdf(int idBeamIn = 2212, int iFitIn = 1, string xmlPath = "../xmldoc/",
+    Info* infoPtr = 0) : PDF(idBeamIn) {init( iFitIn,  xmlPath, infoPtr);}
 
 private:
 
@@ -209,9 +208,8 @@ class CTEQ6pdf : public PDF {
 public:
 
   // Constructor.
-  CTEQ6pdf(int idBeamIn = 2212, int iFitIn = 1,
-    string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-    : PDF(idBeamIn) {init( iFitIn, xmlPath, infoPtr);}
+  CTEQ6pdf(int idBeamIn = 2212, int iFitIn = 1, string xmlPath = "../xmldoc/",
+    Info* infoPtr = 0) : PDF(idBeamIn) {init( iFitIn, xmlPath, infoPtr);}
 
 private:
 
@@ -333,8 +331,8 @@ public:
 
   // Constructor.
  PomH1FitAB(int idBeamIn = 990, int iFit = 1, double rescaleIn = 1.,
-   string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-   : PDF(idBeamIn) {rescale = rescaleIn; init( iFit, xmlPath, infoPtr);}
+   string xmlPath = "../xmldoc/", Info* infoPtr = 0) : PDF(idBeamIn)
+   {rescale = rescaleIn; init( iFit, xmlPath, infoPtr);}
 
 private:
 
@@ -365,8 +363,8 @@ public:
 
   // Constructor.
   PomH1Jets(int idBeamIn = 990,  double rescaleIn = 1.,
-   string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-   : PDF(idBeamIn) {rescale = rescaleIn; init( xmlPath, infoPtr);}
+   string xmlPath = "../xmldoc/", Info* infoPtr = 0) : PDF(idBeamIn)
+   {rescale = rescaleIn; init( xmlPath, infoPtr);}
 
 private:
 
@@ -464,22 +462,14 @@ class NNPDF : public PDF {
 public:
 
   // Constructor.
-  NNPDF(int idBeamIn = 2212, int iFitIn = 1,
-    string xmlPath = "../share/Pythia8/xmldoc/", Info* infoPtr = 0)
-    : PDF(idBeamIn), fPDFGrid(NULL), fXGrid(NULL), fLogXGrid(NULL),
-    fQ2Grid(NULL), fLogQ2Grid(NULL), fRes(NULL) {
-    init( iFitIn, xmlPath, infoPtr); };
+  NNPDF(int idBeamIn = 2212, int iFitIn = 1, string xmlPath = "../xmldoc/",
+    Info* infoPtr = 0) : PDF(idBeamIn), fPDFGrid(NULL), fXGrid(NULL),
+    fLogXGrid(NULL), fQ2Grid(NULL), fLogQ2Grid(NULL), fRes(NULL){
+      init( iFitIn, xmlPath, infoPtr); };
 
   // Destructor.
   ~NNPDF() {
-    if (fPDFGrid) {
-      for (int i = 0; i < fNFL; i++) {
-        for (int j = 0; j < fNX; j++)
-          if (fPDFGrid[i][j]) delete[] fPDFGrid[i][j];
-        if (fPDFGrid[i]) delete[] fPDFGrid[i];
-      }
-      delete[] fPDFGrid;
-    }
+    if (fPDFGrid) delete[] fPDFGrid;
     if (fXGrid) delete[] fXGrid;
     if (fLogXGrid) delete[] fLogXGrid;
     if (fQ2Grid) delete[] fQ2Grid;
@@ -499,7 +489,7 @@ private:
 
   // Variables to be set during code initialization.
   int iFit, fNX, fNQ2;
-  double ***fPDFGrid;
+  double *fPDFGrid;
   double *fXGrid;
   double *fLogXGrid;
   double *fQ2Grid;
diff -rupN pythia_8.212_original/include/Pythia8/Pythia.h pythia_8.212_patched/include/Pythia8/Pythia.h
--- pythia_8.212_original/include/Pythia8/Pythia.h	2015-09-23 16:34:39.000000000 +0100
+++ pythia_8.212_patched/include/Pythia8/Pythia.h	2019-07-08 02:29:07.798972052 +0100
@@ -56,6 +56,11 @@ public:
   // Constructor. (See Pythia.cc file.)
   Pythia(string xmlDir = "../share/Pythia8/xmldoc", bool printBanner = true);
 
+  // Special constructor to copy settings and particle database from another
+  // Pythia object instead of XML files (to speed up multiple initialisations)
+  Pythia(ParticleData& particleDataIn, Settings& settingsIn,
+         bool printBanner = true);
+  
   // Destructor. (See Pythia.cc file.)
   ~Pythia();
 
@@ -119,7 +124,7 @@ public:
     spacePtr = spacePtrIn; return true;}
 
   // Initialize.
-  bool init();
+  bool init(ostream& os = cout);
 
   // Generate the next event.
   bool next();
diff -rupN pythia_8.212_original/include/Pythia8/Settings.h pythia_8.212_patched/include/Pythia8/Settings.h
--- pythia_8.212_original/include/Pythia8/Settings.h	2015-09-23 16:34:39.000000000 +0100
+++ pythia_8.212_patched/include/Pythia8/Settings.h	2019-07-05 23:20:29.938681391 +0100
@@ -302,6 +302,9 @@ public:
   void resetMVec(string keyIn);
   void resetPVec(string keyIn);
 
+  // Check initialisation status
+  bool getIsInit() {return isInit;}
+  
 private:
 
   // Pointer to various information on the generation.
diff -rupN pythia_8.212_original/include/Pythia8/SusyLesHouches.h pythia_8.212_patched/include/Pythia8/SusyLesHouches.h
--- pythia_8.212_original/include/Pythia8/SusyLesHouches.h  2015-09-23 17:34:40.000000000 +0200
+++ pythia_8.212_patched/include/Pythia8/SusyLesHouches.h 2019-10-21 16:21:22.136417708 +0200
@@ -14,6 +14,9 @@
 #define Pythia8_SLHA_H
 
 #include "Pythia8/PythiaStdlib.h"
+// NOTE: Gambit hack to include slhaea support
+// SLHAea (for SLHA input from an SLHAea object instead of a file)
+#include "SLHAea/slhaea.h"
 
 namespace Pythia8 {
 
@@ -387,11 +390,13 @@ public:
   //Constructor, with and without filename.
   SusyLesHouches(int verboseIn=1) : verboseSav(verboseIn),
     headerPrinted(false), footerPrinted(false), filePrinted(false),
-    slhaRead(false), lhefRead(false), lhefSlha(false), useDecay(true) {};
+    slhaRead(false), lhefRead(false), lhefSlha(false), useDecay(true),
+    slhaeaCollPtr(NULL) {}; // NOTE: <== slhaeaCollPtr is a Gambit hack
   SusyLesHouches(string filename, int verboseIn=1) : verboseSav(verboseIn),
     headerPrinted(false), footerPrinted(false), filePrinted(false),
-    slhaRead(true), lhefRead(false), lhefSlha(false), useDecay(true)
-    {readFile(filename);};
+    slhaRead(true), lhefRead(false), lhefSlha(false), useDecay(true),
+    slhaeaCollPtr(NULL) {readFile(filename);}; // NOTE: <== slhaeaCollPtr is a Gambit hack
+
 
   //***************************** SLHA FILE I/O *****************************//
   // Read and write SLHA files
@@ -400,6 +405,8 @@ public:
   int readFile(istream& ,int verboseIn=1,
     bool useDecayIn=true);
   //int writeFile(string filename): write SLHA file on filename
+  // NOTE: Gambit hack to include slhaea support
+  void setSLHAea(const SLHAea::Coll* inputSLHAea) { slhaeaCollPtr = inputSLHAea; }
 
   //Output utilities
   void printHeader();   // print Header
@@ -641,6 +648,9 @@ private:
   int verboseSav;
   bool headerPrinted, footerPrinted, filePrinted;
   bool slhaRead, lhefRead, lhefSlha, useDecay;
+// NOTE: Gambit hack to include slhaea support
+  // SLHAea Collection (for SLHA input from a SLHAea::Coll instead of a file)
+  const SLHAea::Coll* slhaeaCollPtr;
 
 };
 
diff -rupN pythia_8.212_original/src/ParticleData.cc pythia_8.212_patched/src/ParticleData.cc
--- pythia_8.212_original/src/ParticleData.cc	2015-09-23 16:35:08.000000000 +0100
+++ pythia_8.212_patched/src/ParticleData.cc	2019-07-05 23:20:29.958681489 +0100
@@ -572,6 +572,8 @@ void ParticleData::initCommon() {
 
 void ParticleData::initWidths( vector<ResonanceWidths*> resonancePtrs) {
 
+  cout<<" initialising widths with size "<<resonancePtrs.size()<<" pdt size "<<pdt.size()<<endl;
+  
   // Initialize some common data.
   initCommon();
 
@@ -776,8 +778,44 @@ void ParticleData::initWidths( vector<Re
 
 bool ParticleData::readXML(string inFile, bool reset) {
 
+  // Load XML file into memory
+  if (!loadXML(inFile,reset)) return false;
+
+  // Process XML file (now stored in memory)
+  if (!processXML(reset)) return false;
+
+  // Done.
+  return true;
+}
+
+  //--------------------------------------------------------------------------
+
+// Read in database from pre-initialised particleData object.
+
+bool ParticleData::copyXML(const ParticleData &particleDataIn) {
+
+  // First Reset everything.
+  pdt.clear();
+  xmlFileSav.clear();
+  isInit = false;
+  xmlFileSav=particleDataIn.xmlFileSav;
+
+  // Process XML file (now stored in memory)
+  if (!processXML(true)) return false;
+
+  // Done.
+  return true;
+}
+  
+  
+//--------------------------------------------------------------------------
+
+// Load a specific XML file into memory (which may refer to others).
+
+bool ParticleData::loadXML(string inFile, bool reset) {
+
   // Normally reset whole database before beginning.
-  if (reset) {pdt.clear(); isInit = false;}
+  if (reset) {pdt.clear(); xmlFileSav.clear(); isInit = false;}
 
   // List of files to be checked.
   vector<string> files;
@@ -805,73 +843,8 @@ bool ParticleData::readXML(string inFile
       string word1;
       getfirst >> word1;
 
-      // Check for occurence of a particle. Add any continuation lines.
-      if (word1 == "<particle") {
-        while (line.find(">") == string::npos) {
-          string addLine;
-          getline(is, addLine);
-          line += addLine;
-        }
-
-        // Read in particle properties.
-        int idTmp          = intAttributeValue( line, "id");
-        string nameTmp     = attributeValue( line, "name");
-        string antiNameTmp = attributeValue( line, "antiName");
-        if (antiNameTmp == "") antiNameTmp = "void";
-        int spinTypeTmp    = intAttributeValue( line, "spinType");
-        int chargeTypeTmp  = intAttributeValue( line, "chargeType");
-        int colTypeTmp     = intAttributeValue( line, "colType");
-        double m0Tmp       = doubleAttributeValue( line, "m0");
-        double mWidthTmp   = doubleAttributeValue( line, "mWidth");
-        double mMinTmp     = doubleAttributeValue( line, "mMin");
-        double mMaxTmp     = doubleAttributeValue( line, "mMax");
-        double tau0Tmp     = doubleAttributeValue( line, "tau0");
-
-        // Erase if particle already exists.
-        if (isParticle(idTmp)) pdt.erase(idTmp);
-
-        // Store new particle. Save pointer, to be used for decay channels.
-        addParticle( idTmp, nameTmp, antiNameTmp, spinTypeTmp, chargeTypeTmp,
-          colTypeTmp, m0Tmp, mWidthTmp, mMinTmp, mMaxTmp, tau0Tmp);
-        particlePtr = particleDataEntryPtr(idTmp);
-
-      // Check for occurence of a decay channel. Add any continuation lines.
-      } else if (word1 == "<channel") {
-        while (line.find(">") == string::npos) {
-          string addLine;
-          getline(is, addLine);
-          line += addLine;
-        }
-
-        // Read in channel properties - products so far only as a string.
-        int onMode      = intAttributeValue( line, "onMode");
-        double bRatio   = doubleAttributeValue( line, "bRatio");
-        int meMode      = intAttributeValue( line, "meMode");
-        string products = attributeValue( line, "products");
-
-        // Read in decay products from stream. Must have at least one.
-        istringstream prodStream(products);
-        int prod0 = 0; int prod1 = 0; int prod2 = 0; int prod3 = 0;
-        int prod4 = 0; int prod5 = 0; int prod6 = 0; int prod7 = 0;
-        prodStream >> prod0 >> prod1 >> prod2 >> prod3 >> prod4 >> prod5
-                   >> prod6 >> prod7;
-        if (prod0 == 0) {
-          infoPtr->errorMsg("Error in ParticleData::readXML:"
-            " incomplete decay channel", line);
-          return false;
-        }
-
-        // Store new channel (if particle already known).
-        if (particlePtr == 0) {
-          infoPtr->errorMsg("Error in ParticleData::readXML:"
-            " orphan decay channel", line);
-          return false;
-        }
-        particlePtr->addChannel(onMode, bRatio, meMode, prod0, prod1,
-          prod2, prod3, prod4, prod5, prod6, prod7);
-
       // Check for occurence of a file also to be read.
-      } else if (word1 == "<file") {
+      if (word1 == "<file") {
         string file = attributeValue(line, "name");
         if (file == "") {
           infoPtr->errorMsg("Error in ParticleData::readXML:"
@@ -879,7 +852,106 @@ bool ParticleData::readXML(string inFile
         } else files.push_back(file);
       }
 
-    // End of loop over lines in input file and loop over files.
+      // Else save line to memory
+      else {
+        xmlFileSav.push_back(line);
+      }
+    }
+  }
+
+  //Done.
+  return true;
+  
+}
+
+//--------------------------------------------------------------------------
+
+// Process XML contents stored in memory
+
+bool ParticleData::processXML(bool reset) {
+
+  // Number of lines saved
+  int nLines = xmlFileSav.size();
+
+  // Process each line sequentially
+  particlePtr = 0;
+  int i=-1;
+  while (++i < nLines) {
+    
+    // Retrieve line
+    string line = xmlFileSav[i];
+
+    // Get first word of a line.
+    istringstream getfirst(line);
+    string word1;
+    getfirst >> word1;
+
+    // Check for occurence of a particle. Add any continuation lines.
+    if (word1 == "<particle") {
+      while (line.find(">") == string::npos) {
+        if (++i >= nLines) break;
+        string addLine = xmlFileSav[i];        
+        line += addLine;
+      }
+      
+      // Read in particle properties.
+      int idTmp          = intAttributeValue( line, "id");
+      string nameTmp     = attributeValue( line, "name");
+      string antiNameTmp = attributeValue( line, "antiName");
+      if (antiNameTmp == "") antiNameTmp = "void";
+      int spinTypeTmp    = intAttributeValue( line, "spinType");
+      int chargeTypeTmp  = intAttributeValue( line, "chargeType");
+      int colTypeTmp     = intAttributeValue( line, "colType");
+      double m0Tmp       = doubleAttributeValue( line, "m0");
+      double mWidthTmp   = doubleAttributeValue( line, "mWidth");
+      double mMinTmp     = doubleAttributeValue( line, "mMin");
+      double mMaxTmp     = doubleAttributeValue( line, "mMax");
+      double tau0Tmp     = doubleAttributeValue( line, "tau0");
+      
+      // Erase if particle already exists.
+      if (isParticle(idTmp)) pdt.erase(idTmp);
+      
+      // Store new particle. Save pointer, to be used for decay channels.
+      addParticle( idTmp, nameTmp, antiNameTmp, spinTypeTmp, chargeTypeTmp,
+                   colTypeTmp, m0Tmp, mWidthTmp, mMinTmp, mMaxTmp, tau0Tmp);
+      particlePtr = particleDataEntryPtr(idTmp);
+      
+      // Check for occurence of a decay channel. Add any continuation lines.
+    } else if (word1 == "<channel") {
+      while (line.find(">") == string::npos) {
+        if (++i >= nLines) break;        
+        string addLine = xmlFileSav[i];
+        line += addLine;
+      }
+      
+      // Read in channel properties - products so far only as a string.
+      int onMode      = intAttributeValue( line, "onMode");
+      double bRatio   = doubleAttributeValue( line, "bRatio");
+      int meMode      = intAttributeValue( line, "meMode");
+      string products = attributeValue( line, "products");
+      
+      // Read in decay products from stream. Must have at least one.
+      istringstream prodStream(products);
+      int prod0 = 0; int prod1 = 0; int prod2 = 0; int prod3 = 0;
+      int prod4 = 0; int prod5 = 0; int prod6 = 0; int prod7 = 0;
+      prodStream >> prod0 >> prod1 >> prod2 >> prod3 >> prod4 >> prod5
+                 >> prod6 >> prod7;
+      if (prod0 == 0) {
+        infoPtr->errorMsg("Error in ParticleData::readXML:"
+                          " incomplete decay channel", line);
+        return false;
+      }
+
+      // Store new channel (if particle already known).
+      if (particlePtr == 0) {
+        infoPtr->errorMsg("Error in ParticleData::readXML:"
+                          " orphan decay channel", line);
+        return false;
+      }
+      particlePtr->addChannel(onMode, bRatio, meMode, prod0, prod1,
+                              prod2, prod3, prod4, prod5, prod6, prod7);
+      
+      // End of loop over lines in input file and loop over files.
     };
   };
 
diff -rupN pythia_8.212_original/src/PartonDistributions.cc pythia_8.212_patched/src/PartonDistributions.cc
--- pythia_8.212_original/src/PartonDistributions.cc	2015-09-23 16:35:08.000000000 +0100
+++ pythia_8.212_patched/src/PartonDistributions.cc	2019-07-05 23:20:29.958681489 +0100
@@ -2133,17 +2133,10 @@ void NNPDF::init(int iFitIn, string xmlP
   for (int iq = 0; iq < fNQ2; iq++) fLogQ2Grid[iq] = log(fQ2Grid[iq]);
 
   // Prepare grid array.
-  fPDFGrid = new double**[fNFL];
-  for (int i = 0; i < fNFL; i++) {
-    fPDFGrid[i] = new double*[fNX];
-    for (int j = 0; j < fNX; j++) {
-      fPDFGrid[i][j] = new double[fNQ2];
-      for (int z = 0; z < fNQ2; z++) fPDFGrid[i][j][z] = 0.0;
-    }
-  }
-
+    fPDFGrid = new double[fNFL*fNX*fNQ2];
+  
   // Check values of number of grid entries.
-  if (fNX<= 0 || fNX>100 || fNQ2<=0 || fNQ2>50) {
+  if (fNX<4 || fNX>100 || fNQ2<2 || fNQ2>50) {
     cout << "Error in NNPDF::init, Invalid grid values" << endl
          << "fNX = " << fNX << endl << "fNQ2 = " << fNQ2 << endl
          << "fNFL = " <<fNFL << endl;
@@ -2156,46 +2149,210 @@ void NNPDF::init(int iFitIn, string xmlP
   for (int ix = 0; ix < fNX; ix++)
     for (int iq = 0; iq < fNQ2; iq++)
       for (int fl = 0; fl < fNFL; fl++)
-        f >> fPDFGrid[fl][ix][iq];
+      {
+        f >> fPDFGrid[(fl*fNX + ix)*fNQ2 + iq];
+      }
   f.close();
 
   // Other vectors.
   fRes = new double[fNFL];
-
+  
 }
 
 //--------------------------------------------------------------------------
 
-void NNPDF::xfUpdate(int , double x, double Q2) {
+ void NNPDF::xfUpdate(int , double x, double Q2) {
+ 
+ // Update using NNPDF routine, within allowed (x, q) range.
+ xfxevolve(x,Q2);
+ 
+ // Then transfer to Pythia8 notation.
+ xg     = fRes[6];
+ xu     = fRes[8];
+ xd     = fRes[7];
+ xubar  = fRes[4];
+ xdbar  = fRes[5];
+ xs     = fRes[9];
+ xsbar  = fRes[3];
+ xc     = fRes[10];
+ xb     = fRes[11];
+ xgamma = fRes[13];
+ 
+ // Subdivision of valence and sea.
+ xuVal  = xu - xubar;
+ xuSea  = xubar;
+ xdVal  = xd - xdbar;
+ xdSea  = xdbar;
+ 
+ // idSav = 9 to indicate that all flavours reset.
+ idSav  = 9;
+ 
+ }
 
-  // Update using NNPDF routine, within allowed (x, q) range.
-  xfxevolve(x,Q2);
+ 
+//--------------------------------------------------------------------------
+/*
+ *  NNPDF::xfxevolve(double x, double Q2) optimized to improve performance by ~2x
+ *
+ *  Modified by Hrayr Matevosyan on 24/06/15.
+ *  2015 CSSM/CoEPP, University of Adelaide.
+ *
+ */
+void NNPDF::xfxevolve(double x, double Q2) {
 
-  // Then transfer to Pythia8 notation.
-  xg     = fRes[6];
-  xu     = fRes[8];
-  xd     = fRes[7];
-  xubar  = fRes[4];
-  xdbar  = fRes[5];
-  xs     = fRes[9];
-  xsbar  = fRes[3];
-  xc     = fRes[10];
-  xb     = fRes[11];
-  xgamma = fRes[13];
-
-  // Subdivision of valence and sea.
-  xuVal  = xu - xubar;
-  xuSea  = xubar;
-  xdVal  = xd - xdbar;
-  xdSea  = xdbar;
+  // Freeze outside x-Q2 grid.
+  if (x < fXMINGRID)
+    x = fXMINGRID;
+  else if (x > fXGrid[fNX-1])
+    x = fXGrid[fNX-1];
+  
+  if (Q2 < fQ2Grid[0])
+    Q2 = fQ2Grid[0];
+  else if (Q2 > fQ2Grid[fNQ2-1])
+    Q2 = fQ2Grid[fNQ2-1];
+  
+  // Find nearest points in the x-Q2 grid.
+  int min = 0;
+  int max = fNX-1;
+  int mid;
+  while (max-min > 1)
+  {
+    mid = (min+max)/2;
+    if (x < fXGrid[mid]) max = mid;
+    else min = mid;
+  };
+  
+  int ix1 = min-1; //ix-1
+  if (ix1 < 0)
+    ix1=0;
+  else if(ix1 > (fNX-4))
+    ix1 = (fNX-4);
+  
+  // Find nearest points in the Q2 grid.
+  min = 0;
+  max = fNQ2-1;
+  while (max-min > 1)
+  {
+    mid = (min+max)/2;
+    if (Q2 < fQ2Grid[mid]) max = mid;
+    else min = mid;
+  };
+    
+  int ix2 = min;
+  if (ix2 > (fNQ2-2))
+    ix2 = (fNQ2-2);
+ 
+  //x grid values used
+  double x1, *x1a;
+  if (x < static_cast<double>(1e-1))
+  {
+    x1 = log(x);
+    x1a = fLogXGrid + ix1;
+  }
+  else
+  {
+    x1 = x;
+    x1a = fXGrid + ix1;
+  }
+  
+  if(
+     (x1a[0] - x1a[1])*
+     (x1a[0] - x1a[2])*
+     (x1a[0] - x1a[3])*
+     (x1a[1] - x1a[2])*
+     (x1a[1] - x1a[3])*
+     (x1a[2] - x1a[3])
+      == 0
+     )
+  {
+    cout << "NNPDF::polint, failure" << endl;
+    return;
+  }
 
-  // idSav = 9 to indicate that all flavours reset.
-  idSav  = 9;
+  //Q2 grid values used
+  double x2 = log(Q2);
+  double* x2a = fLogQ2Grid+ix2;
+  if ( (x2a[0]-x2a[1]) == 0)
+  {
+    cout << "NNPDF::polint, failure" << endl;
+    return;
+  }
+  
+  //Interpolation Variables
+  int iShift= ( abs(x2-x2a[0]) < abs(x2-x2a[1]) ) ? 0 : 1;
+  
+  double denl = (x2a[iShift]-x2)/(x2a[0]-x2a[1]);
+
+  int ns0 =0;
+  double dif = abs(x1-x1a[0]);
+  for (int i = 1; i < 4; i++)
+  {
+    double dift = abs(x1-x1a[i]);
+    if (dift < dif)
+    {
+      ns0 = i;
+      dif = dift;
+    }
+  }
 
+  //Loop over flavor index
+  for (int ipdf = 0; ipdf < fNFL; ipdf++)
+  {
+    //
+    //Interpolation in Q2
+    //
+    
+    double ym[4];
+    int iIndPDF = (ipdf*fNX + ix1)*fNQ2 + ix2;
+    ym[0] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    iIndPDF+=fNQ2;
+    ym[1] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    iIndPDF+=fNQ2;
+    ym[2] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    iIndPDF+=fNQ2;
+    ym[3] = fPDFGrid[iIndPDF+iShift] + (fPDFGrid[iIndPDF+1] - fPDFGrid[iIndPDF])*denl;
+    
+    //
+    //Interpolation in x
+    //
+    double c[4]={ym[0],ym[1],ym[2],ym[3]};
+    
+    int ns = ns0;
+    double y = ym[ns];
+    ns--;
+    double den;
+    for (int m = 1; m < 4; m++)
+    {
+      for (int i = 0; i < 4-m; i++)
+      {
+        den = (c[i+1]-ym[i])/(x1a[i]-x1a[i+m]);
+        c[i]  = (x1a[i]   - x1) * den;
+        ym[i] = (x1a[i+m] - x1) * den;
+      }
+      if (2*ns < 2-m)
+      {
+        y+= c[ns+1];
+      }
+      else
+      {
+        y+= ym[ns];
+        ns--;
+      }
+    }
+ 
+    fRes[ipdf] = y;
+  }
 }
 
-//--------------------------------------------------------------------------
 
+//--------------------------------------------------------------------------
+/*
+ *  NNPDF::xfxevolve(double x, double Q2) original code v8209
+ */
+/*
 void NNPDF::xfxevolve(double x, double Q2) {
 
   // Freeze outside x-Q2 grid.
@@ -2278,6 +2435,7 @@ void NNPDF::xfxevolve(double x, double Q
   }
 
 }
+*/
 
 //--------------------------------------------------------------------------
 
diff -rupN pythia_8.212_original/src/ProcessLevel.cc pythia_8.212_patched/src/ProcessLevel.cc
--- pythia_8.212_original/src/ProcessLevel.cc	2015-09-23 16:35:08.000000000 +0100
+++ pythia_8.212_patched/src/ProcessLevel.cc	2019-07-05 23:20:29.958681489 +0100
@@ -6,6 +6,20 @@
 // Function definitions (not found in the header) for the ProcessLevel class.
 
 #include "Pythia8/ProcessLevel.h"
+// NOTE: Gambit hack to limit infinite loops using threadsafe timers.
+#ifndef BOOST_CHRONO_HEADER_ONLY
+#define BOOST_CHRONO_HEADER_ONLY
+#ifndef BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#define BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#ifndef BOOST_SYSTEM_NO_DEPRECATED
+#define BOOST_SYSTEM_NO_DEPRECATED
+#include <boost/chrono.hpp>
+typedef boost::chrono::milliseconds ms;
+typedef boost::chrono::thread_clock thread_cl;
+typedef boost::chrono::thread_clock::time_point thread_tp;
+#endif // BOOST_SYSTEM_NO_DEPRECATED
+#endif // BOOST_CHRONO_DONT_PROVIDE_HYBRID_ERROR_HANDLING
+#endif // BOOST_CHRONO_HEADER_ONLY
 
 namespace Pythia8 {
 
@@ -182,9 +196,28 @@ bool ProcessLevel::init( Info* infoPtrIn
       &resonanceDecays, slhaInterfacePtr, userHooksPtr)) ++numberOn;
 
   // Sum maxima for Monte Carlo choice.
+  // NOTE: Gambit hack: Catch nans and infinities while summing up sigmas.
   sigmaMaxSum = 0.;
-  for (int i = 0; i < int(containerPtrs.size()); ++i)
-    sigmaMaxSum += containerPtrs[i]->sigmaMax();
+  bool valid = true;
+  for (int i = 0; i < int(containerPtrs.size()); ++i) {
+    if(std::isfinite(containerPtrs[i]->sigmaMax()))
+      sigmaMaxSum += containerPtrs[i]->sigmaMax();
+    else {
+      std::cerr<<"\n\n\n ERROR: in Pythia8::ProcessLevel::init:\n";
+      std::cerr<<"   Non-finite xsec: "<<containerPtrs[i]->sigmaMax()<<"\n";
+      std::cerr<<"   Process code: "<<containerPtrs[i]->code();
+      std::cerr<<",  Process: "<<containerPtrs[i]->name()<<"\n";
+      std::cerr<<"This model is invalid.\n\n\n";
+      delete containerPtrs[i];
+      containerPtrs.erase(containerPtrs.begin() + i);
+      i--;
+      valid = false;
+    }
+  }
+  if (!valid) {
+    infoPtr->errorMsg("Error in ProcessLevel::init: Non-finite xsecs");
+    return false;
+  }
 
   // Option to pick a second hard interaction: repeat as above.
   int number2On = 0;
@@ -282,12 +315,14 @@ bool ProcessLevel::init( Info* infoPtrIn
        <<"-------------*" << endl;
   }
 
+  /* NOTE: Gambit hack: ColliderBit has its own xsec veto... remove this:
   // If sum of maxima vanishes then refuse to do anything.
   if ( numberOn == 0  || sigmaMaxSum <= 0.) {
     infoPtr->errorMsg("Error in ProcessLevel::init: "
       "all processes have vanishing cross sections");
     return false;
   }
+  *** Gambit hack end */
   if ( doSecondHard && (number2On == 0  || sigma2MaxSum <= 0.) ) {
     infoPtr->errorMsg("Error in ProcessLevel::init: "
       "all second hard processes have vanishing cross sections");
@@ -615,8 +650,15 @@ bool ProcessLevel::nextOne( Event& proce
     physical = true;
 
     // Loop over tries until trial event succeeds.
-    for ( ; ; ) {
-
+    // NOTE: Gambit hack to limit infinite loops using threadsafe timers.
+    // TODO: configurable msTimeLimit...
+    double msTimer=0.;
+    double msTimeLimit = 1000.;
+    ms msDelta;
+    for (thread_tp start = thread_cl::now(); msTimer < msTimeLimit;
+         msDelta = boost::chrono::duration_cast<ms>(thread_cl::now() - start),
+         msTimer = msDelta.count())
+    {
       // Pick one of the subprocesses.
       double sigmaMaxNow = sigmaMaxSum * rndmPtr->flat();
       int iMax = containerPtrs.size() - 1;
@@ -630,6 +672,11 @@ bool ProcessLevel::nextOne( Event& proce
       // Check for end-of-file condition for Les Houches events.
       if (infoPtr->atEndOfFile()) return false;
     }
+    if (msTimer >= msTimeLimit) {
+      std::cerr<<"\n\n\n WARNING: in Pythia8::ProcessLevel::next:\n";
+      std::cerr<<"   Trial event stuck. Aborting event generation\n\n\n";
+      return false;
+    }
 
     // Update sum of maxima if current maximum violated.
     if (containerPtrs[iContainer]->newSigmaMax()) {
diff -rupN pythia_8.212_original/src/Pythia.cc pythia_8.212_patched/src/Pythia.cc
--- pythia_8.212_original/src/Pythia.cc	2015-09-23 16:35:08.000000000 +0100
+++ pythia_8.212_patched/src/Pythia.cc	2019-07-08 02:29:02.250952813 +0100
@@ -113,7 +113,9 @@ Pythia::Pythia(string xmlDir, bool print
     info.errorMsg("Abort from Pythia::Pythia: settings unavailable");
     return;
   }
-
+  // Also save XML path in settings
+  settings.addWord("xmlPath",xmlPath);
+  
   // Check that XML version number matches code version number.
   double versionNumberXML = parm("Pythia:versionNumber");
   isConstructed = (abs(versionNumberXML - VERSIONNUMBERCODE) < 0.0005);
@@ -157,6 +159,112 @@ Pythia::Pythia(string xmlDir, bool print
 
 //--------------------------------------------------------------------------
 
+// Constructor from pre-initialised ParticleData and Settings objects.
+
+Pythia::Pythia(ParticleData& particleDataIn, Settings& settingsIn,
+                 bool printBanner) {
+
+  // Initial values for pointers to PDF's.
+  useNewPdfA      = false;
+  useNewPdfB      = false;
+  useNewPdfHard   = false;
+  useNewPdfPomA   = false;
+  useNewPdfPomB   = false;
+  pdfAPtr         = 0;
+  pdfBPtr         = 0;
+  pdfHardAPtr     = 0;
+  pdfHardBPtr     = 0;
+  pdfPomAPtr      = 0;
+  pdfPomBPtr      = 0;
+
+  // Initial values for pointers to Les Houches Event objects.
+  doLHA           = false;
+  useNewLHA       = false;
+  lhaUpPtr        = 0;
+
+  //Initial value for couplings pointer
+  couplingsPtr    = &couplings;
+
+  // Initial value for pointer to external decay handler.
+  decayHandlePtr  = 0;
+
+  // Initial value for pointer to user hooks.
+  userHooksPtr    = 0;
+
+  // Initial value for pointer to merging hooks.
+  doMerging          = false;
+  hasMergingHooks    = false;
+  hasOwnMergingHooks = false;
+  mergingHooksPtr    = 0;
+
+  // Initial value for pointer to beam shape.
+  useNewBeamShape = false;
+  beamShapePtr    = 0;
+
+  // Initial values for pointers to timelike and spacelike showers.
+  useNewTimesDec  = false;
+  useNewTimes     = false;
+  useNewSpace     = false;
+  timesDecPtr     = 0;
+  timesPtr        = 0;
+  spacePtr        = 0;
+
+  // Copy XML path
+  const string key = "xmlPath";
+  xmlPath = settingsIn.word(key);
+  
+  // Copy settings database
+  settings = settingsIn;
+  // Reset pointers to pertain to this PYTHIA object
+  settings.initPtr( &info);
+  isConstructed = settings.getIsInit();
+  if (!isConstructed) {
+    info.errorMsg("Abort from Pythia::Pythia: settings unavailable");
+    return;
+  }
+
+  // Check that XML version number matches code version number.
+  double versionNumberXML = parm("Pythia:versionNumber");
+  isConstructed = (abs(versionNumberXML - VERSIONNUMBERCODE) < 0.0005);
+  if (!isConstructed) {
+    ostringstream errCode;
+    errCode << fixed << setprecision(3) << ": in code " << VERSIONNUMBERCODE
+            << " but in XML " << versionNumberXML;
+    info.errorMsg("Abort from Pythia::Pythia: unmatched version numbers",
+      errCode.str());
+    return;
+  }
+
+  // Check that header version number matches code version number.
+  isConstructed = (abs(VERSIONNUMBERHEAD - VERSIONNUMBERCODE) < 0.0005);
+  if (!isConstructed) {
+    ostringstream errCode;
+    errCode << fixed << setprecision(3) << ": in code " << VERSIONNUMBERCODE
+            << " but in header " << VERSIONNUMBERHEAD;
+    info.errorMsg("Abort from Pythia::Pythia: unmatched version numbers",
+      errCode.str());
+    return;
+  }
+
+  // Read in files with all particle data.
+  particleData.initPtr( &info, &settings, &rndm, couplingsPtr);
+  isConstructed = particleData.init( particleDataIn);
+  if (!isConstructed) {
+    info.errorMsg("Abort from Pythia::Pythia: particle data unavailable");
+    return;
+  }
+
+  // Write the Pythia banner to output.
+  if (printBanner) banner();
+
+  // Not initialized until at the end of the init() call.
+  isInit = false;
+  info.addCounter(0);
+
+}
+
+//--------------------------------------------------------------------------
+  
 // Destructor.
 
 Pythia::~Pythia() {
@@ -338,7 +446,7 @@ bool Pythia::setPDFPtr( PDF* pdfAPtrIn,
 
 // Routine to initialize with the variable values of the Beams kind.
 
-bool Pythia::init() {
+bool Pythia::init(ostream& os) {  // NOTE: <== os is a Gambit hack
 
   // Check that constructor worked.
   isInit = false;
@@ -677,7 +785,7 @@ bool Pythia::init() {
   // Send info/pointers to process level for initialization.
   if ( doProcessLevel && !processLevel.init( &info, settings, &particleData,
     &rndm, &beamA, &beamB, couplingsPtr, &sigmaTot, doLHA, &slhaInterface,
-    userHooksPtr, sigmaPtrs, phaseSpacePtrs) ) {
+    userHooksPtr, sigmaPtrs, phaseSpacePtrs, os) ) {  // NOTE: <== os is a Gambit hack
     info.errorMsg("Abort from Pythia::init: "
       "processLevel initialization failed");
     return false;
@@ -1618,12 +1726,12 @@ void Pythia::banner(ostream& os) {
      << "ische Physik,                         |  | \n"
      << " |  |     Universitaet Heidelberg, Philosophe"
      << "nweg 16, D-69120 Heidelberg, Germany; |  | \n"
-     << " |  |      e-mail: n.desai@thphys.uni-heidelb"
+     << " |  |      e-mail: n.desai@thuni-heidelb"
      << "erg.de                                |  | \n"
      << " |  |   Philip Ilten;  Massachusetts Institut"
      << "e of Technology,                      |  | \n"
-     << " |  |      stationed at CERN, CH-1211 Geneva "
-     << "23, Switzerland;                      |  | \n"
+     << " |  |      77 Massachusetts Ave, Cambridge, M"
+     << "A 02139, USA;                         |  | \n"
      << " |  |      e-mail: philten@cern.ch           "
      << "                                      |  | \n"
      << " |  |   Stephen Mrenna;  Computing Division, "
diff -rupN pythia_8.212_original/src/ResonanceDecays.cc pythia_8.212_patched/src/ResonanceDecays.cc
--- pythia_8.212_original/src/ResonanceDecays.cc	2015-09-23 16:35:09.000000000 +0100
+++ pythia_8.212_patched/src/ResonanceDecays.cc	2019-07-05 23:20:29.958681489 +0100
@@ -92,6 +92,10 @@ bool ResonanceDecays::next( Event& proce
           idProd.push_back( idNow);
         }
 
+
+        // GAMBIT fix for Pythia bug. (To be fixed in Pythia versions > 8.212)
+        mProd.resize(1);
+
         // Pick masses. Pick new channel if fail.
         if (!pickMasses()) continue;
         foundChannel = true;
@@ -191,11 +195,15 @@ bool ResonanceDecays::pickMasses() {
     mSumMin     += mMinBW[i];
   }
 
-  // If sum of minimal masses above mother mass then give up.
-  if (mSumMin + MSAFETY > mMother) return false;
+  // GAMBIT modification to allow decays at small mass splittings:
+  // Switched order of the two next if-statements and changed
+  // 0.5*MSAFETY to 0.01*MSAFETY.
 
   // If sum of masses below and no Breit-Wigners then done.
-  if (mSum + 0.5 * MSAFETY < mMother && nBW == 0) return true;
+  if (mSum + 0.01 * MSAFETY < mMother && nBW == 0) return true;
+
+  // If sum of minimal masses above mother mass then give up.
+  if (mSumMin + MSAFETY > mMother) return false;
 
   // Else if below then retry Breit-Wigners, with simple treshold.
   if (mSum + MSAFETY < mMother) {
diff -rupN pythia_8.212_original/src/SusyLesHouches.cc pythia_8.212_patched/src/SusyLesHouches.cc
--- pythia_8.212_original/src/SusyLesHouches.cc 2015-09-23 17:35:10.000000000 +0200
+++ pythia_8.212_patched/src/SusyLesHouches.cc  2019-10-21 16:19:59.620048538 +0200
@@ -20,23 +20,34 @@ namespace Pythia8 {
 int SusyLesHouches::readFile(string slhaFileIn, int verboseIn,
   bool useDecayIn) {
 
-  slhaFile = slhaFileIn;
-  // Check that input file is OK.
-  const char* cstring = slhaFile.c_str();
-  igzstream file(cstring);
-
-  // Exit if input file not found. Else print file name.
-  if (!file.good()) {
-    message(2,"readFile",slhaFile+" not found",0);
-    return -1;
-    slhaRead=false;
-  }
-  if (verboseSav >= 3) {
-    message(0,"readFile","parsing "+slhaFile,0);
-    filePrinted = true;
-  }
+  // NOTE: Gambit hack for slhaea support:
+  // If the slhaeaCollPtr is set, get the SLHA content as a stringstream
+  // from that pointer and pass this to Pythia's readFile function.
+  if (slhaeaCollPtr) // GAMBIT hack
+  {
+    std::istringstream slhaea_content(slhaeaCollPtr->str());
+    return readFile( slhaea_content, verboseIn, useDecayIn );
+  }
+  else  // Pythia original
+  {
+    slhaFile = slhaFileIn;
+    // Check that input file is OK.
+    const char* cstring = slhaFile.c_str();
+    igzstream file(cstring);
+
+    // Exit if input file not found. Else print file name.
+    if (!file.good()) {
+      message(2,"readFile",slhaFile+" not found",0);
+      return -1;
+      slhaRead=false;
+    }
+    if (verboseSav >= 3) {
+      message(0,"readFile","parsing "+slhaFile,0);
+      filePrinted = true;
+    }
 
-  return readFile( file, verboseIn, useDecayIn );
+    return readFile( file, verboseIn, useDecayIn );
+  }
 }
 
 int SusyLesHouches::readFile(istream& is, int verboseIn,
@@ -635,7 +646,7 @@ int SusyLesHouches::readFile(istream& is
     return 102;
   }
   else return iFailFile;
-
+    
 }
 
 //--------------------------------------------------------------------------
@@ -679,6 +690,13 @@ void SusyLesHouches::printFooter() {
 
 void SusyLesHouches::printSpectrum(int ifail) {
 
+// NOTE: Gambit hack for debugging
+  // Print a debugging message
+  if (ifail == 999) {
+    std::cout<<"\n\n!! SusyLesHouches within libpythia has been touched. !!\n\n";
+    return;
+  }
+
   // Exit if output switched off
   if (verboseSav <= 0) return;
 
@@ -1467,6 +1485,8 @@ int SusyLesHouches::checkSpectrum() {
     }
   }
 
+  // GAMBIT NMSSM hack
+  /*
   // CPV
   if (modsel(5) != 0) {
     if (!cvhmix.exists()) {
@@ -1474,6 +1494,7 @@ int SusyLesHouches::checkSpectrum() {
       ifail=-1;
     }
   }
+  */ 
 
   // FLV (regardless of whether RPV or not)
   if (modsel(6) != 0) {
@@ -1596,18 +1617,22 @@ int SusyLesHouches::checkSpectrum() {
   }
 
   //NMIX
-  if (nmix.exists()) {
-    for (int i=1;i<=4;i++) {
-      double cn1=0.0;
-      double cn2=0.0;
-      for (int j=1;j<=4;j++) {
-        cn1 += pow(nmix(i,j),2);
-        cn2 += pow(nmix(j,i),2);
-      }
-      if (abs(1.0-cn1) > 1e-3 || abs(1.0-cn2) > 1e-3) {
-        ifail=2;
-        message(2,"checkSpectrum","NMIX is not unitary (wrong format?)",0);
-        break;
+  // GAMBIT NMSSM hack: don't perform check for 4x4 NMIX block when the
+  // NMSSM i used, i.e. when modsel(3) == 1.
+  if (modsel(3) != 1) {
+    if (nmix.exists()) {
+      for (int i=1;i<=4;i++) {
+        double cn1=0.0;
+        double cn2=0.0;
+        for (int j=1;j<=4;j++) {
+          cn1 += pow(nmix(i,j),2);
+          cn2 += pow(nmix(j,i),2);
+        }
+        if (abs(1.0-cn1) > 1e-3 || abs(1.0-cn2) > 1e-3) {
+          ifail=2;
+          message(2,"checkSpectrum","NMIX is not unitary (wrong format?)",0);
+          break;
+        }
       }
     }
   }
@@ -1657,6 +1682,10 @@ int SusyLesHouches::checkSpectrum() {
 
   }
 
+  // GAMBIT hack: these unitarity checks don't include
+  // the corresponding IM- blocks with the imaginary components.
+  // (Fixed in later Pythia versions.) 
+  /*
   //STOPMIX, SBOTMIX
   if (stopmix.exists() && sbotmix.exists()) {
     for (int i=1;i<=2;i++) {
@@ -1749,7 +1778,11 @@ int SusyLesHouches::checkSpectrum() {
         break;
       }
     }
-  }  //NMSSM:
+  }  
+  */ 
+
+
+  //NMSSM:
   if (modsel(3) == 1) {
     //NMNMIX
     if ( nmnmix.exists() ) {
