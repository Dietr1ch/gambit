diff -Naur a/src/bbn.c b/src/bbn.c
--- a/src/bbn.c	2019-05-02 23:54:01.000000000 +0200
+++ b/src/bbn.c	2019-04-26 17:46:58.000000000 +0200
@@ -393,7 +393,7 @@
 
 /*----------------------------------------------------*/
 
-int fill_params(double T, double Tnu, double phie, double h_eta, double a, double rho_phi, double dt0, double* dT, double* dTnu, double* dphie, double* dh_eta, double* da, double* drhophi, double dY_dt[NNUC+1], double Y0[NNUC+1], double Y[NNUC+1], const double Am[NNUC+1], const double Zm[NNUC+1], const double Dm[NNUC+1], const double reacparam[NNUCREAC+1][10], double norm, int loop, int inc, int ip, struct relicparam* paramrelic, struct errorparam* paramerror)
+int fill_params(double T, double* Tnu, double phie, double h_eta, double a, double rho_phi, double dt0, double* dT, double* dTnu, double* dphie, double* dh_eta, double* da, double* drhophi, double dY_dt[NNUC+1], double Y0[NNUC+1], double Y[NNUC+1], const double Am[NNUC+1], const double Zm[NNUC+1], const double Dm[NNUC+1], const double reacparam[NNUCREAC+1][10], double norm, int loop, int inc, int ip, struct relicparam* paramrelic, struct errorparam* paramerror)
 /* Routine computing the time-derivatives of T, phie, h_eta, a, rho_phi and Y[] */
 {
 	int i;
@@ -433,7 +433,7 @@
         wimp_mass_ratio = paramrelic->m_chi / 1.e3 / m_e;
     
 		if (paramrelic->EM_coupled) Tvar=T;
-		else Tvar=Tnu;
+		else Tvar=*Tnu;
 		zW = wimp_mass_ratio*z*T/Tvar;
 	}
 
@@ -555,21 +555,26 @@
 	/* ########### NEUTRINO DENSITY ############ */
 	
 	double Ti=paramrelic->Tinit*K_to_eV;
-	double Tnud=paramrelic->Tnudec*K_to_eV;
+	double Tnud=Ti;
+
+	if(!((paramrelic->wimp)&&((paramrelic->neut_coupled)||(paramrelic->neuteq_coupled))))
+	{
+		if (T>Tnud) *Tnu=T;
+		else *Tnu=pow(h_eta*pow(T,3.)/paramrelic->rhob0,1./3.)*Ti;
+	}
 	
-	double rho_neutrinos=neutdens(Tnu,paramrelic);
+	double rho_neutrinos=neutdens(*Tnu,paramrelic);
 	double P_neutrinos=0.;
 	double drho_neutrinos_dTnu=0.;
 	double rho_neuteq=0.;
 	double P_neuteq=0.;
 	double drho_neuteq=0.;
-	double Tnu_eq=Tnu;
-
-	P_neutrinos=rho_neutrinos/3.;
-	drho_neutrinos_dTnu=neutdens_deriv(Tnu,paramrelic);
+	double Tnu_eq=*Tnu;
 
 	if((paramrelic->wimp)&&((paramrelic->neut_coupled)||(paramrelic->neuteq_coupled)))
 	{
+		P_neutrinos=rho_neutrinos/3.;
+		drho_neutrinos_dTnu=neutdens_deriv(*Tnu,paramrelic);
 		if (paramrelic->neut_coupled)
 		{
 			// Equivalent neutrinos have their own temperature and are decoupled, thus derivative is zero
@@ -579,15 +584,15 @@
 		else
 		{
 			// Common SM and equivalent neutrino temperature
-			rho_neuteq=2.*pow(pi,2.)/30.*7./8.*paramrelic->dNnu*pow(Tnu,4.);
-			drho_neuteq=7.*pow(pi,2.)/30.*paramrelic->dNnu*pow(Tnu,3.);
+			rho_neuteq=2.*pow(pi,2.)/30.*7./8.*paramrelic->dNnu*pow(*Tnu,4.);
+			drho_neuteq=7.*pow(pi,2.)/30.*paramrelic->dNnu*pow(*Tnu,3.);
 		}
 		P_neuteq=rho_neuteq/3.;
 	}
 	else
 	{
 		// SM and equivalent neutrinos share same temperature
-		rho_neuteq=2.*pow(pi,2.)/30.*7./8.*paramrelic->dNnu*pow(Tnu,4.);
+		rho_neuteq=2.*pow(pi,2.)/30.*7./8.*paramrelic->dNnu*pow(*Tnu,4.);
 		P_neuteq=rho_neuteq/3.;
 		drho_neuteq=0.;
 	}
@@ -621,7 +626,7 @@
 	// Summing up all energy densities from different sources
 	double H=sqrt(G*8.*pi/3.*(rho_gamma+rho_epem+rho_wimp+rho_neutrinos+rho_neuteq+rho_baryons+rho_cdm+rhod+rho_phi));
 	
-	rate_pn(f,r,T/K_to_eV,Tnu/K_to_eV,paramrelic,paramerror); // conversion to CGS units
+	rate_pn(f,r,T/K_to_eV,*Tnu/K_to_eV,paramrelic,paramerror); // conversion to CGS units
 	
 	f[1]*=norm;
 	r[1]*=norm;
@@ -660,46 +665,52 @@
 	double dphie_dlna3=-dN_epem_dphie*pow(pi,2.)/(2.*M_u*g_to_GeV)*h_eta*sum_ZY;
 	double dphie_dZY=dN_epem_dphie*pow(pi,2.)/(2.*M_u*g_to_GeV)*h_eta;
 
-	double dlna3_dT,dlna3_dTnu;
-	dlna3_dT=dlna3_dTnu=0.;
+	double dlna3_dT,dlna3_dTnu,dTnu_dt,dlnTnu_dt;
+	dlna3_dT=dlna3_dTnu=dTnu_dt=dlnTnu_dt=0.;
 
 	if((paramrelic->wimp)&&((paramrelic->neut_coupled)||(paramrelic->neuteq_coupled)))
 	{
 		// WIMPs are coupled to neutrinos, so need to dynamically vary Tnu
 		if (paramrelic->neuteq_coupled)
 		{
-			dlna3_dTnu=-(drho_neutrinos_dTnu+drho_neuteq+drho_wimp_dTvar)/(rho_neutrinos+P_neutrinos+rho_neuteq+P_neuteq+rho_wimp+P_wimp-pow(T,4.)/3.*neutN(T));
+			dlna3_dTnu=-(drho_neutrinos_dTnu+drho_neuteq+drho_wimp_dTvar)/(rho_neutrinos+P_neutrinos+rho_neuteq
+																		   +P_neuteq+rho_wimp+P_wimp);
 		}
 		else
 		{
-			dlna3_dTnu=-(drho_neutrinos_dTnu+drho_wimp_dTvar)/(rho_neutrinos+P_neutrinos+rho_wimp+P_wimp-pow(T,4.)/3.*neutN(T));
+			dlna3_dTnu=-(drho_neutrinos_dTnu+drho_wimp_dTvar)/(rho_neutrinos+P_neutrinos+rho_wimp+P_wimp);
 		}
 
+		dTnu_dt=3.*H/dlna3_dTnu;
+		dlnTnu_dt=dTnu_dt/(*Tnu);
 		// No WIMP contribution to dlna3_dT, since they are not EM coupled
 		dlna3_dT=-(drho_gamma_dT+drho_epem_dT+drho_epem_dphie*dphie_dT+rho_baryons*zeta*sum_Y
 					+paramrelic->coupd*drhod_dT-T*dsd_dT)/
-				(rho_gamma+P_gamma+rho_epem+P_epem+rho_baryons*(2./3.*zeta*T*sum_Y+zeta*T*sum_dY_dt/(H*3.)+sum_DeltaMdY_dt/(H*3.))
+				(rho_gamma+P_gamma+rho_epem+P_epem+rho_baryons*(2./3.*zeta*T*sum_Y+zeta*T*sum_dY_dt/(H*3.)
+																				+sum_DeltaMdY_dt/(H*3.))
 				 +paramrelic->coupd*(rhod+Pd)-T*sd+drho_epem_dphie*(dphie_dlna3+dphie_dZY*sum_ZdY_dt/(H*3.))-T*Sigmarad/(H*3.));	
 	}
 	else
 	{
-		dlna3_dTnu=-(drho_neutrinos_dTnu+drho_neuteq)/(rho_neutrinos+P_neutrinos+rho_neuteq+P_neuteq-pow(T,4.)/3.*neutN(T));
-
 		// No WIMPs (relevant WIMP parameters set to 0 earlier), or EM coupled WIMPs
 		dlna3_dT=-(drho_gamma_dT+drho_epem_dT+drho_epem_dphie*dphie_dT+(rho_baryons*K_to_eV)*zeta*sum_Y
 					+paramrelic->coupd*drhod_dT-T*dsd_dT+drho_wimp_dTvar)/
-				(rho_gamma+P_gamma+rho_epem+P_epem+rho_baryons*(2./3.*zeta*T*sum_Y+zeta*T*sum_dY_dt/(H*3.)+sum_DeltaMdY_dt/(H*3.))
+				(rho_gamma+P_gamma+rho_epem+P_epem+rho_baryons*(2./3.*zeta*T*sum_Y+zeta*T*sum_dY_dt/(H*3.)
+																				+sum_DeltaMdY_dt/(H*3.))
 				 +paramrelic->coupd*(rhod+Pd)-T*sd+drho_epem_dphie*(dphie_dlna3+dphie_dZY*sum_ZdY_dt/(H*3.))+rho_wimp+P_wimp-T*Sigmarad/(H*3.));
 	}
-
-	double dTnu_dt,dT_dt;
-	if(isinf(dlna3_dTnu)) dTnu_dt=0.; else dTnu_dt=3.*H/dlna3_dTnu;
-	if(isinf(dlna3_dT)) dT_dt=0.; dT_dt=3.*H/dlna3_dT;
 	
+	double dT_dt=3.*H/dlna3_dT;
 	double dlnT_dt=dT_dt/T;
 	double dh_dt=-3.*h_eta*(H+dlnT_dt);
 	double dphie_dt=dphie_dT*dT_dt+dphie_dlna3*(H*3.)+dphie_dZY*sum_ZdY_dt;
 	double da_dt=H*a;
+
+	if(!((paramrelic->wimp)&&((paramrelic->neut_coupled)||(paramrelic->neuteq_coupled))))
+	{
+		if (T>Tnud) dTnu_dt=dT_dt;
+		else dTnu_dt=(dh_dt*pow(h_eta,-2./3.)*T/3.+pow(h_eta,1./3.)*dT_dt)*Ti/pow(paramrelic->rhob0,1./3.);
+	}
 	
 	double drhophi_dt=0.;
 	if(paramrelic->phi_model&&rho_phi!=0.) drhophi_dt=-(paramrelic->n_phi*H+paramrelic->Gamma_phi)*rho_phi;
@@ -948,7 +959,7 @@
     
     double Tprev=T;
     double Tnu=T;
-    double Tnud=paramrelic->Tnudec*K_to_eV;   // Neutrino decoupling temperature
+    double Tnud=Ti;   // Neutrino decoupling temperature
     double Tnu_eq=Tnu; // Temperature of the equivalent neutrinos. Same as Tnu except in the case of WIMPs with coupling=1
 
     if (DMpn / T > 58.)
@@ -1156,7 +1167,7 @@
 			{
 				/* ########### DARK ENERGY DENSITY AND ENTROPY ########### */
 		
-				fill_params(T,Tnu,phie,h_eta,a,rho_phi,dt,&dT_dt,&dTnu_dt,&dphie_dt,&dh_dt,&da_dt,&drhophi_dt,dY_dt,Y0,Y,Am,Zm,Dm,reacparam,norm,loop,inc,ip,paramrelic,paramerror);
+				fill_params(T,&Tnu,phie,h_eta,a,rho_phi,dt,&dT_dt,&dTnu_dt,&dphie_dt,&dh_dt,&da_dt,&drhophi_dt,dY_dt,Y0,Y,Am,Zm,Dm,reacparam,norm,loop,inc,ip,paramrelic,paramerror);
 						  
 				dlnT_dt=dT_dt/T;
 												 
@@ -1220,13 +1231,13 @@
 					phie=phie0+dphie_dt0*dt;
 					a=a0+da_dt0;
 
-					Tnu0=Tnu;
-					dTnu0_dt=dTnu_dt;
-					Tnu=Tnu0+dTnu0_dt*dt;
-
 					if ((paramrelic->wimp)&&((paramrelic->neut_coupled)||(paramrelic->neuteq_coupled)))
 					{
 						// Tnu as dynamic variable in case of neutrino coupled WIMPs
+						Tnu0=Tnu;
+						dTnu0_dt=dTnu_dt;
+						if (T>=Tnud) Tnu=T;
+						else Tnu=Tnu0+dTnu0_dt*dt;
 						if ((paramrelic->neut_coupled)&&(T<Tnud))
 						{
 							// If WIMPs are coupled only to SM neutrinos, Tnu_eq is proportional to a^-1 after neutrino decoupling
@@ -1238,6 +1249,13 @@
 							Tnu_eq=Tnu;
 						}
 					}
+					else
+					{
+						// If not neutrino coupled WIMPs, Tnu and Tnu_eq is proportional to a^-1 after neutrino decoupling
+						if (T>Tnud) Tnu=T;
+						else Tnu=pow(h_eta*pow(T,3.)/paramrelic->rhob0,1./3.)*Ti;
+						Tnu_eq=Tnu;
+					}
 
 					for (i=1;i<=NNUC;i++)
 					{
@@ -1257,13 +1275,19 @@
 					if(paramrelic->phi_model&&rho_phi!=0.) rho_phi=max(0.,rho_phi0+(drhophi_dt0+drhophi_dt)*0.5*dt);
 					if(paramrelic->phi_model&&rho_phi!=0.) if(rho_phi<1.e-20*pow(pi,2.)/15.*pow(T,4.)) rho_phi=0.;
 
-					Tnu=Tnu0+(dTnu_dt+dTnu0_dt)*0.5*dt;
-
 					if ((paramrelic->wimp)&&((paramrelic->neut_coupled)||(paramrelic->neuteq_coupled)))
 					{
+						if (T>=Tnud) Tnu=T;
+						else Tnu=Tnu0+(dTnu_dt+dTnu0_dt)*0.5*dt;
 						if ((paramrelic->neut_coupled)&&(T<Tnud)) Tnu_eq=pow(h_eta*pow(T,3.)/paramrelic->rhob0,1./3.)*Ti;
 						else Tnu_eq=Tnu;
 					}
+					else
+					{
+						if (T>Tnud) Tnu=T;
+						else Tnu=pow(h_eta*pow(T,3.)/paramrelic->rhob0,1./3.)*Ti;
+						Tnu_eq=Tnu;
+					}
 
 					for (i=1;i<=NNUC;i++)
 					{
@@ -1485,7 +1509,7 @@
 					}
 				}
 		
-				fill_params(T,Tnu,phie,h_eta,a,rho_phi,dt,&dT_dt,&dTnu_dt,&dphie_dt,&dh_dt,&da_dt,&drhophi_dt,dY_dt,Y,Y,Am,Zm,Dm,reacparam,norm,loop,0,0,paramrelic,paramerror);
+				fill_params(T,&Tnu,phie,h_eta,a,rho_phi,dt,&dT_dt,&dTnu_dt,&dphie_dt,&dh_dt,&da_dt,&drhophi_dt,dY_dt,Y,Y,Am,Zm,Dm,reacparam,norm,loop,0,0,paramrelic,paramerror);
 
 				if(iloop==1)
 				{
@@ -1876,7 +1900,7 @@
 				
 				double dT,dTnu,dphie,dh_eta,dY_dt[NNUC+1],da;
 				
-				fill_params(T,Tnu,phie,h_eta,a,rho_phi,dt0,&dT,&dTnu,&dphie,&dh_eta,&da,&drhophi_dt,dY_dt,Y,Y,Am,Zm,Dm,reacparam,norm,0,0,0,paramrelic,paramerror);
+				fill_params(T,&Tnu,phie,h_eta,a,rho_phi,dt0,&dT,&dTnu,&dphie,&dh_eta,&da,&drhophi_dt,dY_dt,Y,Y,Am,Zm,Dm,reacparam,norm,0,0,0,paramrelic,paramerror);
 			
 				dT_rk[iloop]=dT;
 				dTnu_rk[iloop]=dTnu;
@@ -2161,7 +2185,7 @@
 				
 				double dT,dTnu,dphie,dh_eta,da,dY_dt[NNUC+1];
 				
-				fill_params(T,Tnu,phie,h_eta,a,rho_phi,dt0,&dT,&dTnu,&dphie,&dh_eta,&da,&drhophi_dt,dY_dt,Y,Y,Am,Zm,Dm,reacparam,norm,0,0,0,paramrelic,paramerror);
+				fill_params(T,&Tnu,phie,h_eta,a,rho_phi,dt0,&dT,&dTnu,&dphie,&dh_eta,&da,&drhophi_dt,dY_dt,Y,Y,Am,Zm,Dm,reacparam,norm,0,0,0,paramrelic,paramerror);
 			
 				dT_rk[iloop]=dT;
 				dTnu_rk[iloop]=dTnu;
@@ -2550,7 +2574,7 @@
 		printf("%.3e\t %.3e\t %.3e\t %.3e\t %.3e\t %.3e\n",Yp,H2_H,He3_H/H2_H,Li7_H,Li6_H/Li7_H,Be7_H);
 #endif		
         if(isnan(Yp)||isnan(H2_H)||isnan(He3_H/H2_H)||isnan(Li7_H)||isnan(Li6_H/Li7_H)||isnan(Be7_H)) return -1;
-        if((Yp>0.240)&&(Yp<0.258)&&((H2_H>1.2e-5)&&(H2_H<5.3e-5))&&(He3_H/H2_H<1.52)&&(Li7_H>0.85e-10)&&(Li6_H/Li7_H<0.66)) return 0;
+        if((Yp<0.258)&&((H2_H>1.2e-5)&&(H2_H<5.3e-5))&&(He3_H/H2_H<1.52)&&(Li7_H>0.85e-10)&&(Li6_H/Li7_H<0.66)) return 0;
         /* Conservative intervals from hep-ph/0604251 */
         else return 1;
     }
diff -Naur a/src/cosmodel.c b/src/cosmodel.c
--- a/src/cosmodel.c	2019-05-02 16:45:33.000000000 +0200
+++ b/src/cosmodel.c	2019-04-27 02:30:00.000000000 +0200
@@ -66,7 +66,6 @@
 	paramrelic->failsafe=1;         // 0=fast, 1=precise (default), ... See stand_cosmo.c
 	paramrelic->err=0;
     paramrelic->Tinit=27.;          // Starting at T = 27 x 10^9 K as default
-    paramrelic->Tnudec=27.;           // Neutrino decoupling T = 27 x 10^9 K as default
     paramrelic->eta0=6.10e-10;      // Baryon-to-photon ratio (Planck 2015 results XIII)
     paramrelic->Nnu=3.046;          // Number of SM neutrinos, e+- reheating included
     paramrelic->dNnu=0.;            // Number of extra neutrino species (e.g. sterile neutrinos)
@@ -889,22 +888,3 @@
     }
     return drho;
 }
-
-/*--------------------------------------------------------------*/
-
-double neutN(double T)
-/* Computes the round N(z) function of the neutrinos - Pisanti et al., 0705.0290, eq. (A24) */
-{
-	double z=m_e/T;
-
-	if(z>=4.) return 0.;
-
-	double logNz=0.;
-	
-	double n[14]={-10.21703221236002,61.24438067531452,-340.3323864212157,1057.2707914654834,-2045.577491331372,2605.9087171012848,-2266.1521815470196,1374.2623075963388,-586.0618273295763,174.87532902234145,-35.715878215468045,4.7538967685808755,-0.3713438862054167,0.012908416591272199};
-
-	int ie;
-	for(ie=0;ie<14;ie++) logNz+=n[ie]*pow(z,ie);
-
-	return exp(logNz);
-}
diff -Naur a/src/include.h b/src/include.h
--- a/src/include.h	2019-05-02 16:45:39.000000000 +0200
+++ b/src/include.h	2019-04-27 01:30:59.000000000 +0200
@@ -121,7 +121,6 @@
     double m_chi;               // Mass of WIMP
     double g_chi;
     double Tinit;				// Initial temperature
-    double Tnudec;				// Neutrino decoupling temperature
     int wimp;                   // Switch to enable (1) / disable (0) wimps
     int SMC_wimp;               // wimp coupling to SM particles. 1 for EM, 2 for neutrino, 3 for neutrino and equivalent neutrino
     int selfConjugate;          // 1/0 for self-conjugate/non-self-conjugate WIMP
@@ -240,7 +239,6 @@
 double nonthermal(double T, struct relicparam* paramrelic);
 double neutdens(double Tnu, struct relicparam* paramrelic);
 double neutdens_deriv(double Tnu, struct relicparam* paramrelic);
-double neutN(double T);
 
 /* bbnrate.c */
 double rate_pn_enu(int type, double T9, double Tnu, relicparam* paramrelic, errorparam* paramerror);
@@ -251,7 +249,7 @@
 
 /* bbn.c */
 int linearize(double T, const double reacparam[NNUCREACMAX+1][10], double f[NNUCREACMAX+1], double r[NNUCREACMAX+1], int loop, int inc, int ip, double dt, double Y0[NNUC+1], double Y[NNUC+1], double dY_dt[NNUC+1], double rhob);
-int fill_params(double T, double Tnu, double phie, double h_eta, double a, double rho_phi, double dt0, double* dT, double* dTnu, double* dphie, double* dh_eta, double* da, double* drhophi, double dY_dt[NNUC+1], double Y0[NNUC+1], double Y[NNUC+1], const double Am[NNUC+1], const double Zm[NNUC+1], const double Dm[NNUC+1], const double reacparam[NNUCREAC+1][10], double norm, int loop, int inc, int ip, struct relicparam* paramrelic, struct errorparam* paramerror);
+int fill_params(double T, double* Tnu, double phie, double h_eta, double a, double rho_phi, double dt0, double* dT, double* dTnu, double* dphie, double* dh_eta, double* da, double* drhophi, double dY_dt[NNUC+1], double Y0[NNUC+1], double Y[NNUC+1], const double Am[NNUC+1], const double Zm[NNUC+1], const double Dm[NNUC+1], const double reacparam[NNUCREAC+1][10], double norm, int loop, int inc, int ip, struct relicparam* paramrelic, struct errorparam* paramerror);
 int nucl_single(struct relicparam* paramrelic, double ratioH[NNUC+1], struct errorparam* paramerror);
 int nucl_err(struct relicparam* paramrelic, double ratioH[NNUC+1], double cov_ratioH[NNUC+1][NNUC+1]);
 int nucl(struct relicparam* paramrelic, double ratioH[NNUC+1]);
