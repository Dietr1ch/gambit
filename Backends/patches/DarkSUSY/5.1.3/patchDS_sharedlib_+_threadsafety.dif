diff -rupN darksusy-5.1.3.pristine/configure darksusy-5.1.3/configure
--- darksusy-5.1.3.pristine/configure	2015-04-07 10:23:05.000000000 +0100
+++ darksusy-5.1.3/configure	2016-02-13 16:18:13.886759474 +0000
@@ -3337,11 +3337,11 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 if test "${FCSET}" = "false" ; then
   if test "${FC}" = "ifort"; then
     echo "Fortran compiler is $FC"
-    FCFLAGS=${FCFLAGS+-O -extend_source}
+    FCFLAGS=${FCFLAGS+-O -extend_source -openmp -fPIC}
   fi
   if test "${FC}" = "gfortran"; then
     echo "Fortran compiler is $FC"
-    FCFLAGS=${FCFLAGS+-O -ffixed-line-length-none}
+    FCFLAGS=${FCFLAGS+-O -ffixed-line-length-none -fopenmp -fPIC}
   fi
 fi
 
diff -rupN darksusy-5.1.3.pristine/configure.ac darksusy-5.1.3/configure.ac
--- darksusy-5.1.3.pristine/configure.ac	2015-04-07 10:23:05.000000000 +0100
+++ darksusy-5.1.3/configure.ac	2016-02-05 14:35:08.231004284 +0000
@@ -28,11 +28,11 @@ AC_PROG_FC([ifort gfortran])
 if test "${FCSET}" = "false" ; then
   if test "${FC}" = "ifort"; then 
     echo "Fortran compiler is $FC"
-    FCFLAGS=${FCFLAGS+-O -extend_source}
+    FCFLAGS=${FCFLAGS+-O -extend_source -openmp -fPIC}
   fi 
   if test "${FC}" = "gfortran"; then
     echo "Fortran compiler is $FC"
-    FCFLAGS=${FCFLAGS+-O -ffixed-line-length-none}
+    FCFLAGS=${FCFLAGS+-O -ffixed-line-length-none -fopenmp -fPIC}
   fi
 fi
 
Binary files darksusy-5.1.3.pristine/contrib/FeynHiggs-2.9.4/libFH.so and darksusy-5.1.3/contrib/FeynHiggs-2.9.4/libFH.so differ
diff -rupN darksusy-5.1.3.pristine/contrib/FeynHiggs-2.9.4/makefile.in darksusy-5.1.3/contrib/FeynHiggs-2.9.4/makefile.in
--- darksusy-5.1.3.pristine/contrib/FeynHiggs-2.9.4/makefile.in	2013-02-10 06:43:34.000000000 +0000
+++ darksusy-5.1.3/contrib/FeynHiggs-2.9.4/makefile.in	2016-02-16 15:26:02.949096912 +0000
@@ -31,6 +31,9 @@ ARGS = $(PARALLEL) \
 default all lib frontend mma: force
 	cd $(BLD) && $(MAKE) $(ARGS) $@
 
+lib_shared: lib
+	$(FC) $(FFLAGS) -shared -o $(DS_LIB)/libFH.so build/*.o
+
 install: default
 	-mkdir "$(PREFIX)"
 	-mkdir "$(LIBDIR)" "$(INCLUDEDIR)" "$(BINDIR)"
diff -rupN darksusy-5.1.3.pristine/contrib/FeynHiggs-2.9.4/src/Decays/VecSet.F darksusy-5.1.3/contrib/FeynHiggs-2.9.4/src/Decays/VecSet.F
--- darksusy-5.1.3.pristine/contrib/FeynHiggs-2.9.4/src/Decays/VecSet.F	2013-02-10 06:43:34.000000000 +0000
+++ darksusy-5.1.3/contrib/FeynHiggs-2.9.4/src/Decays/VecSet.F	2016-02-03 09:19:30.694574453 +0000
@@ -27,7 +27,7 @@
 #define EpsL(x,y)  vec_(x,y, 3, i)
 #define EpsTL(x,y) vec_(x,y, 4, i)
 
-	ComplexType spi_(2, 6:7, nvec, 1)
+	ComplexType spi_(2, 6:7, nvec, LEGS)
 	equivalence (vec, spi_)
 
 #define Spi(hel,om,x) spi_(x, om, hel+6, i)
diff -rupN darksusy-5.1.3.pristine/contrib/galprop/v50p/Configure.cc darksusy-5.1.3/contrib/galprop/v50p/Configure.cc
--- darksusy-5.1.3.pristine/contrib/galprop/v50p/Configure.cc	1970-01-01 01:00:00.000000000 +0100
+++ darksusy-5.1.3/contrib/galprop/v50p/Configure.cc	2016-02-16 15:34:05.717088266 +0000
@@ -0,0 +1,24 @@
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+// * Configure.cc *                                galprop package * 4/14/2000 
+//**"****!****"****!****"****!****"****!****"****!****"****!****"****!****"****|
+using namespace std;//AWS20050624
+#include<iostream>
+#include"Configure.h"
+
+int Configure::init()
+{
+   cout<<">>>>Configure"<<endl;
+   directory_length=100;
+   galdef_directory=new char[directory_length];
+   fits_directory=new char[directory_length];
+   adjunct_directory=new char[directory_length];
+   strcpy(galdef_directory, "/home/pat/darksusy-5.1.3/share/DarkSUSY/GALDEF/");
+   strcpy(  fits_directory, "/home/pat/darksusy-5.1.3/share/DarkSUSY/FITS/"  );
+   strcpy(adjunct_directory,"/home/pat/darksusy-5.1.3/share/DarkSUSY/adjunct/"  );
+   cout<<"Configure: galdef_directory:  "<< galdef_directory<<endl;
+   cout<<"Configure:   fits_directory:  "<<   fits_directory<<endl;
+   cout<<"Configure:adjunct_directory:  "<<adjunct_directory<<endl;
+   cout<<"<<<<Configure"<<endl;
+   return 0;
+}
diff -rupN darksusy-5.1.3.pristine/contrib/galprop/v50p/nuc_package.cc darksusy-5.1.3/contrib/galprop/v50p/nuc_package.cc
--- darksusy-5.1.3.pristine/contrib/galprop/v50p/nuc_package.cc	1970-01-01 01:00:00.000000000 +0100
+++ darksusy-5.1.3/contrib/galprop/v50p/nuc_package.cc	2016-02-16 15:34:05.737088266 +0000
@@ -0,0 +1,834 @@
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+// * nuc_package.cc *                              galprop package * 2001/08/16
+//**"****!****"****!****"****!****"****!****"****!****"****!****"****!****"****|
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+// This file contains 4 routines on c++ which read the nuclear data from files,
+// evaluate the isotopic cross sections and take care of the unstable nuclei
+// decay channels. A sample driver program is in the bottom of this file.
+// The isotope_cs routine uses Webber's and Tsao & Silberberg fortran codes,
+// wsigma and yieldx.
+//                            ### Igor Moskalenko, NASA/GSFC ### 2001/08/16 ###
+//
+// Description of routines
+// ^^^^^^^^^^^^^^^^^^^^^^^
+//1 void read_nucdata() - reads 3D data arrays from files, it is organized
+//1 as following:
+//1 a constant N_DATA_FILES defines the total number of data-files to read;
+//1 an array of pointers data_filename[N_DATA_FILES] specifies the file names;
+//1 the dimensions of arrays in files are read into n_data[3][N_DATA_FILES];
+//1 the correspondence between data files and routines is established by  
+//1 file_no[N_DATA_FILES] = {0,1,2}, where 0=isotope_cs.dat, 1=nucdata.dat etc.;
+//1 finally an array of pointers data_file[N_DATA_FILES] indicates the areas
+//1 allocated for the data arrays which store the data from files.
+//1 The DATA FILES to read by the read_nucdata are organized as following:
+//1 in the beginning there are comments with basic description (any line number),
+//1 which follows by 3 integer numbers - array dimensions, which follows by
+//1 the data lines with some lines commented.
+//1 The comments should contain any simbol in the 1st column (not space !), 
+//1 space in the 1st column will mean the data line.
+//
+//2 float nucdata
+//2   (int ksp,int iz,int ia,int K_electron,int izf,int iaf,int* izl,int* ial,float* To) -
+//2 for any given primary nucleus (iz,ia) and any stable (or long-lived) 
+//2 final nucleus (izf,iaf) calculates the decay chain and returns branching ratio.
+//2    input:
+//2 ksp =0 - network of decays compiled from [NDS]; =1 from [GM87];
+//2 iz,ia - primary charge and atomic number (iz<29, ia<65);
+//2 K_electron =0 for the naked (iz,ia) nucleus; =1 for H-like atoms.
+//2 izf,iaf - final charge and atomic number;
+//2 uses file_no[1] as indicator of the data array.
+//2    output:
+//2 izl,ial - return charge and atomic number of an INTERMEDIATE long-lived 
+//2           isotope (if any); otherwise (izl,ial)=(0,0);
+//2 To  - if (izl,ial)#0, returns half-lifetime of (izl,ial) in sec; 
+//2       if (izl,ial)=0, but primary (iz,ia) is a long-lived isotope,
+//2          To gives its half-lifetime;
+//2       =0 otherwise;
+//2 branching ratio is returned by nucdata: 
+//2 if (iz,ia)=(izf,iaf), B =1 for stables and long-lived nuclei; =0 otherwise.
+//2    comments:
+//2 For each Z and A boundary nuclei are chosen (on the left and right), so that
+//2 outside of this area all decay treated as proton- or neutron-emission.
+//2 Inside this area all decays treated as beta(+/-) decays unless there are
+//2 special decay channels - see file nucdata.dat. The program allows up
+//2 to 4 generations in any of the special decay channels (up to 3^4 nuclei
+//2 in the final state !), beta,p,n-decays - no limits, and returns the final
+//2 branching for specified nucleus and To for intermediate long-lived isotope 
+//2 if exists.
+//2 The nucdata.dat file contains zi.ai,zf1.af1,br1,zf2.af2,br2,zf3.af3,br3:
+//2 decay channels with their branchings in order of increasing ai; and zi 
+//2 for the same ai.
+//2 Rule - secondary zf.af can appear ONLY BELOW the line where it was primary !
+//2 Any character in the 1st column can be used to comment the line.
+//2 Data on the lifetime T1/2 of long-live isotopes in cosmic rays include
+//2 reanalysis of their decay probabilities. This is particular important for
+//2 secondary K-electron capture isotopes which is suppressed in CR where 
+//2 the main channel is to be beta(+/-) decay.
+//2    references:
+//2 [B76]  Berenyi, D. et al. 1976, NPA 256, 87
+//2 [F99]  Fisker,J.L., Martinez-Pinedo,G., Langamke,K. 1999, Eur.Phys.J. A5, 229
+//2 [GM87] Garcia-Munoz M. et al. 1987, ApJS 64, 269 (non-beta decays & branch.)
+//2 [M98]  Martinez-Pinedo G., Vogel P. 1998, PRL 81, 281
+//2 [NDS]  Nuclear Data Sheets
+//2 [ToI]  Table of Isotopes, 8th Ed., by R.B.Firestone etal.(J.Wiley & Sons,Inc.),1996. 
+//2 [W98]  Wuosmaa A.H. et al. 1998, PRL 80, 2085 (54Mn[b+ & b-] half lifetime)  
+//
+//3 float isotope_cs(float emev,int iz,int ia,int izf,int iaf,int kopt,int* info)
+//3 For any given primary nucleus (iz,ia) and any final nucleus (izf,iaf) 
+//3 returns the cross section (mb) of the reaction p+(zi,ai) -> (zf,af) +X.
+//3    input:
+//3 emev  - energy of the primary nucleus in MeV/nucleon;
+//3 iz,ia - primary charge and atomic number;
+//3 izf,iaf - final charge and atomic number/ izf=0 is alloyed, gives fits of
+//3           isobaric cross sections (only with kopt = 11, 21);
+//3 kopt  =0 - uses best alghorithm described in comments below (not recommended);
+//3       =1 - forces to use Webber'93 code (no renormalization etc.);
+//3       =2 - forces to use TS00 code (no renormalization etc.);
+//3       =3 - forces to use a const cross section fitted to the data.
+//3       =10- forces to use Webber'93 code (renormalized if data exists);
+//3       =11- forces to use cross section fit if exists (otherwise equiv. 10);
+//3       =12- forces to use a numerical table if exists (otherwise equiv. 11);
+//3       =20- forces to use TS00 code (renormalized if data exists).
+//3       =21- forces to use cross section fit if exists (otherwise equiv. 20).
+//3       =22- forces to use a numerical table if exists (otherwise equiv. 21);
+//3 The best values recommended are kopt = 12, 22 (12 is preferrable).
+//3 uses file_no[1] and file_no[3] as indicators of the data array and fit params.
+//3    output:
+//3 info  =0 if no data exists, the Webber'93 or TS00 evaluation is used;
+//3       =1 if data exist and the renormalized Webber's formulae were used;
+//3       =2 if data exist and the renormalized TS00 formulae were used;
+//3       =3 if data exist and a const cross section is fitted to the data;
+//3       =10 Webber'93 code used in all cases (renormalized if data exists);
+//3       =20 TS00 code used in all cases (renormalized if data exists);
+//3       =-11,-21 if used the cross section fit;
+//3    comments:
+//3 The CS_DATA array containts the following data:
+//3 Zi.Ai, Zf.Af, emev/n, CSmb, CSerr.
+//3 if CSerr>0, it is the absolute error of the measurement;
+//3 if CSerr<0, it is the relative error and the abs. err. will be calculated 
+//3 automatically in the subroutine.
+//3 Any character in the 1st column can be used to comment the line.
+//3 isobaric cross sections (zf = 0):
+//3 *-marks the errors corrected by imos
+//3 #-marks where the data summed (e.g. B11+C11) are taken at close 
+//3   (but not equal) energies. 
+//3 kopt =0 alghorithm (not recommended): when no data exists for the required
+//3 channel, the Webber's evaluation is used. When Webber's code give 0, the result 
+//3 of TS00 code is used. When the data exist, it calculates the renormalization
+//3 coefficient for the two approximations (Webber's and TS00) using the
+//3 least-square method. Then Xi2 test is used to choose the best approximation.
+//3 When both (Webber and TS98) approximations give 0, but the experimental
+//3 value is non zero, uses a const cross section fitted to the data.
+//3    references:
+//3 [Ab94] Abdullin S.K. et al. 1994, Nucl. Phys. A 569, 753
+//3 [Gl93] Glagolev V.V. et al. 1993, Z. Phys. C 60, 421
+//3 [Ko99] Korejwo A. et al. 1999, Proc. 26th ICRC (Salt Lake City), OG 3.2.22 
+//3 [LM69] Lebowitz E., Miller J.M. 1969, Phys. Rev. 177, 1548
+//3 [Ni72] Nicholls J.E. et al. 1972, Nucl. Phys. A 181, 329
+//3 [Ol83] Olson D.L., et al. 1983, Phys.Rev.C 28, 1602 (the same as [ 17.])
+//3 [Ra79] Radin J.R., Gradsztajn E., Smith A.R. 1979, Phys. Rev. C 20, 787
+//3 [RV84] Read S.M., Viola V.E., Jr. 1984, Atom. Data Nucl. Data Tables 31, 359
+//3        if no err. is shown, relative err. 0.1 (cs>10mb), 0.2 (cs<10mb), 
+//3        0.3 (cs<1mb) are assumed; sometimes I made it differently /imos.
+//3 [TS98] Silberberg R., Tsao C.H., Barghouty A.F. 1998, ApJ 501, 911 
+//3 [We90] Webber W.R. 1990, in AIP Conf. Proc. 203, ed. W.V.Jones et al.
+//3          (NY: AIP), 294
+//3 [We96] Webber W.R. 1996, private comm.(from Ramaty R. et al.1997,ApJ 488,730)
+//3    !  relative err. 0.1 (cs>10mb), 0.2 (cs<10mb) are assumed.
+//3 [We98] Webber W.R., et al. 1998, ApJ 508, 949
+//3    !!RELATIVE ERRORS adopted: B =0.04; C =0.08; D =0.16; E =0.26
+//3 [We98prc] Webber W.R. et al. 1998, PRC 58, 3539 (Tables 7,12-15)
+//3    ! For Table 7 relative err. 0.1 (cs>10mb), 0.2 (cs<10mb) are assumed;
+//3    !!REL. ERR. adopted: A =0.03; B =0.04; C =0.07; D =0.10; E =0.18; F =0.26
+//3 -- All the following data are taken from the Transport Collab. on 21.04.99:
+//3 [ 17.] EXCLUDED - Lindstorm P.J., et al. 1975, Report LBL-3650 (see [Ol83])
+//3 [105.] Webber W.R., Kish J.C., Schrier D.A. 1990, Phys.Rev. C 41, 547
+//3 [108.] Chen C.-X., et al. 1997, ApJ 479, 504
+//3 [109.] Knott C.N., et al. 1997, Phys.Rev. C 56, 398
+//3 [110.] Chen C.-X., et al. 1997, Phys.Rev. C 56, 1536
+//3 [111.] ???
+//3 [MM03] Moskalenko I.V., Mashnik S.G. 2003, Proc. 28th ICRC (Tsukuba), p.1969
+//
+//4 double eval_cs(double emev,int za1,int za2,int* info)
+//4 the routine checks if there exists a channel with a cross section (mb) given
+//4 by a table and if so interpolates it linearly.
+//4    input:
+//4 emev  - energy of the primary nucleus in MeV/nucleon;
+//4 za1= (100*z1+a1) - primary charge and atomic number;
+//4 za2= (100*z2+a2) - final charge and atomic number;
+//4    output:
+//4 info =-1 - no channel found in the table, returns 0;
+//4      = 1 - channel found, but emev < the lowest grid pt, returns 0;
+//4      = 2 - channel found, but emev > the highest grid pt, returns cs at max energy given;
+//4      = 3 - emev falls exactly on the grid, returns cs;
+//4      = 4 - returns interpolated value.
+//=="====!===="====!===="====!===="====!===="====!===="====!===="====!===="====!
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+// GLOBAL definitions
+using namespace std;//AWS20050624
+#include<iostream>//AWS20031223
+#include<cstdlib> //IMOS20020112 AWS20050624
+#include<string>
+#include<cctype>               //AWS20050624
+#include<fstream>
+#include<cmath>
+#include "fort_interface.h"
+#include "constants.h"
+#define max(a,b) (((a) > (b)) ? (a) : (b))
+#define fnuc(z,a) (100 * (z) + (a))
+#define inuc(b) (int)(100 * (b) + 0.1)
+
+#define N_DATA_FILES 4                 // total number of data-files to read
+
+char  *data_filename[N_DATA_FILES]     // data-files to read
+         ={"/home/pat/darksusy-5.1.3/share/DarkSUSY/isotope_cs.dat",
+	   "/home/pat/darksusy-5.1.3/share/DarkSUSY/nucdata.dat",
+	   "/home/pat/darksusy-5.1.3/share/DarkSUSY/p_cs_fits.dat",
+	   "/home/pat/darksusy-5.1.3/share/DarkSUSY/eval_iso_cs.dat"};
+int   n_data[3][N_DATA_FILES],         // their dimensions n1,n2,n3  
+    file_no[N_DATA_FILES] = {0,1,2,3}; // 0=isotope_cs.dat, 1=nucdata.dat etc.
+float *data_file[N_DATA_FILES];        // pointers to the data arrays
+
+double eval_cs(double,int,int,int*);
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+void read_nucdata()
+{
+   float *tmp,*tmp1;
+   int i,j,k,size;
+   const int BufferSize=200;
+   char readBuffer[BufferSize];
+   ifstream data;
+
+   for(j=0; j<N_DATA_FILES; j++)
+   {
+      data.open(data_filename[j]);                    // open file if exists
+      if(data.fail())
+      {
+         cerr<<"read_nucdata: Error opening file "<<data_filename[j]<<endl;
+         exit(1);
+      }
+
+      while(!isspace(data.get()) && !data.eof())      // skip comments:
+         data.getline(readBuffer,BufferSize,'\n');    // any symbol in 1st col. 
+
+      for(i=0; i<3; data >> n_data[i++][j]);          // read array's sizes
+      data.getline(readBuffer,BufferSize,'\n');       // skip the rest of line
+
+      for(size=1, i=0; i<3; size*=n_data[i++][j]);    // allocate space
+//      data_file[j] = (float*) calloc( (size_t) size, (size_t) sizeof(float));
+      data_file[j] = new float[size];
+      
+      for(k = 0; k < size && !data.eof();)            // read data loop
+      {
+         while(!isspace(data.get()) && !data.eof())   // skip comments:
+            data.getline(readBuffer,BufferSize,'\n'); // any symbol in 1st col. 
+         for(i=0; i < n_data[0][j]; i++) data >> *(data_file[j]+k++);
+         data.getline(readBuffer,BufferSize,'\n');    // skip the rest of line
+      }
+      data.close();
+   }
+   return;
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+//IMOS20060420 cleanup arrays to prevent memory leaks
+void cleanup_nucdata()
+{
+  for(int j=0; j<N_DATA_FILES; j++) delete data_file[j];
+  return;
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+double nucdata(int ksp,int iz,int ia,int K_electron,int izf,int iaf,int* izl,int* ial,double* To)
+{
+   int i,j,k,l,m,n,iy,iz0,ia0,iz4,ia4,iz5,ia5,iw[121],
+       nksp=ksp*n_data[0][file_no[1]]*n_data[1][file_no[1]];
+   float w[2][121], *decay = data_file[file_no[1]]+nksp;
+   double b, xxx;
+
+// STABLE & LONG-LIVED ISOTOPES (numbers in the table are the proton numbers)
+// The long-lived isotopes listed in "longliv" table are included as stable;
+   int stable[64][3] = {      // second index changes faster
+       1,  0,  1,     1,  0,  1,     1,  0,  2,     2,  0,  2, //  A = 1- 4
+       0,  0,  0,     3,  0,  3,     3,  0,  4,     0,  0,  0, //  A = 5- 8
+       4,  0,  4,     4,  0,  5,     5,  0,  5,     6,  0,  6, //  A = 9-12
+       6,  0,  6,     6,  0,  7,     7,  0,  7,     8,  0,  8, //  A =13-16
+       8,  0,  8,     8,  0,  8,     9,  0,  9,    10,  0, 10, //  A =17-20
+      10,  0, 10,    10,  0, 11,    11,  0, 11,    12,  0, 12, //  A =21-24
+      12,  0, 12,    12,  0, 13,    13,  0, 13,    14,  0, 14, //  A =25-28
+      14,  0, 14,    14,  0, 14,    15,  0, 15,    14,  0, 16, //  A =29-32
+      16,  0, 16,    16,  0, 16,    17,  0, 17,    16, 17, 18, //  A =33-36
+      17,  0, 18,    18,  0, 18,    18,  0, 19,    18, 19, 20, //  A =37-40
+      19,  0, 20,    18,  0, 20,    20,  0, 20,    20,  0, 22, //  A =41-44
+      21,  0, 21,    20,  0, 22,    22,  0, 22,    20,  0, 22, //  A =45-48
+      22,  0, 23,    22, 23, 24,    23,  0, 24,    24,  0, 24, //  A =49-52
+      24,  0, 25,    24, 25, 26,    25,  0, 26,    26,  0, 28, //  A =53-56
+      26,  0, 27,    26,  0, 28,    27,  0, 28,    26, 27, 28, //  A =57-60
+      28,  0, 28,    28,  0, 28,    28,  0, 29,    28,  0, 28  //  A =61-64
+   };
+
+// LONG-LIVED ISOTOPES (>~1y): Zi.Ai T_1/2(y) Zf.Af - [][][0] half-life shown for naked nucleus
+   int nll = 25;                                 // - [][][1] half-life shown for H2-like atoms
+   float longliv[25][2][3] = {   // third index changes faster
+      1.03,  12.33,    2.03,     //  3H (b-) 3He   100% [ToI]
+      1.03,  12.33,    2.03,     // no EC
+
+      4.07,  0.,       4.07,     // stable
+      4.07,  0.1459,   3.07,     //  7Be(EC) 7Li   100% [ToI]
+
+      4.10,  1.60e6,   5.10,     // 10Be(b-)10B    100% [ToI]
+      4.10,  1.60e6,   5.10,     // no EC
+
+      6.14,  5.73e3,   7.14,     // 14C (b-)14N    100% [ToI]
+      6.14,  5.73e3,   7.14,     // no EC
+
+     11.22,  4.80e3,  10.22,     // 22Na(b+)22Ne        [M98]
+     11.22,  2.60e0,  10.22,     // 22Na(EC?)22Ne       [ToI] T1/2(Lab)=2.60e0 y
+
+     13.26,  9.10e5,  12.26,     // 26Al(b+)26Mg        [M98]
+     13.26,  4.075e6, 12.26,     // 26Al(EC)26Mg        [M98] T1/2(Lab)=7.4e5 y [ToI]
+
+     14.32,  172.,    16.32,     // 32Si(2b-)32S   100% [ToI] Si-P -S 
+     14.32,  172.,    16.32,     // no EC
+
+     17.36,  3.07e5,  18.36,     // 36Cl(b-)36Ar        [ToI]
+     17.36,  1.58e7,  16.36,     // 36Cl(EC)36S         [ToI] T1/2(Lab)=3.01e5 y
+
+     18.37,  0.,      18.37,     // stable
+     18.37,  0.1,     17.37,     // 37Ar(EC)37Cl   100% [ToI] T1/2(Lab)=35.04 d
+
+     18.39,  2.69e2,  19.39,     // 39Ar(b-)39K    100% [ToI]
+     18.39,  2.69e2,  19.39,     // no EC
+
+     19.40,  1.43e9,  20.40,     // 40K (b-)40Ca   89.3%[ToI] T1/2(Lab)=1.277e9 y incl 10.7% ECb+
+     19.40,  1.43e9,  20.40,     // no EC
+
+     20.41,  0.,      20.41,     // stable
+     20.41,  1.03e5,  19.41,     // 41Ca(EC)41K    100% [ToI]
+
+     18.42,  32.9,    20.42,     // 42Ar(2b-)42Ca  100% [ToI] Ar-K -Ca
+     18.42,  32.9,    20.42,     // no EC
+
+     22.44,  0.,      22.44,     // stable
+     22.44,  49.,     20.44,     // 44Ti(ECb+)44Ca 100% [ToI] Ti(EC)Sc(b+)Ca
+
+     23.49,  0.,      23.49,     // stable
+     23.49,  0.903,   22.49,     // 49V (EC)49Ti   100% [ToI] 
+
+     24.51,  0.,      24.51,     // stable
+     24.51,  0.076,   23.51,     // 51Cr(EC)51V   <100% [ToI] 
+
+     25.53,  0.,      25.53,     // stable
+     25.53,  3.74e6,  24.53,     // 53Mn(EC)53Cr   100% [ToI]
+
+     25.54,  6.30e5,  26.54,     // 54Mn(b-)54Fe        [W98]
+     25.54,  0.855,   24.54,     // 54Mn(EC)54Cr        [ToI] T1/2(Lab)=312.3 d
+
+     26.55,  0.,      26.55,     // stable
+     26.55,  2.73e0,  25.55,     // 55Fe(EC)55Mn   100% [ToI]
+
+     28.56,  4.00e4,  26.56,     // 56Ni(2b+)56Fe <100% [F99] Ni-Co-Fe
+     28.56,  0.1,     26.56,     // 56Ni(ECb+)56Fe      [ToI] T1/2(Lab)=~30 d Ni(EC)Co(b+)Fe
+
+     27.57,  0.,      27.57,     // stable
+     27.57,  0.744,   26.57,     // 57Co(EC)57Fe   100% [ToI]
+
+     28.59,  0.,      28.59,     // stable
+     28.59,  7.60e4,  27.59,     // 59Ni(EC)59Co  <100% [ToI] [B76]
+
+     27.60,  5.27e0,  28.60,     // 60Co(b-)60Ni   100% [ToI]
+     27.60,  5.27e0,  28.60,     // no EC
+
+     26.60,  1.50e6,  27.60,     // 60Fe(b-)60Co   100% [ToI]
+     26.60,  1.50e6,  27.60,     // no EC
+
+     28.63,  1.00e2,  29.63,     // 63Ni(b-)63Cu   100% [ToI]
+     28.63,  1.00e2,  29.63      // no EC
+   };
+// K-capture nuclei - factor of 2 because only 1 electron
+   for(i=0;i<nll;i++) if(longliv[i][0][1]!=longliv[i][1][1]) longliv[i][1][1] *=2.; 
+   
+// BOUNDARY NUCLEI 
+// on the left side from the left boundary, the proton-emission is assumed;
+// on the right side from the right boundary, the neutron-emission is assumed.
+// ZB.AB; left boundary[][0]: Nn=0(1)28; right boundary[][1]: Np=1(1)28 
+    int nb = 29;
+    float boundary[29][2] = {  // second index changes faster
+       1.01,  1.04,    3.04,  2.08,
+       3.05,  3.11,    6.09,  4.14,
+       6.10,  5.15,    8.13,  6.16,
+       8.14,  7.21,   10.17,  8.22,
+      12.20,  9.24,   12.21, 10.26,
+      14.24, 11.30,   14.25, 12.30,
+      15.27, 13.34,   16.29, 14.35,
+      16.30, 15.38,   18.33, 16.40,
+      20.36, 17.43,   20.37, 18.46,
+      20.38, 19.48,   22.41, 20.51,
+      22.42, 21.52,   24.45, 22.53,
+      24.46, 23.55,   24.47, 24.59,
+      25.49, 25.63,   26.51, 26.65,
+      27.53, 27.69,   27.54, 28.69,
+      28.56, 00.99
+   };
+
+   b = *To = *izl = *ial = 0;
+   if(iz <= 0 || ia <= 0) return(0.);    // check against negative numbers,
+   if(iz*ia > 1 && iz >= ia) return(0.); // non-existed nuclei,
+   if(2864 < fnuc(iz,ia)) return(0.);    // Ni64 is the heaviest nucleus
+   if(64 < ia) return(0.);               // A=64 is the maximal atomic number
+
+// CHECK FOR NUCLEI OUTSIDE THE BOUNDARIES (p/n decay)
+   iz0 = iz;
+   ia0 = ia;
+   if(ia>inuc(boundary[iz-1][1]-iz)) ia0=inuc(boundary[iz-1][1]-iz); // n -decay
+   if(29>ia-iz) if(ia>inuc(modf(boundary[ia-iz][0], &xxx)))          // p -decay
+   { 
+      iz0=(int)boundary[ia-iz][0];
+      ia0=inuc(boundary[ia-iz][0]-iz0);
+   }
+
+   for(i=0; i<121; iw[i++]=-1)  for(j=0; j<2; w[j++][i]=0.);
+
+// SEARCH FOR A SPECIAL CASE (non beta decay)
+   for(i=0; i<n_data[1][file_no[1]]; i++)
+      if(fnuc(iz0,ia0) == inuc(*(decay +i*n_data[0][file_no[1]] +0)))
+      {
+          iw[0]  = i;            // if found, save the line number
+          w[1][0]= 1.00;         // assign 1 to the branching ratio
+          break;
+      }
+
+// STANDARD CASE (beta decay & long-lived isotopes)
+   if(iw[0] < 0)
+   {
+      iz5 = iz0;
+      ia5 = ia0;
+// *** BETA DECAY ***
+      if(iz0 > stable[ia0-1][2]) iz5 = stable[ia0-1][2];   // b+ decay
+      if(iz0 < stable[ia0-1][0]) iz5 = stable[ia0-1][0];   // b- decay
+// *** LONG-LIVED ISOTOPES (>~1 y) ***
+      for(i=0; i<nll; i++)
+         if(fnuc(iz5,ia5) == inuc(longliv[i][K_electron][0]))
+         {
+            *izl = iz5;
+            *ial = ia5;
+            *To = longliv[i][K_electron][1]*year2sec;
+            if(!*To) *izl=*ial=0;
+            iz5 = (int) longliv[i][K_electron][2];
+            ia5 = inuc(longliv[i][K_electron][2]-iz5);
+            break;
+         }
+      if(fnuc(izf,iaf)==fnuc(iz5,ia5) || fnuc(izf,iaf)==fnuc(*izl,*ial)) b = 1.;
+      if(fnuc(iz0,ia0) == fnuc(*izl,*ial)) *izl = *ial = 0;
+      return(b);
+   }
+
+// DEVELOPING A NETWORK OF DECAYS
+   for(l=-1, m=0, ia4=1, i=0; i<4; ia4 =(int) pow(3.,++i))
+   {
+      for(l+=ia4, iy=0, n=0; n<ia4; n++, m++)
+      {                                                      // check if there is
+         if(iw[m] < 0) continue;                             // a required channel
+         for(w[0][m]=0., k=2; k<8; k+=2)
+         {
+            w[0][l+3*n+k/2]                                  // store sec.nuclei
+               =*(decay +iw[m]*n_data[0][file_no[1]] +k-1);
+            w[1][l+3*n+k/2]                                  // store branchings
+               =*(decay +iw[m]*n_data[0][file_no[1]] +k)*w[1][m];
+            for(j=0; j<iw[m]; j++)                           // check if sec.nucleus
+               if(*(decay +iw[m]*n_data[0][file_no[1]] +k-1) // also develops a
+                  == *(decay +j*n_data[0][file_no[1]] +0))   // network of decays
+               {
+                  iw[l+3*n+k/2] = j;                         // store such a nucleus
+                  iy = l+3*n+k/2;
+               }  ///printf("%d %d %d %d %d %d\n",l,n,m,k,j,iy);
+         }
+      }
+      if(iy == 0) break;
+   }
+
+// CHECK FOR STABILITY OF THE FINAL NUCLEI
+   for(k=0; k<=l+3*n; k++)
+   {
+      *To = *izl = *ial = 0;
+      if(w[0][k] == 0.) continue;
+      iz4 = (int) w[0][k];
+      ia4 = inuc(w[0][k]-iz4);
+      iz5 = iz4;
+      ia5 = ia4;
+// *** BETA DECAY ***
+      if(iz4 > stable[ia4-1][2]) iz5 = stable[ia4-1][2];   // b+ decay
+      if(iz4 < stable[ia4-1][0]) iz5 = stable[ia4-1][0];   // b- decay
+// *** LONG-LIVED ISOTOPES (>~1 y) ***
+      for(i=0; i<nll; i++)
+      {
+         if(fnuc(iz5,ia5) != inuc(longliv[i][K_electron][0])) continue;
+         *izl = iz5;
+         *ial = ia5;
+         *To = longliv[i][K_electron][1]*year2sec;
+         if(!*To) *izl=*ial=0;
+         iz5 = (int) longliv[i][K_electron][2];
+         ia5 = inuc(longliv[i][K_electron][2]-iz5);
+         break;
+      }
+      if(fnuc(izf,iaf) == fnuc(*izl,*ial) || fnuc(izf,iaf) == fnuc(iz5,ia5))
+         return(w[1][k]);
+   }
+   return(b);
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+double isotope_cs(double emev,int iz,int ia,int izf,int iaf,int kopt,int* info)
+{
+   int a1,a2,i,j,size, itable=0, info1;
+   float e1,y,err2,xi1,xi2, CSmb=0., f1=0., f2=0., T[11], a[3]={1.,1.,0.}, b[6];
+   float *cs_data = data_file[file_no[0]], *p_cs = data_file[file_no[2]], *tp=T;
+   double ej;
+   
+   e1 = emev;
+   *info = kopt;
+
+// CHECK if user wants to use specific program (the value of "kopt")
+   if(kopt == 1) CSmb = wsigma_cc(iz,ia,izf,iaf,emev);       // Webber's code IMOS20020502
+   if(kopt == 2) CSmb = yieldx_cc(iz,ia,izf,iaf,e1);         // TS code       IMOS20020502
+   CSmb = max(0.,CSmb);
+   if(kopt == 1 || kopt == 2) return(CSmb);
+
+   a1 = fnuc(iz, ia);
+   a2 = fnuc(izf,iaf);
+
+// EVALUATED CROSS SECTIONS
+
+   if(kopt == 12 || kopt == 22)
+   {      
+      CSmb = eval_cs(emev,a1,a2,&info1);
+      if (info1 > 0) return(max(0.,CSmb));
+      kopt--;                                          // if evaluation doesn't exist,  
+   }                                                   // try other options
+
+// if user wants, use THE CROSS SECTION FITS
+
+   if(kopt == 11 || kopt == 21)
+   {      
+// special cases: Be, B - recursion calls
+      if(izf != 0)
+      {
+// A = 10
+         if(10 == iaf)  // B10 = B10 + C10 = a10 - Be10
+         {
+            b[0] = isotope_cs(emev,iz,ia,0,iaf,21,&j);
+            if(j == -21)
+            {                                          // B10
+                if(510 == a2) 
+                {
+                   b[0]-=isotope_cs(emev,iz,ia,4,iaf,21,&j);
+                   return(max(0.,b[0]));
+                }
+                if(5 < izf) return(0.);                // C10, =0
+            }
+         }
+// A = 11
+         if(11 == iaf)  // B11 = a11 = Be11 + B11 + C11
+         {
+            b[0] = isotope_cs(emev,iz,ia,0,iaf,21,&j);
+            if(j == -21) 
+            {
+               if(511 == a2) return(max(0.,b[0]));     // B11
+               return(0.);                             // =0 for the rest
+            }
+         }
+      }
+// straight search in the table
+      for(i=0; i<n_data[1][file_no[2]]; i++, p_cs+=n_data[0][file_no[2]])
+         if(a1 == inuc(*p_cs) && a2 == inuc(*(p_cs+1)))
+         {
+            for(p_cs+=2, j=0; j<6; b[j++]=*p_cs++);    // take the parameters
+            if(b[0] >= 0.)                             // if positive use fit
+            {
+               *info=-kopt;
+               if(emev < b[5]) return(0);              // fitting function
+               b[0]*=(1.+sin(b[1]*pow(log10(emev),1.*b[2]))*exp(-b[3]*(emev-b[4])));
+               return(max(0.,b[0]));
+            }
+            kopt = (int)(-b[0]+0.1);                   // negative b[0] gives kopt
+         }
+      if(izf == 0) return(0.);
+   }
+
+// CHECK if user wants to use specific program (the value of "kopt")
+   if(kopt == 1) CSmb = wsigma_cc(iz,ia,izf,iaf,emev);       // Webber's code IMOS20020502
+   if(kopt == 2) CSmb = yieldx_cc(iz,ia,izf,iaf,e1);         // TS code       IMOS20020502
+   CSmb = max(0.,CSmb);
+   if(kopt == 1 || kopt == 2) return(CSmb);
+
+// STARTING THE ALGHORITHM
+
+   for(i=0; i<11; T[i++] = 0.);
+
+// CHECK the array: cs_data (is there a channel we are looking for ?)
+
+   for(size=1, i=0; i<3; size*=n_data[i++][file_no[0]]);
+   for(tp = T, i=0; i<size; i+=n_data[0][file_no[0]], tp = T, f1=0., f2=0.)
+   {
+      if(a1 != inuc(*(cs_data+i)))   continue;
+      if(a2 != inuc(*(cs_data+i+1))) continue;
+
+// if there is such a channel then the LEAST-SQUARE FIT
+
+      itable++;
+      if(*(cs_data+i+4) < 0.) *(cs_data+i+4) *= -*(cs_data+i+3);  // calc.abs.err.
+      err2 = pow(*(cs_data+i+4),2);                               // err^2
+      y = *(cs_data+i+3);                                         // cs measured
+      ej = *(cs_data+i+2);                                        // @ energy
+
+      if(kopt/10 != 2) f1=wsigma_cc(iz,ia,izf,iaf,ej);             // Webber IMOS20020502
+      if(kopt/10 != 1) f2=yieldx_cc(iz,ia,izf,iaf,*(cs_data+i+2)); // TS     IMOS20020502
+
+// calculations of the separate terms:
+      *tp++ += f1*y /err2;       // Webber
+      *tp++ += f1*f1/err2;
+      *tp++ += f2*y /err2;       // TS
+      *tp++ += f2*f2/err2;
+      *tp++ += y    /err2;       // const cs
+      *tp++ += 1.   /err2;
+      
+// calculation of terms for the Xi2 estimates
+      *tp++ += y*y    /err2;
+      *tp++ += 2.*f1*y/err2;
+      *tp++ += f1*f1  /err2;
+      *tp++ += 2.*f2*y/err2;
+      *tp   += f2*f2  /err2;
+
+// calculation of renormalization coefficients 
+      for(j=0; j<3; j++) a[j]= (T[2*j+1] != 0.) ? T[2*j]/T[2*j+1]: a[j];
+   }
+   if(kopt == 3 && a[2] != 0.) return(a[2]);                  // const cr.sect.
+   if(kopt/10 == 1) CSmb = wsigma_cc(iz,ia,izf,iaf,emev);     // Webber code IMOS20020502
+   if(kopt/10 == 2) CSmb = yieldx_cc(iz,ia,izf,iaf,e1);       // TS code     IMOS20020502
+   if(kopt/10 == 1 || kopt/10 == 2) return(max(0.,CSmb*a[kopt/10-1]));
+
+// CHOOSE THE BEST APPROXIMATION (kopt = 0)
+   if(itable < 2)                                         // no data or 1 pt.
+   {  
+      *info = itable;
+      CSmb = a[0]*wsigma_cc(iz,ia,izf,iaf,emev);          // use Webber code     IMOS20020502
+      if(CSmb <= 0.) 
+      {                                                   // if W-code give 0,
+         CSmb = a[1]*yieldx_cc(iz,ia,izf,iaf,e1);         // take the TS approx. IMOS20020502
+         if(CSmb != 0. && itable == 1) *info = 2;
+      }
+   } else                                                 // data exists
+   {
+      xi1= T[6] -a[0]*T[7] +a[0]*a[0]*T[8];               // Xi2 evaluation 1
+      xi2= T[6] -a[1]*T[9] +a[1]*a[1]*T[10];              // Xi2 evaluation 2
+      if(xi1 < xi2)
+      {
+         *info = 1;
+         CSmb = a[0]*wsigma_cc(iz,ia,izf,iaf,emev);       // renorm. Webber approx. IMOS20020502
+      } else
+      {
+         *info = 2;
+         CSmb = a[1]*yieldx_cc(iz,ia,izf,iaf,e1);         // renorm. TS approx.     IMOS20020502
+      }
+   }
+   return(max(0.,CSmb));
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+double eval_cs(double emev,int za1,int za2,int* info)
+{
+   int i,size;
+   float *eval = data_file[file_no[3]];
+   double x[2]={-1.e10,1.e10},y[2]={0.,0.};
+
+// CHECK the array: eval (is there a channel we are looking for ?)
+
+   for(size=1, i=0; i<3; size*=n_data[i++][file_no[3]]);
+   for(*info=0, i=0; i<size; i+=n_data[0][file_no[3]])
+   {
+      if(za1 != inuc(*(eval+i)))   continue;
+      if(za2 != inuc(*(eval+i+1))) continue;
+
+      if(x[0] < *(eval+i+2) && *(eval+i+2) <= emev)   // find lower energy pt
+      { 
+         x[0] = *(eval+i+2); 
+         y[0] = *(eval+i+3);
+      }
+      if(emev <= *(eval+i+2) && *(eval+i+2) < x[1])   // find higher energy pt 
+      { 
+         x[1] = *(eval+i+2); 
+         y[1] = *(eval+i+3);
+      }
+   }
+
+   if(x[0]*x[1] < -1.e19) { *info = -1; return(0.); } // no evaluation found, return 0
+
+   if(x[0] <   0.) { *info = 1; return(0.); }         // no lower grid pt, return 0
+   if(x[1] > 9.e9) { *info = 2; return(y[0]); }       // no higher grid pt, extrapolate
+
+   if(x[1]-x[0] == 0.) { *info = 3; return(y[1]); }   // emev falls exactly on the grid
+
+   for(*info = 4, i=0; i<2; i++) x[i] = log10(x[i]);
+   return(y[0]+(log10(emev)-x[0])*(y[1]-y[0])/(x[1]-x[0]));// interpolate
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+// A SAMPLE TEST PROGRAM
+/*
+#include<stdio.h>
+#define min(a,b) (((a) > (b)) ? (b) : (a))
+extern "C" void   set_sigma__(int*);                           // Webber's init IMOS20020502
+extern "C" void   yieldx_(int*,int*,int*,int*,float*,float*);  // TS code       IMOS20020502
+extern "C" double wsigma_(int*,int*,int*,int*,double*);        // Webber's code IMOS20020502
+main()
+{
+   FILE *f1,*f2;
+   int i,j,k,n,m,info,iz,ia,jz,ja,sz[9],sa[9],izl,ial, ksp=0, cdr=51, 
+      kopt[9]={0,1,2,10,11,12,20,21,22};
+   float *tmp;
+   double ej,b,To,cs;
+   char filename[20], ch;                  // IMOS20020502
+
+   cout<<"\nTESTING THE NUCLEAR PACKAGE / version of 3/23/2000, imos \n\n";
+
+// test read_nucdata
+   
+   cout<<"read_nucdata: I am starting\n";
+   read_nucdata();                                // read data from files
+   cout<<"read_nucdata: I am finishing\n";
+
+   f1=fopen("test_cs.1","w");                     // print data to a file
+   for(fprintf(f1,"\n"), n=0; n<N_DATA_FILES; n++, fprintf(f1,"\n")) 
+      for(tmp = data_file[n], k=0; k<n_data[2][n]; k++, fprintf(f1,"\n")) 
+         for(i=0; i<n_data[1][n]; i++, fprintf(f1,"\n")) 
+            for(j=0; j<n_data[0][n]; j++) fprintf(f1,"%11.3f",*tmp++);
+   fclose(f1);
+   cout<<"read_nucdata: test finished, check file test_cs.1\n\n";
+         
+// test nucdata
+
+   cout<<"test nuclear reaction network ?(y/n)\n";
+   cin>>ch;
+   if(ch != 'y' && ch != 'Y') goto test3;
+
+   cout<<"nucdata: start testing\n";
+   f1=fopen("test_cs.2","w");
+   f2=fopen("test_cs.2K","w");
+   for(iz=1; iz<29; iz++)                               // check all the reactions
+   {
+      for(i=0;i<20; fprintf(f1,"-"), i++); 
+      for(fprintf(f1,"%4d  ",iz), i=0;i<20; fprintf(f1,"-"), i++); fprintf(f1,"\n");
+      for(i=0;i<20; fprintf(f2,"-"), i++); 
+      for(fprintf(f2,"%4d  ",iz), i=0;i<20; fprintf(f2,"-"), i++); fprintf(f2,"\n");
+      for(ia=2*iz-2; ia<2.5*iz+4.2; ia++)
+         for(jz=1; jz<29; jz++)
+            for(ja=2*jz-4; ja<2.5*jz+4.2; ja++)
+	    {
+               b = nucdata(ksp,iz,ia,0,jz,ja,&izl,&ial,&To);
+               if(b == 0.) continue;
+               fprintf(f1,"%5d.%2d%5d.%2d%5d.%2d%14.3E%8.3f\n",iz,ia,jz,ja,izl,ial,To,b);
+               printf("%5d.%2d%5d.%2d%5d.%2d%14.3E%8.3f\n",iz,ia,jz,ja,izl,ial,To,b);
+
+               b = nucdata(ksp,iz,ia,1,jz,ja,&izl,&ial,&To);
+               if(b == 0.) continue;
+               fprintf(f2,"%5d.%2d%5d.%2d%5d.%2d%14.3E%8.3f\n",iz,ia,jz,ja,izl,ial,To,b);
+               printf("%5d.%2d%5d.%2d%5d.%2d%14.3E%8.3f\n",iz,ia,jz,ja,izl,ial,To,b);
+            }
+   }
+   cout<<"nucdata: test finished, check file test_cs.2\n\n";
+
+// test isotope_cs
+
+test3:
+   cout<<"test cross sections ?(y/n)\n";
+   cin>>ch;
+   if(ch != 'y' && ch != 'Y') goto test4;
+   
+   cout<<"cross sections: start testing \n";
+   set_sigma__(&cdr);           // initialization of Webber's code IMOS20020502
+   
+   f1=fopen("test_cs.3","w");
+   for(ej=900., iz=1; iz<29; iz++)
+      for(ia=2*iz-2; ia<2.5*iz+4.2; ia++)
+      {
+         if(!nucdata(0,iz,ia,0,iz,ia,&izl,&ial,&To)) continue;
+         for(jz=2; jz<iz+1; jz++)
+            for(ja=max(1,2*jz-2); ja<min(2*jz+4,ia); ja++, fprintf(f1,"\n"))
+            {
+               fprintf(f1,"%7.2f%7.2f%12.3E",iz+ia/100.,jz+ja/100.,ej); 
+               printf("%7.2f%7.2f%12.3e",iz+ia/100.,jz+ja/100.,ej); 
+               for(i=0; i<3; i++) 
+                  printf("%12.3e",isotope_cs(ej,iz,ia,jz,ja,kopt[i],&j)); 
+               cout<<endl;
+               for(i=0; i<9; i++) 
+                  fprintf(f1,"%12.3E",isotope_cs(ej,iz,ia,jz,ja,kopt[i],&j));
+            }
+      }
+   fclose(f1);
+   cout<<"cross sections: test finished, check file test_cs.3\n\n";
+
+// testing cross section fits
+
+test4:
+   cout<<"test cross section fits ?(y/n)\n";
+   cin>>ch;
+   if(ch != 'y' && ch != 'Y') exit(0);
+   set_sigma__(&cdr);          // initialization of Webber's code IMOS20020502
+test4_1:   
+   cout<<"cross section fits: start testing \n\n"
+       <<"give IZ IA  IZF IAF IZF IAF... 0 0:\n";
+   cin>>iz>>ia>>jz>>ja;
+   for(n=0;n<3;n++) 
+   {
+      cin>>sz[n]>>sa[n];
+      if(!(sz[n]*sa[n])) break;
+   }
+   filename[0]='\0';
+   sprintf(filename,"x%1d%1d%1d%1d_%1d%1d%1d%1d",iz/10,iz%10,ia/10,ia%10,jz/10,jz%10,ja/10,ja%10);
+   
+   f1=fopen(filename,"w");
+   for(ej=1, k=0; k<100; k++, ej*=1.1, printf("%12.3e\n",ej))
+   {
+      fprintf(f1,"\n%12.3e",ej);
+      for(i=0; i<9; i++) 
+      { 
+         cs=isotope_cs(ej,iz,ia,jz,ja,kopt[i],&j);
+	 for(m=0; m<n; m++) cs+=isotope_cs(ej,iz,ia,sz[m],sa[m],kopt[i],&j);
+         fprintf(f1,"%12.3e",cs);
+      }
+   }
+   fprintf(f1,"\n");
+   fclose(f1);
+   cout<<"output file: "<<filename<<endl;   
+   cout<<"do you want one more channel ?(y/n)\n";
+   cin>>ch;
+   if(ch == 'y' || ch == 'Y') goto test4_1;
+}
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+// Webber's isotopic production cross section  IMOS20020502
+double wsigma_cc(int IZ, int IA, int IZF, int IAF, double E)
+{
+   return( wsigma_(&IZ,&IA,&IZF,&IAF,&E) );
+}
+
+//**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
+
+// Silberberg & Tsao isotopic production cross section  IMOS20020502
+double yieldx_cc(int IZ, int IA, int IZF, int IAF, float E)
+{
+   float CSmb;
+   yieldx_(&IZ,&IA,&IZF,&IAF,&E,&CSmb);
+   return( 1.*CSmb );
+}
+*/
+
Binary files darksusy-5.1.3.pristine/contrib/HiggsBounds-3.8.1/HiggsBounds/Expt_tables/S95_t1.binary and darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/Expt_tables/S95_t1.binary differ
Binary files darksusy-5.1.3.pristine/contrib/HiggsBounds-3.8.1/HiggsBounds/Expt_tables/S95_t2.binary and darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/Expt_tables/S95_t2.binary differ
Binary files darksusy-5.1.3.pristine/contrib/HiggsBounds-3.8.1/HiggsBounds/libHB.so and darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/libHB.so differ
diff -rupN darksusy-5.1.3.pristine/contrib/HiggsBounds-3.8.1/HiggsBounds/makefile_darksusy.in darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/makefile_darksusy.in
--- darksusy-5.1.3.pristine/contrib/HiggsBounds-3.8.1/HiggsBounds/makefile_darksusy.in	2015-04-07 10:23:05.000000000 +0100
+++ darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/makefile_darksusy.in	2016-02-16 15:28:43.937094029 +0000
@@ -106,10 +106,10 @@ OBJSsubroutines =  $(OBJSbasic) \
 default: HiggsBounds
 
 %.o: %.f
-	$(F77C) -c $< -o $@
+	$(F77C) $(F90FLAGS) -c $< -o $@
 
 %.o: %.F
-	$(F77C) -c $< -o $@
+	$(F77C) $(F90FLAGS) -c $< -o $@
 
 %.o %.mod: %.f90
 	$(F90C) $(F90FLAGS) $(ADDITIONALDEFINE) -c $< 
@@ -138,6 +138,17 @@ libHB:  $(MODS) $(OBJSsubroutines)
 
 libHB.a: libHB
 
+libHB_shared:  $(MODS) $(OBJSsubroutines)
+	$(F90C) $(F90FLAGS) -shared -o $(DS_LIB)/libHB.so $(OBJSsubroutines)
+	rm -f Expt_tables/S95_t1.binary 
+	rm -f Expt_tables/S95_t2.binary 
+	rm -f Theory_tables/BRSM.binary 	
+	touch Expt_tables/S95_t1.binary 
+	touch Expt_tables/S95_t2.binary 
+	touch Theory_tables/BRSM.binary 
+
+libHB.so: libHB_shared
+
 HBwithFH:  libHB.a
 	$(F77C) $(FHINCLUDE) example_programs/HBwithFH.F -o example_programs/HBwithFH $(FHLIBS) $(HBLIBS)
 	$(F90C) $(FHINCLUDE) example_programs/HBSLHAinputblocksfromFH_extras.F example_programs/HBSLHAinputblocksfromFH.F90 -o example_programs/HBSLHAinputblocksfromFH $(FHLIBS) $(HBLIBS)
@@ -157,10 +168,9 @@ clean:
 	rm -f *.o *.mod *.MOD *.a
 	rm -f store_pathname.f90
 
-hyperclean:
-	rm -f *.o *.mod *.MOD *.a *~ 
+hyperclean: clean
+	rm -f *~ 
 	rm -f example_programs/*~ 
-	rm -f store_pathname.f90
 	rm -f example_programs/HBwithFH
 	rm -f example_programs/HBwithCPsuperH
 	rm -f example_programs/example-SM_vs_4thGen
Binary files darksusy-5.1.3.pristine/contrib/HiggsBounds-3.8.1/HiggsBounds/Theory_tables/BRSM.binary and darksusy-5.1.3/contrib/HiggsBounds-3.8.1/HiggsBounds/Theory_tables/BRSM.binary differ
diff -rupN darksusy-5.1.3.pristine/contrib/isajet781-for-darksusy/func.f darksusy-5.1.3/contrib/isajet781-for-darksusy/func.f
--- darksusy-5.1.3.pristine/contrib/isajet781-for-darksusy/func.f	2011-11-03 14:34:52.000000000 +0000
+++ darksusy-5.1.3/contrib/isajet781-for-darksusy/func.f	1970-01-01 01:00:00.000000000 +0100
@@ -1,189 +0,0 @@
-
-******************************************************************
-******************************************************************
-******************************************************************
-      FUNCTION FUNC(X)
-
-
-      IMPLICIT NONE
-      
-      CHARACTER*6 PINF,PN1,PN2
-      REAL*8 A
-      COMMON/VARS/A(1800)
- 
-      COMMON /CTRL/
-     &AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX,
-     &NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-
-      REAL*8 AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX
-      INTEGER NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-      
-      REAL*8 X(25)
-      REAL*8 P(0:3,4)
-
-      REAL*8 RR,SN,PI,GEVTOPBN,FUNC,ds_da_dc,AS_MIN,PM,E,XMASS,Z,
-     &COS1, PM1,PM2,PM3,PM4,SIN1,SFACT,CFACT,TFACT,B1,B2,FA,AS,DJACOB,
-     &ECM,XFA,FA12,E1,E2,R1,R2,E3,R3,E4,R4,F_PS,FA12_integr,FUNC_TMP,
-     &SQME
-     
-      INTEGER I
-      
-      RR(E,XMASS)  = SQRT(MAX(0d0,(E-XMASS)*(E+XMASS)))
-      SN(Z)        = SQRT(MAX(0d0,(1-z)*(1+z)))
-      
-      
-      PI=DACOS(-1d0)
-      GEVTOPBN= 0.3893796623*1.E+09      
-      
-      FUNC=0.
-      ds_da_dc=0.
-      
-
- 
-      AS_MIN=2d0
-      PM=abs(A(93))
-C------------------------------------------ 
-      COS1=1d0-2d0*X(1)
-
-
-      IF(COS1.gt.COS_MAX) goto 999
-      IF(COS1.lt.cos_min) goto 999
-      SIN1=SN(COS1)
-
-
-C------------------------------------------      
-	
-      DO I =NPROC_MIN,NPROC_MAX,NPROC_STEP
-        
-        CALL PMAS(I,1,PM1)
-        CALL PMAS(I,2,PM2)
-	IF(ABS(PM1/PM).gt.SUPPEXPMAX.or.ABS(PM2/PM).gt.SUPPEXPMAX) 
-     >  goto 900
-        CALL PMAS(I,3,PM3)
-        CALL PMAS(I,4,PM4)
-	
-	PN1=PINF(I,1)
-        PN2=PINF(I,2)
-	SFACT=1.
-	CFACT=1.
-
-	IF(PN1.ne.PN2) SFACT=2.
-
-	IF(PN1.ne.'~o1'.and.PN1.ne.'~o2'.and.PN1.ne.'~g')  CFACT=2.
-	IF(PN2.ne.'~o1'.and.PN2.ne.'~o2'.and.PN2.ne.'~g')  CFACT=2.
-	
-	IF(PN1.eq.'~1+'.and.PN2.eq.'~1-')  CFACT=1.
-	
-	IF(PN1.eq.'~e1'.and.PN2.eq.'~E1')  CFACT=1.
-	IF(PN1.eq.'~e2'.and.PN2.eq.'~E2')  CFACT=1.
-	IF(PN1.eq.'~e3'.and.PN2.eq.'~E3')  CFACT=1.
-	IF(PN1.eq.'~n1'.and.PN2.eq.'~N1')  CFACT=1.
-	IF(PN1.eq.'~n2'.and.PN2.eq.'~N2')  CFACT=1.
-	IF(PN1.eq.'~n3'.and.PN2.eq.'~N3')  CFACT=1.
-	IF(PN1.eq.'~u1'.and.PN2.eq.'~U1')  CFACT=1.
-	IF(PN1.eq.'~d1'.and.PN2.eq.'~D1')  CFACT=1.
-	IF(PN1.eq.'~c1'.and.PN2.eq.'~C1')  CFACT=1.
-	IF(PN1.eq.'~s1'.and.PN2.eq.'~S1')  CFACT=1.
-	IF(PN1.eq.'~t1'.and.PN2.eq.'~T1')  CFACT=1.
-	IF(PN1.eq.'~b1'.and.PN2.eq.'~B1')  CFACT=1.
-	
-	TFACT=SFACT*CFACT
-	
-     
-      
-	
-	pm1=abs(pm1)
-	pm2=abs(pm2)
-	pm3=abs(pm3)
-	pm4=abs(pm4)
-	
-      
-	
-	B1=pm1/pm
-	B2=pm2/pm
-        
-	
-     
-        IF(NDIMUSER.eq.1) then
-          FA=1.
-          AS=AS_MAX
-          DJACOB=2.
-        ELSEIF(NDIMUSER.ge.2) then
-	
-          AS=AS_MIN+(AS_MAX-AS_MIN)*X(2)
-          DJACOB=(AS_MAX-AS_MIN)*2.
-	  IF(AS.le.b1+b2) goto 900
-	  
-	  IF(NDIMUSER.eq.2) THEN
-	      FA=FA12(AS,I,XF)
-	      
-	    
-	  ELSEIF(NDIMUSER.eq.3.and.NDIMUSER_EFF.eq.2) THEN
-	
-   	      FA=FA12_integr(AS,b1,b2,XF)*
-     &        ((AS**2-b1**2-b2**2)**2-4.*b1**2*b2**2)
-     &        /sqrt(AS)/(2.*sqrt(2.*pi)*b1**(3./2.)*b2**(3./2.))
-
-         
-          ELSEIF(NDIMUSER.eq.3.and.NDIMUSER_EFF.eq.3) THEN
-	      XFA=X(3)
-	      FA=FA12(AS,I,XFA)
-	      
-          ENDIF
-      
-        ENDIF
-	
-         
-        ECM=AS*PM
-        IF(ECM.GT.max(PM1+PM2,PM3+PM4)) then
-	
-	
-          E1=(ECM+(PM1-PM2)*(PM1+PM2)/ECM)/2D0
-          E2=(ECM+(PM2-PM1)*(PM1+PM2)/ECM)/2D0
-          R1=RR(E1,PM1)
-          R2=R1
- 	
-          P(0,1)=E1
-          P(1,1)=0.
-          P(2,1)=0.
-          P(3,1)=-R1
-          P(0,2)=E2
-          P(1,2)=0.
-          P(2,2)=0.
-          P(3,2)=R1
-	
-          E3=(ECM+(PM3-PM4)*(PM3+PM4)/ECM)/2D0
-          R3=RR(E3,PM3)
-          E4=(ECM+(PM4-PM3)*(PM3+PM4)/ECM)/2D0
-          R4=R3
-
-          P(0,3)=E3
-          P(1,3)=R3*SIN1
-          P(2,3)=0.
-          P(3,3)=R3*COS1
-         
-	  P(0,4)=E4
-          P(1,4)=-P(1,3)
-          P(2,4)=0.
-          P(3,4)=-P(3,3)
-           
-       	 
-	  F_PS=R3/R1/(32d0*Pi*ECM**2)
-	  FUNC_TMP =TFACT*SQME(I,P)*F_PS*FA*DJACOB*GEVTOPBN
-          ds_da_dc=FUNC_TMP+ds_da_dc
-	  IF(I.eq.26.and.NDIMUSER.eq.3.and.NDIMUSER_EFF.eq.2) goto 999
-	  
-	  
-        ENDIF
-  900   CONTINUE     
-
-      ENDDO
-  999 FUNC=ds_da_dc
-       
-
-      IF(FUNC.le.1D-16) FUNC=1D-16
- 
-      return
-      end
diff -rupN darksusy-5.1.3.pristine/contrib/isajet781-for-darksusy/func_int.f darksusy-5.1.3/contrib/isajet781-for-darksusy/func_int.f
--- darksusy-5.1.3.pristine/contrib/isajet781-for-darksusy/func_int.f	2011-11-03 14:34:52.000000000 +0000
+++ darksusy-5.1.3/contrib/isajet781-for-darksusy/func_int.f	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-
-
-C-------------------------------------------------------
-C#######################################################
-C-------------------------------------------------------
-
-      FUNCTION FUNC_INT(IPRINT)
-      IMPLICIT NONE
-C------- BASES COMMON BLOCKS ---------------------
-      
-      EXTERNAL FUNC
-      REAL*8  FUNC_INT,FUNC
-      
-      INTEGER NDIM,IG,MXDIM,NWILD,NCALL
-      REAL*8 XL,XU
-      PARAMETER (MXDIM = 50 )                                           
-      COMMON /BPARM1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,IG(MXDIM),NCALL    
-c      DATA NWILD/2/,NCALL/1000/      
-      INTEGER INTV, IPNT, NLOOP, MLOOP,ITMX1,ITMX2
-      REAL*8 ACC1,ACC2
-      COMMON /BPARM2/ ACC1,ACC2,ITMX1,ITMX2                             
-c      DATA  ITMX1/5/,ITMX2/5/,ACC1/0.1d0/,ACC2/0.1d0/
-      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP      
-c---------------------------------------------------
-      REAL*8 ESTIM, SIGMA, CTIME
-
-     
-      COMMON /CTRL/
-     &AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX,
-     &NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-
-      REAL*8 AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX
-      INTEGER NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-     
-      INTEGER I,IPRINT,IT1,IT2
-      
-      CALL BSINIT 
-      
-      ITMX1=5
-      ITMX2=5
-      NDIM =NDIMUSER_EFF
-      NWILD=NDIM
-      ACC1=1.
-      ACC2=1.
-      
-      DO 1 I=1,NDIMUSER_EFF
-        XL(I)=0d0
-        XU(I)=1d0
-    1 CONTINUE
-      XL(3)=0.000001
-      XU(3)=XF
-   
-c-------------------------------------------------
-
-      INTV=IPRINT
-      
-c       print *,'NCALLS=', NCALL,IPRINT,INTV,NPROC_MIN,NPROC_MAX
-      
-c      CALL BSINIT                                                  
-      CALL BASES( FUNC, ESTIM, SIGMA, CTIME, IT1, IT2 )             
-      
-      FUNC_INT=ESTIM
-      
-     
-      
-      RETURN
-      END
diff -rupN darksusy-5.1.3.pristine/contrib/isajet781-for-darksusy/isared.f darksusy-5.1.3/contrib/isajet781-for-darksusy/isared.f
--- darksusy-5.1.3.pristine/contrib/isajet781-for-darksusy/isared.f	2011-11-03 14:34:52.000000000 +0000
+++ darksusy-5.1.3/contrib/isajet781-for-darksusy/isared.f	1970-01-01 01:00:00.000000000 +0100
@@ -1,391 +0,0 @@
-CDECK  ID>, ISARED.
-cccccccccccccccccccccccccccccccccccccccccccccc
-c      AUTHORS: Baer,Balazs,Belyaev
-c
-c      Last modification -> 10/27/2005 A.Belyaev
-c      Last modification -> 10/04/2007 A.Belyaev
-c      Last modification -> 12/06/2007 A.Belyaev -> sigma*v (v->0) added
-c
-cccccccccccccccccccccccccccccccccccccccccccccc
-     
-      SUBROUTINE ISARED(IPRT)
-c      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
-      IMPLICIT NONE
-      
-	
-c----------USER--------------------------------      
-      COMMON /CTRL/
-     &AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX,
-     &NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-
-      REAL*8 AS_MAX,XFINI,XF,COS_MIN,COS_MAX,CS_MIN,SUPPEXP, SUPPEXPMAX
-      INTEGER NDIMUSER,NDIMUSER_EFF,ISUM,NST_MAX,
-     &NPROC_MIN,NPROC_MAX,NPROC_STEP
-     
-
-      INTEGER IPRINT
-      
-      DATA   AS_MAX / 3D0 /, XFINI/0.05D0/, NDIMUSER/3/, NST_MAX/10/,
-     &      NPROC_MIN/1/,   NPROC_MAX/1820/, NPROC_STEP/1/, IPRINT/1/,
-     &      COS_MIN / -0.999999d0 / , COS_MAX / 0.999999d0 /,
-     &      CS_MIN  /0d0/, ISUM/1/, SUPPEXPMAX/2d0/
-     
-
-      common/printlevel/NPRINT
-      INTEGER NPRINT
-c-----------------------------------------------      
-      COMMON   /GOOD/    NNOGOOD,IALLOW 
-      INTEGER  NNOGOOD,IALLOW                                                                                                       
-c------BASES------------------------------------\
-     
-      INTEGER NDIM,IG,MXDIM,NWILD,NCALL
-      REAL*8 XL,XU
-   
-      PARAMETER (MXDIM = 50 )                                           
-      COMMON /BPARM1/ XL(MXDIM),XU(MXDIM),NDIM,NWILD,IG(MXDIM),NCALL    
-      DATA NWILD/2/,NCALL/1000/      
-      
-      INTEGER INTV, IPNT, NLOOP, MLOOP,ITMX1,ITMX2
-      REAL*8 ACC1,ACC2
-      COMMON /BPARM2/ ACC1,ACC2,ITMX1,ITMX2                             
-      DATA  ITMX1/5/,ITMX2/5/,ACC1/1d0/,ACC2/1d0/
-      COMMON /BSCNTL/ INTV, IPNT, NLOOP, MLOOP                          
-c-----------------------------------------------
-      REAL*8 xb,g,pm
-      CHARACTER*6 names
-      INTEGER J,idof,IPTOT
-      COMMON /INPART/ xb(29),g(29),pm(29),idof(29),IPTOT
-      COMMON /NAMES/ names(29)
-
-      DATA IPTOT/29/
-      DATA  (IDOF(J),J=1,29)
-     _/  2,     2 ,     16,
-     _   2 ,	1 ,     1,      1,      3,     3, 
-     _  	1 ,     1 ,     1,      3,     3,    3,    3,
-     _   2 ,    1 ,     1,      1,      3,     3,
-     _  	1 ,     1 ,     1,      3,     3,    3,    3/
-
-     
-      DATA  (NAMES(J),J=1,29)
-     _/'~o1',  '~o2' ,'~g',
-     _  '~1-' ,'~e1' , '~e2' , '~e3' ,'~t1','~b1', 
-     _         '~n1' , '~n2' , '~n3' ,'~u1','~d1','~c1','~s1',
-     _  '~1+' ,'~E1' , '~E2' , '~E3' ,'~T1','~B1', 
-     _         '~N1' , '~N2' , '~N3' ,'~U1','~D1','~C1','~S1'/
-c-----------------------------------------------
-      REAL*4 OMGH2,SIGMA,XFREEZ,FFF_V
-      INTEGER NSTEPS
-      COMMON/SUGRED/ OMGH2,SIGMA,XFREEZ,NSTEPS,FFF_V
-c-----ISAJET-----------------------------------   
-      COMMON/SSLUN/LOUT,LHEOUT
-      INTEGER LOUT,LHEOUT
-      SAVE /SSLUN/
-C     XSUGIN contains the inputs to SUGRA:
-C     XSUGIN(1) = M_0        XSUGIN(2) = M_(1/2)  XSUGIN(3) = A_0
-C     XSUGIN(4) = tan(beta)  XSUGIN(5) = sgn(mu)  XSUGIN(6) = M_t
-C     XSUGIN(7) = SUG BC scale
-C     XGMIN(1) = LAM         XGMIN(2)  = M_MES    XGMIN(3)  = XN5
-C     XGMIN(4) = tan(beta)   XGMIN(5)  = sgn(mu)  XGMIN(6) = M_t
-C     XGMIN(7) = CGRAV       XGMIN(8)  =RSL       XGMIN(9)  = DEL_HD
-C     XGMIN(10)  = DEL_HU    XGMIN(11) = DY       XGMIN(12) = N5_1
-C     XGMIN(13)  = N5_2      XGMIN(14) = N5_3
-C     XNRIN(1) = M_N3        XNRIN(2) = M_MAJ     XNRIN(3) = ANSS 
-C     XNRIN(4) = M_N3SS
-C     XISAIN contains the MSSMi inputs in natural order.
-      COMMON /SUGXIN/ XISAIN(24),XSUGIN(7),XGMIN(14),XNRIN(4),
-     $XAMIN(11)
-      REAL XISAIN,XSUGIN,XGMIN,XNRIN,XAMIN
-      SAVE /SUGXIN/
-C          Frozen couplings from RG equations:
-C     GSS( 1) = g_1        GSS( 2) = g_2        GSS( 3) = g_3
-C     GSS( 4) = y_tau      GSS( 5) = y_b        GSS( 6) = y_t
-C     GSS( 7) = M_1        GSS( 8) = M_2        GSS( 9) = M_3
-C     GSS(10) = A_tau      GSS(11) = A_b        GSS(12) = A_t
-C     GSS(13) = M_hd^2     GSS(14) = M_hu^2     GSS(15) = M_er^2
-C     GSS(16) = M_el^2     GSS(17) = M_dnr^2    GSS(18) = M_upr^2
-C     GSS(19) = M_upl^2    GSS(20) = M_taur^2   GSS(21) = M_taul^2
-C     GSS(22) = M_btr^2    GSS(23) = M_tpr^2    GSS(24) = M_tpl^2
-C     GSS(25) = mu         GSS(26) = B          GSS(27) = Y_N
-C     GSS(28) = M_nr       GSS(29) = A_n        GSS(30) = vdq
-C     GSS(31) = vuq
-C          Masses:
-C     MSS( 1) = glss     MSS( 2) = upl      MSS( 3) = upr
-C     MSS( 4) = dnl      MSS( 5) = dnr      MSS( 6) = stl
-C     MSS( 7) = str      MSS( 8) = chl      MSS( 9) = chr
-C     MSS(10) = b1       MSS(11) = b2       MSS(12) = t1
-C     MSS(13) = t2       MSS(14) = nuel     MSS(15) = numl
-C     MSS(16) = nutl     MSS(17) = el-      MSS(18) = er-
-C     MSS(19) = mul-     MSS(20) = mur-     MSS(21) = tau1
-C     MSS(22) = tau2     MSS(23) = z1ss     MSS(24) = z2ss
-C     MSS(25) = z3ss     MSS(26) = z4ss     MSS(27) = w1ss
-C     MSS(28) = w2ss     MSS(29) = hl0      MSS(30) = hh0
-C     MSS(31) = ha0      MSS(32) = h+
-C          Unification:
-C     MGUTSS  = M_GUT    GGUTSS  = g_GUT    AGUTSS  = alpha_GUT
-      COMMON /SUGMG/ MSS(32),GSS(31),MGUTSS,GGUTSS,AGUTSS,FTGUT,
-     $FBGUT,FTAGUT,FNGUT
-      REAL MSS,GSS,MGUTSS,GGUTSS,AGUTSS,FTGUT,FBGUT,FTAGUT,FNGUT
-      SAVE /SUGMG/
-      COMMON /SUGPAS/ XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
-     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ,
-     $FNMZ,AMNRMJ,NOGOOD,IAL3UN,ITACHY,MHPNEG,MHLNEG,MHCNEG,
-     $IGUTST,ASM3,
-     $VUMT,VDMT,ASMTP,ASMSS,M3Q,MHDSQ,MHUSQ,MHDSMG,MHUSMG,MUMG,BMG,
-     $FT2Z1,FB2Z1,FL2Z1
-      REAL XTANB,MSUSY,AMT,MGUT,MU,G2,GP,V,VP,XW,
-     $A1MZ,A2MZ,ASMZ,FTAMZ,FBMZ,B,SIN2B,FTMT,G3MT,VEV,HIGFRZ,
-     $FNMZ,AMNRMJ,ASM3,VUMT,VDMT,ASMTP,ASMSS,M3Q,MHDSQ,MHUSQ,
-     $MHDSMG,MHUSMG,MUMG,BMG,FT2Z1,FB2Z1,FL2Z1
-      INTEGER NOGOOD,IAL3UN,ITACHY,MHPNEG,MHLNEG,MHCNEG,IGUTST
-      SAVE /SUGPAS/
-c----------COMPHEP------------------------------      
-      COMMON/VARS/A(1800)
-      REAL*8 A
-c-----------------------------------------------      
-c-----------------------------------------------      
-      CHARACTER*6 PINF
-      REAL*8 PBNTOGEV,PI,SQRT_GN,FFF,XFI,XF_OLD,SUMM,GEFF,
-     &FUNC_INT,FFF_TMP,OMEGA,FFF_OLD
-      
-      INTEGER IPRT,NPROC_MAX_S,NPROC_MIN_S,IPM,IDEL,
-     &NDIMUSER_SAVE,NST,NDIMUSER_EFF_SAVE, NCALL_SAV,I
-    
-      
-c-----------------------------------------------      
-      REAL*8 del(29)
-    
-      REAL*8 vvv,AS_MAX_SAVE,conv1,conv2,CS_V
-      
-      
-      IPRINT=IPRT
-      NPRINT=IPRINT
-      
-      XF=XFINI
-      FFF=0d0
-	
-      SQRT_GN=dsqrt(67.07d0)/1d+20
-      PBNTOGEV=1d0/0.3893796623/1d+09	
-       
-      Pi=DACOS(-1d0)
-      
-      FFF=0
-      NNOGOOD=0
-      
-      call vini
-***************************
-
-      call isachp
-
-*****************************
-! Z1,Z2,W1, e1, e2, e3, n1,n2,n3,u1,d1,c1,s1,t1,b1,gss
-****************************
-	PM(1)=abs(A(93))   	!neutr1
-        PM(2)=abs(A(95))   	!neutr2
-        PM(3)=abs(A(131))  	!gluino
-	
-        PM(4)=abs(A(89))   	!charg
-        PM(5)=abs(A(132))  	!sel
-        PM(6)=abs(A(134))  	!smu
-        PM(7)=abs(A(106))  	!sta
-        PM(8)=abs(A(122))   	!stop
-        PM(9)=abs(A(126))  	!sbot
-	
-   	
-        PM(10)=abs(A(136))  	!snu_e
-        PM(11)=abs(A(137))  	!snu_l
-        PM(12)=abs(A(112))  	!snu_tau
-        PM(13)=abs(A(138))  	!sup1
-        PM(14)=abs(A(140))  	!sd_1
-        PM(15)=abs(A(142))  	!sc1
-        PM(16)=abs(A(144))  	!ss_1
-	
-        PM(17)=	PM(4)		!charg
-        PM(18)=	PM(5)  		!sel
-        PM(19)=	PM(6)  		!smu
-        PM(20)=	PM(7)  		!sta
-        PM(21)=	PM(8)		!stop
-        PM(22)=	PM(9)  		!sbot
-	
- 
-        PM(23)=	PM(10)  	!snu_e
-        PM(24)=	PM(11)  	!snu_l
-        PM(25)=	PM(12)  	!snu_tau
-        PM(26)=	PM(13)  	!sup1
-        PM(27)=	PM(14)  	!sd_1
-        PM(28)=	PM(15)  	!sc1
-        PM(29)=	PM(17)  	!ss_1
-***********************************************      
-
- 
-      SUPPEXP=1E+20
- 
-      DO IPM=2,IPTOT
-        if(min(pm(IPM),PM(1)).ne.pm(1).and.iallow.eq.0) then
-          iallow=-11 !NEUTR IS NOT THE LIGHTEST
-          if(iprt.gt.2) print *,'Z1 IS NOT LSP',IPM,PM(IPM),PM(1)
-          NNOGOOD=5
-          goto 555
-          ENDIF 
-          SUPPEXP=min(SUPPEXP,pm(IPM)/pm(1))
-      ENDDO
-
-      geff=0d0
-      DO IDEL=1,IPTOT
-        del(idel)=(pm(idel)-pm(1))/pm(1)
-        geff=geff+ 2. * (1.+del(IDEL))**(3./2.) * Exp(-del(idel)/XF)
-        if(iprint.gt.2) 
-     &print *,  (1.+del(IDEL))**(3./2.) * Exp(-del(idel)/XF), del(idel)
-      ENDDO
-      IF(IPRINT.gt.1) print *,'GEFF=', GEFF,'   ','SUPPEXP=',SUPPEXP
-      NDIMUSER_EFF=NDIMUSER
-      IF(SUPPEXP.ge.SUPPEXPMAX.and.NDIMUSER.eq.3)  NDIMUSER_EFF=2 
-      if(iprint.gt.2) 
-     & print *, 'NDIMUSER_EFF=', NDIMUSER_EFF,SUPPEXP
-     
-
-cccccccccccccccccc    
-c      goto 111
-
-      NST=0
-      NDIMUSER_SAVE=NDIMUSER
-      NDIMUSER_EFF_SAVE=NDIMUSER_EFF
-c       print *,'ISARED:', NPROC_MIN,NPROC_MAX
-
-      IF(NDIMUSER.ge.2) NDIMUSER=2
-      NDIMUSER_EFF=NDIMUSER
-      NCALL_SAV=NCALL
-      NCALL=NCALL/2.
-888   continue
-      NST=NST+1
-      IF(NST.GT.NST_MAX) goto 666
-      
-      IPRINT=IPRT
-c--------------------	
-      FFF_OLD=FFF  
-      FFF=FUNC_INT(IPRINT)
-      IF(FFF.lt.CS_MIN) GOTO  666
-c--------------------	  
-
-      IF(NDIMUSER_SAVE.eq.2) GOTO 777
-      if(IPRT.gt.1) print *,'FFF0=', FFF
-
-        
-      IF(FFF.le.0) then
-         FFF=0.
-         goto 666
-      ENDIF
-
-
-       XFI=LOG(
-     &     PM(1)/(2d0*Pi**3)*geff/2d0*sqrt(45d0/(2d0*81d0))/SQRT_GN
-     &     *FFF*PBNTOGEV*SQRT(XF)
-     &     )
-       
-
-       XF_OLD=XF
-       XF=1D0/XFI
-       
-
-
-       IF(iprint.gt.1) then
-       print *,'======================='
-       print *,'XF = ',XF,1d0/XF
-       print *,'CS  = ',FFF
-       print *,'NST = ',NST
-       print *,'======================='
-       endif
-
-       IF(XF.le.0.) then
-         XF=XFINI
-         FFF=0
-         goto 666
-       ENDIF
-
-ccc       IF(abs(XF-XF_OLD)/XF.gt.0.01) goto 888
-       IF(abs(FFF-FFF_OLD)/FFF.gt.0.03) goto 888
-ccc    print *,'xxxxxxxx 3d Integration xxxxxxxxxx'
- 777   CONTINUE
- 666   NCALL=NCALL*2.
-       NDIMUSER=NDIMUSER_SAVE
-       NDIMUSER_EFF=NDIMUSER_EFF_SAVE
-       IF(NDIMUSER.eq.2    ) goto 999
-       IF(NDIMUSER_EFF.eq.2) NCALL=NCALL/2.
-
-       IF(FFF.lt.CS_MIN) THEN
-          FFF=1.E-20
-          GOTO 999
-       ENDIF
-
-
-       FFF=FUNC_INT(IPRINT)
- 999   continue
-  
-c      print *,'IPRINT=',IPRINT
-       IF(IPRINT.ge.3) then
-         NPROC_MAX_S=NPROC_MAX
-         NPROC_MIN_S=NPROC_MIN
-         SUMM=0.
-         
-         
-         DO I =NPROC_MIN_S,NPROC_MAX_S,NPROC_STEP
-           if(SUPPEXP.ge.SUPPEXPMAX.and.I.gt.26) GOTO 444
-           NPROC_MIN=I
-           NPROC_MAX=I
-           FFF_TMP=FUNC_INT(-1)
-           IF(FFF_TMP/FFF.gt.0.01) THEN
-             print '(I6,A4,F6.2,A2,4A8)',
-     &       I,'  ',FFF_TMP/FFF*100,' %',
-     &       (PINF(I,J),J=1,4)
-             SUMM=SUMM+FFF_TMP/FFF
-           ENDIF
-         ENDDO
- 444     continue	 
-
-         NPROC_MAX=NPROC_MAX_S
-         NPROC_MIN=NPROC_MIN_S
-       endif
-
-      
- 
- 555   continue
-       if(iprint.gt.1) then
-       print *,'===========FINAL======='
-       print *, 'freez out temp=',1d0/XF
-       print *, 'n steps       =',NST
-       print *, 'CS (fb)       =',FFF*1000d0
-       print *, 'OMEGA H^2     =',OMEGA(FFF)
-       print *,'======================='
-       endif
-
-       OMGH2 =OMEGA(FFF)
-       SIGMA =FFF
-       XFREEZ=XF
-       NSTEPS =NST
-
-       NCALL=NCALL_SAV
-      
-cccccccccccccccccccccccccccccccccccccccccccc
- 111   continue
-       NDIMUSER_SAVE=NDIMUSER
-       AS_MAX_SAVE  =AS_MAX
-       NDIMUSER=1
-       NDIMUSER_EFF=1
-
-       
-       VVV=1.E-03
-       AS_MAX=2.*sqrt(1.+(VVV/2.)**2)  
-       CONV1 =  2.998E+10  ! speed of light cm/sec
-       CONV2 =  1.000E-36  ! 1pb ==> cm^2
-
-       CS_V  =  FUNC_INT(IPRINT)
-       FFF_V =  CS_V*VVV*CONV1*CONV2
-
-       NDIMUSER=NDIMUSER_SAVE
-       AS_MAX=AS_MAX_SAVE
-       
-
-cccccccccccccccccccccccccccccccccccccccccccc       
-
-      RETURN
-      END
diff -rupN darksusy-5.1.3.pristine/contrib/isajet781-for-darksusy/makefile.in darksusy-5.1.3/contrib/isajet781-for-darksusy/makefile.in
--- darksusy-5.1.3.pristine/contrib/isajet781-for-darksusy/makefile.in	2011-11-03 14:34:52.000000000 +0000
+++ darksusy-5.1.3/contrib/isajet781-for-darksusy/makefile.in	2016-02-16 15:23:54.953099204 +0000
@@ -6,9 +6,6 @@
 FF=@F77@
 FOPT=@FOPT@
 
-DS_ROOT=../..
-LIB=$(DS_ROOT)/lib
-
 ########################################################
 ### READ THROUGH AND CHANGE THE DEFAULT VALUES BELOW ###
 ### BEFORE COMPILING.                                ###
@@ -20,21 +17,24 @@ LIB=$(DS_ROOT)/lib
 # to libisajet.a.
 # For compatibility with gfortran, aldata.o _is_ included here (after 'BLOCK DATA' has been changed to 'SUBROUTINE').
 
-OBJ = aldata.o alqcd.o amass.o amgmw.o ayukdiag.o b0func.o bases.o besk1.o bhinit.o bhplot.o bhrset.o bhsave.o bi.o bk2mvsm.o boostx.o brems.o bschck.o bsdate.o bsdims.o bsetgu.o bsetgv.o bsggut.o bsgrid.o bsinfo.o bsinit.o bsintg.o bslist.o bsordr.o bsparm.o bsprnt.o bsread.o bstcnv.o bstime.o bsutim.o bswrit.o bufin.o bufout.o c0.o cbk2mvsm.o ccon.o cdagger.o charge.o chargino.o chdec.o chint.o ci.o cmatmul.o cmd.o cmodsq.o colr12.o colr13.o colr22.o con.o coup1x.o coup2x.o coup3x.o coup4x.o cputim.o cre.o crge215.o crge601.o crkstp.o csfmul.o csmrgedr.o cteq5l.o ctq5pdf.o ctrace.o ctxc2i.o ctxi2c.o ctxin.o ctxout.o d0.o dadmul.o dagger.o dblpcm.o dblvec.o dboost.o dcabs1.o ddilog.o decay.o decjet.o decoutcoup.o decps1.o decps2.o decrun.o decss3.o dectau.o decva.o dhfill.o dhinit.o dhplot.o di.o diagsqm.o dincgm.o disnan.o dlabad.o dladiv.o dlaisnan.o dlamc1.o dlamc2.o dlamc3.o dlamc4.o dlamc5.o dlamch.o dlapy2.o dlapy3.o dmatmul.o domssm.o downmhcond.o downmhighmh.o downmhighmz.o downmscond.o downsqm.o dre.o drge215.o drge601.o drkstp.o drllyn.o drn.o drnset.o drotsq.o drotsqback.o dscal.o dsmma.o dsmrgedr.o dtrace.o dtrint.o dzasum.o dznrm2.o eaixxx.o eaoxxx.o ebeam.o edit.o eebeg.o eemax.o ei.o eigsys.o eisrs1.o elctrn.o epf.o estruc.o evol01.o evol02.o evol03.o evol05.o evol06.o evol07.o evol11.o evolms.o evolve.o fa12.o fa12_integr.o fbrbm.o fes.o flavor.o fntg.o fortop.o frgjet.o frgmnt.o fsixxx.o fsoxxx.o func.o func_int.o funs.o fvixxx.o fvoxxx.o gamma.o gammac1.o gammac2.o gammahp.o gammasm.o gammawb1.o gammawb2.o gamtot.o gbeam.o ges.o getpas.o getpt.o gettot.o ggggxx.o gggxxx.o gluneno.o gout601.o gstruc.o hdcyad.o hdcysy.o heavyx.o hermtest.o hevolv.o higgs.o highin.o hioxxx.o hsssxx.o hssxxx.o hvsxxx.o hvvxxx.o idamax.o idanti.o idgen.o ieeeck.o iframs.o ilaenv.o ilazlc.o inisap.o iosxxx.o iovxxx.o ipartns.o ipjset.o iprtns.o irmov0.o isaamu.o isabeg.o isabmm.o isabsg.o isachp.o isaend.o isaevt.o isahep.o isaini.o isajet.o isalha.o isalhd.o isalhe.o isared.o isares.o isasrt.o isawbg.o isawev.o isawig.o isawnd.o ispjet.o istrad.o iswdky.o itrans.o ixxxxx.o j3xxxx.o jeexxx.o jetgen.o jgggxx.o jggxxx.o jioxxx.o jssxxx.o jtioxx.o jvssxx.o jvsxxx.o jvvxxx.o jw3wxx.o jwwwxx.o kkgf1.o kkgf2.o kkgf3.o kmin.o label.o lboost.o logerr.o logic.o logmgm.o logmgy.o logmij.o logp.o logphi.o logphw.o logpt.o logqm.o logqt.o logthw.o logx.o logxw.o logyth.o logyw.o lsame.o lstsq.o mass.o masssqm.o mat2vec.o mbias.o mbset.o mginit.o mmamsb.o modsq.o mom2cx.o momntx.o movlev.o mprod2.o mprod2x.o mprod3.o mprod3x.o mprod4x.o mprod5x.o muljet.o nogood.o omega.o ordecr.o order.o orth.o outcoup.o oxxxxx.o pdgid.o piblbl.o piblbr.o pibrbr.o pielel.o pierer.o pillll.o pilllr.o pilrlr.o pinene.o pitltl.o pitltr.o pitrtr.o prtevt.o prtlim.o prtlst.o ptfun.o qcdini.o qcdint.o qcdinz.o qcdjet.o qcdt.o qcdz.o qfunc.o ranf.o ranfgt.o ranfmt.o ranfst.o ranlux.o rdbeg.o rdtape.o readin.o rejfrg.o rejjet.o remsf.o rend.o rescal.o reset.o rge157.o rgeflav.o rgens.o rgeread.o rkstp.o rotate.o rotate215.o rotatesm.o rotback.o rotback215.o rotbacksm.o rotsq.o rotsqback.o rotxxx.o rpdecy.o rpinf1.o rpinf2.o rpint1.o rpint2.o rpint3.o rpmain.o rpmoda.o rpnorm.o rprate.o rprtch.o setcon.o setdky.o seth.o sethss.o setkkg.o setnxt.o settyp.o setw.o sfmul.o shcler.o shfill.o shinit.o shplot.o shrset.o shupdt.o sig0l.o sig0r.o sig0s.o sigdy.o sigdy2.o sigee.o sigfil.o siggam.o sigh.o sigh2.o sigh3.o sighss.o sigint.o sigkkg.o sigpl.o sigpr.o sigps.o sigqcd.o sigsse.o sigssl.o sigssy.o sigssz.o sigtc.o sigtc2.o sigtc3.o sigwh.o sigwhs.o sigww.o sigww2.o smszg.o sorttf.o sortth.o sortzg.o spchck.o sphist.o spinfo.o spline.o sprgen.o spring.o sqdiag.o sqrlam.o sqsix.o ssa0.o ssalfs.o ssb0.o ssb00.o ssb1.o ssb1f.o ssbt20.o ssbt22.o ssc0.o ssd0.o ssd27.o ssdhll.o ssdint.o ssdlam.o ssf.o ssf0.o ssfel.o ssg.o ssglbf.o ssgst.o ssgt.o ssgwq1.o ssgwq2.o ssgwt1.o ssgwt2.o ssgwt3.o ssgwt4.o ssgwt5.o ssgwt6.o ssgwt7.o ssgwt8.o ssgx1.o ssgx10.o ssgx11.o ssgx2.o ssgx3.o ssgx4.o ssgx5.o ssgx6.o ssgx7.o ssgx8.o ssgx9.o ssgzg1.o ssgzg2.o ssgzg3.o ssgzt.o ssh.o ssh0.o sshcc.o sshff.o sshff1.o sshgl.o sshgm.o sshgm1.o sshhx.o sshibf.o sshnn.o sshsf.o sshww.o sshww1.o sshww2.o ssl1st.o sslpbf.o sslrt1.o ssm1lp.o ssmass.o ssme3.o ssmhc.o ssmhn.o ssmqcd.o ssmssm.o ssn1st.o ssnorm.o sspole.o ssqkbf.o ssrsgb.o ssrsgl.o ssrsgt.o sssave.o sssnws.o ssssxx.o ssstbf.o sssvme.o sssxxx.o sstest.o sstpbf.o sswibf.o sswwf1.o sswz2p.o sswz3p.o sswzbf.o sswzf1.o sswzf2.o sswzf3.o sswzf4.o sswzf5.o sswzf6.o sswzf7.o ssxint.o ssxlam.o sszhx.o sszibf.o sszwf1.o sszzf1.o sszzf2.o sszzf3.o sszzf4.o sszzf5.o sszzg1.o sszzg2.o sszzg3.o sszzg4.o st1cneu.o st3int.o st3mat.o stbwz1.o stradd.o strotate.o strotback.o struc.o strucw.o sualfe.o sualfs.o sug2bsg.o sugeff.o sugefffl.o sugfrz.o sugmas.o sugra.o sugrge.o surg06.o surg26.o sxxxxx.o symmtest.o szjj1.o szjj2.o szjj3.o szjj4.o szjj5.o szjj6.o szjj7.o tactiv.o tcsfmul.o thetaxy.o timer.o tql2.o tqleig.o tr3x3.o trace.o trdiag.o tred2.o triint.o tsfmul.o twojet.o twokin.o uoutcoup.o upmhcond.o upmhcond2.o upmzmhigh.o upmzmhigh2.o upsqm.o usmma.o vec2mat.o vgen.o visaje.o vssxxx.o vvssxx.o vvsxxx.o vvvxxx.o vxxxxx.o w3w3xx.o wgens.o whiggs.o wilson.o wpair.o wwkin.o wwss.o wwst.o wwtt.o wwwwxx.o wzss.o wzst.o wzsu.o wztu.o xerbla.o xhchck.o xhfill.o xhinit.o xhordr.o xhplot.o xhrnge.o xhscle.o xkaim.o xkare.o xwwww.o xwwzz.o xzzww.o xzzzz.o ygenj.o yukdiag.o zaxpy.o zcopy.o zdotc.o zdotu.o zdscal.o zerol.o zgebak.o zgebal.o zgeev.o zgehd2.o zgehrd.o zgemm.o zgemv.o zgerc.o zhseqr.o zjj.o zjj0.o zjj1.o zjj2.o zjj3.o zjj4.o zjj5.o zjj6.o zjj7.o zlacgv.o zlacpy.o zladiv.o zlahqr.o zlahr2.o zlange.o zlaqr0.o zlaqr1.o zlaqr2.o zlaqr3.o zlaqr4.o zlaqr5.o zlarf.o zlarfb.o zlarfg.o zlarft.o zlartg.o zlascl.o zlaset.o zlassq.o zlatrs.o zrot.o zscal.o zswap.o ztrevc.o ztrexc.o ztrmm.o ztrmv.o ztrsv.o zung2r.o zunghr.o zungqr.o zunm2r.o zunmhr.o zunmqr.o zzall.o zzstar.o
+OBJ = aldata.o alqcd.o amass.o amgmw.o ayukdiag.o b0func.o bases.o besk1.o bhinit.o bhplot.o bhrset.o bhsave.o bi.o bk2mvsm.o boostx.o brems.o bschck.o bsdate.o bsdims.o bsetgu.o bsetgv.o bsggut.o bsgrid.o bsinfo.o bsinit.o bsintg.o bslist.o bsordr.o bsparm.o bsprnt.o bsread.o bstcnv.o bstime.o bsutim.o bswrit.o bufin.o bufout.o c0.o cbk2mvsm.o ccon.o cdagger.o charge.o chargino.o chdec.o chint.o ci.o cmatmul.o cmd.o cmodsq.o colr12.o colr13.o colr22.o con.o coup1x.o coup2x.o coup3x.o coup4x.o cputim.o cre.o crge215.o crge601.o crkstp.o csfmul.o csmrgedr.o cteq5l.o ctq5pdf.o ctrace.o ctxc2i.o ctxi2c.o ctxin.o ctxout.o d0.o dadmul.o dagger.o dblpcm.o dblvec.o dboost.o dcabs1.o ddilog.o decay.o decjet.o decoutcoup.o decps1.o decps2.o decrun.o decss3.o dectau.o decva.o dhfill.o dhinit.o dhplot.o di.o diagsqm.o dincgm.o disnan.o dlabad.o dladiv.o dlaisnan.o dlamc1.o dlamc2.o dlamc3.o dlamc4.o dlamc5.o dlamch.o dlapy2.o dlapy3.o dmatmul.o domssm.o downmhcond.o downmhighmh.o downmhighmz.o downmscond.o downsqm.o dre.o drge215.o drge601.o drkstp.o drllyn.o drn.o drnset.o drotsq.o drotsqback.o dscal.o dsmma.o dsmrgedr.o dtrace.o dtrint.o dzasum.o dznrm2.o eaixxx.o eaoxxx.o ebeam.o edit.o eebeg.o eemax.o ei.o eigsys.o eisrs1.o elctrn.o epf.o estruc.o evol01.o evol02.o evol03.o evol05.o evol06.o evol07.o evol11.o evolms.o evolve.o fa12_integr.o fbrbm.o fes.o flavor.o fntg.o fortop.o frgjet.o frgmnt.o fsixxx.o fsoxxx.o funs.o fvixxx.o fvoxxx.o gamma.o gammac1.o gammac2.o gammahp.o gammasm.o gammawb1.o gammawb2.o gamtot.o gbeam.o ges.o getpas.o getpt.o gettot.o ggggxx.o gggxxx.o gluneno.o gout601.o gstruc.o hdcyad.o hdcysy.o heavyx.o hermtest.o hevolv.o higgs.o highin.o hioxxx.o hsssxx.o hssxxx.o hvsxxx.o hvvxxx.o idamax.o idanti.o idgen.o ieeeck.o iframs.o ilaenv.o ilazlc.o inisap.o iosxxx.o iovxxx.o ipartns.o ipjset.o iprtns.o irmov0.o isaamu.o isabeg.o isabmm.o isabsg.o isachp.o isaend.o isaevt.o isahep.o isaini.o isajet.o isalha.o isalhd.o isalhe.o isares.o isasrt.o isawbg.o isawev.o isawig.o isawnd.o ispjet.o istrad.o iswdky.o itrans.o ixxxxx.o j3xxxx.o jeexxx.o jetgen.o jgggxx.o jggxxx.o jioxxx.o jssxxx.o jtioxx.o jvssxx.o jvsxxx.o jvvxxx.o jw3wxx.o jwwwxx.o kkgf1.o kkgf2.o kkgf3.o kmin.o label.o lboost.o logerr.o logic.o logmgm.o logmgy.o logmij.o logp.o logphi.o logphw.o logpt.o logqm.o logqt.o logthw.o logx.o logxw.o logyth.o logyw.o lsame.o lstsq.o mass.o masssqm.o mat2vec.o mbias.o mbset.o mginit.o mmamsb.o modsq.o mom2cx.o momntx.o movlev.o mprod2.o mprod2x.o mprod3.o mprod3x.o mprod4x.o mprod5x.o muljet.o nogood.o omega.o ordecr.o order.o orth.o outcoup.o oxxxxx.o pdgid.o piblbl.o piblbr.o pibrbr.o pielel.o pierer.o pillll.o pilllr.o pilrlr.o pinene.o pitltl.o pitltr.o pitrtr.o prtevt.o prtlim.o prtlst.o ptfun.o qcdini.o qcdint.o qcdinz.o qcdjet.o qcdt.o qcdz.o qfunc.o ranf.o ranfgt.o ranfmt.o ranfst.o ranlux.o rdbeg.o rdtape.o readin.o rejfrg.o rejjet.o remsf.o rend.o rescal.o reset.o rge157.o rgeflav.o rgens.o rgeread.o rkstp.o rotate.o rotate215.o rotatesm.o rotback.o rotback215.o rotbacksm.o rotsq.o rotsqback.o rotxxx.o rpdecy.o rpinf1.o rpinf2.o rpint1.o rpint2.o rpint3.o rpmain.o rpmoda.o rpnorm.o rprate.o rprtch.o setcon.o setdky.o seth.o sethss.o setkkg.o setnxt.o settyp.o setw.o sfmul.o shcler.o shfill.o shinit.o shplot.o shrset.o shupdt.o sig0l.o sig0r.o sig0s.o sigdy.o sigdy2.o sigee.o sigfil.o siggam.o sigh.o sigh2.o sigh3.o sighss.o sigint.o sigkkg.o sigpl.o sigpr.o sigps.o sigqcd.o sigsse.o sigssl.o sigssy.o sigssz.o sigtc.o sigtc2.o sigtc3.o sigwh.o sigwhs.o sigww.o sigww2.o smszg.o sorttf.o sortth.o sortzg.o spchck.o sphist.o spinfo.o spline.o sprgen.o spring.o sqdiag.o sqrlam.o sqsix.o ssa0.o ssalfs.o ssb0.o ssb00.o ssb1.o ssb1f.o ssbt20.o ssbt22.o ssc0.o ssd0.o ssd27.o ssdhll.o ssdint.o ssdlam.o ssf.o ssf0.o ssfel.o ssg.o ssglbf.o ssgst.o ssgt.o ssgwq1.o ssgwq2.o ssgwt1.o ssgwt2.o ssgwt3.o ssgwt4.o ssgwt5.o ssgwt6.o ssgwt7.o ssgwt8.o ssgx1.o ssgx10.o ssgx11.o ssgx2.o ssgx3.o ssgx4.o ssgx5.o ssgx6.o ssgx7.o ssgx8.o ssgx9.o ssgzg1.o ssgzg2.o ssgzg3.o ssgzt.o ssh.o ssh0.o sshcc.o sshff.o sshff1.o sshgl.o sshgm.o sshgm1.o sshhx.o sshibf.o sshnn.o sshsf.o sshww.o sshww1.o sshww2.o ssid.o ssl1st.o sslpbf.o sslrt1.o ssm1lp.o ssmass.o ssme3.o ssmhc.o ssmhn.o ssmqcd.o ssmssm.o ssn1st.o ssnorm.o sspole.o ssqkbf.o ssrsgb.o ssrsgl.o ssrsgt.o sssave.o sssnws.o ssssxx.o ssstbf.o sssvme.o sssxxx.o sstest.o sstpbf.o sswibf.o sswwf1.o sswz2p.o sswz3p.o sswzbf.o sswzf1.o sswzf2.o sswzf3.o sswzf4.o sswzf5.o sswzf6.o sswzf7.o ssxint.o ssxlam.o sszhx.o sszibf.o sszwf1.o sszzf1.o sszzf2.o sszzf3.o sszzf4.o sszzf5.o sszzg1.o sszzg2.o sszzg3.o sszzg4.o st1cneu.o st3int.o st3mat.o stbwz1.o stradd.o strotate.o strotback.o struc.o strucw.o sualfe.o sualfs.o sug2bsg.o sugeff.o sugefffl.o sugfrz.o sugmas.o sugra.o sugrge.o surg06.o surg26.o sxxxxx.o symmtest.o szjj1.o szjj2.o szjj3.o szjj4.o szjj5.o szjj6.o szjj7.o tactiv.o tcsfmul.o thetaxy.o timer.o tql2.o tqleig.o tr3x3.o trace.o trdiag.o tred2.o triint.o tsfmul.o twojet.o twokin.o uoutcoup.o upmhcond.o upmhcond2.o upmzmhigh.o upmzmhigh2.o upsqm.o usmma.o vec2mat.o vgen.o visaje.o vssxxx.o vvssxx.o vvsxxx.o vvvxxx.o vxxxxx.o w3w3xx.o wgens.o whiggs.o wilson.o wpair.o wwkin.o wwss.o wwst.o wwtt.o wwwwxx.o wzss.o wzst.o wzsu.o wztu.o xerbla.o xhchck.o xhfill.o xhinit.o xhordr.o xhplot.o xhrnge.o xhscle.o xkaim.o xkare.o xwwww.o xwwzz.o xzzww.o xzzzz.o ygenj.o yukdiag.o zaxpy.o zcopy.o zdotc.o zdotu.o zdscal.o zerol.o zgebak.o zgebal.o zgeev.o zgehd2.o zgehrd.o zgemm.o zgemv.o zgerc.o zhseqr.o zjj.o zjj0.o zjj1.o zjj2.o zjj3.o zjj4.o zjj5.o zjj6.o zjj7.o zlacgv.o zlacpy.o zladiv.o zlahqr.o zlahr2.o zlange.o zlaqr0.o zlaqr1.o zlaqr2.o zlaqr3.o zlaqr4.o zlaqr5.o zlarf.o zlarfb.o zlarfg.o zlarft.o zlartg.o zlascl.o zlaset.o zlassq.o zlatrs.o zrot.o zscal.o zswap.o ztrevc.o ztrexc.o ztrmm.o ztrmv.o ztrsv.o zung2r.o zunghr.o zungqr.o zunm2r.o zunmhr.o zunmqr.o zzall.o zzstar.o
 
 #OBJ2 = aldata.o
 
-vpath %.a $(LIB)
+vpath %.a $(DS_LIB)
 
 #all : libisajet.a aldata.o
-all : libisajet.a
+all : libisajet.a libisajet.so
 
 #aldata.o: aldata.f
-#	$(FF) $(FOPT) -c -o $(LIB)/aldata.o aldata.f
+#	$(FF) $(FOPT) -c -o $(DS_LIB)/aldata.o aldata.f
 
 libisajet.a: $(OBJ)
-	ar r $(LIB)/libisajet.a $(OBJ)
-	ranlib $(LIB)/libisajet.a
+	ar r $(DS_LIB)/libisajet.a $(OBJ)
+	ranlib $(DS_LIB)/libisajet.a
+
+libisajet.so: $(OBJ)
+	$(FF) $(FOPT) -shared -o $(DS_LIB)/libisajet.so $(OBJ)
 
 clean:
 	rm -f *.o
diff -rupN darksusy-5.1.3.pristine/contrib/isajet781-for-darksusy/ssid.f darksusy-5.1.3/contrib/isajet781-for-darksusy/ssid.f
--- darksusy-5.1.3.pristine/contrib/isajet781-for-darksusy/ssid.f	1970-01-01 01:00:00.000000000 +0100
+++ darksusy-5.1.3/contrib/isajet781-for-darksusy/ssid.f	2016-02-02 18:00:59.475882565 +0000
@@ -0,0 +1,80 @@
+      CHARACTER*5 FUNCTION SSID(ID)
+C-----------------------------------------------------------------------
+C
+C     Return character name for ID, assuming the default IDENT codes
+C     are used in /SSTYPE/.
+C
+C     Extracted by hand from ISAJET 1.8.5's isajet.car
+C     Pat Scott Feb 2 2016
+C
+C-----------------------------------------------------------------------
+      IMPLICIT NONE
+
+      COMMON/SSLUN/LOUT,LHEOUT
+      INTEGER LOUT,LHEOUT
+      SAVE /SSLUN/
+
+      CHARACTER*5 LABEL(-120:120)
+      SAVE LABEL
+      INTEGER ID,J
+C
+      DATA LABEL(0)/'     '/
+C
+      DATA (LABEL(J),J=1,10)
+     $/'UP   ','DN   ','ST   ','CH   ','BT   ','TP   '
+     $,'ERROR','ERROR','GL   ','GM   '/
+      DATA (LABEL(J),J=-1,-10,-1)
+     $/'UB   ','DB   ','SB   ','CB   ','BB   ','TB   '
+     $,'ERROR','ERROR','ERROR','ERROR'/
+C
+      DATA (LABEL(J),J=11,20)
+     $/'NUE  ','E-   ','NUM  ','MU-  ','NUT  ','TAU- '
+     $,'ERROR','ERROR','ERROR','ERROR'/
+      DATA (LABEL(J),J=-11,-20,-1)
+     $/'ANUE ','E+   ','ANUM ','MU+  ','ANUT ','TAU+ '
+     $,'ERROR','ERROR','ERROR','ERROR'/
+C
+      DATA (LABEL(J),J=21,30)
+     $/'UPL  ','DNL  ','STL  ','CHL  ','BT1  ','TP1  '
+     $,'ERROR','ERROR','GLSS ','Z1SS '/
+      DATA (LABEL(J),J=-21,-30,-1)
+     $/'UBL  ','DBL  ','SBL  ','CBL  ','BB1  ','TB1  '
+     $,'ERROR','ERROR','ERROR','ERROR'/
+C
+      DATA (LABEL(J),J=31,40)
+     $/'NUEL ','EL-  ','NUML ','MUL- ','NUTL ','TAU1-'
+     $,'ERROR','ERROR','W1SS+','Z2SS '/
+      DATA (LABEL(J),J=-31,-40,-1)
+     $/'ANUEL','EL+  ','ANUML','MUL+ ','ANUTL','TAU1+'
+     $,'ERROR','ERROR','W1SS-','ERROR'/
+C
+      DATA (LABEL(J),J=41,50)
+     $/'UPR  ','DNR  ','STR  ','CHR  ','BT2  ','TP2  '
+     $,'ERROR','ERROR','W2SS+','Z3SS '/
+      DATA (LABEL(J),J=-41,-50,-1)
+     $/'UBR  ','DBR  ','SBR  ','CBR  ','BB2  ','TB2  '
+     $,'ERROR','ERROR','W2SS-','ERROR'/
+C
+      DATA (LABEL(J),J=51,60)
+     $/'NUER ','ER-  ','NUMR ','MUR- ','NUTR ','TAU2-'
+     $,'ERROR','ERROR','ERROR','Z4SS '/
+      DATA (LABEL(J),J=-51,-60,-1)
+     $/'ANUEL','ER+  ','ANUMR','MUR+ ','ANUTR','TAU2+'
+     $,'ERROR','ERROR','ERROR','ERROR'/
+C
+      DATA (LABEL(J),J=82,86)
+     $/'HL0  ','HH0  ','HA0  ','ERROR','H+   '/
+      DATA LABEL(-86)/'H-   '/
+C
+      DATA LABEL(80)/'W+   '/,LABEL(-80)/'W-   '/,LABEL(90)/'Z0   '/
+      DATA LABEL(91)/'GVSS '/
+      DATA LABEL(110)/'PI0  '/
+      DATA LABEL(120)/'PI+  '/,LABEL(-120)/'PI-  '/
+C
+      IF(IABS(ID).GT.120) THEN
+        WRITE(LOUT,*) 'SSID: ID = ',ID
+        STOP99
+      ENDIF
+      SSID=LABEL(ID)
+      RETURN
+      END
diff -rupN darksusy-5.1.3.pristine/contrib/TSPACK/makefile.in darksusy-5.1.3/contrib/TSPACK/makefile.in
--- darksusy-5.1.3.pristine/contrib/TSPACK/makefile.in	2013-02-10 06:43:34.000000000 +0000
+++ darksusy-5.1.3/contrib/TSPACK/makefile.in	2016-02-02 12:05:04.402044521 +0000
@@ -9,8 +9,7 @@ FOPT=@FOPT@
 # Dependencies and libraries
 DINC=../../include
 LIB=../../lib
-
-INC_DEP = 
+BUILD=../../build/
 
 vpath %.h $(DINC)
 
@@ -19,12 +18,11 @@ tspack = ENDSLP.f SIGS.f SNHCSH.f STORE.
 
 all: tspack
 
-tspack : $(tspack) makefile
+tspack : 
 	cat $(tspack) > tspack.f
 	$(FF) $(FOPT) -c -I$(DINC) -o tspack.o tspack.f
+	mv tspack.o $(BUILD)/
 	rm tspack.f
-	ar rv $(LIB)/libdarksusy.a tspack.o
-	ranlib $(LIB)/libdarksusy.a
 
 clean:
 	rm -f tspack.f *.o
diff -rupN darksusy-5.1.3.pristine/include/dsdirver.h darksusy-5.1.3/include/dsdirver.h
--- darksusy-5.1.3.pristine/include/dsdirver.h	1970-01-01 01:00:00.000000000 +0100
+++ darksusy-5.1.3/include/dsdirver.h	2016-02-16 15:34:02.585088323 +0000
@@ -0,0 +1,21 @@
+*         -*- mode: fortran -*-
+*######################################################################*
+*                       i n c l u d e     f i l e                      *
+*######################################################################*
+
+************************************************************************
+***                           dsdirver.h                             ***
+***         this piece of code is needed as a separate file          ***
+***            the rest of the code 'includes' dsdirver.h            ***
+c----------------------------------------------------------------------c
+*** This file is created by config2.pl on Tue Feb 16 15:34:02 GMT 2016
+
+      character*14 dsver
+      parameter(dsver='darksusy-5.1.3')
+      character*25 dsinstall
+      parameter(dsinstall='/home/pat/darksusy-5.1.3/')
+      character*60 dsversion
+      common /dsv/dsversion
+      save /dsv/
+***                                                                  ***
+************************** end of dsdirver.h ***************************
diff -rupN darksusy-5.1.3.pristine/include/dswacom.h darksusy-5.1.3/include/dswacom.h
--- darksusy-5.1.3.pristine/include/dswacom.h	2015-12-20 21:43:06.000000000 +0000
+++ darksusy-5.1.3/include/dswacom.h	2016-02-05 14:57:05.686980691 +0000
@@ -18,30 +18,26 @@ c...to 52.
       integer wamax,walast(2),wanm
       parameter(wamax=6) ! number of tables to load simultaneously
       parameter(wanm=28) ! number of masses for tabulation
-      real*8 lb,ub,mi,thindex,zindex,dth,dz
-      real phiint,phidiff,phimixed
-      integer milow,thn,zn,yload
+      real*8 lb(14),ub(14),mi(wanm),thindex(-1:90,2),
+     &  zindex(-1:50,2),dth(-1:90),dz(-1:50)
+      real phiint(-1:90,0:50,wanm,13,2,wamax),
+     &  phidiff(-1:90,-1:50,wanm,13,2,wamax),
+     &  phimixed(-1:90,-1:50,wanm,13,2,wamax)
+      integer milow(14),thn,zn,yload(2,26)
       integer kind2ki(3)
       character*128 wadir
       character waftype
       character*40 wabase
-      common/wasim/lb(14),ub(14),mi(wanm),thindex(-1:90,2),
-     &  zindex(-1:50,2),dth(-1:90),dz(-1:50),
-     &  yload(2,26),walast,
-     &  milow(14),thn,zn,kind2ki,
+      common/wasim/lb,ub,mi,thindex,zindex,dth,dz,
+     &  yload,walast,
+     &  milow,thn,zn,kind2ki,
      &  wadir,waftype,wabase
-      common/wasim2/ phiint(-1:90,0:50,wanm,13,2,wamax),
-     &  phidiff(-1:90,-1:50,wanm,13,2,wamax),
-     &  phimixed(-1:90,-1:50,wanm,13,2,wamax)
+      common/wasim2/ phiint, phidiff, phimixed
 
 c...wagen - general stuff
       integer ch2chi(29),chi2chii(14),chii2chi(13),chi2ch(14)
       common /wagen/ch2chi,chi2chii,chii2chi,chi2ch
 
-c...wainfo - tag etc.
-      integer waerr,waistat
-      common/wainfo/waerr,waistat
-
 c...waopt - options
       real*8 wasbrmin
       common/waopt/wasbrmin
@@ -58,8 +54,7 @@ c...wabranch - annihilation branching ra
      &  wasv,wasigsip,wasigsdp,dswasetupcalled
 
 c save common block
-      save /wasim/,/wainfo/,/wasim2/,/wasim3/,/wagen/,
-     &  /wabranch/,/waopt/
+      save /wasim/,/wasim2/,/wasim3/,/wagen/,/wabranch/,/waopt/
 ***                                                                 ***
 ************************** end of muoncom.h ***************************
 
diff -rupN darksusy-5.1.3.pristine/include/FHCouplings.h darksusy-5.1.3/include/FHCouplings.h
--- darksusy-5.1.3.pristine/include/FHCouplings.h	1970-01-01 01:00:00.000000000 +0100
+++ darksusy-5.1.3/include/FHCouplings.h	2013-02-10 06:43:34.000000000 +0000
@@ -0,0 +1,149 @@
+#if 0
+	FHCouplings.h
+		human-readable indexing for the
+		couplings, gammas, and gammasms arrays
+		this file is part of FeynHiggs
+		last modified 11 May 12 th
+
+Note1: comments are real funny here because we want to include
+       this file in both Fortran and C
+
+Note2: for the same reason, the funny notation couplingS etc.
+       is used because we have to remap array indices in C and
+       Fortran does not care about caps.
+#endif
+
+
+#ifndef FHCOUPLINGS_H
+#define FHCOUPLINGS_H
+
+#define ncouplings 681
+#define Roffset 472
+#define Coupling(c)		couplingS(c)
+#define LCoupling(c)		couplingS(c)
+#define RCoupling(c)		couplingS(c+Roffset)
+
+#define ncouplingsms 231
+#define RSMoffset 108
+#define CouplingSM(c)		couplingsmS(c)
+#define LCouplingSM(c)		couplingsmS(c)
+#define RCouplingSM(c)		couplingsmS(c+RSMoffset)
+
+#define ngammas 978
+#define BRoffset 491
+#define GammaTot(h)		gammaS(h)
+#define Gamma(c)		gammaS(c+4)
+#define BR(c)			gammaS(c+BRoffset)
+
+#define ngammasms 250
+#define BRSMoffset 127
+#define GammaSMTot(h)		gammasmS(h)
+#define GammaSM(c)		gammasmS(c+4)
+#define BRSM(c)			gammasmS(c+BRSMoffset)
+
+
+#define H0VV(h,vv) h+3*vv-3
+#if 0
+  h  = 1..3	Higgs: h0, HH, A0
+  vv = 1..5	vector-boson pair: gamma gamma, gamma Z, ZZ, WW, gg
+#endif
+
+#define H0FF(h,t,g1,g2) h+3*t+12*g1+36*g2-36
+#if 0
+  h  = 1..3	Higgs: h0, HH, A0
+  t  = 1..4	fermion type: nu, e, u, d
+  g1 = 1..3	fermion 1 generation
+  g2 = 1..3	fermion 2 generation
+#endif
+
+#define HpFF(p,g1,g2) p+2*g1+6*g2+115
+#if 0
+  p  = 1..2	decay products: leptons, quarks
+  g1 = 1..3	up-type fermion 1 generation
+  g2 = 1..3	down-type fermion 2 generation
+#endif
+
+#define H0ChaCha(h,c1,c2) h+3*c1+6*c2+132
+#if 0
+  h  = 1..3	Higgs: h0, HH, A0
+  c1 = 1..2	chargino 1
+  c2 = 1..2	chargino 2
+#endif
+
+#define H0NeuNeu(h,n1,n2) h+3*n1+12*n2+138
+#if 0
+  h  = 1..3	Higgs: h0, HH, A0
+  n1 = 1..4	neutralino 1
+  n2 = 1..4	neutralino 2
+#endif
+
+#define HpNeuCha(n1,c2) n1+4*c2+197
+#if 0
+  n1 = 1..4	neutralino
+  c2 = 1..2	chargino
+#endif
+
+#define H0HV(h,hv) h+3*hv+206
+#if 0
+  h  = 1..3	decaying Higgs: h0, HH, A0
+  hv = 1..3	produced pair: h0-Z, HH-Z, A0-Z
+#endif
+
+#define HpHV(hv) hv+218
+#if 0
+  hv = 1..3	produced pair: h0-W, HH-W, A0-W
+#endif
+
+#define H0HH(h,h1,h2) h+3*h1+12*h2+206
+#if 0
+  h  = 1..3	decaying Higgs: h0, HH, A0
+  h1 = 1..4	produced Higgs 1: h0, HH, A0, Hp
+  h2 = 1..4	produced Higgs 2: h0, HH, A0, Hp
+#endif
+
+#define H0SfSf(h,s1,s2,t,g) h+3*s1+6*s2+12*t+48*g+200
+#if 0
+  h  = 1..3	Higgs: h0, HH, A0
+  s1 = 1..2	sfermion 1
+  s2 = 1..2	sfermion 2
+  t  = 1..4	sfermion type: nu, e, u, d
+  g = 1..3	common sfermion generation
+#endif
+
+#define HpSfSf(s1,s2,p,g1,g2) s1+2*s2+4*p+8*g1+24*g2+375
+#if 0
+  s1 = 1..2	sfermion 1
+  s2 = 1..2	sfermion 2
+  p  = 1..2	decay products: sleptons, squarks
+  g1 = 1..3	up-type sfermion 1 generation
+  g2 = 1..3	down-type sfermion 2 generation
+#endif
+
+#define tBF(bf) bf+485
+#if 0
+  bf = 1..2	W-b, H-b
+#endif
+
+
+#define nprodxs 49
+
+#define bbh(h)		prodXS(h)
+#define bbhSM(h)	prodXS(h+3)
+#define btagbh(h)	prodXS(h+6)
+#define btagbhSM(h)	prodXS(h+9)
+#define ggh(h)		prodXS(h+12)
+#define ggh2(h)		prodXS(h+15)
+#define gghSM(h)	prodXS(h+18)
+#define qqh(h)		prodXS(h+21)
+#define qqhSM(h)	prodXS(h+24)
+#define tth(h)		prodXS(h+27)
+#define tthSM(h)	prodXS(h+30)
+#define Wh(h)		prodXS(h+33)
+#define WhSM(h)		prodXS(h+36)
+#define Zh(h)		prodXS(h+39)
+#define ZhSM(h)		prodXS(h+42)
+#define StSth(h)	prodXS(h+45)
+#define tHm		prodXS(49)
+
+#endif
+
diff -rupN darksusy-5.1.3.pristine/include/PDG.h darksusy-5.1.3/include/PDG.h
--- darksusy-5.1.3.pristine/include/PDG.h	1970-01-01 01:00:00.000000000 +0100
+++ darksusy-5.1.3/include/PDG.h	2013-02-10 06:43:34.000000000 +0000
@@ -0,0 +1,79 @@
+#if 0
+	PDG.h
+		declaration of Particle Data Group codes
+		last modified 22 Jun 06 th
+#endif
+
+
+#ifndef PDG_H
+#define PDG_H
+
+#define PDGLen 16
+#define PDGDigits 10
+
+#define PDG_down	1
+#define PDG_up		2
+#define PDG_strange	3
+#define PDG_charm	4
+#define PDG_bottom	5
+#define PDG_top		6
+
+#define PDG_electron	11
+#define PDG_nu_e	12
+#define PDG_muon	13
+#define PDG_nu_mu	14
+#define PDG_tau		15
+#define PDG_nu_tau	16
+
+#define PDG_gluon	21
+#define PDG_photon	22
+#define PDG_Z		23
+#define PDG_W		24
+#define PDG_h0		25
+#define PDG_HH		35
+#define PDG_A0		36
+#define PDG_Hp		37
+#define PDG_graviton	39
+#define PDG_H3		45
+#define PDG_A2		46
+
+#define PDG_sdown1	1000001
+#define PDG_sup1	1000002
+#define PDG_sstrange1	1000003
+#define PDG_scharm1	1000004
+#define PDG_sbottom1	1000005
+#define PDG_stop1	1000006
+
+#define PDG_selectron1	1000011
+#define PDG_snu_e1	1000012
+#define PDG_smuon1	1000013
+#define PDG_snu_mu1	1000014
+#define PDG_stau1	1000015
+#define PDG_snu_tau1	1000016
+
+#define PDG_sdown2	2000001
+#define PDG_sup2	2000002
+#define PDG_sstrange2	2000003
+#define PDG_scharm2	2000004
+#define PDG_sbottom2	2000005
+#define PDG_stop2	2000006
+
+#define PDG_selectron2	2000011
+#define PDG_snu_e2	2000012
+#define PDG_smuon2	2000013
+#define PDG_snu_mu2	2000014
+#define PDG_stau2	2000015
+#define PDG_snu_tau2	2000016
+
+#define PDG_gluino	1000021
+#define PDG_neutralino1	1000022
+#define PDG_neutralino2	1000023
+#define PDG_neutralino3	1000025
+#define PDG_neutralino4	1000035
+#define PDG_neutralino5 1000045
+#define PDG_chargino1	1000024
+#define PDG_chargino2	1000037
+#define PDG_gravitino	1000039
+
+#endif
+
diff -rupN darksusy-5.1.3.pristine/include/SLHADefs.h darksusy-5.1.3/include/SLHADefs.h
--- darksusy-5.1.3.pristine/include/SLHADefs.h	1970-01-01 01:00:00.000000000 +0100
+++ darksusy-5.1.3/include/SLHADefs.h	2013-02-10 06:43:34.000000000 +0000
@@ -0,0 +1,742 @@
+#if 0
+	SLHADefs.h
+		declarations for SLHALib data
+		generated 1 Jun 2012 9:36
+#endif
+
+#ifndef SLHADEFS_H
+#define SLHADEFS_H
+
+#define invalid (-999)
+
+#define OffsetModSel 0
+#define LengthModSel 6
+#define BlockModSel(i) SlhaData(i)
+#define ModSel_Model Slhadata(1)
+#define ModSel_GridPts Slhadata(2)
+#define ModSel_Content Slhadata(3)
+#define ModSel_RPV Slhadata(4)
+#define ModSel_CPV Slhadata(5)
+#define ModSel_FV Slhadata(6)
+
+#define OffsetSMInputs 6
+#define LengthSMInputs 16
+#define BlockSMInputs(i) SlhaData(6+i)
+#define SMInputs_invAlfaMZ Slhadata(7)
+#define SMInputs_GF Slhadata(8)
+#define SMInputs_AlfasMZ Slhadata(9)
+#define SMInputs_MZ Slhadata(10)
+#define SMInputs_Mf(t,g) Slhadata(6+t+4*(g))
+#define SMInputs_MfFlat(i) Slhadata(10+i)
+#define   SMInputs_Mnu1 SMInputs_Mf(1,1)
+#define   SMInputs_Me SMInputs_Mf(2,1)
+#define   SMInputs_Mu SMInputs_Mf(3,1)
+#define   SMInputs_Md SMInputs_Mf(4,1)
+#define   SMInputs_Mnu2 SMInputs_Mf(1,2)
+#define   SMInputs_Mmu SMInputs_Mf(2,2)
+#define   SMInputs_Mc SMInputs_Mf(3,2)
+#define   SMInputs_Ms SMInputs_Mf(4,2)
+#define   SMInputs_Mnu3 SMInputs_Mf(1,3)
+#define   SMInputs_Mtau SMInputs_Mf(2,3)
+#define   SMInputs_Mt SMInputs_Mf(3,3)
+#define   SMInputs_Mb SMInputs_Mf(4,3)
+
+#define OffsetMinPar 22
+#define LengthMinPar 6
+#define BlockMinPar(i) SlhaData(22+i)
+#define MinPar_M0 Slhadata(23)
+#define   MinPar_Lambda MinPar_M0
+#define MinPar_M12 Slhadata(24)
+#define   MinPar_Mmess MinPar_M12
+#define   MinPar_M32 MinPar_M12
+#define MinPar_TB Slhadata(25)
+#define MinPar_signMUE Slhadata(26)
+#define MinPar_A Slhadata(27)
+#define   MinPar_N5 MinPar_A
+#define MinPar_cgrav Slhadata(28)
+
+#define OffsetExtPar 28
+#define LengthExtPar 42
+#define BlockExtPar(i) SlhaData(28+i)
+#define ExtPar_Q SlhaData(29)
+#define ExtPar_M1 Slhadata(30)
+#define ExtPar_M2 Slhadata(31)
+#define ExtPar_M3 Slhadata(32)
+#define ExtPar_Af(t) Slhadata(31+t)
+#define   ExtPar_Atau ExtPar_Af(2)
+#define   ExtPar_At ExtPar_Af(3)
+#define   ExtPar_Ab ExtPar_Af(4)
+#define ExtPar_MHu2 Slhadata(36)
+#define ExtPar_MHd2 Slhadata(37)
+#define ExtPar_MUE Slhadata(38)
+#define ExtPar_MA02 Slhadata(39)
+#define ExtPar_TB Slhadata(40)
+#define ExtPar_MA0 Slhadata(41)
+#define ExtPar_MHp Slhadata(42)
+#define ExtPar_MSS(g,q) Slhadata(39+g+3*(q))
+#define   ExtPar_MSL(g) ExtPar_MSS(g,1)
+#define   ExtPar_MSE(g) ExtPar_MSS(g,2)
+#define   ExtPar_MSQ(g) ExtPar_MSS(g,3)
+#define   ExtPar_MSU(g) ExtPar_MSS(g,4)
+#define   ExtPar_MSD(g) ExtPar_MSS(g,5)
+#define ExtPar_N5(g) Slhadata(57+g)
+#define ExtPar_lambda Slhadata(61)
+#define ExtPar_kappa Slhadata(62)
+#define ExtPar_Alambda Slhadata(63)
+#define ExtPar_Akappa Slhadata(64)
+#define ExtPar_lambdaS Slhadata(65)
+#define ExtPar_xiF Slhadata(66)
+#define ExtPar_xiS Slhadata(67)
+#define ExtPar_MUEprime Slhadata(68)
+#define ExtPar_mS2prime Slhadata(69)
+#define ExtPar_mS2 Slhadata(70)
+
+#define OffsetQExtPar 70
+#define LengthQExtPar 16
+#define BlockQExtPar(i) SlhaData(70+i)
+#define QExtPar_QM1 SlhaData(71)
+#define QExtPar_QM2 SlhaData(72)
+#define QExtPar_QM3 SlhaData(73)
+#define QExtPar_QAf(t) SlhaData(72+t)
+#define   QExtPar_QAtau QExtPar_QAf(2)
+#define   QExtPar_QAt QExtPar_QAf(3)
+#define   QExtPar_QAb QExtPar_QAf(4)
+#define QExtPar_QMHu2 SlhaData(77)
+#define QExtPar_QMHd2 SlhaData(78)
+#define QExtPar_QMUE SlhaData(79)
+#define QExtPar_QMA02 SlhaData(80)
+#define QExtPar_QTB SlhaData(81)
+#define QExtPar_QMSS(q) SlhaData(81+q)
+#define   QExtPar_QMSL QExtPar_QMSS(1)
+#define   QExtPar_QMSE QExtPar_QMSS(2)
+#define   QExtPar_QMSQ QExtPar_QMSS(3)
+#define   QExtPar_QMSU QExtPar_QMSS(4)
+#define   QExtPar_QMSD QExtPar_QMSS(5)
+
+#define OffsetNMSSMRun 86
+#define LengthNMSSMRun 11
+#define BlockNMSSMRun(i) SlhaData(86+i)
+#define NMSSMRun_Q SlhaData(87)
+#define NMSSMRun_lambda Slhadata(88)
+#define NMSSMRun_kappa Slhadata(89)
+#define NMSSMRun_Alambda Slhadata(90)
+#define NMSSMRun_Akappa Slhadata(91)
+#define NMSSMRun_lambdaS Slhadata(92)
+#define NMSSMRun_xiF Slhadata(93)
+#define NMSSMRun_xiS Slhadata(94)
+#define NMSSMRun_MUEprime Slhadata(95)
+#define NMSSMRun_mS2prime Slhadata(96)
+#define NMSSMRun_mS2 Slhadata(97)
+
+#define OffsetMass 97
+#define LengthMass 53
+#define BlockMass(i) SlhaData(97+i)
+#define Mass_Mf(t,g) Slhadata(93+t+4*(g))
+#define Mass_MfFlat(i) Slhadata(97+i)
+#define Mass_MSf(s,t,g) Slhadata(99+s+8*(g)+2*(t))
+#define Mass_MSfFlat(i) Slhadata(109+i)
+#define Mass_MZ Slhadata(134)
+#define Mass_MW Slhadata(135)
+#define Mass_Mh0 Slhadata(136)
+#define Mass_MHH Slhadata(137)
+#define Mass_MA0 Slhadata(138)
+#define Mass_MHp Slhadata(139)
+#define   Mass_MH1 Mass_Mh0
+#define   Mass_MH2 Mass_MHH
+#define Mass_MH3 Slhadata(140)
+#define   Mass_MA1 Mass_MA0
+#define Mass_MA2 Slhadata(141)
+#define Mass_MNeu(n) Slhadata(141+n)
+#define Mass_MCha(c) Slhadata(146+c)
+#define Mass_MGl Slhadata(149)
+#define Mass_MGrav Slhadata(150)
+
+#define OffsetDMass 150
+#define LengthDMass 5
+#define BlockDMass(i) SlhaData(150+i)
+#define DMass_Q SlhaData(151)
+#define DMass_DeltaMh0 Slhadata(152)
+#define DMass_DeltaMHH Slhadata(153)
+#define DMass_DeltaMA0 Slhadata(154)
+#define DMass_DeltaMHp Slhadata(155)
+
+#define OffsetNMix 155
+#define LengthNMix 16
+#define BlockNMix(i) SlhaData(155+i)
+#define NMix_ZNeu(n1,n2) Slhadata(151+n1+4*(n2))
+#define NMix_ZNeuFlat(i) Slhadata(155+i)
+
+#define OffsetUMix 171
+#define LengthUMix 4
+#define BlockUMix(i) SlhaData(171+i)
+#define UMix_UCha(c1,c2) Slhadata(169+c1+2*(c2))
+#define UMix_UChaFlat(i) Slhadata(171+i)
+
+#define OffsetVMix 175
+#define LengthVMix 4
+#define BlockVMix(i) SlhaData(175+i)
+#define VMix_VCha(c1,c2) Slhadata(173+c1+2*(c2))
+#define VMix_VChaFlat(i) Slhadata(175+i)
+
+#define OffsetSfMix 179
+#define LengthSfMix 12
+#define BlockSfMix(i) SlhaData(179+i)
+#define SfMix_USf(s1,s2,t) Slhadata(169+s1+2*(s2)+4*(t))
+#define SfMix_USfFlat(i,t) Slhadata(171+i+4*(t))
+
+#define OffsetStauMix 179
+#define LengthStauMix 4
+#define BlockStauMix(i) SlhaData(179+i)
+#define   StauMix_USf(s1,s2) SfMix_USf(s1,s2,2)
+#define   StauMix_USfFlat(i) SfMix_USfFlat(i,2)
+
+#define OffsetStopMix 183
+#define LengthStopMix 4
+#define BlockStopMix(i) SlhaData(183+i)
+#define   StopMix_USf(s1,s2) SfMix_USf(s1,s2,3)
+#define   StopMix_USfFlat(i) SfMix_USfFlat(i,3)
+
+#define OffsetSbotMix 187
+#define LengthSbotMix 4
+#define BlockSbotMix(i) SlhaData(187+i)
+#define   SbotMix_USf(s1,s2) SfMix_USf(s1,s2,4)
+#define   SbotMix_USfFlat(i) SfMix_USfFlat(i,4)
+
+#define OffsetAlpha 191
+#define LengthAlpha 1
+#define BlockAlpha(i) SlhaData(191+i)
+#define Alpha_Alpha Slhadata(192)
+
+#define OffsetDAlpha 192
+#define LengthDAlpha 1
+#define BlockDAlpha(i) SlhaData(192+i)
+#define DAlpha_DeltaAlpha Slhadata(193)
+
+#define OffsetHMix 193
+#define LengthHMix 5
+#define BlockHMix(i) SlhaData(193+i)
+#define HMix_Q SlhaData(194)
+#define HMix_MUE Slhadata(195)
+#define HMix_TB Slhadata(196)
+#define HMix_VEV Slhadata(197)
+#define HMix_MA02 Slhadata(198)
+
+#define OffsetGauge 198
+#define LengthGauge 4
+#define BlockGauge(i) SlhaData(198+i)
+#define Gauge_Q SlhaData(199)
+#define Gauge_g1 Slhadata(200)
+#define Gauge_g2 Slhadata(201)
+#define Gauge_g3 Slhadata(202)
+
+#define OffsetMSoft 202
+#define LengthMSoft 21
+#define BlockMSoft(i) SlhaData(202+i)
+#define MSoft_Q SlhaData(203)
+#define MSoft_M1 Slhadata(204)
+#define MSoft_M2 Slhadata(205)
+#define MSoft_M3 Slhadata(206)
+#define MSoft_MHu2 Slhadata(207)
+#define MSoft_MHd2 Slhadata(208)
+#define MSoft_MSS(g,q) Slhadata(205+g+3*(q))
+#define   MSoft_MSL(g) MSoft_MSS(g,1)
+#define   MSoft_MSE(g) MSoft_MSS(g,2)
+#define   MSoft_MSQ(g) MSoft_MSS(g,3)
+#define   MSoft_MSU(g) MSoft_MSS(g,4)
+#define   MSoft_MSD(g) MSoft_MSS(g,5)
+
+#define OffsetAf 223
+#define LengthAf 30
+#define BlockAf(i) SlhaData(223+i)
+#define Af_Q(t) SlhaData(204+10*(t))
+#define Af_Af(g1,g2,t) Slhadata(201+g1+3*(g2)+10*(t))
+#define Af_AfFlat(i,t) Slhadata(204+i+10*(t))
+
+#define OffsetAe 223
+#define LengthAe 11
+#define BlockAe(i) SlhaData(223+i)
+#define   Ae_Q Af_Q(2)
+#define   Ae_Af(g1,g2) Af_Af(g1,g2,2)
+#define   Ae_AfFlat(i) Af_AfFlat(i,2)
+#define   Ae_Atau Ae_Af(3,3)
+
+#define OffsetAu 234
+#define LengthAu 11
+#define BlockAu(i) SlhaData(234+i)
+#define   Au_Q Af_Q(3)
+#define   Au_Af(g1,g2) Af_Af(g1,g2,3)
+#define   Au_AfFlat(i) Af_AfFlat(i,3)
+#define   Au_At Au_Af(3,3)
+
+#define OffsetAd 245
+#define LengthAd 11
+#define BlockAd(i) SlhaData(245+i)
+#define   Ad_Q Af_Q(4)
+#define   Ad_Af(g1,g2) Af_Af(g1,g2,4)
+#define   Ad_AfFlat(i) Af_AfFlat(i,4)
+#define   Ad_Ab Ad_Af(3,3)
+
+#define OffsetYf 256
+#define LengthYf 30
+#define BlockYf(i) SlhaData(256+i)
+#define Yf_Q(t) SlhaData(237+10*(t))
+#define Yf_Yf(g1,g2,t) Slhadata(234+g1+3*(g2)+10*(t))
+#define Yf_YfFlat(i,t) Slhadata(237+i+10*(t))
+
+#define OffsetYe 256
+#define LengthYe 11
+#define BlockYe(i) SlhaData(256+i)
+#define   Ye_Q Yf_Q(2)
+#define   Ye_Yf(g1,g2) Yf_Yf(g1,g2,2)
+#define   Ye_YfFlat(i) Yf_YfFlat(i,2)
+#define   Ye_Ytau Ye_Yf(3,3)
+
+#define OffsetYu 267
+#define LengthYu 11
+#define BlockYu(i) SlhaData(267+i)
+#define   Yu_Q Yf_Q(3)
+#define   Yu_Yf(g1,g2) Yf_Yf(g1,g2,3)
+#define   Yu_YfFlat(i) Yf_YfFlat(i,3)
+#define   Yu_Yt Yu_Yf(3,3)
+
+#define OffsetYd 278
+#define LengthYd 11
+#define BlockYd(i) SlhaData(278+i)
+#define   Yd_Q Yf_Q(4)
+#define   Yd_Yf(g1,g2) Yf_Yf(g1,g2,4)
+#define   Yd_YfFlat(i) Yf_YfFlat(i,4)
+#define   Yd_Yb Yd_Yf(3,3)
+
+#define OffsetRVLamLLEIn 289
+#define LengthRVLamLLEIn 27
+#define BlockRVLamLLEIn(i) SlhaData(289+i)
+#define RVLamLLEIn_lamLLE(i,j,k) Slhadata(277+i+3*(j)+9*(k))
+#define RVLamLLEIn_lamLLEFlat(i) Slhadata(289+i)
+
+#define OffsetRVLamLQDIn 316
+#define LengthRVLamLQDIn 27
+#define BlockRVLamLQDIn(i) SlhaData(316+i)
+#define RVLamLQDIn_lamLQD(i,j,k) Slhadata(304+i+3*(j)+9*(k))
+#define RVLamLQDIn_lamLQDFlat(i) Slhadata(316+i)
+
+#define OffsetRVLamUDDIn 343
+#define LengthRVLamUDDIn 27
+#define BlockRVLamUDDIn(i) SlhaData(343+i)
+#define RVLamUDDIn_lamUDD(i,j,k) Slhadata(331+i+3*(j)+9*(k))
+#define RVLamUDDIn_lamUDDFlat(i) Slhadata(343+i)
+
+#define OffsetRVLamLLE 370
+#define LengthRVLamLLE 28
+#define BlockRVLamLLE(i) SlhaData(370+i)
+#define RVLamLLE_Q SlhaData(371)
+#define RVLamLLE_lamLLE(i,j,k) Slhadata(359+i+3*(j)+9*(k))
+#define RVLamLLE_lamLLEFlat(i) Slhadata(371+i)
+
+#define OffsetRVLamLQD 398
+#define LengthRVLamLQD 28
+#define BlockRVLamLQD(i) SlhaData(398+i)
+#define RVLamLQD_Q SlhaData(399)
+#define RVLamLQD_lamLQD(i,j,k) Slhadata(387+i+3*(j)+9*(k))
+#define RVLamLQD_lamLQDFlat(i) Slhadata(399+i)
+
+#define OffsetRVLamUDD 426
+#define LengthRVLamUDD 28
+#define BlockRVLamUDD(i) SlhaData(426+i)
+#define RVLamUDD_Q SlhaData(427)
+#define RVLamUDD_lamUDD(i,j,k) Slhadata(415+i+3*(j)+9*(k))
+#define RVLamUDD_lamUDDFlat(i) Slhadata(427+i)
+
+#define OffsetRVTLLEIn 454
+#define LengthRVTLLEIn 27
+#define BlockRVTLLEIn(i) SlhaData(454+i)
+#define RVTLLEIn_TLLE(i,j,k) Slhadata(442+i+3*(j)+9*(k))
+#define RVTLLEIn_TLLEFlat(i) Slhadata(454+i)
+
+#define OffsetRVTLQDIn 481
+#define LengthRVTLQDIn 27
+#define BlockRVTLQDIn(i) SlhaData(481+i)
+#define RVTLQDIn_TLQD(i,j,k) Slhadata(469+i+3*(j)+9*(k))
+#define RVTLQDIn_TLQDFlat(i) Slhadata(481+i)
+
+#define OffsetRVTUDDIn 508
+#define LengthRVTUDDIn 27
+#define BlockRVTUDDIn(i) SlhaData(508+i)
+#define RVTUDDIn_TUDD(i,j,k) Slhadata(496+i+3*(j)+9*(k))
+#define RVTUDDIn_TUDDFlat(i) Slhadata(508+i)
+
+#define OffsetRVTLLE 535
+#define LengthRVTLLE 28
+#define BlockRVTLLE(i) SlhaData(535+i)
+#define RVTLLE_Q SlhaData(536)
+#define RVTLLE_TLLE(i,j,k) Slhadata(524+i+3*(j)+9*(k))
+#define RVTLLE_TLLEFlat(i) Slhadata(536+i)
+
+#define OffsetRVTLQD 563
+#define LengthRVTLQD 28
+#define BlockRVTLQD(i) SlhaData(563+i)
+#define RVTLQD_Q SlhaData(564)
+#define RVTLQD_TLQD(i,j,k) Slhadata(552+i+3*(j)+9*(k))
+#define RVTLQD_TLQDFlat(i) Slhadata(564+i)
+
+#define OffsetRVTUDD 591
+#define LengthRVTUDD 28
+#define BlockRVTUDD(i) SlhaData(591+i)
+#define RVTUDD_Q SlhaData(592)
+#define RVTUDD_TUDD(i,j,k) Slhadata(580+i+3*(j)+9*(k))
+#define RVTUDD_TUDDFlat(i) Slhadata(592+i)
+
+#define OffsetRVKappaIn 619
+#define LengthRVKappaIn 3
+#define BlockRVKappaIn(i) SlhaData(619+i)
+#define RVKappaIn_kappa(i) Slhadata(619+i)
+
+#define OffsetRVKappa 622
+#define LengthRVKappa 4
+#define BlockRVKappa(i) SlhaData(622+i)
+#define RVKappa_Q SlhaData(623)
+#define RVKappa_kappa(i) Slhadata(623+i)
+
+#define OffsetRVDIn 626
+#define LengthRVDIn 3
+#define BlockRVDIn(i) SlhaData(626+i)
+#define RVDIn_D(i) Slhadata(626+i)
+
+#define OffsetRVD 629
+#define LengthRVD 4
+#define BlockRVD(i) SlhaData(629+i)
+#define RVD_Q SlhaData(630)
+#define RVD_D(i) Slhadata(630+i)
+
+#define OffsetRVSnVEVIn 633
+#define LengthRVSnVEVIn 3
+#define BlockRVSnVEVIn(i) SlhaData(633+i)
+#define RVSnVEVIn_VEV(i) Slhadata(633+i)
+
+#define OffsetRVSnVEV 636
+#define LengthRVSnVEV 4
+#define BlockRVSnVEV(i) SlhaData(636+i)
+#define RVSnVEV_Q SlhaData(637)
+#define RVSnVEV_VEV(i) Slhadata(637+i)
+
+#define OffsetRVM2LH1In 640
+#define LengthRVM2LH1In 3
+#define BlockRVM2LH1In(i) SlhaData(640+i)
+#define RVM2LH1In_M2LH1(i) Slhadata(640+i)
+
+#define OffsetRVM2LH1 643
+#define LengthRVM2LH1 4
+#define BlockRVM2LH1(i) SlhaData(643+i)
+#define RVM2LH1_Q SlhaData(644)
+#define RVM2LH1_M2LH1(i) Slhadata(644+i)
+
+#define OffsetRVNMix 647
+#define LengthRVNMix 49
+#define BlockRVNMix(i) SlhaData(647+i)
+#define RVNMix_ZNeu(n1,n2) Slhadata(640+n1+7*(n2))
+#define RVNMix_ZNeuFlat(i) Slhadata(647+i)
+
+#define OffsetRVUMix 696
+#define LengthRVUMix 25
+#define BlockRVUMix(i) SlhaData(696+i)
+#define RVUMix_UCha(c1,c2) Slhadata(691+c1+5*(c2))
+#define RVUMix_UChaFlat(i) Slhadata(696+i)
+
+#define OffsetRVVMix 721
+#define LengthRVVMix 25
+#define BlockRVVMix(i) SlhaData(721+i)
+#define RVVMix_VCha(c1,c2) Slhadata(716+c1+5*(c2))
+#define RVVMix_VChaFlat(i) Slhadata(721+i)
+
+#define OffsetRVHMix 746
+#define LengthRVHMix 25
+#define BlockRVHMix(i) SlhaData(746+i)
+#define RVHMix_UH(h1,h2) Slhadata(741+h1+5*(h2))
+#define RVHMix_UHFlat(i) Slhadata(746+i)
+
+#define OffsetRVAMix 771
+#define LengthRVAMix 25
+#define BlockRVAMix(i) SlhaData(771+i)
+#define RVAMix_UA(h1,h2) Slhadata(766+h1+5*(h2))
+#define RVAMix_UAFlat(i) Slhadata(771+i)
+
+#define OffsetRVLMix 796
+#define LengthRVLMix 64
+#define BlockRVLMix(i) SlhaData(796+i)
+#define RVLMix_CLep(l1,l2) Slhadata(788+l1+8*(l2))
+#define RVLMix_CLepFlat(i) Slhadata(796+i)
+
+#define OffsetVCKMIn 860
+#define LengthVCKMIn 4
+#define BlockVCKMIn(i) SlhaData(860+i)
+#define VCKMIn_lambda Slhadata(861)
+#define VCKMIn_A Slhadata(862)
+#define VCKMIn_rhobar Slhadata(863)
+#define VCKMIn_etabar Slhadata(864)
+
+#define OffsetVCKM 864
+#define LengthVCKM 10
+#define BlockVCKM(i) SlhaData(864+i)
+#define VCKM_Q SlhaData(865)
+#define VCKM_VCKM(g1,g2) Slhadata(862+g1+3*(g2))
+#define VCKM_VCKMFlat(i) Slhadata(865+i)
+
+#define OffsetUPMNSIn 874
+#define LengthUPMNSIn 6
+#define BlockUPMNSIn(i) SlhaData(874+i)
+#define UPMNSIn_theta12 Slhadata(875)
+#define UPMNSIn_theta23 Slhadata(876)
+#define UPMNSIn_theta13 Slhadata(877)
+#define UPMNSIn_delta13 Slhadata(878)
+#define UPMNSIn_alpha1 Slhadata(879)
+#define UPMNSIn_alpha2 Slhadata(880)
+
+#define OffsetUPMNS 880
+#define LengthUPMNS 10
+#define BlockUPMNS(i) SlhaData(880+i)
+#define UPMNS_Q SlhaData(881)
+#define UPMNS_UPMNS(g1,g2) Slhadata(878+g1+3*(g2))
+#define UPMNS_UPMNSFlat(i) Slhadata(881+i)
+
+#define OffsetMSS2In 890
+#define LengthMSS2In 45
+#define BlockMSS2In(i) SlhaData(890+i)
+#define MSS2In_MSS2(g1,g2,q) Slhadata(878+g1+3*(g2)+9*(q))
+#define MSS2In_MSS2Flat(i,q) Slhadata(881+i+9*(q))
+
+#define OffsetMSL2In 890
+#define LengthMSL2In 9
+#define BlockMSL2In(i) SlhaData(890+i)
+#define   MSL2In_MSL2(g1,g2) MSS2In_MSS2(g1,g2,1)
+#define   MSL2In_MSL2Flat(i) MSS2In_MSS2Flat(i,1)
+
+#define OffsetMSE2In 899
+#define LengthMSE2In 9
+#define BlockMSE2In(i) SlhaData(899+i)
+#define   MSE2In_MSE2(g1,g2) MSS2In_MSS2(g1,g2,2)
+#define   MSE2In_MSE2Flat(i) MSS2In_MSS2Flat(i,2)
+
+#define OffsetMSQ2In 908
+#define LengthMSQ2In 9
+#define BlockMSQ2In(i) SlhaData(908+i)
+#define   MSQ2In_MSQ2(g1,g2) MSS2In_MSS2(g1,g2,3)
+#define   MSQ2In_MSQ2Flat(i) MSS2In_MSS2Flat(i,3)
+
+#define OffsetMSU2In 917
+#define LengthMSU2In 9
+#define BlockMSU2In(i) SlhaData(917+i)
+#define   MSU2In_MSU2(g1,g2) MSS2In_MSS2(g1,g2,4)
+#define   MSU2In_MSU2Flat(i) MSS2In_MSS2Flat(i,4)
+
+#define OffsetMSD2In 926
+#define LengthMSD2In 9
+#define BlockMSD2In(i) SlhaData(926+i)
+#define   MSD2In_MSD2(g1,g2) MSS2In_MSS2(g1,g2,5)
+#define   MSD2In_MSD2Flat(i) MSS2In_MSS2Flat(i,5)
+
+#define OffsetMSS2 935
+#define LengthMSS2 50
+#define BlockMSS2(i) SlhaData(935+i)
+#define MSS2_Q(q) SlhaData(926+10*(q))
+#define MSS2_MSS2(g1,g2,q) Slhadata(923+g1+3*(g2)+10*(q))
+#define MSS2_MSS2Flat(i,q) Slhadata(926+i+10*(q))
+
+#define OffsetMSL2 935
+#define LengthMSL2 10
+#define BlockMSL2(i) SlhaData(935+i)
+#define   MSL2_Q MSS2_Q(1)
+#define   MSL2_MSL2(g1,g2) MSS2_MSS2(g1,g2,1)
+#define   MSL2_MSL2Flat(i) MSS2_MSS2Flat(i,1)
+
+#define OffsetMSE2 945
+#define LengthMSE2 10
+#define BlockMSE2(i) SlhaData(945+i)
+#define   MSE2_Q MSS2_Q(2)
+#define   MSE2_MSE2(g1,g2) MSS2_MSS2(g1,g2,2)
+#define   MSE2_MSE2Flat(i) MSS2_MSS2Flat(i,2)
+
+#define OffsetMSQ2 955
+#define LengthMSQ2 10
+#define BlockMSQ2(i) SlhaData(955+i)
+#define   MSQ2_Q MSS2_Q(3)
+#define   MSQ2_MSQ2(g1,g2) MSS2_MSS2(g1,g2,3)
+#define   MSQ2_MSQ2Flat(i) MSS2_MSS2Flat(i,3)
+
+#define OffsetMSU2 965
+#define LengthMSU2 10
+#define BlockMSU2(i) SlhaData(965+i)
+#define   MSU2_Q MSS2_Q(4)
+#define   MSU2_MSU2(g1,g2) MSS2_MSS2(g1,g2,4)
+#define   MSU2_MSU2Flat(i) MSS2_MSS2Flat(i,4)
+
+#define OffsetMSD2 975
+#define LengthMSD2 10
+#define BlockMSD2(i) SlhaData(975+i)
+#define   MSD2_Q MSS2_Q(5)
+#define   MSD2_MSD2(g1,g2) MSS2_MSS2(g1,g2,5)
+#define   MSD2_MSD2Flat(i) MSS2_MSS2Flat(i,5)
+
+#define OffsetTfIn 985
+#define LengthTfIn 27
+#define BlockTfIn(i) SlhaData(985+i)
+#define TfIn_Tf(g1,g2,t) Slhadata(964+g1+3*(g2)+9*(t))
+#define TfIn_TfFlat(i,t) Slhadata(967+i+9*(t))
+
+#define OffsetTeIn 985
+#define LengthTeIn 9
+#define BlockTeIn(i) SlhaData(985+i)
+#define   TeIn_Tf(g1,g2) TfIn_Tf(g1,g2,2)
+#define   TeIn_TfFlat(i) TfIn_TfFlat(i,2)
+
+#define OffsetTuIn 994
+#define LengthTuIn 9
+#define BlockTuIn(i) SlhaData(994+i)
+#define   TuIn_Tf(g1,g2) TfIn_Tf(g1,g2,3)
+#define   TuIn_TfFlat(i) TfIn_TfFlat(i,3)
+
+#define OffsetTdIn 1003
+#define LengthTdIn 9
+#define BlockTdIn(i) SlhaData(1003+i)
+#define   TdIn_Tf(g1,g2) TfIn_Tf(g1,g2,4)
+#define   TdIn_TfFlat(i) TfIn_TfFlat(i,4)
+
+#define OffsetTf 1012
+#define LengthTf 30
+#define BlockTf(i) SlhaData(1012+i)
+#define Tf_Q(t) SlhaData(993+10*(t))
+#define Tf_Tf(g1,g2,t) Slhadata(990+g1+3*(g2)+10*(t))
+#define Tf_TfFlat(i,t) Slhadata(993+i+10*(t))
+
+#define OffsetTe 1012
+#define LengthTe 10
+#define BlockTe(i) SlhaData(1012+i)
+#define   Te_Q Tf_Q(2)
+#define   Te_Tf(g1,g2) Tf_Tf(g1,g2,2)
+#define   Te_TfFlat(i) Tf_TfFlat(i,2)
+
+#define OffsetTu 1022
+#define LengthTu 10
+#define BlockTu(i) SlhaData(1022+i)
+#define   Tu_Q Tf_Q(3)
+#define   Tu_Tf(g1,g2) Tf_Tf(g1,g2,3)
+#define   Tu_TfFlat(i) Tf_TfFlat(i,3)
+
+#define OffsetTd 1032
+#define LengthTd 10
+#define BlockTd(i) SlhaData(1032+i)
+#define   Td_Q Tf_Q(4)
+#define   Td_Tf(g1,g2) Tf_Tf(g1,g2,4)
+#define   Td_TfFlat(i) Tf_TfFlat(i,4)
+
+#define OffsetASfMix 1042
+#define LengthASfMix 144
+#define BlockASfMix(i) SlhaData(1042+i)
+#define ASfMix_UASf(s1,s2,t) Slhadata(1000+s1+6*(s2)+36*(t))
+#define ASfMix_UASfFlat(i,t) Slhadata(1006+i+36*(t))
+
+#define OffsetSnuMix 1042
+#define LengthSnuMix 36
+#define BlockSnuMix(i) SlhaData(1042+i)
+#define   SnuMix_UASf(s1,s2) ASfMix_UASf(s1,s2,1)
+#define   SnuMix_UASfFlat(i) ASfMix_UASfFlat(i,1)
+
+#define OffsetSelMix 1078
+#define LengthSelMix 36
+#define BlockSelMix(i) SlhaData(1078+i)
+#define   SelMix_UASf(s1,s2) ASfMix_UASf(s1,s2,2)
+#define   SelMix_UASfFlat(i) ASfMix_UASfFlat(i,2)
+
+#define OffsetUSqMix 1114
+#define LengthUSqMix 36
+#define BlockUSqMix(i) SlhaData(1114+i)
+#define   USqMix_UASf(s1,s2) ASfMix_UASf(s1,s2,3)
+#define   USqMix_UASfFlat(i) ASfMix_UASfFlat(i,3)
+
+#define OffsetDSqMix 1150
+#define LengthDSqMix 36
+#define BlockDSqMix(i) SlhaData(1150+i)
+#define   DSqMix_UASf(s1,s2) ASfMix_UASf(s1,s2,4)
+#define   DSqMix_UASfFlat(i) ASfMix_UASfFlat(i,4)
+
+#define OffsetSnSMix 1186
+#define LengthSnSMix 9
+#define BlockSnSMix(i) SlhaData(1186+i)
+#define SnSMix_US(g1,g2) Slhadata(1183+g1+3*(g2))
+#define SnSMix_USFlat(i) Slhadata(1186+i)
+
+#define OffsetSnAMix 1195
+#define LengthSnAMix 9
+#define BlockSnAMix(i) SlhaData(1195+i)
+#define SnAMix_UA(g1,g2) Slhadata(1192+g1+3*(g2))
+#define SnAMix_UAFlat(i) Slhadata(1195+i)
+
+#define OffsetCVHMix 1204
+#define LengthCVHMix 16
+#define BlockCVHMix(i) SlhaData(1204+i)
+#define CVHMix_UH(h1,h2) Slhadata(1200+h1+4*(h2))
+#define CVHMix_UHFlat(i) Slhadata(1204+i)
+
+#define OffsetNMNMix 1220
+#define LengthNMNMix 25
+#define BlockNMNMix(i) SlhaData(1220+i)
+#define NMNMix_ZNeu(n1,n2) Slhadata(1215+n1+5*(n2))
+#define NMNMix_ZNeuFlat(i) Slhadata(1220+i)
+
+#define OffsetNMHMix 1245
+#define LengthNMHMix 9
+#define BlockNMHMix(i) SlhaData(1245+i)
+#define NMHMix_UH(h1,h2) Slhadata(1242+h1+3*(h2))
+#define NMHMix_UHFlat(i) Slhadata(1245+i)
+
+#define OffsetNMAMix 1254
+#define LengthNMAMix 9
+#define BlockNMAMix(i) SlhaData(1254+i)
+#define NMAMix_UA(h1,h2) Slhadata(1251+h1+3*(h2))
+#define NMAMix_UAFlat(i) Slhadata(1254+i)
+
+#define OffsetPrecObs 1263
+#define LengthPrecObs 15
+#define BlockPrecObs(i) SlhaData(1263+i)
+#define PrecObs_DeltaRho Slhadata(1264)
+#define PrecObs_MWMSSM Slhadata(1265)
+#define PrecObs_MWSM Slhadata(1266)
+#define PrecObs_SW2effMSSM Slhadata(1267)
+#define PrecObs_SW2effSM Slhadata(1268)
+#define PrecObs_gminus2mu Slhadata(1269)
+#define PrecObs_EDMeTh Slhadata(1270)
+#define PrecObs_EDMn Slhadata(1271)
+#define PrecObs_EDMHg Slhadata(1272)
+#define PrecObs_bsgammaMSSM Slhadata(1273)
+#define PrecObs_bsgammaSM Slhadata(1274)
+#define PrecObs_DeltaMsMSSM Slhadata(1275)
+#define PrecObs_DeltaMsSM Slhadata(1276)
+#define PrecObs_BsmumuMSSM Slhadata(1277)
+#define PrecObs_BsmumuSM Slhadata(1278)
+
+#define OffsetSPInfo 1278
+#define LengthSPInfo 92
+#define BlockSPInfo(i) SlhaData(1278+i)
+#define SPInfo_NLines SlhaData(1279)
+#define SPInfo_Severity SlhaData(1280)
+#define SPInfo_Code(n) SlhaData(1280+n)
+#define SPInfo_Text(i,n) SlhaData(1290+i+5*(n))
+#define SPInfo_TextFlat(i) SlhaData(1295+i)
+#define   SPInfo_Len 80
+
+#define OffsetDCInfo 1370
+#define LengthDCInfo 92
+#define BlockDCInfo(i) SlhaData(1370+i)
+#define DCInfo_NLines SlhaData(1371)
+#define DCInfo_Severity SlhaData(1372)
+#define DCInfo_Code(n) SlhaData(1372+n)
+#define DCInfo_Text(i,n) SlhaData(1382+i+5*(n))
+#define DCInfo_TextFlat(i) SlhaData(1387+i)
+#define   DCInfo_Len 80
+
+#define OffsetDecays 1462
+#define LengthDecays 4096
+#define BlockDecays(i) SlhaData(1462+i)
+#define Decays_Data(n) Slhadata(1462+n)
+
+#define nslhadata 5558
+
+#endif
diff -rupN darksusy-5.1.3.pristine/include/SLHA.h darksusy-5.1.3/include/SLHA.h
--- darksusy-5.1.3.pristine/include/SLHA.h	1970-01-01 01:00:00.000000000 +0100
+++ darksusy-5.1.3/include/SLHA.h	2013-02-10 06:43:34.000000000 +0000
@@ -0,0 +1,17 @@
+#if 0
+	SLHA.h
+		declarations of the external SLHA functions
+		last modified 30 Nov 11 th
+#endif
+
+#include "SLHADefs.h"
+
+	RealType SLHAGetDecay
+	external SLHAGetDecay
+
+	integer SLHANewDecay, SLHADecayTable
+	external SLHANewDecay, SLHADecayTable
+
+	integer SLHAExist, SLHAValid
+	external SLHAExist, SLHAValid
+
diff -rupN darksusy-5.1.3.pristine/makefile.in darksusy-5.1.3/makefile.in
--- darksusy-5.1.3.pristine/makefile.in	2015-04-07 10:23:05.000000000 +0100
+++ darksusy-5.1.3/makefile.in	2016-02-16 15:33:54.337088470 +0000
@@ -82,7 +82,11 @@ config_paths config :
 
 darksusy_lib dslib : tspack
 	mkdir -p lib
-	cd $(DS_ROOT)/src; make all
+	cd $(DS_ROOT)/src; make libdarksusy.a
+
+darksusy_lib_shared dslib_shared : tspack libisajet_shared feynhiggs_shared higgsbounds_shared
+	mkdir -p lib
+	cd $(DS_ROOT)/src; make DS_LIB="$(DS_INSTALL)/lib" libdarksusy.so
 
 install : install_builds install_tables
 
@@ -139,15 +143,27 @@ install_tables :
 	cd $(DS_ROOT)/share/DarkSUSY; make all
 
 libisajet :
-	cd $(ISAJETDIR); make
+	cd $(ISAJETDIR); make libisajet.a
+
+libisajet_shared :
+	cd $(ISAJETDIR); make DS_LIB="$(DS_INSTALL)/lib" libisajet.so
 
 tspack:
 	cd $(TSPACKDIR); make
 
 feynhiggs :
 	cd $(FEYNHIGGSDIR); \
-	make lib ; \
+	make FC="$(FF)" FFLAGS="$(FOPT)" CFLAGS="-fPIC" lib ; \
 	cp -p build/libFH.a $(DS_ROOT)/lib/ ; \
+	make copy_feynhiggs_headers
+
+feynhiggs_shared :
+	cd $(FEYNHIGGSDIR); \
+	make FC="$(FF)" FFLAGS="$(FOPT)" CFLAGS="-fPIC" DS_LIB="$(DS_INSTALL)/lib" lib_shared
+	make copy_feynhiggs_headers
+
+copy_feynhiggs_headers :
+	cd $(FEYNHIGGSDIR); \
 	cp -p build/include/FHCouplings.h $(DS_ROOT)/include/ ;  \
 	cp -p build/include/SLHA.h $(DS_ROOT)/include/  ; \
 	cp -p build/include/SLHADefs.h $(DS_ROOT)/include/  ; \
@@ -158,6 +174,10 @@ higgsbounds :
 	make -f makefile_darksusy libHB ; \
 	cp -p libHB.a $(DS_ROOT)/lib/
 
+higgsbounds_shared :
+	cd $(HBDIR); \
+	make -f makefile_darksusy DS_LIB="$(DS_INSTALL)/lib" libHB_shared ; \
+
 # SLHA is currently not built, as feynhiggs includes slhalib
 slha :
 	cd $(SLHADIR); \
@@ -184,7 +204,7 @@ clean :
 	cd $(DS_ROOT)/contrib/galprop/v50p; $(MAKE) clean
 	cd $(FEYNHIGGSDIR); $(MAKE) clean ; rm -fr ds
 	cd $(SLHADIR); $(MAKE) clean ; rm -fr ds
-	cd $(HBDIR); $(MAKE) -f makefile_darksusy -i veryclean; $(MAKE) -f makefile_darksusy -i hyperclean
+	cd $(HBDIR); $(MAKE) -f makefile_darksusy -i clean
 	cd $(TSPACKDIR); $(MAKE) clean
 
 
@@ -198,6 +218,11 @@ rmmore:
 	rm -f $(DS_ROOT)/lib/libFH.a
 	rm -f $(DS_ROOT)/lib/libSLHA.a
 	rm -f $(DS_ROOT)/lib/libHB.a
+	rm -f $(DS_ROOT)/lib/libdarksusy.so
+	rm -f $(DS_ROOT)/lib/libisajet.so
+	rm -f $(DS_ROOT)/lib/libFH.so
+	rm -f $(DS_ROOT)/lib/libSLHA.so
+	rm -f $(DS_ROOT)/lib/libHB.so
 	rm -f $(DS_ROOT)/lib/aldata.o
 	rm -f $(DS_ROOT)/lib/libcfitsio.a
 	rm -f $(DS_ROOT)/share/DarkSUSY/ascii2bin
@@ -229,6 +254,7 @@ rmmore:
 # If it is, we know that DS_INSTALL must point to DS_ROOT.
 uninstall:
 	rm -f $(DS_INSTALL)/lib/libdarksusy.a
+	rm -f $(DS_INSTALL)/lib/libdarksusy.so
 	rm -f $(DS_INSTALL)/lib/aldata.o
 	if [ ! -f $(DS_INSTALL)/makefile.in ] ; then \
 		echo 'The install directory is different from DS_ROOT' ; \
diff -rupN darksusy-5.1.3.pristine/src/ini/dsdirname.c.in darksusy-5.1.3/src/ini/dsdirname.c.in
--- darksusy-5.1.3.pristine/src/ini/dsdirname.c.in	2008-02-21 16:08:34.000000000 +0000
+++ darksusy-5.1.3/src/ini/dsdirname.c.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-/* #include "../../config.h" */
-#include <string.h>
-
-#define DSROOTNAME "@prefix@"
-
-void dsdirname(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSROOTNAME);
-  return;
-}
-
-void dsdirname_(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSROOTNAME);
-  return;
-}
-
-void dsdirname__(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSROOTNAME);
-  return;
-}
diff -rupN darksusy-5.1.3.pristine/src/ini/dssetdsinstall.f darksusy-5.1.3/src/ini/dssetdsinstall.f
--- darksusy-5.1.3.pristine/src/ini/dssetdsinstall.f	2011-11-04 23:48:05.000000000 +0000
+++ darksusy-5.1.3/src/ini/dssetdsinstall.f	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-      subroutine dssetdsinstall
-      implicit none
-      integer i
-      character*300 name
-      include 'dsdirver.h'
-      call dsdirname(name)
-      i=1
- 10   if (name(i:i).eq.'\000') goto 20
-      i=i+1
-      goto 10
- 20   i=i-1
-c      write (*,*) 'i=',i
-cccc      dsinstall=name(:i)//'/'
-      write (*,*) 'dssetdsinstall: cannot reset dsinstall'
-      stop
-c      write (*,*) dsinstall
-      end
diff -rupN darksusy-5.1.3.pristine/src/ini/dssetdsversion.f darksusy-5.1.3/src/ini/dssetdsversion.f
--- darksusy-5.1.3.pristine/src/ini/dssetdsversion.f	2008-02-21 16:08:34.000000000 +0000
+++ darksusy-5.1.3/src/ini/dssetdsversion.f	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-      subroutine dssetdsversion
-      implicit none
-      integer i
-      character*300 name
-      include 'dsdirver.h'
-      call dsvername(name)
-      i=1
- 10   if (name(i:i).eq.'\000') goto 20
-      i=i+1
-      goto 10
- 20   i=i-1
-c      write (*,*) 'i=',i
-      dsversion=name(:i)
-c      write (*,*) dsversion
-      end
diff -rupN darksusy-5.1.3.pristine/src/ini/dsvername.c.in darksusy-5.1.3/src/ini/dsvername.c.in
--- darksusy-5.1.3.pristine/src/ini/dsvername.c.in	2008-02-21 16:08:34.000000000 +0000
+++ darksusy-5.1.3/src/ini/dsvername.c.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-/* #include "../../config.h" */
-#include <string.h>
-
-#define DSVERNAME "@DSVERSION@@DSREV@"
-
-void dsvername(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSVERNAME);
-  return;
-}
-
-void dsvername_(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSVERNAME);
-  return;
-}
-
-void dsvername__(char*name)
-{
-  name[0]='\0';
-  strcpy(name,DSVERNAME);
-  return;
-}
diff -rupN darksusy-5.1.3.pristine/src/ini/makefile darksusy-5.1.3/src/ini/makefile
--- darksusy-5.1.3.pristine/src/ini/makefile	1970-01-01 01:00:00.000000000 +0100
+++ darksusy-5.1.3/src/ini/makefile	2016-02-16 15:34:06.205088258 +0000
@@ -0,0 +1,37 @@
+# Makefile for ini directory
+# Author: Joakim Edsjo, edsjo@physto.se
+# Changed by Paolo Gondolo (2011)
+# This file is automatically created by makemfpg.pl on Nov 04, 2011.
+
+# Define fortran compiler and options (set when ./configure is run
+# in the DarkSUSY root directory
+FF=gfortran
+FOPT=-O -ffixed-line-length-none -fopenmp -fPIC
+
+FC=$(FF)
+FFLAGS=$(FOPT) -c -I$(DINC)
+
+# Dependencies and libraries
+DINC=../../include
+DOBJ=../../build
+
+INC_DEP = dsprep.h dsrncom.h dsmssm.h dsascom.h dsaccom.h dsio.h \
+dsandwcom.h dsnuclides.h dsidtag.h dsdirver.h dspbcom.h dshacom.h \
+dswacom.h
+
+vpath %.h $(DINC)
+
+SRC = dscval.f dsfval.f dsinit.f dsival.f dskillsp.f dslowcase.f \
+dslval.f dsreadnuclides.f dsreadpar.f
+
+OBJ = $(patsubst %.f,$(DOBJ)/%.o,$(SRC))
+
+OBJF = $(patsubst %.F,$(DOBJ)/%.o,$(SRC))
+
+all : $(OBJ) $(OBJF)
+
+$(DOBJ)/%.o : %.F $(INC_DEP)
+	$(FC) $(FFLAGS) $< -o $@
+
+$(DOBJ)/%.o : %.f $(INC_DEP)
+	$(FC) $(FFLAGS) $< -o $@
diff -rupN darksusy-5.1.3.pristine/src/ini/makefile.in darksusy-5.1.3/src/ini/makefile.in
--- darksusy-5.1.3.pristine/src/ini/makefile.in	2011-11-04 23:48:05.000000000 +0000
+++ darksusy-5.1.3/src/ini/makefile.in	2016-02-02 12:48:22.605727992 +0000
@@ -22,7 +22,7 @@ dswacom.h
 vpath %.h $(DINC)
 
 SRC = dscval.f dsfval.f dsinit.f dsival.f dskillsp.f dslowcase.f \
-dslval.f dsreadnuclides.f dsreadpar.f dssetdsinstall.f dssetdsversion.f
+dslval.f dsreadnuclides.f dsreadpar.f
 
 OBJ = $(patsubst %.f,$(DOBJ)/%.o,$(SRC))
 
diff -rupN darksusy-5.1.3.pristine/src/makefile.in darksusy-5.1.3/src/makefile.in
--- darksusy-5.1.3.pristine/src/makefile.in	2015-04-07 10:23:05.000000000 +0100
+++ darksusy-5.1.3/src/makefile.in	2016-02-16 15:20:51.969102481 +0000
@@ -10,9 +10,11 @@
 #### DO NOT CHANGE ANYTHING BELOW THIS LINE ###
 ###############################################
 
+FF=@F77@
+FOPT=@FOPT@
+
 # Here we set where the library goes and where include files are.
 
-LIB=../lib
 INC=../include
 TSPACKDIR=@TSPACKDIR@
 BUILD=../build
@@ -32,18 +34,22 @@ all-local : make-lib
 make-lib :
 	cd ..; make dslib
 
-all : libdarksusy.a
+all : libdarksusy.a libdarksusy.so
 
 libdarksusy.a : $(DOBJ)
 	ar rS $(LIB)/libdarksusy.a $(BUILD)/*.o
 	ranlib $(LIB)/libdarksusy.a
 
+libdarksusy.so : $(DOBJ)
+	 $(FF) $(FOPT) -shared $(BUILD)/*.o $(DS_LIB)/libFH.so $(DS_LIB)/libHB.so $(DS_LIB)/libisajet.so -o $(DS_LIB)/libdarksusy.so 
+
 $(DOBJ) : 
 	cd $(@:_obj=) ; make all
 
 .PHONY: clean distclean $(DOBJ)
 distclean : clean
 	rm $(LIB)/libdarksusy.a
+	rm $(LIB)/libdarksusy.so
 clean : 
 	rm -f $(BUILD)/*.o
 
diff -rupN darksusy-5.1.3.pristine/src/nt/dsntmuonyield.f darksusy-5.1.3/src/nt/dsntmuonyield.f
--- darksusy-5.1.3.pristine/src/nt/dsntmuonyield.f	2013-01-31 21:46:16.000000000 +0000
+++ darksusy-5.1.3/src/nt/dsntmuonyield.f	2016-02-03 21:20:18.288408294 +0000
@@ -78,21 +78,16 @@ c      call wirate(6,6,1)
          stop
       endif
          
-      waistat=0
-
       yield = 0.d0
       if (ptype.eq.1 .or. ptype.eq.3) then
         yield=dswayield(wamwimp,emu,theta,wh,kind,t1,istat)
-        waistat=or(waistat,istat)
       endif
 
       if (ptype.eq.2 .or. ptype.eq.3) then
         yield=yield+dswayield(wamwimp,emu,theta,wh,kind,t2,istat)
-        waistat=or(waistat,istat)
       endif
       
       dsntmuonyield=yield
-      istat=waistat
 
       end
 
diff -rupN darksusy-5.1.3.pristine/src/wa/dswadydth.f darksusy-5.1.3/src/wa/dswadydth.f
--- darksusy-5.1.3.pristine/src/wa/dswadydth.f	2015-12-20 21:43:06.000000000 +0000
+++ darksusy-5.1.3/src/wa/dswadydth.f	2016-02-02 18:42:09.797410390 +0000
@@ -8,7 +8,6 @@
       real*8 function dswadydth(cth, phim0,phim1,phim2,phie0,phieth,phithm,
      & phichi,phiwh,phifk,phifv)
       implicit none
-      include 'dswacom.h'
 
 c------------------------ variables ------------------------------------
 
diff -rupN darksusy-5.1.3.pristine/src/wa/dswaemean.f darksusy-5.1.3/src/wa/dswaemean.f
--- darksusy-5.1.3.pristine/src/wa/dswaemean.f	2009-03-30 13:08:08.000000000 +0100
+++ darksusy-5.1.3/src/wa/dswaemean.f	2016-02-02 18:42:16.749410265 +0000
@@ -8,8 +8,6 @@
 
       real*8 function dswaemean(e0,m0,m1,m2)
       implicit none
-      include 'dswacom.h'
-      include 'dsidtag.h'
 
 c------------------------ variables ------------------------------------
 
diff -rupN darksusy-5.1.3.pristine/src/wa/dswaifind.f darksusy-5.1.3/src/wa/dswaifind.f
--- darksusy-5.1.3.pristine/src/wa/dswaifind.f	2008-04-07 22:27:47.000000000 +0100
+++ darksusy-5.1.3/src/wa/dswaifind.f	2016-02-02 18:42:21.813410175 +0000
@@ -6,7 +6,6 @@
       subroutine dswaifind(value,array,ipl,ii,imin,imax)
       implicit none
 
-      include 'dswacom.h'
       include 'dsidtag.h'
 
       integer imin,imax,i,inew,imint,imaxt,iold,ii
diff -rupN darksusy-5.1.3.pristine/src/wa/dswainit.f darksusy-5.1.3/src/wa/dswainit.f
--- darksusy-5.1.3.pristine/src/wa/dswainit.f	2013-01-27 15:37:53.000000000 +0000
+++ darksusy-5.1.3/src/wa/dswainit.f	2016-02-05 15:01:39.514975787 +0000
@@ -271,9 +271,9 @@ c     &            k,mfi
 
 c...Create mixed tables, differential in energy, integrated in theta
                 do l=0,zn-1
-                  tmpy=0.d0
+                  tmpy=0.e0
                   do m=0,thn
-                     tmpy=tmpy+phidiff(m,l,k,j,i,yli)*dth(m)
+                     tmpy=tmpy+phidiff(m,l,k,j,i,yli)*real(dth(m))
                      phimixed(m,l,k,j,i,yli)=tmpy
                   enddo
                 enddo
@@ -338,7 +338,6 @@ c     &   10.0d0,80.3d0,91.2d0,5*10.d0/
      &  1500.0d0,2000.0d0,3000.0d0,5000.0d0,7500.0d0,10000.0d0/
 c...Lowest mass index for the 14 channels chi
       data milow/1,1,1,1,4,16,1,12,13,1,1,1,1,1/
-      data waerr/0/
       data waftype/'b'/
 c      data wabase/'we-res-b-full'/
 c      data wabase/'we-res-may2012'/
diff -rupN darksusy-5.1.3.pristine/src/wa/dswayield.f darksusy-5.1.3/src/wa/dswayield.f
--- darksusy-5.1.3.pristine/src/wa/dswayield.f	2011-05-24 09:54:48.000000000 +0100
+++ darksusy-5.1.3/src/wa/dswayield.f	2016-02-02 18:42:34.557409946 +0000
@@ -59,8 +59,6 @@
       real*8 function dswayield(mneu,e,theta,wh,kind,type,istat)
       implicit none
       include 'dswacom.h'
-      include 'dsidtag.h'
-      include 'dsio.h'
 
 c------------------------ variables ------------------------------------
 
diff -rupN darksusy-5.1.3.pristine/src/wa/dswayieldf.f darksusy-5.1.3/src/wa/dswayieldf.f
--- darksusy-5.1.3.pristine/src/wa/dswayieldf.f	2015-12-20 21:43:06.000000000 +0000
+++ darksusy-5.1.3/src/wa/dswayieldf.f	2016-02-03 20:58:33.228431665 +0000
@@ -52,11 +52,13 @@
 
       real*8 function dswayieldf(mwimp,e,theta,chi,wh,kind,
      &  type,istat)
+      use omp_lib
       implicit none
       include 'dswacom.h'
       include 'dsidtag.h'
       include 'dsio.h'
 
+
 c------------------------ variables ------------------------------------
 
       real*8 mwimp,e,theta,phi1,phi2,mp1,mp2,zpl,thpl,mn,z,th,
@@ -64,7 +66,7 @@ c------------------------ variables ----
       integer chi,istat,zi,thi,m1i,m2i,whi,kind,type,yli,chii,ii
       character*2 wh
       logical wb
-      external dswacom, slog ! set up common block variables
+      external slog
 
 c-----------------------------------------------------------------------
 
@@ -73,8 +75,11 @@ c---------------------------------------
 
 c...Safecheck
       if (yli.eq.0) then
-         call dswainit(kind,type)
-         yli=yload(kind,type)
+        if (omp_get_thread_num() .eq. 0) then
+          call dswainit(kind,type)
+        endif
+!$omp barrier
+        yli=yload(kind,type)
       endif
 
       dswayieldf=0.0d0
diff -rupN darksusy-5.1.3.pristine/src/wa/dswayieldfth.f darksusy-5.1.3/src/wa/dswayieldfth.f
--- darksusy-5.1.3.pristine/src/wa/dswayieldfth.f	2015-12-20 21:43:06.000000000 +0000
+++ darksusy-5.1.3/src/wa/dswayieldfth.f	2016-02-02 18:43:57.029408469 +0000
@@ -6,7 +6,7 @@
 *****************************************************************************
 
       real*8 function dswayieldfth(e0,m0,mp1,mp2,emuthr,thmax,chi,wh,
-     &  kind,type,istat)
+     &  kind,type,istat,waerror)
       implicit none
       include 'dswacom.h'
       include 'dsidtag.h'
@@ -16,7 +16,7 @@ c------------------------ variables ----
 
       real*8 e0,m0,mp1,mp2,emuthr,thmax,m00,e00,thu
       real*8 mp1t,mp2t
-      integer chi,istat,kind,type
+      integer chi,istat,kind,type,waerror
       character*2 wh
 
       real*8 sum,emax,emin,e1cm,pi
@@ -149,9 +149,9 @@ c          endif
 
       if (wb) then
         if (wh.eq.'su'.or.wh.eq.'SU') then
-          sum=dswayield_int(dswadydth,cos(thu),1.0d0,chi,1,m00,mp1t,mp2t,e00,emuthr,thmax,kind,type)
+          sum=dswayield_int(dswadydth,cos(thu),1.0d0,chi,1,m00,mp1t,mp2t,e00,emuthr,thmax,kind,type,waerror)
         else
-          sum=dswayield_int(dswadydth,cos(thu),1.0d0,chi,2,m00,mp1t,mp2t,e00,emuthr,thmax,kind,type)
+          sum=dswayield_int(dswadydth,cos(thu),1.0d0,chi,2,m00,mp1t,mp2t,e00,emuthr,thmax,kind,type,waerror)
         endif
         dswayieldfth=sum*1.0d-15
       endif
diff -rupN darksusy-5.1.3.pristine/src/wa/dswayield_int.f darksusy-5.1.3/src/wa/dswayield_int.f
--- darksusy-5.1.3.pristine/src/wa/dswayield_int.f	2015-12-20 21:43:06.000000000 +0000
+++ darksusy-5.1.3/src/wa/dswayield_int.f	2016-02-02 18:43:13.885409242 +0000
@@ -1,5 +1,5 @@
       real*8 function dswayield_int(f,a,b,phichi,phiwh,phim0,phim1,phim2,
-     & phie0,phieth,phithm,phifk,phifv)        
+     & phie0,phieth,phithm,phifk,phifv,waerror)        
 
 c_______________________________________________________________________
 c  integrate function f between a and b
@@ -10,11 +10,10 @@ c  author: joakim edsjo (edsjo@physto.se
 c  based on paolo gondolos wxint.f routine.
 c=======================================================================
       implicit none
-      include 'dswacom.h'
       real*8 f,a,b,tot,eps,st,os,ost,del,sum,x
       real*8 phim0,phim1,phim2,phie0,phieth,phithm
       integer phichi,phiwh,phifk,phifv   ! phiwh=1 - sun, 2 - earth
-      integer jmax,it,l,j,nfcn,jdid
+      integer jmax,it,l,j,nfcn,jdid,waerror
       external f
 c      parameter (a=-1.0,b=1.0,eps=1.0d-4,jmax=20)
       parameter (eps=1.0d-2,jmax=30)  ! je change in eps ps change in jmax
@@ -51,7 +50,7 @@ c        type *,'jdid',jdid,' os',os, 'o
       enddo
 
       write(*,*) 'DS WARNING: too many steps in dswayield_int.'
-      waerr=1
+      waerror=1
       dswayield_int=0.0d0
 
       end
diff -rupN darksusy-5.1.3.pristine/src/wa/dswayieldone.f darksusy-5.1.3/src/wa/dswayieldone.f
--- darksusy-5.1.3.pristine/src/wa/dswayieldone.f	2013-01-31 21:46:16.000000000 +0000
+++ darksusy-5.1.3/src/wa/dswayieldone.f	2016-02-01 19:48:57.409275000 +0000
@@ -105,16 +105,16 @@
 *****************************************************************************
 
       real*8 function dswayieldone(mneu,e,theta,ch,wh,kind,type,istat)
+      use omp_lib
       implicit none
       include 'dswacom.h'
       include 'dsidtag.h'
-      include 'dsio.h'
 
 c------------------------ variables ------------------------------------
 
       real*8 mneu,e,theta,flx
       real*8 mp1,mp2,e1,e2
-      integer ch,chi,istat,i,kind,type
+      integer ch,chi,istat,waerror,i,kind,type
       character*2 wh
 
       logical chok
@@ -134,7 +134,7 @@ c---------------------------------------
 c      write(*,*) 'dswayieldone called with ',kind,type
 
       istat=0
-      waerr=0
+      waerror=0
       mp1=0.d0
       mp2=0.d0
 
@@ -142,19 +142,24 @@ c      write(*,*) 'dswayieldone called w
 
 c--------------------------------------- if first call, load yield tables
 
-
       if (first) then
-        do i=1,26
-           yload(1,i)=0
-           yload(2,i)=0
-        enddo
-        walast(1)=0 ! last index for integrated yields stored in memory
-        walast(2)=0 ! last index for differential yields stored in memory
-        first=.false.
+        if (omp_get_thread_num() .eq. 0) then
+          do i=1,26
+             yload(1,i)=0
+             yload(2,i)=0
+          enddo
+          walast(1)=0 ! last index for integrated yields stored in memory
+          walast(2)=0 ! last index for differential yields stored in memory
+          first=.false.
+        endif
+!$omp barrier
       endif
 
       if (yload(kind2ki(kind),type).eq.0) then
-        call dswainit(kind,type)
+        if (omp_get_thread_num() .eq. 0) then
+          call dswainit(kind,type)
+        endif
+!$omp barrier
       endif
 
 c-----------------------------------------------------------------------
@@ -233,59 +238,59 @@ c...check different annihilation channel
 
 c---------- S10 S10 channel ----------
           if (ch.eq.1) then
-            flx=flx+2.d0*dswayields(e1,e,theta,1,wh,kind,type,istat)
+            flx=flx+2.d0*dswayields(e1,e,theta,1,wh,kind,type,istat,waerror)
 
 c---------- S10 S20 channel ----------
           elseif (ch.eq.2) then
-            flx=flx+dswayields(e1,e,theta,1,wh,kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,2,wh,kind,type,istat)
+            flx=flx+dswayields(e1,e,theta,1,wh,kind,type,istat,waerror)
+            flx=flx+dswayields(e2,e,theta,2,wh,kind,type,istat,waerror)
 
 c---------- S20 S20 channel ----------
           elseif (ch.eq.3) then
-            flx=flx+2.d0*dswayields(e1,e,theta,2,wh,kind,type,istat)
+            flx=flx+2.d0*dswayields(e1,e,theta,2,wh,kind,type,istat,waerror)
 
 c---------- S30 S30 channel ----------
           elseif (ch.eq.4) then
-            flx=flx+2.d0*dswayields(e1,e,theta,3,wh,kind,type,istat)
+            flx=flx+2.d0*dswayields(e1,e,theta,3,wh,kind,type,istat,waerror)
 
 c---------- S10 S30 channel ----------
           elseif (ch.eq.5) then
-            flx=flx+dswayields(e1,e,theta,1,wh,kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat)
+            flx=flx+dswayields(e1,e,theta,1,wh,kind,type,istat,waerror)
+            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat,waerror)
 
 c---------- S20 S30 channel ----------
           elseif (ch.eq.6) then
-            flx=flx+dswayields(e1,e,theta,2,wh,kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat)
+            flx=flx+dswayields(e1,e,theta,2,wh,kind,type,istat,waerror)
+            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat,waerror)
 
 c---------- S+ S- channel ----------
           elseif (ch.eq.7) then
-            flx=flx+2.d0*dswayields(e1,e,theta,4,wh,kind,type,istat)
+            flx=flx+2.d0*dswayields(e1,e,theta,4,wh,kind,type,istat,waerror)
 
 c---------- Z0 S10 channel ----------
           elseif (ch.eq.8) then
             flx=flx+0.5d0*dswayieldf(e1,e,theta,9,wh,
      &        kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,1,wh,kind,type,istat)
+            flx=flx+dswayields(e2,e,theta,1,wh,kind,type,istat,waerror)
 
 c---------- Z0 S20 channel ----------
           elseif (ch.eq.9) then
             flx=flx+0.5d0*dswayieldf(e1,e,theta,9,wh,
      &        kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,2,wh,kind,type,istat)
+            flx=flx+dswayields(e2,e,theta,2,wh,kind,type,istat,waerror)
 
 c---------- Z0 S30 channel ----------
           elseif (ch.eq.10) then
             flx=flx+0.5d0*dswayieldf(e1,e,theta,9,wh,
      &        kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat)
+            flx=flx+dswayields(e2,e,theta,3,wh,kind,type,istat,waerror)
 
 c---------- w+h- w-h+ channel ----------
 c...this calculation gives a mean of the two channels w+h- & w-h+
           elseif (ch.eq.11) then
             flx=flx+0.5d0*dswayieldf(e1,e,theta,8,wh,
      &        kind,type,istat)
-            flx=flx+dswayields(e2,e,theta,4,wh,kind,type,istat)
+            flx=flx+dswayields(e2,e,theta,4,wh,kind,type,istat,waerror)
 
 c---------- z0 gamma channel ----------
           elseif (ch.eq.29) then
@@ -307,14 +312,13 @@ c          endif
 
       endif
 
-      if (waerr.gt.0) then
+      if (waerror.gt.0) then
         write(*,*) 'DS WARNING in dswayieldone for model ',idtag,
      &    ', yield type ',type,' and channel ',ch
         write(*,*) '  the integration over scalar decay angles ran',
      &    ' into numerical problems.'
         write(*,*) '  The results can only be trusted as a lower',
      &    'bound.'
-        waistat=ibset(waistat,2)
         istat=ibset(istat,2)
       endif
 
diff -rupN darksusy-5.1.3.pristine/src/wa/dswayields2.f darksusy-5.1.3/src/wa/dswayields2.f
--- darksusy-5.1.3.pristine/src/wa/dswayields2.f	2009-05-08 09:54:47.000000000 +0100
+++ darksusy-5.1.3/src/wa/dswayields2.f	2016-02-01 19:48:57.413275000 +0000
@@ -8,14 +8,14 @@
 *****************************************************************************
 
       real*8 function dswayields2(eh,emuth,thmax,hno,wh,kind,
-     &  type,istat)
+     &  type,istat,waerror)
       implicit none
       include 'dswacom.h'
 
 c------------------------ variables ------------------------------------
 
       real*8 eh,emuth,thmax
-      integer hno,istat,kind,type,chi
+      integer hno,istat,waerror,kind,type,chi
       character*2 wh
 
       real*8 e1,e2,yield
@@ -39,7 +39,7 @@ c..."fundamental" channels
           if (was0br(chi2ch(chi),hno).gt.0.0d0) then
             yield=yield+was0br(chi2ch(chi),hno)*2.0d0*
      &        dswayieldfth(eh,was0m(hno),map(chi),map(chi),emuth,thmax,
-     &          chi,wh,kind,type,istat)
+     &          chi,wh,kind,type,istat,waerror)
           endif
   100   continue
 
@@ -47,95 +47,95 @@ c..."complex" channels
         if (was0br(1,hno).gt.0.0d0) then    ! S10 S10 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(1))
           yield=yield+2.0*was0br(1,hno)*dswayields3(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(2,hno).gt.0.0d0) then    ! S10 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(2))
           yield=yield+was0br(2,hno)*dswayields3(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(2),was0m(1))
           yield=yield+was0br(2,hno)*dswayields3(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(3,hno).gt.0.0d0) then    ! S20 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(2))
           yield=yield+2.0*was0br(3,hno)*dswayields3(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(4,hno).gt.0.0d0) then    ! S30 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(3),was0m(3))
           yield=yield+2.0*was0br(4,hno)*dswayields3(e1,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(5,hno).gt.0.0d0) then    ! S10 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(3))
           yield=yield+was0br(5,hno)*dswayields3(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(1))
           yield=yield+was0br(5,hno)*dswayields3(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(6,hno).gt.0.0d0) then    ! S20 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(3))
           yield=yield+was0br(6,hno)*dswayields3(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(2))
           yield=yield+was0br(6,hno)*dswayields3(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(7,hno).gt.0.0d0) then    ! S+ S- channel
           e1=dswaemean(eh,was0m(hno),wascm,wascm)
           yield=yield+2.0*
      &      was0br(7,hno)*dswayields3(e1,emuth,thmax,4,wh,
-     &        kind,type,istat)
+     &        kind,type,istat,waerror)
         endif
 
         if (was0br(8,hno).gt.0.0d0) then    ! z0 S10 channel
           e2=dswaemean(eh,was0m(hno),was0m(1),map(9))
           yield=yield+was0br(8,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(1),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(8,hno)*dswayields3(e2,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(9,hno).gt.0.0d0) then    ! z0 S20 channel
           e2=dswaemean(eh,was0m(hno),was0m(2),map(9))
           yield=yield+was0br(9,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(2),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(9,hno)*dswayields3(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(10,hno).gt.0.0d0) then    ! z0 S30 channel
           e2=dswaemean(eh,was0m(hno),was0m(3),map(9))
           yield=yield+was0br(10,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(3),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(10,hno)*dswayields3(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(11,hno).gt.0.0d0) then    ! w-S+ w+S- channel
           e2=dswaemean(eh,was0m(hno),wascm,map(8))
           yield=yield+was0br(11,hno)*
      +    dswayieldfth(eh,was0m(hno),map(8),wascm,emuth,thmax,
-     &      8,wh,kind,type,istat)
+     &      8,wh,kind,type,istat,waerror)
           yield=yield+was0br(11,hno)*dswayields3(e2,emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(29,hno).gt.0.0d0) then    ! Z0 gamma
           yield=yield+was0br(29,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),0.0d0,emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
         endif
 
 c---------- charged scalar bosons ----------
@@ -144,118 +144,118 @@ c---------- charged scalar bosons ------
         if (wascbr(1).gt.0.0d0) then ! u d-bar
            yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(1),map(2),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(2),map(1),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(2).gt.0.0d0) then ! u s-bar
            yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(3),map(2),emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
           yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(2),map(3),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(3).gt.0.0d0) then ! u b-bar
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(5),map(2),emuth,thmax,
-     &      5,wh,kind,type,istat)
+     &      5,wh,kind,type,istat,waerror)
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(2),map(5),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(4).gt.0.0d0) then ! c d-bar
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(4),map(1),emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(1),map(4),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(5).gt.0.0d0) then ! c s-bar
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(4),map(3),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(3),map(4),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(6).gt.0.0d0) then ! c b-bar
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(4),map(5),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(5),map(4),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(7).gt.0.0d0) then ! t d-bar
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(6),map(1),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(1),map(6),emuth,thmax,
-     &    1,wh,kind,type,istat)
+     &    1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(8).gt.0.0d0) then ! t s-bar
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(6),map(3),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(3),map(6),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(9).gt.0.0d0) then ! t b-bar
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(6),map(5),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(5),map(6),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(12).gt.0.0d0) then ! tau nu_tau
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(11),map(14),emuth,thmax,
-     &    11,wh,kind,type,istat)
+     &    11,wh,kind,type,istat,waerror)
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(14),map(11),emuth,thmax,
-     &    14,wh,kind,type,istat)
+     &    14,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(13).gt.0.0d0) then ! w+ h1
           yield=yield+wascbr(13)*
      &    dswayieldfth(eh,wascm,map(8),was0m(1),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(1),map(8))
           yield=yield+wascbr(13)*
-     &      dswayields3(e2,emuth,thmax,1,wh,kind,type,istat)
+     &      dswayields3(e2,emuth,thmax,1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(14).gt.0.0d0) then ! w+ h2
           yield=yield+wascbr(14)*
      &    dswayieldfth(eh,wascm,map(8),was0m(2),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(2),map(8))
           yield=yield+wascbr(14)*
-     &      dswayields3(e2,emuth,thmax,2,wh,kind,type,istat)
+     &      dswayields3(e2,emuth,thmax,2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(15).gt.0.0d0) then ! w+ h3
           yield=yield+wascbr(15)*
      &    dswayieldfth(eh,wascm,map(8),was0m(3),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(3),map(8))
           yield=yield+wascbr(15)*
-     &      dswayields3(e2,emuth,thmax,3,wh,kind,type,istat)
+     &      dswayields3(e2,emuth,thmax,3,wh,kind,type,istat,waerror)
         endif
 
       endif
diff -rupN darksusy-5.1.3.pristine/src/wa/dswayields3.f darksusy-5.1.3/src/wa/dswayields3.f
--- darksusy-5.1.3.pristine/src/wa/dswayields3.f	2009-05-08 09:54:47.000000000 +0100
+++ darksusy-5.1.3/src/wa/dswayields3.f	2016-02-01 19:48:57.413275000 +0000
@@ -8,14 +8,14 @@
 *****************************************************************************
 
       real*8 function dswayields3(eh,emuth,thmax,hno,wh,kind,
-     &  type,istat)
+     &  type,istat,waerror)
       implicit none
       include 'dswacom.h'
 
 c------------------------ variables ------------------------------------
 
       real*8 eh,emuth,thmax
-      integer hno,istat,kind,type,chi
+      integer hno,istat,waerror,kind,type,chi
       character*2 wh
 
       real*8 e1,e2,yield
@@ -39,7 +39,7 @@ c..."fundamental" channels
           if (was0br(chi2ch(chi),hno).gt.0.0d0) then
             yield=yield+was0br(chi2ch(chi),hno)*2.0d0*
      &        dswayieldfth(eh,was0m(hno),map(chi),map(chi),emuth,thmax,
-     &          chi,wh,kind,type,istat)
+     &          chi,wh,kind,type,istat,waerror)
           endif
   100   continue
 
@@ -47,95 +47,95 @@ c..."complex" channels
         if (was0br(1,hno).gt.0.0d0) then    ! S10 S10 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(1))
           yield=yield+2.0*was0br(1,hno)*dswayields4(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(2,hno).gt.0.0d0) then    ! S10 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(2))
           yield=yield+was0br(2,hno)*dswayields4(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(2),was0m(1))
           yield=yield+was0br(2,hno)*dswayields4(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(3,hno).gt.0.0d0) then    ! S20 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(2))
           yield=yield+2.0*was0br(3,hno)*dswayields4(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(4,hno).gt.0.0d0) then    ! S30 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(3),was0m(3))
           yield=yield+2.0*was0br(4,hno)*dswayields4(e1,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(5,hno).gt.0.0d0) then    ! S10 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(3))
           yield=yield+was0br(5,hno)*dswayields4(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(1))
           yield=yield+was0br(5,hno)*dswayields4(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(6,hno).gt.0.0d0) then    ! S20 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(3))
           yield=yield+was0br(6,hno)*dswayields4(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(2))
           yield=yield+was0br(6,hno)*dswayields4(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(7,hno).gt.0.0d0) then    ! S+ S- channel
           e1=dswaemean(eh,was0m(hno),wascm,wascm)
           yield=yield+2.0*
      &      was0br(7,hno)*dswayields4(e1,emuth,thmax,4,wh,
-     &        kind,type,istat)
+     &        kind,type,istat,waerror)
         endif
 
         if (was0br(8,hno).gt.0.0d0) then    ! z0 S10 channel
           e2=dswaemean(eh,was0m(hno),was0m(1),map(9))
           yield=yield+was0br(8,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(1),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(8,hno)*dswayields4(e2,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(9,hno).gt.0.0d0) then    ! z0 S20 channel
           e2=dswaemean(eh,was0m(hno),was0m(2),map(9))
           yield=yield+was0br(9,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(2),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(9,hno)*dswayields4(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(10,hno).gt.0.0d0) then    ! z0 S30 channel
           e2=dswaemean(eh,was0m(hno),was0m(3),map(9))
           yield=yield+was0br(10,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(3),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(10,hno)*dswayields4(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(11,hno).gt.0.0d0) then    ! w-S+ w+S- channel
           e2=dswaemean(eh,was0m(hno),wascm,map(8))
           yield=yield+was0br(11,hno)*
      +    dswayieldfth(eh,was0m(hno),map(8),wascm,emuth,thmax,
-     &      8,wh,kind,type,istat)
+     &      8,wh,kind,type,istat,waerror)
           yield=yield+was0br(11,hno)*dswayields4(e2,emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(29,hno).gt.0.0d0) then    ! Z0 gamma
           yield=yield+was0br(29,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),0.0d0,emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
         endif
 
 c---------- charged scalar bosons ----------
@@ -144,118 +144,118 @@ c---------- charged scalar bosons ------
         if (wascbr(1).gt.0.0d0) then ! u d-bar
            yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(1),map(2),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(2),map(1),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(2).gt.0.0d0) then ! u s-bar
            yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(3),map(2),emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
           yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(2),map(3),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(3).gt.0.0d0) then ! u b-bar
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(5),map(2),emuth,thmax,
-     &      5,wh,kind,type,istat)
+     &      5,wh,kind,type,istat,waerror)
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(2),map(5),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(4).gt.0.0d0) then ! c d-bar
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(4),map(1),emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(1),map(4),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(5).gt.0.0d0) then ! c s-bar
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(4),map(3),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(3),map(4),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(6).gt.0.0d0) then ! c b-bar
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(4),map(5),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(5),map(4),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(7).gt.0.0d0) then ! t d-bar
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(6),map(1),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(1),map(6),emuth,thmax,
-     &    1,wh,kind,type,istat)
+     &    1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(8).gt.0.0d0) then ! t s-bar
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(6),map(3),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(3),map(6),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(9).gt.0.0d0) then ! t b-bar
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(6),map(5),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(5),map(6),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(12).gt.0.0d0) then ! tau nu_tau
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(11),map(14),emuth,thmax,
-     &    11,wh,kind,type,istat)
+     &    11,wh,kind,type,istat,waerror)
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(14),map(11),emuth,thmax,
-     &    14,wh,kind,type,istat)
+     &    14,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(13).gt.0.0d0) then ! w+ h1
           yield=yield+wascbr(13)*
      &    dswayieldfth(eh,wascm,map(8),was0m(1),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(1),map(8))
           yield=yield+wascbr(13)*
-     &      dswayields4(e2,emuth,thmax,1,wh,kind,type,istat)
+     &      dswayields4(e2,emuth,thmax,1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(14).gt.0.0d0) then ! w+ h2
           yield=yield+wascbr(14)*
      &    dswayieldfth(eh,wascm,map(8),was0m(2),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(2),map(8))
           yield=yield+wascbr(14)*
-     &      dswayields4(e2,emuth,thmax,2,wh,kind,type,istat)
+     &      dswayields4(e2,emuth,thmax,2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(15).gt.0.0d0) then ! w+ h3
           yield=yield+wascbr(15)*
      &    dswayieldfth(eh,wascm,map(8),was0m(3),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(3),map(8))
           yield=yield+wascbr(15)*
-     &      dswayields4(e2,emuth,thmax,3,wh,kind,type,istat)
+     &      dswayields4(e2,emuth,thmax,3,wh,kind,type,istat,waerror)
         endif
 
       endif
diff -rupN darksusy-5.1.3.pristine/src/wa/dswayields4.f darksusy-5.1.3/src/wa/dswayields4.f
--- darksusy-5.1.3.pristine/src/wa/dswayields4.f	2009-05-08 09:54:47.000000000 +0100
+++ darksusy-5.1.3/src/wa/dswayields4.f	2016-02-01 19:48:57.413275000 +0000
@@ -8,7 +8,7 @@
 *****************************************************************************
 
       real*8 function dswayields4(eh,emuth,thmax,hno,wh,
-     &  kind,type,istat)
+     &  kind,type,istat,waerror)
       implicit none
       include 'dswacom.h'
       include 'dsidtag.h'
@@ -16,7 +16,7 @@
 c------------------------ variables ------------------------------------
 
       real*8 eh,emuth,thmax
-      integer hno,istat,kind,type
+      integer hno,istat,waerror,kind,type
       character*2 wh
 
       real*8 yield
@@ -40,7 +40,7 @@ c..."fundamental" channels
           if (was0br(chi2ch(chi),hno).gt.0.0d0) then
             yield=yield+was0br(chi2ch(chi),hno)*2.0d0*
      &        dswayieldfth(eh,was0m(hno),map(chi),map(chi),emuth,thmax,
-     &          chi,wh,kind,type,istat)
+     &          chi,wh,kind,type,istat,waerror)
           endif
   100   continue
 
@@ -51,91 +51,91 @@ c---------- charged scalar bosons ------
         if (wascbr(1).gt.0.0d0) then ! u d-bar
            yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(1),map(2),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(2),map(1),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(2).gt.0.0d0) then ! u s-bar
            yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(3),map(2),emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
           yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(2),map(3),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(3).gt.0.0d0) then ! u b-bar
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(5),map(2),emuth,thmax,
-     &      5,wh,kind,type,istat)
+     &      5,wh,kind,type,istat,waerror)
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(2),map(5),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(4).gt.0.0d0) then ! c d-bar
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(4),map(1),emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(1),map(4),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(5).gt.0.0d0) then ! c s-bar
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(4),map(3),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(3),map(4),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(6).gt.0.0d0) then ! c b-bar
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(4),map(5),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(5),map(4),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(7).gt.0.0d0) then ! t d-bar
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(6),map(1),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(1),map(6),emuth,thmax,
-     &    1,wh,kind,type,istat)
+     &    1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(8).gt.0.0d0) then ! t s-bar
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(6),map(3),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(3),map(6),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(9).gt.0.0d0) then ! t b-bar
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(6),map(5),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(5),map(6),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(12).gt.0.0d0) then ! tau nu_tau
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(11),map(14),emuth,thmax,
-     &    11,wh,kind,type,istat)
+     &    11,wh,kind,type,istat,waerror)
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(14),map(11),emuth,thmax,
-     &    14,wh,kind,type,istat)
+     &    14,wh,kind,type,istat,waerror)
         endif
 
       endif
diff -rupN darksusy-5.1.3.pristine/src/wa/dswayields.f darksusy-5.1.3/src/wa/dswayields.f
--- darksusy-5.1.3.pristine/src/wa/dswayields.f	2009-05-08 09:54:47.000000000 +0100
+++ darksusy-5.1.3/src/wa/dswayields.f	2016-02-01 19:48:57.409275000 +0000
@@ -8,14 +8,14 @@
 *****************************************************************************
 
       real*8 function dswayields(eh,emuth,thmax,hno,wh,kind,
-     &  type,istat)
+     &  type,istat,waerror)
       implicit none
       include 'dswacom.h'
 
 c------------------------ variables ------------------------------------
 
       real*8 eh,emuth,thmax
-      integer hno,istat,kind,type,chi
+      integer hno,istat,waerror,kind,type,chi
       character*2 wh
 
       real*8 e1,e2,yield
@@ -38,7 +38,7 @@ c..."fundamental" channels
           if (was0br(chi2ch(chi),hno).gt.0.0d0) then
             yield=yield+was0br(chi2ch(chi),hno)*2.0d0*
      &        dswayieldfth(eh,was0m(hno),map(chi),map(chi),emuth,thmax,
-     &          chi,wh,kind,type,istat)
+     &          chi,wh,kind,type,istat,waerror)
           endif
   100   continue
 
@@ -46,95 +46,95 @@ c..."complex" channels
         if (was0br(1,hno).gt.0.0d0) then    ! S10 S10 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(1))
           yield=yield+2.0*was0br(1,hno)*dswayields2(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(2,hno).gt.0.0d0) then    ! S10 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(2))
           yield=yield+was0br(2,hno)*dswayields2(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(2),was0m(1))
           yield=yield+was0br(2,hno)*dswayields2(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(3,hno).gt.0.0d0) then    ! S20 S20 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(2))
           yield=yield+2.0*was0br(3,hno)*dswayields2(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(4,hno).gt.0.0d0) then    ! S30 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(3),was0m(3))
           yield=yield+2.0*was0br(4,hno)*dswayields2(e1,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(5,hno).gt.0.0d0) then    ! S10 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(1),was0m(3))
           yield=yield+was0br(5,hno)*dswayields2(e1,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(1))
           yield=yield+was0br(5,hno)*dswayields2(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(6,hno).gt.0.0d0) then    ! S20 S30 channel
           e1=dswaemean(eh,was0m(hno),was0m(2),was0m(3))
           yield=yield+was0br(6,hno)*dswayields2(e1,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,was0m(hno),was0m(3),was0m(2))
           yield=yield+was0br(6,hno)*dswayields2(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(7,hno).gt.0.0d0) then    ! S+ S- channel
           e1=dswaemean(eh,was0m(hno),wascm,wascm)
           yield=yield+2.0*
      &      was0br(7,hno)*dswayields2(e1,emuth,thmax,4,wh,
-     &        kind,type,istat)
+     &        kind,type,istat,waerror)
         endif
 
         if (was0br(8,hno).gt.0.0d0) then    ! z0 S10 channel
           e2=dswaemean(eh,was0m(hno),was0m(1),map(9))
           yield=yield+was0br(8,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(1),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(8,hno)*dswayields2(e2,emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(9,hno).gt.0.0d0) then    ! z0 S20 channel
           e2=dswaemean(eh,was0m(hno),was0m(2),map(9))
           yield=yield+was0br(9,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(2),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(9,hno)*dswayields2(e2,emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(10,hno).gt.0.0d0) then    ! z0 S30 channel
           e2=dswaemean(eh,was0m(hno),was0m(3),map(9))
           yield=yield+was0br(10,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),was0m(3),emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
           yield=yield+was0br(10,hno)*dswayields2(e2,emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(11,hno).gt.0.0d0) then    ! w-S+ w+S- channel
           e2=dswaemean(eh,was0m(hno),wascm,map(8))
           yield=yield+was0br(11,hno)*
      +    dswayieldfth(eh,was0m(hno),map(8),wascm,emuth,thmax,
-     &      8,wh,kind,type,istat)
+     &      8,wh,kind,type,istat,waerror)
           yield=yield+was0br(11,hno)*dswayields2(e2,emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
         endif
 
         if (was0br(29,hno).gt.0.0d0) then    ! Z0 gamma
           yield=yield+was0br(29,hno)*
      +    dswayieldfth(eh,was0m(hno),map(9),0.0d0,emuth,thmax,
-     &      9,wh,kind,type,istat)
+     &      9,wh,kind,type,istat,waerror)
         endif
 c        write(*,*) '   ...after complex: ',yield
 
@@ -144,118 +144,118 @@ c---------- charged scalar bosons ------
         if (wascbr(1).gt.0.0d0) then ! u d-bar
            yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(1),map(2),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
           yield=yield+wascbr(1)*
      &    dswayieldfth(eh,wascm,map(2),map(1),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(2).gt.0.0d0) then ! u s-bar
            yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(3),map(2),emuth,thmax,
-     &      3,wh,kind,type,istat)
+     &      3,wh,kind,type,istat,waerror)
           yield=yield+wascbr(2)*
      &    dswayieldfth(eh,wascm,map(2),map(3),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(3).gt.0.0d0) then ! u b-bar
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(5),map(2),emuth,thmax,
-     &      5,wh,kind,type,istat)
+     &      5,wh,kind,type,istat,waerror)
           yield=yield+wascbr(3)*
      &    dswayieldfth(eh,wascm,map(2),map(5),emuth,thmax,
-     &      2,wh,kind,type,istat)
+     &      2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(4).gt.0.0d0) then ! c d-bar
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(4),map(1),emuth,thmax,
-     &      4,wh,kind,type,istat)
+     &      4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(4)*
      &    dswayieldfth(eh,wascm,map(1),map(4),emuth,thmax,
-     &      1,wh,kind,type,istat)
+     &      1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(5).gt.0.0d0) then ! c s-bar
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(4),map(3),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(5)*
      &    dswayieldfth(eh,wascm,map(3),map(4),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(6).gt.0.0d0) then ! c b-bar
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(4),map(5),emuth,thmax,
-     &    4,wh,kind,type,istat)
+     &    4,wh,kind,type,istat,waerror)
           yield=yield+wascbr(6)*
      &    dswayieldfth(eh,wascm,map(5),map(4),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(7).gt.0.0d0) then ! t d-bar
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(6),map(1),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(7)*
      &    dswayieldfth(eh,wascm,map(1),map(6),emuth,thmax,
-     &    1,wh,kind,type,istat)
+     &    1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(8).gt.0.0d0) then ! t s-bar
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(6),map(3),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(8)*
      &    dswayieldfth(eh,wascm,map(3),map(6),emuth,thmax,
-     &    3,wh,kind,type,istat)
+     &    3,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(9).gt.0.0d0) then ! t b-bar
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(6),map(5),emuth,thmax,
-     &    6,wh,kind,type,istat)
+     &    6,wh,kind,type,istat,waerror)
           yield=yield+wascbr(9)*
      &    dswayieldfth(eh,wascm,map(5),map(6),emuth,thmax,
-     &    5,wh,kind,type,istat)
+     &    5,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(12).gt.0.0d0) then ! tau nu_tau
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(11),map(14),emuth,thmax,
-     &    11,wh,kind,type,istat)
+     &    11,wh,kind,type,istat,waerror)
           yield=yield+wascbr(12)*
      &    dswayieldfth(eh,wascm,map(14),map(11),emuth,thmax,
-     &    14,wh,kind,type,istat)
+     &    14,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(13).gt.0.0d0) then ! w+ h1
           yield=yield+wascbr(13)*
      &    dswayieldfth(eh,wascm,map(8),was0m(1),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(1),map(8))
           yield=yield+wascbr(13)*
-     &      dswayields2(e2,emuth,thmax,1,wh,kind,type,istat)
+     &      dswayields2(e2,emuth,thmax,1,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(14).gt.0.0d0) then ! w+ h2
           yield=yield+wascbr(14)*
      &    dswayieldfth(eh,wascm,map(8),was0m(2),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(2),map(8))
           yield=yield+wascbr(14)*
-     &      dswayields2(e2,emuth,thmax,2,wh,kind,type,istat)
+     &      dswayields2(e2,emuth,thmax,2,wh,kind,type,istat,waerror)
         endif
 
         if (wascbr(15).gt.0.0d0) then ! w+ h3
           yield=yield+wascbr(15)*
      &    dswayieldfth(eh,wascm,map(8),was0m(3),emuth,thmax,
-     &    8,wh,kind,type,istat)
+     &    8,wh,kind,type,istat,waerror)
           e2=dswaemean(eh,wascm,was0m(3),map(8))
           yield=yield+wascbr(15)*
-     &      dswayields2(e2,emuth,thmax,3,wh,kind,type,istat)
+     &      dswayields2(e2,emuth,thmax,3,wh,kind,type,istat,waerror)
         endif
 
       endif
