--- ../../../installed/MultiModeCode/2.0.0/modpk_potential.f90	2015-04-20 16:36:02.000000000 +0100
+++ ../../../include/gambit/Backends/backend_types/MultiModeCode_2_0_0/modpk_potential.f90	2017-11-25 00:34:28.000000000 +0000
@@ -48,7 +48,7 @@
     integer :: phi_light_index
     real(dp) :: lambda4(size(phi)), alpha2(num_inflaton)
 
-    real(dp) :: lambda2
+    real(dp) :: lambda2, derr
     real(dp), dimension(size(phi),size(phi)) :: m2_matrix
     integer :: i,j, temp_choice
 
@@ -284,6 +284,10 @@
           cos(2.0e0_dp*pi*phi(ii) - 2.0e0_dp*pi*phi(jj))
       end do; end do
 
+    case(18)
+      ! SMASH potential - see deriv. expressions in modpk_backgrnd
+      ii = locate(chiHarray,phi(1))
+      call polint(chiHarray(ii:ii+4), potHarray(ii:ii+4), phi(1), V_potential, derr)
 
 
     case default
@@ -334,7 +338,7 @@
     real(dp) :: p_exp
     integer :: ii
 
-    real(dp) :: V0, twopi
+    real(dp) :: V0, twopi, derr(size(phi))
     real(dp), dimension(size(phi)) :: A_i
     real(dp), dimension(size(phi),size(phi)) :: B_ij
     integer :: alpha, beta
@@ -501,6 +505,10 @@
            end do
          end do
 
+       case(18)
+       ! SMASH potential - see deriv. expressions in modpk_backgrnd
+         ii = locate(chiHarray,phi(1))
+         call polint(chiHarray(ii:ii+4), dpotHarray(ii:ii+4), phi(1), first_deriv(1), derr(1))
 
        !END MULTIFIELD
        case default
@@ -542,7 +550,7 @@
     real(dp), dimension(size(phi),size(phi)) :: m2_matrix
 
     real(dp), dimension(size(phi)) :: location_phi, step_size, step_slope
-    real(dp), dimension(size(phi)) :: stepsize
+    real(dp), dimension(size(phi)) :: stepsize, derr
     real(dp), dimension(:,:), allocatable :: numderiv
     real(dp), dimension(:), allocatable :: numderiv1
 
@@ -771,6 +779,10 @@
            end do
          end do
 
+       case(18)
+       ! SMASH potential - see deriv. expressions in modpk_backgrnd
+         ii = locate(chiHarray,phi(1))
+         call polint(chiHarray(ii:ii+4), d2potHarray(ii:ii+4), phi(1), second_deriv(1,1), derr(1))
 
        case default
 
@@ -794,13 +806,13 @@
   !of the scalar running, alpha_s
   function d3Vdphi3(phi) result(third_deriv)
     real(dp), intent(in) :: phi(:)
-    real(dp) :: third_deriv(size(phi),size(phi),size(phi))
+    real(dp) :: third_deriv(size(phi),size(phi),size(phi))!,lambda(size(phi))
     real(dp) :: m2_V(size(phi))
     integer :: ii
 
     real(dp) :: p_exp
 
-    real(dp), dimension(size(phi)) :: location_phi, step_size, step_slope
+    real(dp), dimension(size(phi)) :: location_phi, step_size, step_slope, derr
 
     third_deriv = 0e0_dp
 
@@ -808,6 +820,16 @@
     case(1)
       m2_V = 10.e0_dp**(vparams(1,:))
       third_deriv=0e0_dp
+
+    ! temporary solution, will work on this later.
+    ! case(3)
+    !  lambda = 10.e0_dp**vparams(1,:)
+    !  third_deriv=0e0_dp
+    !  forall (i = 1:size(phi)) third_deriv(i,i,i) = 6.e0_dp*lambda(i)*phi(i)
+
+    case(4)
+      third_deriv=0e0_dp
+
     case(14)
 
       !Multifield step potential
@@ -852,6 +874,13 @@
           m2_V(ii)*abs(phi(ii))**(p_exp-3.0e0_dp)
       end do
 
+     case(18)
+     ! SMASH potential - see deriv. expressions in modpk_backgrnd
+       ii = locate(chiHarray,phi(1))
+       call polint(chiHarray(ii:ii+4), d3potHarray(ii:ii+4), &
+                         phi(1), third_deriv(1,1,1), derr(1))
+       print*,"third_deriv(1,1,1) = ", third_deriv(1,1,1), "derr(1)" , derr(1)
+
     case default
 
       print*, "MODECODE: potential_choice =", potential_choice
@@ -923,9 +952,17 @@
     !
     real(dp) :: getEps
     real(dp), INTENT(IN) :: phi(:), dphi(:)
+    real(dp), dimension(size(phi)) ::  dVpot
+    real(dp) ::  Vpot
 
-    !MULTIFIELD
-    getEps = 0.5e0_dp*(M_Pl)**2 * dot_product(dphi,dphi)
+    if (potential_choice == 18) then
+      Vpot = pot(phi)
+      dVpot = dVdphi(phi)
+      getEps = 0.5e0_dp*(dVpot(1)/Vpot)**2
+ 	else
+      !MULTIFIELD
+      getEps = 0.5e0_dp*(M_Pl)**2 * dot_product(dphi,dphi)
+	end if
 
     if (getEps >=3.0e0_dp) then
       print*, "MODECODE: epsilon =", getEps
@@ -1222,6 +1259,8 @@
     power_adiab = (1e0_dp/phi_dot_0_scaled**2)*power_adiab
     !------------------------------------------------------------
 
+    print*, "power_adiab = ", power_adiab
+
     !Isocurvature power spectra
     if (numb_infl>1) then
 
