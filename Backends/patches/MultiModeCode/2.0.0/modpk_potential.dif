*** ../../Backends/installed/MultiModeCode/2.0.0/modpk_potential.f90	2015-04-20 16:36:02.000000000 +0100
--- ../../Backends/include/gambit/Backends/backend_types/MultiModeCode_2_0_0/modpk_potential.f90	2018-09-05 11:17:46.000000000 +0100
***************
*** 48,54 ****
      integer :: phi_light_index
      real(dp) :: lambda4(size(phi)), alpha2(num_inflaton)
  
!     real(dp) :: lambda2
      real(dp), dimension(size(phi),size(phi)) :: m2_matrix
      integer :: i,j, temp_choice
  
--- 48,54 ----
      integer :: phi_light_index
      real(dp) :: lambda4(size(phi)), alpha2(num_inflaton)
  
!     real(dp) :: lambda2, derr
      real(dp), dimension(size(phi),size(phi)) :: m2_matrix
      integer :: i,j, temp_choice
  
***************
*** 284,289 ****
--- 284,293 ----
            cos(2.0e0_dp*pi*phi(ii) - 2.0e0_dp*pi*phi(jj))
        end do; end do
  
+     case(18)
+       ! SMASH potential - see deriv. expressions in modpk_backgrnd
+       ii = locate(chiHarray,phi(1))
+       call polint(chiHarray(ii:ii+4), potHarray(ii:ii+4), phi(1), V_potential, derr)
  
  
      case default
***************
*** 334,340 ****
      real(dp) :: p_exp
      integer :: ii
  
!     real(dp) :: V0, twopi
      real(dp), dimension(size(phi)) :: A_i
      real(dp), dimension(size(phi),size(phi)) :: B_ij
      integer :: alpha, beta
--- 338,344 ----
      real(dp) :: p_exp
      integer :: ii
  
!     real(dp) :: V0, twopi, derr(size(phi))
      real(dp), dimension(size(phi)) :: A_i
      real(dp), dimension(size(phi),size(phi)) :: B_ij
      integer :: alpha, beta
***************
*** 501,506 ****
--- 505,514 ----
             end do
           end do
  
+        case(18)
+        ! SMASH potential - see deriv. expressions in modpk_backgrnd
+          ii = locate(chiHarray,phi(1))
+          call polint(chiHarray(ii:ii+4), dpotHarray(ii:ii+4), phi(1), first_deriv(1), derr(1))
  
         !END MULTIFIELD
         case default
***************
*** 542,548 ****
      real(dp), dimension(size(phi),size(phi)) :: m2_matrix
  
      real(dp), dimension(size(phi)) :: location_phi, step_size, step_slope
!     real(dp), dimension(size(phi)) :: stepsize
      real(dp), dimension(:,:), allocatable :: numderiv
      real(dp), dimension(:), allocatable :: numderiv1
  
--- 550,556 ----
      real(dp), dimension(size(phi),size(phi)) :: m2_matrix
  
      real(dp), dimension(size(phi)) :: location_phi, step_size, step_slope
!     real(dp), dimension(size(phi)) :: stepsize, derr
      real(dp), dimension(:,:), allocatable :: numderiv
      real(dp), dimension(:), allocatable :: numderiv1
  
***************
*** 771,776 ****
--- 779,788 ----
             end do
           end do
  
+        case(18)
+        ! SMASH potential - see deriv. expressions in modpk_backgrnd
+          ii = locate(chiHarray,phi(1))
+          call polint(chiHarray(ii:ii+4), d2potHarray(ii:ii+4), phi(1), second_deriv(1,1), derr(1))
  
         case default
  
***************
*** 794,806 ****
    !of the scalar running, alpha_s
    function d3Vdphi3(phi) result(third_deriv)
      real(dp), intent(in) :: phi(:)
!     real(dp) :: third_deriv(size(phi),size(phi),size(phi))
      real(dp) :: m2_V(size(phi))
      integer :: ii
  
      real(dp) :: p_exp
  
!     real(dp), dimension(size(phi)) :: location_phi, step_size, step_slope
  
      third_deriv = 0e0_dp
  
--- 806,818 ----
    !of the scalar running, alpha_s
    function d3Vdphi3(phi) result(third_deriv)
      real(dp), intent(in) :: phi(:)
!     real(dp) :: third_deriv(size(phi),size(phi),size(phi))!,lambda(size(phi))
      real(dp) :: m2_V(size(phi))
      integer :: ii
  
      real(dp) :: p_exp
  
!     real(dp), dimension(size(phi)) :: location_phi, step_size, step_slope, derr
  
      third_deriv = 0e0_dp
  
***************
*** 808,813 ****
--- 820,835 ----
      case(1)
        m2_V = 10.e0_dp**(vparams(1,:))
        third_deriv=0e0_dp
+ 
+     ! temporary solution, will work on this later.
+     ! case(3)
+     !  lambda = 10.e0_dp**vparams(1,:)
+     !  third_deriv=0e0_dp
+     !  forall (i = 1:size(phi)) third_deriv(i,i,i) = 6.e0_dp*lambda(i)*phi(i)
+ 
+     case(4)
+       third_deriv=0e0_dp
+ 
      case(14)
  
        !Multifield step potential
***************
*** 852,857 ****
--- 874,886 ----
            m2_V(ii)*abs(phi(ii))**(p_exp-3.0e0_dp)
        end do
  
+      case(18)
+      ! SMASH potential - see deriv. expressions in modpk_backgrnd
+        ii = locate(chiHarray,phi(1))
+        call polint(chiHarray(ii:ii+4), d3potHarray(ii:ii+4), &
+                          phi(1), third_deriv(1,1,1), derr(1))
+        ! print*,"third_deriv(1,1,1) = ", third_deriv(1,1,1), "derr(1)" , derr(1)
+ 
      case default
  
        print*, "MODECODE: potential_choice =", potential_choice
***************
*** 923,931 ****
      !
      real(dp) :: getEps
      real(dp), INTENT(IN) :: phi(:), dphi(:)
  
!     !MULTIFIELD
!     getEps = 0.5e0_dp*(M_Pl)**2 * dot_product(dphi,dphi)
  
      if (getEps >=3.0e0_dp) then
        print*, "MODECODE: epsilon =", getEps
--- 952,968 ----
      !
      real(dp) :: getEps
      real(dp), INTENT(IN) :: phi(:), dphi(:)
+     real(dp), dimension(size(phi)) ::  dVpot
+     real(dp) ::  Vpot
  
!     if (potential_choice == 18) then
!       Vpot = pot(phi)
!       dVpot = dVdphi(phi)
!       getEps = 0.5e0_dp*(dVpot(1)/Vpot)**2
!  	else
!       !MULTIFIELD
!       getEps = 0.5e0_dp*(M_Pl)**2 * dot_product(dphi,dphi)
! 	end if
  
      if (getEps >=3.0e0_dp) then
        print*, "MODECODE: epsilon =", getEps
