diff -rupN Pythia/examples/main_MDMSM_1.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/examples/main_MDMSM_1.cc
--- Pythia/examples/main_MDMSM_1.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/examples/main_MDMSM_1.cc	2021-03-08 16:53:53.175484915 +1000
@@ -0,0 +1,88 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+// File based on main25.cc in Pythia 8.149
+//==========================================================================
+
+#include "Pythia8/Pythia.h"
+#include "Sigma_MDMSM_gg_xchixchig.h"
+#include "Sigma_MDMSM_gg_xchixchi.h"
+#include "Sigma_MDMSM_gu_xchixchiu.h"
+#include "Sigma_MDMSM_gc_xchixchic.h"
+#include "Sigma_MDMSM_gd_xchixchid.h"
+#include "Sigma_MDMSM_gs_xchixchis.h"
+#include "Sigma_MDMSM_uux_xchixchig.h"
+#include "Sigma_MDMSM_ccx_xchixchig.h"
+#include "Sigma_MDMSM_ddx_xchixchig.h"
+#include "Sigma_MDMSM_ssx_xchixchig.h"
+
+using namespace Pythia8; 
+
+int main() 
+{
+
+  // Number of events to generate and to list. Max number of errors.
+  // Warning: generation of complete events is much slower than if you use
+  // PartonLevel:all = off to only get cross sections, so adjust nEvent.
+  int nEvent = 3000; 
+  int nAbort = 5; 
+
+  // Pythia generator.
+  Pythia pythia; 
+
+  // Read param_card file
+  pythia.readString("SLHA:file = ../Processes_MDMSM/param_card_MDMSM.dat"); 
+
+  // Provide process pointers to Pythia
+  pythia.setSigmaPtr(new Sigma_MDMSM_gg_xchixchig()); 
+  pythia.setSigmaPtr(new Sigma_MDMSM_gg_xchixchi()); 
+  pythia.setSigmaPtr(new Sigma_MDMSM_gu_xchixchiu()); 
+  pythia.setSigmaPtr(new Sigma_MDMSM_gc_xchixchic()); 
+  pythia.setSigmaPtr(new Sigma_MDMSM_gd_xchixchid()); 
+  pythia.setSigmaPtr(new Sigma_MDMSM_gs_xchixchis()); 
+  pythia.setSigmaPtr(new Sigma_MDMSM_uux_xchixchig()); 
+  pythia.setSigmaPtr(new Sigma_MDMSM_ccx_xchixchig()); 
+  pythia.setSigmaPtr(new Sigma_MDMSM_ddx_xchixchig()); 
+  pythia.setSigmaPtr(new Sigma_MDMSM_ssx_xchixchig()); 
+
+  // Phase space cut on pThat.
+  pythia.readString("PhaseSpace:pTHatMin = 20."); 
+
+  // Optionally only compare cross sections.
+  pythia.readString("PartonLevel:all = off"); 
+
+  // Initialization for LHC.
+  pythia.init(); 
+
+  // List changes.
+  pythia.settings.listChanged(); 
+  pythia.particleData.listChanged(); 
+
+  // Begin event loop.
+  int iAbort = 0; 
+  for (int iEvent = 0; iEvent < nEvent; ++ iEvent)
+  {
+    if (iEvent%(max(1, nEvent/20)) == 0)
+      cout <<  " Now begin event " << iEvent <<  "\n"; 
+
+    // Generate events. Quit if many failures.
+    if ( !pythia.next())
+    {
+      if (++ iAbort < nAbort)
+        continue; 
+      cout <<  " Event generation aborted prematurely, owing to error!\n"; 
+      break; 
+    }
+
+    // End of event loop.
+  }
+
+  // Final statistics.
+  pythia.stat(); 
+
+  // Done.
+  return 0; 
+}
+
diff -rupN Pythia/examples/Makefile_MDMSM_1 /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/examples/Makefile_MDMSM_1
--- Pythia/examples/Makefile_MDMSM_1	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/examples/Makefile_MDMSM_1	2021-03-08 16:53:53.175484915 +1000
@@ -0,0 +1,38 @@
+#==========================================================================
+# This file has been automatically generated for Pythia 8 by
+#  MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+#  By the MadGraph5_aMC@NLO Development Team
+#  Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+#==========================================================================
+
+SHELL = /bin/sh
+
+-include Makefile.inc
+
+# flags:
+#
+#FFLAGSSHARED = -fPIC
+CFLAGSSHARED = -fPIC
+CXXFLAGSSHARED = -fPIC
+
+# Location of directories.
+TMPDIR=../tmp
+INCDIR1=include
+INCDIR2=Processes_MDMSM
+SRCDIR=.
+LIBDIR=lib
+LIBDIRARCH=lib/archive
+PROCDIR=Processes_MDMSM
+
+all: $(targets) 
+
+CPPFLAGS= -I../$(INCDIR1) -I../$(INCDIR2)
+LIBS=-L../$(LIBDIRARCH) -L../lib -lpythia8 -l$(PROCDIR) -lz
+
+all: main_MDMSM_1
+
+main_MDMSM_1: main_MDMSM_1.o ../$(LIBDIRARCH)/lib$(PROCDIR).a
+	$(CXX) -o main_MDMSM_1 main_MDMSM_1.o $(LIBS)
+
+../$(LIBDIRARCH)/lib$(PROCDIR).a: ../$(PROCDIR)/Makefile
+	cd ../$(PROCDIR); make
diff -rupN Pythia/include/HelAmps_MDMSM.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/HelAmps_MDMSM.h
--- Pythia/include/HelAmps_MDMSM.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/HelAmps_MDMSM.h	2021-03-08 16:53:51.879413963 +1000
@@ -0,0 +1,853 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef HelAmps_MDMSM_H
+#define HelAmps_MDMSM_H
+
+#include <cmath> 
+#include <complex> 
+
+using namespace std; 
+
+namespace Pythia8_MDMSM 
+{
+void ixxxxx(double p[4], double fmass, int nhel, int nsf, std::complex<double>
+    fi[6]);
+
+void oxxxxx(double p[4], double fmass, int nhel, int nsf, std::complex<double>
+    fo[6]);
+
+void vxxxxx(double p[4], double vmass, int nhel, int nsv, std::complex<double>
+    v[6]);
+
+void sxxxxx(double p[4], int nss, std::complex<double> sc[3]); 
+
+double Sgn(double e, double f); 
+
+void txxxxx(double p[4], double tmass, int nhel, int nst, std::complex<double>
+    fi[18]);
+
+void VVVVS1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[]);
+
+void VVVS1_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void FFV3_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void FFV4C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void FFV5C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void FFS3_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void VVS2P0_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[]);
+
+void FFS4_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void FFV5_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void FFS5C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void VVVV5_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, std::complex<double> & vertex);
+
+void VVVVS1P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[]);
+
+void VVVV3P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[]);
+
+void VVVVS2P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[]);
+
+void FFS1C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void VVVV3_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void FFV4C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void FFS2C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+void FFS2_4C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[]);
+
+void FFS4_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void SSSS1_2(std::complex<double> S1[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> S2[]);
+
+void VVV1_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[]);
+
+void VVS1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void FFS2_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+void FFS2_4_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex);
+
+void FFV1C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void VVSS1P0_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void VVVVS2P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[]);
+
+void VSS1P0_1(std::complex<double> S2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[]);
+
+void VVSS1_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> S4[]);
+
+void FFV3C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void VVVVS2_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[]);
+
+void FFS5_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void FFS4C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVVV4P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[]);
+
+void VVS2_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void FFV1_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void SSS1_3(std::complex<double> S1[], std::complex<double> S2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void VVVVS3_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[]);
+
+void VVVV2_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, std::complex<double> & vertex);
+
+void VVSS1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> S3[]);
+
+void VVVV5P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void VSS1_0(std::complex<double> V1[], std::complex<double> S2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void FFS3C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void FFV2_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+void FFV2_5_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex);
+void FFV2_3_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex);
+void FFV2_4_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex);
+
+void VVVV1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, std::complex<double> & vertex);
+
+void FFS1_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void FFV2C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+void FFV2_5C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[]);
+void FFV2_3C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[]);
+void FFV2_4C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[]);
+
+void FFS5_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void VVVV4P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void VVVV4_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void FFV4_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void VVVS1P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void FFV2P0_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void FFS4P0_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void VVV1P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void VVVVS1_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[]);
+
+void VVVS1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S4[], std::complex<double>
+    COUP, std::complex<double> & vertex);
+
+void FFV3_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVVV2_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[]);
+
+void VVVV3_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[]);
+
+void FFS3_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void FFS3C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void FFV5_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void FFS1_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void FFS5C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void VVVV5_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[]);
+
+void VVVV4P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void VVVV3P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void FFS1C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void VVVVS1_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[]);
+
+void VVVVS3P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[]);
+
+void FFV3_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void FFV4C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVVV3_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[]);
+
+void FFS2C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+void FFS2_4C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex);
+
+void VVVVS2_5(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, double M5, double W5, std::complex<double> S5[]);
+
+void FFS4_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void SSSS1_1(std::complex<double> S2[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> S1[]);
+
+void VVV1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVS1_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[]);
+
+void FFS2_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+void FFS2_4_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[]);
+
+void FFS5C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void FFV1C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVS1P0_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[]);
+
+void VVVV3P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void VVVS1P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void VVVV2_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[]);
+
+void FFS2C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+void FFS2_4C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> S3[]);
+
+void FFV5C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVVV1_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[]);
+
+void VVVVS2_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    S5[], std::complex<double> COUP, std::complex<double> & vertex);
+
+void VVV1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void VVS1_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> V2[]);
+
+void FFS4C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void FFS2_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+void FFS2_4_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[]);
+
+void VVS2_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> V2[]);
+
+void FFV1C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void FFV1_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void VVVV3P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[]);
+
+void SSS1_0(std::complex<double> S1[], std::complex<double> S2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVVS1_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> S4[]);
+
+void VVVVS3_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    S5[], std::complex<double> COUP, std::complex<double> & vertex);
+
+void VVVV1P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void VVSS1_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void VSS1_1(std::complex<double> S2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[]);
+
+void VVVS1P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[]);
+
+void FFV2_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+void FFV2_5_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[]);
+void FFV2_3_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[]);
+void FFV2_4_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[]);
+
+void VVVV1_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void VVVVS2_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[]);
+
+void VVVVS1P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[]);
+
+void FFV2C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+void FFV2_5C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex);
+void FFV2_3C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex);
+void FFV2_4C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex);
+
+void FFS5_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void VVVV1P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[]);
+
+void VVVV4_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void FFV4_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVS2_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[]);
+
+void FFV2P0_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void VVV1P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> V2[]);
+
+void VVVVS1_5(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, double M5, double W5, std::complex<double> S5[]);
+
+void VVVS1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[]);
+
+void VVVVS1P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[]);
+
+void VVVV2_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void FFV5C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void VVSS1_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void FFS3_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VSS1_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> S2[]);
+
+void FFS3C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void FFV5_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void VVVV1_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void FFS1_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVVVS1P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[]);
+
+void FFV2C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+void FFV2_5C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[]);
+void FFV2_3C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[]);
+void FFV2_4C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[]);
+
+void VVVV5_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void VVVV4P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[]);
+
+void VVVV4_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[]);
+
+void FFV4_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void VVVVS2P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[]);
+
+void VVSS1P0_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void FFS1C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void VVV1P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[]);
+
+void VVVVS1_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[]);
+
+void VVVVS3P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[]);
+
+void FFV3_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void FFV4C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void VVVVS2_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[]);
+
+void FFS3_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void VVS2P0_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> V2[]);
+
+void FFS4_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void SSSS1_0(std::complex<double> S1[], std::complex<double> S2[],
+    std::complex<double> S3[], std::complex<double> S4[], std::complex<double>
+    COUP, std::complex<double> & vertex);
+
+void FFS1_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void VVVVS3_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[]);
+
+void FFS5C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVVV5_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void VVVVS2P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[]);
+
+void VVVV3_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, std::complex<double> & vertex);
+
+void FFV1P0_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void FFS1C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void VVVVS3P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[]);
+
+void VVVV2P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void FFS2C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+void FFS2_4C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[]);
+
+void VVVV1P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void FFV3C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void SSSS1_3(std::complex<double> S1[], std::complex<double> S2[],
+    std::complex<double> S4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> S3[]);
+
+void VVVVS3_5(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, double M5, double W5, std::complex<double> S5[]);
+
+void VVS1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void VVVVS1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    S5[], std::complex<double> COUP, std::complex<double> & vertex);
+
+void FFS4C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void FFS2_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+void FFS2_4_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> S3[]);
+
+void FFV1C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void VVV1_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> V2[]);
+
+void FFV1_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void SSS1_1(std::complex<double> S2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> S1[]);
+
+void VVVV1P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[]);
+
+void VVVVS3P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[]);
+
+void VVVV2P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void FFV2_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+void FFV2_5_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[]);
+void FFV2_3_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[]);
+void FFV2_4_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[]);
+
+void FFV3C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void VVVVS2_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[]);
+
+void FFS2P0_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void FFS5_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void FFS4C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+void VVVVS3_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[]);
+
+void VVVV4_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, std::complex<double> & vertex);
+
+void SSS1_2(std::complex<double> S1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> S2[]);
+
+void VVS2_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void FFV1_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[]);
+
+void FFV3C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void FFV5C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+
+void VVVS1_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[]);
+
+void VVVVS3_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[]);
+
+void VVVV2_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void VVVV3_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[]);
+
+void VVSS1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S3[], std::complex<double> S4[], std::complex<double>
+    COUP, std::complex<double> & vertex);
+
+void VSS1_3(std::complex<double> V1[], std::complex<double> S2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[]);
+
+void FFS3C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void FFV5_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex);
+
+void FFV2_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+void FFV2_5_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[]);
+void FFV2_3_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[]);
+void FFV2_4_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[]);
+
+void VVVV1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[]);
+
+void SSSS1_4(std::complex<double> S1[], std::complex<double> S2[],
+    std::complex<double> S3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> S4[]);
+
+void FFV2C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[]);
+void FFV2_5C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[]);
+void FFV2_3C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[]);
+void FFV2_4C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[]);
+
+void VVVV5_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[]);
+
+void VVVV4_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[]);
+
+void FFV4_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[]);
+
+}  // end namespace Pythia8_MDMSM
+
+#endif  // HelAmps_MDMSM_H
diff -rupN Pythia/include/Parameters_MDMSM.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Parameters_MDMSM.h
--- Pythia/include/Parameters_MDMSM.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Parameters_MDMSM.h	2021-03-08 16:53:53.011475940 +1000
@@ -0,0 +1,86 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_parameters_MDMSM_H
+#define Pythia8_parameters_MDMSM_H
+
+#include <complex> 
+
+#include "Pythia8/ParticleData.h"
+#include "Pythia8/StandardModel.h"
+#include "Pythia8/SusyLesHouches.h"
+
+using namespace std; 
+
+using namespace Pythia8; 
+
+class Parameters_MDMSM
+{
+  public:
+
+    static Parameters_MDMSM * getInstance(); 
+
+    // Model parameters independent of aS
+    std::complex<double> mdl_complexi, mdl_I1b11, mdl_I1b22, mdl_I1b33,
+        mdl_I2b11, mdl_I2b22, mdl_I2b33, mdl_I3b11, mdl_I3b22, mdl_I3b33,
+        mdl_I4b11, mdl_I4b22, mdl_I4b33;
+    double mdl_wY, mdl_Wchi, mdl_WH, mdl_WT, mdl_WW, mdl_WZ, mdl_mY, mdl_mchi,
+        mdl_MH, mdl_MB, mdl_MS, mdl_MD, mdl_MT, mdl_MC, mdl_MU, mdl_MTA,
+        mdl_MMU, mdl_Me, mdl_MZ, mdl_ymtau, mdl_ymm, mdl_yme, mdl_ymt, mdl_ymb,
+        mdl_ymc, mdl_yms, mdl_ymup, mdl_ymdo, mdl_Gf, aEWM1, mdl_gggY2,
+        mdl_gggY1, mdl_cY, mdl_gchi, ZERO, mdl_MZ__exp__2, mdl_MZ__exp__4,
+        mdl_sqrt__2, mdl_MH__exp__2, mdl_aEW, mdl_MW, mdl_sqrt__aEW, mdl_ee,
+        mdl_MW__exp__2, mdl_sw2, mdl_cw, mdl_sqrt__sw2, mdl_sw, mdl_g1, mdl_gw,
+        mdl_vev, mdl_vev__exp__2, mdl_lam, mdl_yb, mdl_yc, mdl_ydo, mdl_ye,
+        mdl_ym, mdl_ys, mdl_yt, mdl_ytau, mdl_yup, mdl_muH, mdl_ee__exp__2,
+        mdl_sw__exp__2, mdl_cw__exp__2;
+    // Model parameters dependent on aS
+    double aS, mdl_sqrt__aS, G, mdl_G__exp__2; 
+    // Model couplings independent of aS
+    std::complex<double> GC_13, GC_14, GC_1, GC_2, GC_3, GC_4, GC_5, GC_6,
+        GC_7, GC_8, GC_9, GC_17, GC_18, GC_19, GC_20, GC_21, GC_22, GC_23,
+        GC_24, GC_25, GC_26, GC_27, GC_28, GC_29, GC_30, GC_31, GC_32, GC_33,
+        GC_34, GC_35, GC_36, GC_37, GC_38, GC_39, GC_40, GC_41, GC_42, GC_43,
+        GC_44, GC_45, GC_46, GC_47, GC_48, GC_49, GC_50, GC_51, GC_52, GC_53,
+        GC_54, GC_55, GC_56, GC_57, GC_58, GC_59, GC_60, GC_61, GC_62, GC_63,
+        GC_64, GC_65, GC_66, GC_67, GC_68, GC_69, GC_70, GC_71, GC_72, GC_73,
+        GC_74, GC_75, GC_76, GC_77, GC_78, GC_79, GC_80, GC_81, GC_82, GC_83,
+        GC_84, GC_85, GC_86, GC_87, GC_88, GC_89, GC_90, GC_91, GC_92, GC_93,
+        GC_94, GC_95, GC_96, GC_97, GC_98, GC_99, GC_100, GC_101, GC_102;
+    // Model couplings dependent on aS
+    std::complex<double> GC_15, GC_11, GC_12, GC_16, GC_10; 
+
+    // Set parameters that are unchanged during the run
+    void setIndependentParameters(ParticleData * & pd, Couplings * & csm,
+        SusyLesHouches * & slhaPtr);
+    // Set couplings that are unchanged during the run
+    void setIndependentCouplings(); 
+    // Set parameters that are changed event by event
+    void setDependentParameters(ParticleData * & pd, Couplings * & csm,
+        SusyLesHouches * & slhaPtr, double alpS);
+    // TMP: hardcoded bogus implementation with no arguments since this
+    // is being called from within the matrix elements.
+    void setDependentParameters() {}; 
+
+    // Set couplings that are changed event by event
+    void setDependentCouplings(); 
+
+    // Print parameters that are unchanged during the run
+    void printIndependentParameters(); 
+    // Print couplings that are unchanged during the run
+    void printIndependentCouplings(); 
+    // Print parameters that are changed event by event
+    void printDependentParameters(); 
+    // Print couplings that are changed event by event
+    void printDependentCouplings(); 
+
+  private:
+    static Parameters_MDMSM * instance; 
+}; 
+
+#endif  // Pythia8_parameters_MDMSM_H
+
diff -rupN Pythia/include/Sigma_MDMSM_ccx_xchixchig.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_ccx_xchixchig.h
--- Pythia/include/Sigma_MDMSM_ccx_xchixchig.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_ccx_xchixchig.h	2021-03-08 16:53:44.375002482 +1000
@@ -0,0 +1,88 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_Sigma_MDMSM_ccx_xchixchig_H
+#define Pythia8_Sigma_MDMSM_ccx_xchixchig_H
+
+#include <complex> 
+
+#include "Pythia8/SigmaProcess.h"
+#include "Parameters_MDMSM.h"
+
+using namespace std; 
+
+namespace Pythia8 
+{
+//==========================================================================
+// A class for calculating the matrix elements for
+// Process: c c~ > ~chi ~chi g NP<=2 WEIGHTED<=3 @2
+//--------------------------------------------------------------------------
+
+class Sigma_MDMSM_ccx_xchixchig : public Sigma3Process 
+{
+  public:
+
+    // Constructor.
+    Sigma_MDMSM_ccx_xchixchig() {}
+
+    // Initialize process.
+    virtual void initProc(); 
+
+    // Calculate flavour-independent parts of cross section.
+    virtual void sigmaKin(); 
+
+    // Evaluate sigmaHat(sHat).
+    virtual double sigmaHat(); 
+
+    // Select flavour, colour and anticolour.
+    virtual void setIdColAcol(); 
+
+    // Evaluate weight for decay angles.
+    virtual double weightDecay(Event& process, int iResBeg, int iResEnd); 
+
+    // Info on the subprocess.
+    virtual string name() const {return "ccx_xchixchig (MDMSM)";}
+
+    virtual int code() const {return 10208;}
+
+    virtual string inFlux() const {return "qqbarSame";}
+    int id3Mass() const {return 52;}
+    int id4Mass() const {return 52;}
+    virtual int resonanceA() const {return 99902;}
+    // Tell Pythia that sigmaHat returns the ME^2
+    virtual bool convertM2() const {return true;}
+
+  private:
+
+    // Private functions to calculate the matrix element for all subprocesses
+    // Calculate wavefunctions
+    void calculate_wavefunctions(const int perm[], const int hel[]); 
+    static const int nwavefuncs = 7; 
+    std::complex<double> w[nwavefuncs][18]; 
+    static const int namplitudes = 1; 
+    std::complex<double> amp[namplitudes]; 
+    double matrix_2_ccx_xchixchig(); 
+
+    // Constants for array limits
+    static const int nexternal = 5; 
+    static const int nprocesses = 2; 
+
+    // Store the matrix element value from sigmaKin
+    double matrix_element[nprocesses]; 
+
+    // Color flows, used when selecting color
+    double * jamp2[nprocesses]; 
+
+    // Pointer to the model parameters
+    Parameters_MDMSM * pars; 
+
+}; 
+
+}  // end namespace Pythia8
+
+#endif  // Pythia8_Sigma_MDMSM_ccx_xchixchig_H
+
diff -rupN Pythia/include/Sigma_MDMSM_ddx_xchixchig.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_ddx_xchixchig.h
--- Pythia/include/Sigma_MDMSM_ddx_xchixchig.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_ddx_xchixchig.h	2021-03-08 16:53:44.423005118 +1000
@@ -0,0 +1,88 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_Sigma_MDMSM_ddx_xchixchig_H
+#define Pythia8_Sigma_MDMSM_ddx_xchixchig_H
+
+#include <complex> 
+
+#include "Pythia8/SigmaProcess.h"
+#include "Parameters_MDMSM.h"
+
+using namespace std; 
+
+namespace Pythia8 
+{
+//==========================================================================
+// A class for calculating the matrix elements for
+// Process: d d~ > ~chi ~chi g NP<=2 WEIGHTED<=3 @2
+//--------------------------------------------------------------------------
+
+class Sigma_MDMSM_ddx_xchixchig : public Sigma3Process 
+{
+  public:
+
+    // Constructor.
+    Sigma_MDMSM_ddx_xchixchig() {}
+
+    // Initialize process.
+    virtual void initProc(); 
+
+    // Calculate flavour-independent parts of cross section.
+    virtual void sigmaKin(); 
+
+    // Evaluate sigmaHat(sHat).
+    virtual double sigmaHat(); 
+
+    // Select flavour, colour and anticolour.
+    virtual void setIdColAcol(); 
+
+    // Evaluate weight for decay angles.
+    virtual double weightDecay(Event& process, int iResBeg, int iResEnd); 
+
+    // Info on the subprocess.
+    virtual string name() const {return "ddx_xchixchig (MDMSM)";}
+
+    virtual int code() const {return 10209;}
+
+    virtual string inFlux() const {return "qqbarSame";}
+    int id3Mass() const {return 52;}
+    int id4Mass() const {return 52;}
+    virtual int resonanceA() const {return 99902;}
+    // Tell Pythia that sigmaHat returns the ME^2
+    virtual bool convertM2() const {return true;}
+
+  private:
+
+    // Private functions to calculate the matrix element for all subprocesses
+    // Calculate wavefunctions
+    void calculate_wavefunctions(const int perm[], const int hel[]); 
+    static const int nwavefuncs = 7; 
+    std::complex<double> w[nwavefuncs][18]; 
+    static const int namplitudes = 1; 
+    std::complex<double> amp[namplitudes]; 
+    double matrix_2_ddx_xchixchig(); 
+
+    // Constants for array limits
+    static const int nexternal = 5; 
+    static const int nprocesses = 2; 
+
+    // Store the matrix element value from sigmaKin
+    double matrix_element[nprocesses]; 
+
+    // Color flows, used when selecting color
+    double * jamp2[nprocesses]; 
+
+    // Pointer to the model parameters
+    Parameters_MDMSM * pars; 
+
+}; 
+
+}  // end namespace Pythia8
+
+#endif  // Pythia8_Sigma_MDMSM_ddx_xchixchig_H
+
diff -rupN Pythia/include/Sigma_MDMSM_gc_xchixchic.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gc_xchixchic.h
--- Pythia/include/Sigma_MDMSM_gc_xchixchic.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gc_xchixchic.h	2021-03-08 16:53:44.102987547 +1000
@@ -0,0 +1,91 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_Sigma_MDMSM_gc_xchixchic_H
+#define Pythia8_Sigma_MDMSM_gc_xchixchic_H
+
+#include <complex> 
+
+#include "Pythia8/SigmaProcess.h"
+#include "Parameters_MDMSM.h"
+
+using namespace std; 
+
+namespace Pythia8 
+{
+//==========================================================================
+// A class for calculating the matrix elements for
+// Process: g c > ~chi ~chi c NP<=2 WEIGHTED<=3 @2
+// Process: g c~ > ~chi ~chi c~ NP<=2 WEIGHTED<=3 @2
+//--------------------------------------------------------------------------
+
+class Sigma_MDMSM_gc_xchixchic : public Sigma3Process 
+{
+  public:
+
+    // Constructor.
+    Sigma_MDMSM_gc_xchixchic() {}
+
+    // Initialize process.
+    virtual void initProc(); 
+
+    // Calculate flavour-independent parts of cross section.
+    virtual void sigmaKin(); 
+
+    // Evaluate sigmaHat(sHat).
+    virtual double sigmaHat(); 
+
+    // Select flavour, colour and anticolour.
+    virtual void setIdColAcol(); 
+
+    // Evaluate weight for decay angles.
+    virtual double weightDecay(Event& process, int iResBeg, int iResEnd); 
+
+    // Info on the subprocess.
+    virtual string name() const {return "gc_xchixchic (MDMSM)";}
+
+    virtual int code() const {return 10204;}
+
+    virtual string inFlux() const {return "qg";}
+    int id3Mass() const {return 52;}
+    int id4Mass() const {return 52;}
+    int id5Mass() const {return 4;}
+    virtual int resonanceA() const {return 99902;}
+    // Tell Pythia that sigmaHat returns the ME^2
+    virtual bool convertM2() const {return true;}
+
+  private:
+
+    // Private functions to calculate the matrix element for all subprocesses
+    // Calculate wavefunctions
+    void calculate_wavefunctions(const int perm[], const int hel[]); 
+    static const int nwavefuncs = 10; 
+    std::complex<double> w[nwavefuncs][18]; 
+    static const int namplitudes = 2; 
+    std::complex<double> amp[namplitudes]; 
+    double matrix_2_gc_xchixchic(); 
+    double matrix_2_gcx_xchixchicx(); 
+
+    // Constants for array limits
+    static const int nexternal = 5; 
+    static const int nprocesses = 4; 
+
+    // Store the matrix element value from sigmaKin
+    double matrix_element[nprocesses]; 
+
+    // Color flows, used when selecting color
+    double * jamp2[nprocesses]; 
+
+    // Pointer to the model parameters
+    Parameters_MDMSM * pars; 
+
+}; 
+
+}  // end namespace Pythia8
+
+#endif  // Pythia8_Sigma_MDMSM_gc_xchixchic_H
+
diff -rupN Pythia/include/Sigma_MDMSM_gd_xchixchid.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gd_xchixchid.h
--- Pythia/include/Sigma_MDMSM_gd_xchixchid.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gd_xchixchid.h	2021-03-08 16:53:44.178991720 +1000
@@ -0,0 +1,91 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_Sigma_MDMSM_gd_xchixchid_H
+#define Pythia8_Sigma_MDMSM_gd_xchixchid_H
+
+#include <complex> 
+
+#include "Pythia8/SigmaProcess.h"
+#include "Parameters_MDMSM.h"
+
+using namespace std; 
+
+namespace Pythia8 
+{
+//==========================================================================
+// A class for calculating the matrix elements for
+// Process: g d > ~chi ~chi d NP<=2 WEIGHTED<=3 @2
+// Process: g d~ > ~chi ~chi d~ NP<=2 WEIGHTED<=3 @2
+//--------------------------------------------------------------------------
+
+class Sigma_MDMSM_gd_xchixchid : public Sigma3Process 
+{
+  public:
+
+    // Constructor.
+    Sigma_MDMSM_gd_xchixchid() {}
+
+    // Initialize process.
+    virtual void initProc(); 
+
+    // Calculate flavour-independent parts of cross section.
+    virtual void sigmaKin(); 
+
+    // Evaluate sigmaHat(sHat).
+    virtual double sigmaHat(); 
+
+    // Select flavour, colour and anticolour.
+    virtual void setIdColAcol(); 
+
+    // Evaluate weight for decay angles.
+    virtual double weightDecay(Event& process, int iResBeg, int iResEnd); 
+
+    // Info on the subprocess.
+    virtual string name() const {return "gd_xchixchid (MDMSM)";}
+
+    virtual int code() const {return 10205;}
+
+    virtual string inFlux() const {return "qg";}
+    int id3Mass() const {return 52;}
+    int id4Mass() const {return 52;}
+    int id5Mass() const {return 1;}
+    virtual int resonanceA() const {return 99902;}
+    // Tell Pythia that sigmaHat returns the ME^2
+    virtual bool convertM2() const {return true;}
+
+  private:
+
+    // Private functions to calculate the matrix element for all subprocesses
+    // Calculate wavefunctions
+    void calculate_wavefunctions(const int perm[], const int hel[]); 
+    static const int nwavefuncs = 10; 
+    std::complex<double> w[nwavefuncs][18]; 
+    static const int namplitudes = 2; 
+    std::complex<double> amp[namplitudes]; 
+    double matrix_2_gd_xchixchid(); 
+    double matrix_2_gdx_xchixchidx(); 
+
+    // Constants for array limits
+    static const int nexternal = 5; 
+    static const int nprocesses = 4; 
+
+    // Store the matrix element value from sigmaKin
+    double matrix_element[nprocesses]; 
+
+    // Color flows, used when selecting color
+    double * jamp2[nprocesses]; 
+
+    // Pointer to the model parameters
+    Parameters_MDMSM * pars; 
+
+}; 
+
+}  // end namespace Pythia8
+
+#endif  // Pythia8_Sigma_MDMSM_gd_xchixchid_H
+
diff -rupN Pythia/include/Sigma_MDMSM_gg_xchixchig.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gg_xchixchig.h
--- Pythia/include/Sigma_MDMSM_gg_xchixchig.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gg_xchixchig.h	2021-03-08 16:53:43.926977881 +1000
@@ -0,0 +1,88 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_Sigma_MDMSM_gg_xchixchig_H
+#define Pythia8_Sigma_MDMSM_gg_xchixchig_H
+
+#include <complex> 
+
+#include "Pythia8/SigmaProcess.h"
+#include "Parameters_MDMSM.h"
+
+using namespace std; 
+
+namespace Pythia8 
+{
+//==========================================================================
+// A class for calculating the matrix elements for
+// Process: g g > ~chi ~chi g NP<=2 WEIGHTED<=3 @2
+//--------------------------------------------------------------------------
+
+class Sigma_MDMSM_gg_xchixchig : public Sigma3Process 
+{
+  public:
+
+    // Constructor.
+    Sigma_MDMSM_gg_xchixchig() {}
+
+    // Initialize process.
+    virtual void initProc(); 
+
+    // Calculate flavour-independent parts of cross section.
+    virtual void sigmaKin(); 
+
+    // Evaluate sigmaHat(sHat).
+    virtual double sigmaHat(); 
+
+    // Select flavour, colour and anticolour.
+    virtual void setIdColAcol(); 
+
+    // Evaluate weight for decay angles.
+    virtual double weightDecay(Event& process, int iResBeg, int iResEnd); 
+
+    // Info on the subprocess.
+    virtual string name() const {return "gg_xchixchig (MDMSM)";}
+
+    virtual int code() const {return 10201;}
+
+    virtual string inFlux() const {return "gg";}
+    int id3Mass() const {return 52;}
+    int id4Mass() const {return 52;}
+    virtual int resonanceA() const {return 99902;}
+    // Tell Pythia that sigmaHat returns the ME^2
+    virtual bool convertM2() const {return true;}
+
+  private:
+
+    // Private functions to calculate the matrix element for all subprocesses
+    // Calculate wavefunctions
+    void calculate_wavefunctions(const int perm[], const int hel[]); 
+    static const int nwavefuncs = 10; 
+    std::complex<double> w[nwavefuncs][18]; 
+    static const int namplitudes = 4; 
+    std::complex<double> amp[namplitudes]; 
+    double matrix_2_gg_xchixchig(); 
+
+    // Constants for array limits
+    static const int nexternal = 5; 
+    static const int nprocesses = 1; 
+
+    // Store the matrix element value from sigmaKin
+    double matrix_element[nprocesses]; 
+
+    // Color flows, used when selecting color
+    double * jamp2[nprocesses]; 
+
+    // Pointer to the model parameters
+    Parameters_MDMSM * pars; 
+
+}; 
+
+}  // end namespace Pythia8
+
+#endif  // Pythia8_Sigma_MDMSM_gg_xchixchig_H
+
diff -rupN Pythia/include/Sigma_MDMSM_gg_xchixchi.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gg_xchixchi.h
--- Pythia/include/Sigma_MDMSM_gg_xchixchi.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gg_xchixchi.h	2021-03-08 16:53:43.978980737 +1000
@@ -0,0 +1,90 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_Sigma_MDMSM_gg_xchixchi_H
+#define Pythia8_Sigma_MDMSM_gg_xchixchi_H
+
+#include <complex> 
+
+#include "Pythia8/SigmaProcess.h"
+#include "Parameters_MDMSM.h"
+
+using namespace std; 
+
+namespace Pythia8 
+{
+//==========================================================================
+// A class for calculating the matrix elements for
+// Process: g g > ~chi ~chi NP<=2 WEIGHTED<=2 @1
+//--------------------------------------------------------------------------
+
+class Sigma_MDMSM_gg_xchixchi : public Sigma2Process 
+{
+  public:
+
+    // Constructor.
+    Sigma_MDMSM_gg_xchixchi() {}
+
+    // Initialize process.
+    virtual void initProc(); 
+
+    // Calculate flavour-independent parts of cross section.
+    virtual void sigmaKin(); 
+
+    // Evaluate sigmaHat(sHat).
+    virtual double sigmaHat(); 
+
+    // Select flavour, colour and anticolour.
+    virtual void setIdColAcol(); 
+
+    // Evaluate weight for decay angles.
+    virtual double weightDecay(Event& process, int iResBeg, int iResEnd); 
+
+    // Info on the subprocess.
+    virtual string name() const {return "gg_xchixchi (MDMSM)";}
+
+    virtual int code() const {return 10102;}
+
+    virtual string inFlux() const {return "gg";}
+    int id3Mass() const {return 52;}
+    int id4Mass() const {return 52;}
+    virtual int resonanceA() const {return 99902;}
+    virtual bool isSChannel() const {return true;}
+    virtual int idSChannel() const {return 99902;}
+    // Tell Pythia that sigmaHat returns the ME^2
+    virtual bool convertM2() const {return true;}
+
+  private:
+
+    // Private functions to calculate the matrix element for all subprocesses
+    // Calculate wavefunctions
+    void calculate_wavefunctions(const int perm[], const int hel[]); 
+    static const int nwavefuncs = 5; 
+    std::complex<double> w[nwavefuncs][18]; 
+    static const int namplitudes = 1; 
+    std::complex<double> amp[namplitudes]; 
+    double matrix_1_gg_xchixchi(); 
+
+    // Constants for array limits
+    static const int nexternal = 4; 
+    static const int nprocesses = 1; 
+
+    // Store the matrix element value from sigmaKin
+    double matrix_element[nprocesses]; 
+
+    // Color flows, used when selecting color
+    double * jamp2[nprocesses]; 
+
+    // Pointer to the model parameters
+    Parameters_MDMSM * pars; 
+
+}; 
+
+}  // end namespace Pythia8
+
+#endif  // Pythia8_Sigma_MDMSM_gg_xchixchi_H
+
diff -rupN Pythia/include/Sigma_MDMSM_gs_xchixchis.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gs_xchixchis.h
--- Pythia/include/Sigma_MDMSM_gs_xchixchis.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gs_xchixchis.h	2021-03-08 16:53:44.254995893 +1000
@@ -0,0 +1,91 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_Sigma_MDMSM_gs_xchixchis_H
+#define Pythia8_Sigma_MDMSM_gs_xchixchis_H
+
+#include <complex> 
+
+#include "Pythia8/SigmaProcess.h"
+#include "Parameters_MDMSM.h"
+
+using namespace std; 
+
+namespace Pythia8 
+{
+//==========================================================================
+// A class for calculating the matrix elements for
+// Process: g s > ~chi ~chi s NP<=2 WEIGHTED<=3 @2
+// Process: g s~ > ~chi ~chi s~ NP<=2 WEIGHTED<=3 @2
+//--------------------------------------------------------------------------
+
+class Sigma_MDMSM_gs_xchixchis : public Sigma3Process 
+{
+  public:
+
+    // Constructor.
+    Sigma_MDMSM_gs_xchixchis() {}
+
+    // Initialize process.
+    virtual void initProc(); 
+
+    // Calculate flavour-independent parts of cross section.
+    virtual void sigmaKin(); 
+
+    // Evaluate sigmaHat(sHat).
+    virtual double sigmaHat(); 
+
+    // Select flavour, colour and anticolour.
+    virtual void setIdColAcol(); 
+
+    // Evaluate weight for decay angles.
+    virtual double weightDecay(Event& process, int iResBeg, int iResEnd); 
+
+    // Info on the subprocess.
+    virtual string name() const {return "gs_xchixchis (MDMSM)";}
+
+    virtual int code() const {return 10206;}
+
+    virtual string inFlux() const {return "qg";}
+    int id3Mass() const {return 52;}
+    int id4Mass() const {return 52;}
+    int id5Mass() const {return 3;}
+    virtual int resonanceA() const {return 99902;}
+    // Tell Pythia that sigmaHat returns the ME^2
+    virtual bool convertM2() const {return true;}
+
+  private:
+
+    // Private functions to calculate the matrix element for all subprocesses
+    // Calculate wavefunctions
+    void calculate_wavefunctions(const int perm[], const int hel[]); 
+    static const int nwavefuncs = 10; 
+    std::complex<double> w[nwavefuncs][18]; 
+    static const int namplitudes = 2; 
+    std::complex<double> amp[namplitudes]; 
+    double matrix_2_gs_xchixchis(); 
+    double matrix_2_gsx_xchixchisx(); 
+
+    // Constants for array limits
+    static const int nexternal = 5; 
+    static const int nprocesses = 4; 
+
+    // Store the matrix element value from sigmaKin
+    double matrix_element[nprocesses]; 
+
+    // Color flows, used when selecting color
+    double * jamp2[nprocesses]; 
+
+    // Pointer to the model parameters
+    Parameters_MDMSM * pars; 
+
+}; 
+
+}  // end namespace Pythia8
+
+#endif  // Pythia8_Sigma_MDMSM_gs_xchixchis_H
+
diff -rupN Pythia/include/Sigma_MDMSM_gu_xchixchiu.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gu_xchixchiu.h
--- Pythia/include/Sigma_MDMSM_gu_xchixchiu.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_gu_xchixchiu.h	2021-03-08 16:53:44.026983374 +1000
@@ -0,0 +1,91 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_Sigma_MDMSM_gu_xchixchiu_H
+#define Pythia8_Sigma_MDMSM_gu_xchixchiu_H
+
+#include <complex> 
+
+#include "Pythia8/SigmaProcess.h"
+#include "Parameters_MDMSM.h"
+
+using namespace std; 
+
+namespace Pythia8 
+{
+//==========================================================================
+// A class for calculating the matrix elements for
+// Process: g u > ~chi ~chi u NP<=2 WEIGHTED<=3 @2
+// Process: g u~ > ~chi ~chi u~ NP<=2 WEIGHTED<=3 @2
+//--------------------------------------------------------------------------
+
+class Sigma_MDMSM_gu_xchixchiu : public Sigma3Process 
+{
+  public:
+
+    // Constructor.
+    Sigma_MDMSM_gu_xchixchiu() {}
+
+    // Initialize process.
+    virtual void initProc(); 
+
+    // Calculate flavour-independent parts of cross section.
+    virtual void sigmaKin(); 
+
+    // Evaluate sigmaHat(sHat).
+    virtual double sigmaHat(); 
+
+    // Select flavour, colour and anticolour.
+    virtual void setIdColAcol(); 
+
+    // Evaluate weight for decay angles.
+    virtual double weightDecay(Event& process, int iResBeg, int iResEnd); 
+
+    // Info on the subprocess.
+    virtual string name() const {return "gu_xchixchiu (MDMSM)";}
+
+    virtual int code() const {return 10203;}
+
+    virtual string inFlux() const {return "qg";}
+    int id3Mass() const {return 52;}
+    int id4Mass() const {return 52;}
+    int id5Mass() const {return 2;}
+    virtual int resonanceA() const {return 99902;}
+    // Tell Pythia that sigmaHat returns the ME^2
+    virtual bool convertM2() const {return true;}
+
+  private:
+
+    // Private functions to calculate the matrix element for all subprocesses
+    // Calculate wavefunctions
+    void calculate_wavefunctions(const int perm[], const int hel[]); 
+    static const int nwavefuncs = 10; 
+    std::complex<double> w[nwavefuncs][18]; 
+    static const int namplitudes = 2; 
+    std::complex<double> amp[namplitudes]; 
+    double matrix_2_gu_xchixchiu(); 
+    double matrix_2_gux_xchixchiux(); 
+
+    // Constants for array limits
+    static const int nexternal = 5; 
+    static const int nprocesses = 4; 
+
+    // Store the matrix element value from sigmaKin
+    double matrix_element[nprocesses]; 
+
+    // Color flows, used when selecting color
+    double * jamp2[nprocesses]; 
+
+    // Pointer to the model parameters
+    Parameters_MDMSM * pars; 
+
+}; 
+
+}  // end namespace Pythia8
+
+#endif  // Pythia8_Sigma_MDMSM_gu_xchixchiu_H
+
diff -rupN Pythia/include/Sigma_MDMSM_ssx_xchixchig.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_ssx_xchixchig.h
--- Pythia/include/Sigma_MDMSM_ssx_xchixchig.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_ssx_xchixchig.h	2021-03-08 16:53:44.479008192 +1000
@@ -0,0 +1,88 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_Sigma_MDMSM_ssx_xchixchig_H
+#define Pythia8_Sigma_MDMSM_ssx_xchixchig_H
+
+#include <complex> 
+
+#include "Pythia8/SigmaProcess.h"
+#include "Parameters_MDMSM.h"
+
+using namespace std; 
+
+namespace Pythia8 
+{
+//==========================================================================
+// A class for calculating the matrix elements for
+// Process: s s~ > ~chi ~chi g NP<=2 WEIGHTED<=3 @2
+//--------------------------------------------------------------------------
+
+class Sigma_MDMSM_ssx_xchixchig : public Sigma3Process 
+{
+  public:
+
+    // Constructor.
+    Sigma_MDMSM_ssx_xchixchig() {}
+
+    // Initialize process.
+    virtual void initProc(); 
+
+    // Calculate flavour-independent parts of cross section.
+    virtual void sigmaKin(); 
+
+    // Evaluate sigmaHat(sHat).
+    virtual double sigmaHat(); 
+
+    // Select flavour, colour and anticolour.
+    virtual void setIdColAcol(); 
+
+    // Evaluate weight for decay angles.
+    virtual double weightDecay(Event& process, int iResBeg, int iResEnd); 
+
+    // Info on the subprocess.
+    virtual string name() const {return "ssx_xchixchig (MDMSM)";}
+
+    virtual int code() const {return 10210;}
+
+    virtual string inFlux() const {return "qqbarSame";}
+    int id3Mass() const {return 52;}
+    int id4Mass() const {return 52;}
+    virtual int resonanceA() const {return 99902;}
+    // Tell Pythia that sigmaHat returns the ME^2
+    virtual bool convertM2() const {return true;}
+
+  private:
+
+    // Private functions to calculate the matrix element for all subprocesses
+    // Calculate wavefunctions
+    void calculate_wavefunctions(const int perm[], const int hel[]); 
+    static const int nwavefuncs = 7; 
+    std::complex<double> w[nwavefuncs][18]; 
+    static const int namplitudes = 1; 
+    std::complex<double> amp[namplitudes]; 
+    double matrix_2_ssx_xchixchig(); 
+
+    // Constants for array limits
+    static const int nexternal = 5; 
+    static const int nprocesses = 2; 
+
+    // Store the matrix element value from sigmaKin
+    double matrix_element[nprocesses]; 
+
+    // Color flows, used when selecting color
+    double * jamp2[nprocesses]; 
+
+    // Pointer to the model parameters
+    Parameters_MDMSM * pars; 
+
+}; 
+
+}  // end namespace Pythia8
+
+#endif  // Pythia8_Sigma_MDMSM_ssx_xchixchig_H
+
diff -rupN Pythia/include/Sigma_MDMSM_uux_xchixchig.h /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_uux_xchixchig.h
--- Pythia/include/Sigma_MDMSM_uux_xchixchig.h	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/include/Sigma_MDMSM_uux_xchixchig.h	2021-03-08 16:53:44.322999627 +1000
@@ -0,0 +1,88 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#ifndef Pythia8_Sigma_MDMSM_uux_xchixchig_H
+#define Pythia8_Sigma_MDMSM_uux_xchixchig_H
+
+#include <complex> 
+
+#include "Pythia8/SigmaProcess.h"
+#include "Parameters_MDMSM.h"
+
+using namespace std; 
+
+namespace Pythia8 
+{
+//==========================================================================
+// A class for calculating the matrix elements for
+// Process: u u~ > ~chi ~chi g NP<=2 WEIGHTED<=3 @2
+//--------------------------------------------------------------------------
+
+class Sigma_MDMSM_uux_xchixchig : public Sigma3Process 
+{
+  public:
+
+    // Constructor.
+    Sigma_MDMSM_uux_xchixchig() {}
+
+    // Initialize process.
+    virtual void initProc(); 
+
+    // Calculate flavour-independent parts of cross section.
+    virtual void sigmaKin(); 
+
+    // Evaluate sigmaHat(sHat).
+    virtual double sigmaHat(); 
+
+    // Select flavour, colour and anticolour.
+    virtual void setIdColAcol(); 
+
+    // Evaluate weight for decay angles.
+    virtual double weightDecay(Event& process, int iResBeg, int iResEnd); 
+
+    // Info on the subprocess.
+    virtual string name() const {return "uux_xchixchig (MDMSM)";}
+
+    virtual int code() const {return 10207;}
+
+    virtual string inFlux() const {return "qqbarSame";}
+    int id3Mass() const {return 52;}
+    int id4Mass() const {return 52;}
+    virtual int resonanceA() const {return 99902;}
+    // Tell Pythia that sigmaHat returns the ME^2
+    virtual bool convertM2() const {return true;}
+
+  private:
+
+    // Private functions to calculate the matrix element for all subprocesses
+    // Calculate wavefunctions
+    void calculate_wavefunctions(const int perm[], const int hel[]); 
+    static const int nwavefuncs = 7; 
+    std::complex<double> w[nwavefuncs][18]; 
+    static const int namplitudes = 1; 
+    std::complex<double> amp[namplitudes]; 
+    double matrix_2_uux_xchixchig(); 
+
+    // Constants for array limits
+    static const int nexternal = 5; 
+    static const int nprocesses = 2; 
+
+    // Store the matrix element value from sigmaKin
+    double matrix_element[nprocesses]; 
+
+    // Color flows, used when selecting color
+    double * jamp2[nprocesses]; 
+
+    // Pointer to the model parameters
+    Parameters_MDMSM * pars; 
+
+}; 
+
+}  // end namespace Pythia8
+
+#endif  // Pythia8_Sigma_MDMSM_uux_xchixchig_H
+
diff -rupN Pythia/share/Pythia8/xmldoc/Index.xml /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/share/Pythia8/xmldoc/Index.xml
--- Pythia/share/Pythia8/xmldoc/Index.xml	2015-09-24 01:35:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/share/Pythia8/xmldoc/Index.xml	2021-03-08 16:53:53.547505274 +1000
@@ -39,6 +39,8 @@
 <aidx href="HiggsProcesses">Higgs</aidx><br/> 
 &nbsp;&nbsp;--&nbsp;&nbsp; 
 <aidx href="SUSYProcesses">SUSY</aidx><br/> 
+&nbsp;&nbsp;--&nbsp;&nbsp;
+<aidx href="MDMSMProcesses">MDMSM</aidx><br/>
 &nbsp;&nbsp;--&nbsp;&nbsp; 
 <aidx href="NewGaugeBosonProcesses">New Gauge Bosons</aidx><br/> 
 &nbsp;&nbsp;--&nbsp;&nbsp; 
diff -rupN Pythia/share/Pythia8/xmldoc/MDMSMProcesses.xml /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/share/Pythia8/xmldoc/MDMSMProcesses.xml
--- Pythia/share/Pythia8/xmldoc/MDMSMProcesses.xml	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/share/Pythia8/xmldoc/MDMSMProcesses.xml	2021-03-08 16:53:53.547505274 +1000
@@ -0,0 +1,43 @@
+<flag name="MDMSM:all" default="off">
+Common switch for production of MDMSM processes. Added by GAMBIT.
+</flag>
+
+<flag name="MDMSM:gd2xchixchid" default="off">
+Switch for MDMSM process <ei>g d &rarr; ~chi ~chi d NP<=2<\ei>. Added by GAMBIT.
+</flag>
+
+<flag name="MDMSM:uux2xchixchig" default="off">
+Switch for MDMSM process <ei>u u~ &rarr; ~chi ~chi g NP<=2<\ei>. Added by GAMBIT.
+</flag>
+
+<flag name="MDMSM:gs2xchixchis" default="off">
+Switch for MDMSM process <ei>g s &rarr; ~chi ~chi s NP<=2<\ei>. Added by GAMBIT.
+</flag>
+
+<flag name="MDMSM:ddx2xchixchig" default="off">
+Switch for MDMSM process <ei>d d~ &rarr; ~chi ~chi g NP<=2<\ei>. Added by GAMBIT.
+</flag>
+
+<flag name="MDMSM:gu2xchixchiu" default="off">
+Switch for MDMSM process <ei>g u &rarr; ~chi ~chi u NP<=2<\ei>. Added by GAMBIT.
+</flag>
+
+<flag name="MDMSM:gg2xchixchig" default="off">
+Switch for MDMSM process <ei>g g &rarr; ~chi ~chi g NP<=2<\ei>. Added by GAMBIT.
+</flag>
+
+<flag name="MDMSM:gc2xchixchic" default="off">
+Switch for MDMSM process <ei>g c &rarr; ~chi ~chi c NP<=2<\ei>. Added by GAMBIT.
+</flag>
+
+<flag name="MDMSM:gg2xchixchi" default="off">
+Switch for MDMSM process <ei>g g &rarr; ~chi ~chi NP<=2<\ei>. Added by GAMBIT.
+</flag>
+
+<flag name="MDMSM:ssx2xchixchig" default="off">
+Switch for MDMSM process <ei>s s~ &rarr; ~chi ~chi g NP<=2<\ei>. Added by GAMBIT.
+</flag>
+
+<flag name="MDMSM:ccx2xchixchig" default="off">
+Switch for MDMSM process <ei>c c~ &rarr; ~chi ~chi g NP<=2<\ei>. Added by GAMBIT.
+</flag>
diff -rupN Pythia/src/HelAmps_MDMSM.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/HelAmps_MDMSM.cc
--- Pythia/src/HelAmps_MDMSM.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/HelAmps_MDMSM.cc	2021-03-08 16:53:52.999475283 +1000
@@ -0,0 +1,6867 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "HelAmps_MDMSM.h"
+#include <complex> 
+#include <cmath> 
+#include <iostream> 
+#include <cstdlib> 
+using namespace std; 
+
+namespace Pythia8_MDMSM 
+{
+
+
+double Sgn(double a, double b)
+{
+  return (b < 0)? - abs(a):abs(a); 
+}
+
+void sxxxxx(double p[4], int nss, complex<double> sc[3])
+{
+  sc[2] = complex<double> (1.00, 0.00); 
+  sc[0] = complex<double> (p[0] * nss, p[3] * nss); 
+  sc[1] = complex<double> (p[1] * nss, p[2] * nss); 
+  return; 
+}
+
+
+void txxxxx(double p[4], double tmass, int nhel, int nst, complex<double>
+    tc[18])
+{
+  complex<double> ft[6][4], ep[4], em[4], e0[4]; 
+  double pt, pt2, pp, pzpt, emp, sqh, sqs; 
+  int i, j; 
+
+  sqh = sqrt(0.5); 
+  sqs = sqrt(0.5/3); 
+
+  pt2 = p[1] * p[1] + p[2] * p[2]; 
+  pp = min(p[0], sqrt(pt2 + p[3] * p[3])); 
+  pt = min(pp, sqrt(pt2)); 
+
+  ft[4][0] = complex<double> (p[0] * nst, p[3] * nst); 
+  ft[5][0] = complex<double> (p[1] * nst, p[2] * nst); 
+
+  // construct eps+
+  if(nhel >= 0)
+  {
+    if(pp == 0)
+    {
+      ep[0] = complex<double> (0, 0); 
+      ep[1] = complex<double> (-sqh, 0); 
+      ep[2] = complex<double> (0, nst * sqh); 
+      ep[3] = complex<double> (0, 0); 
+    }
+    else
+    {
+      ep[0] = complex<double> (0, 0); 
+      ep[3] = complex<double> (pt/pp * sqh, 0); 
+
+      if(pt != 0)
+      {
+        pzpt = p[3]/(pp * pt) * sqh; 
+        ep[1] = complex<double> (-p[1] * pzpt, -nst * p[2]/pt * sqh); 
+        ep[2] = complex<double> (-p[2] * pzpt, nst * p[1]/pt * sqh); 
+      }
+      else
+      {
+        ep[1] = complex<double> (-sqh, 0); 
+        ep[2] = complex<double> (0, nst * Sgn(sqh, p[3])); 
+      }
+    }
+
+  }
+
+  // construct eps-
+  if(nhel <= 0)
+  {
+    if(pp == 0)
+    {
+      em[0] = complex<double> (0, 0); 
+      em[1] = complex<double> (sqh, 0); 
+      em[2] = complex<double> (0, nst * sqh); 
+      em[3] = complex<double> (0, 0); 
+    }
+    else
+    {
+      em[0] = complex<double> (0, 0); 
+      em[3] = complex<double> (-pt/pp * sqh, 0); 
+
+      if(pt != 0)
+      {
+        pzpt = -p[3]/(pp * pt) * sqh; 
+        em[1] = complex<double> (-p[1] * pzpt, -nst * p[2]/pt * sqh); 
+        em[2] = complex<double> (-p[2] * pzpt, nst * p[1]/pt * sqh); 
+      }
+      else
+      {
+        em[1] = complex<double> (sqh, 0); 
+        em[2] = complex<double> (0, nst * Sgn(sqh, p[3])); 
+      }
+    }
+  }
+
+  // construct eps0
+  if(std::labs(nhel) <= 1)
+  {
+    if(pp == 0)
+    {
+      e0[0] = complex<double> (0, 0); 
+      e0[1] = complex<double> (0, 0); 
+      e0[2] = complex<double> (0, 0); 
+      e0[3] = complex<double> (1, 0); 
+    }
+    else
+    {
+      emp = p[0]/(tmass * pp); 
+      e0[0] = complex<double> (pp/tmass, 0); 
+      e0[3] = complex<double> (p[3] * emp, 0); 
+
+      if(pt != 0)
+      {
+        e0[1] = complex<double> (p[1] * emp, 0); 
+        e0[2] = complex<double> (p[2] * emp, 0); 
+      }
+      else
+      {
+        e0[1] = complex<double> (0, 0); 
+        e0[2] = complex<double> (0, 0); 
+      }
+    }
+  }
+
+  if(nhel == 2)
+  {
+    for(j = 0; j < 4; j++ )
+    {
+      for(i = 0; i < 4; i++ )
+        ft[i][j] = ep[i] * ep[j]; 
+    }
+  }
+  else if(nhel == -2)
+  {
+    for(j = 0; j < 4; j++ )
+    {
+      for(i = 0; i < 4; i++ )
+        ft[i][j] = em[i] * em[j]; 
+    }
+  }
+  else if(tmass == 0)
+  {
+    for(j = 0; j < 4; j++ )
+    {
+      for(i = 0; i < 4; i++ )
+        ft[i][j] = 0; 
+    }
+  }
+  else if(tmass != 0)
+  {
+    if(nhel == 1)
+    {
+      for(j = 0; j < 4; j++ )
+      {
+        for(i = 0; i < 4; i++ )
+          ft[i][j] = sqh * (ep[i] * e0[j] + e0[i] * ep[j]); 
+      }
+    }
+    else if(nhel == 0)
+    {
+      for(j = 0; j < 4; j++ )
+      {
+        for(i = 0; i < 4; i++ )
+          ft[i][j] = sqs * (ep[i] * em[j] + em[i] * ep[j]
+         + 2.0 * e0[i] * e0[j]); 
+      }
+    }
+    else if(nhel == -1)
+    {
+      for(j = 0; j < 4; j++ )
+      {
+        for(i = 0; i < 4; i++ )
+          ft[i][j] = sqh * (em[i] * e0[j] + e0[i] * em[j]); 
+      }
+    }
+    else
+    {
+      std::cerr <<  "Invalid helicity in txxxxx.\n"; 
+      std::exit(1); 
+    }
+  }
+
+  tc[0] = ft[4][0]; 
+  tc[1] = ft[5][0]; 
+
+  for(j = 0; j < 4; j++ )
+  {
+    for(i = 0; i < 4; i++ )
+      tc[j * 4 + i + 2] = ft[j][i]; 
+  }
+}
+
+void oxxxxx(double p[4], double fmass, int nhel, int nsf, complex<double> fo[6])
+{
+  complex<double> chi[2]; 
+  double sf[2], sfomeg[2], omega[2], pp, pp3, sqp0p3, sqm[2]; 
+  int nh, ip, im; 
+  fo[0] = complex<double> (p[0] * nsf, p[3] * nsf); 
+  fo[1] = complex<double> (p[1] * nsf, p[2] * nsf); 
+  nh = nhel * nsf; 
+  if (fmass != 0.000)
+  {
+    pp = min(p[0], sqrt((p[1] * p[1]) + (p[2] * p[2]) + (p[3] * p[3]))); 
+    if (pp == 0.000)
+    {
+      sqm[0] = sqrt(std::abs(fmass)); 
+      sqm[1] = Sgn(sqm[0], fmass); 
+      ip = -((1 - nh)/2) * nhel; 
+      im = (1 + nh)/2 * nhel; 
+      fo[2] = im * sqm[std::abs(ip)]; 
+      fo[3] = ip * nsf * sqm[std::abs(ip)]; 
+      fo[4] = im * nsf * sqm[std::abs(im)]; 
+      fo[5] = ip * sqm[std::abs(im)]; 
+    }
+    else
+    {
+      pp = min(p[0], sqrt((p[1] * p[1]) + (p[2] * p[2]) + (p[3] * p[3]))); 
+      sf[0] = double(1 + nsf + (1 - nsf) * nh) * 0.5; 
+      sf[1] = double(1 + nsf - (1 - nsf) * nh) * 0.5; 
+      omega[0] = sqrt(p[0] + pp); 
+      omega[1] = fmass/omega[0]; 
+      ip = (1 + nh)/2; 
+      im = (1 - nh)/2; 
+      sfomeg[0] = sf[0] * omega[ip]; 
+      sfomeg[1] = sf[1] * omega[im]; 
+      pp3 = max(pp + p[3], 0.00); 
+      chi[0] = complex<double> (sqrt(pp3 * 0.5/pp), 0.00); 
+      if (pp3 == 0.00)
+      {
+        chi[1] = complex<double> (-nh, 0.00); 
+      }
+      else
+      {
+        chi[1] = complex<double> (nh * p[1], -p[2])/sqrt(2.0 * pp * pp3); 
+      }
+      fo[2] = sfomeg[1] * chi[im]; 
+      fo[3] = sfomeg[1] * chi[ip]; 
+      fo[4] = sfomeg[0] * chi[im]; 
+      fo[5] = sfomeg[0] * chi[ip]; 
+    }
+  }
+  else
+  {
+    if((p[1] == 0.00) and (p[2] == 0.00) and (p[3] < 0.00))
+    {
+      sqp0p3 = 0.00; 
+    }
+    else
+    {
+      sqp0p3 = sqrt(max(p[0] + p[3], 0.00)) * nsf; 
+    }
+    chi[0] = complex<double> (sqp0p3, 0.00); 
+    if(sqp0p3 == 0.000)
+    {
+      chi[1] = complex<double> (-nhel, 0.00) * sqrt(2.0 * p[0]); 
+    }
+    else
+    {
+      chi[1] = complex<double> (nh * p[1], -p[2])/sqp0p3; 
+    }
+    if(nh == 1)
+    {
+      fo[2] = chi[0]; 
+      fo[3] = chi[1]; 
+      fo[4] = complex<double> (0.00, 0.00); 
+      fo[5] = complex<double> (0.00, 0.00); 
+    }
+    else
+    {
+      fo[2] = complex<double> (0.00, 0.00); 
+      fo[3] = complex<double> (0.00, 0.00); 
+      fo[4] = chi[1]; 
+      fo[5] = chi[0]; 
+    }
+  }
+  return; 
+}
+
+void ixxxxx(double p[4], double fmass, int nhel, int nsf, complex<double> fi[6])
+{
+  complex<double> chi[2]; 
+  double sf[2], sfomega[2], omega[2], pp, pp3, sqp0p3, sqm[2]; 
+  int ip, im, nh; 
+  fi[0] = complex<double> (-p[0] * nsf, -p[3] * nsf); 
+  fi[1] = complex<double> (-p[1] * nsf, -p[2] * nsf); 
+  nh = nhel * nsf; 
+  if (fmass != 0.0)
+  {
+    pp = min(p[0], sqrt(p[1] * p[1] + p[2] * p[2] + p[3] * p[3])); 
+    if (pp == 0.0)
+    {
+      sqm[0] = sqrt(std::abs(fmass)); 
+      sqm[1] = Sgn(sqm[0], fmass); 
+      ip = (1 + nh)/2; 
+      im = (1 - nh)/2; 
+      fi[2] = ip * sqm[ip]; 
+      fi[3] = im * nsf * sqm[ip]; 
+      fi[4] = ip * nsf * sqm[im]; 
+      fi[5] = im * sqm[im]; 
+    }
+    else
+    {
+      sf[0] = (1 + nsf + (1 - nsf) * nh) * 0.5; 
+      sf[1] = (1 + nsf - (1 - nsf) * nh) * 0.5; 
+      omega[0] = sqrt(p[0] + pp); 
+      omega[1] = fmass/omega[0]; 
+      ip = (1 + nh)/2; 
+      im = (1 - nh)/2; 
+      sfomega[0] = sf[0] * omega[ip]; 
+      sfomega[1] = sf[1] * omega[im]; 
+      pp3 = max(pp + p[3], 0.0); 
+      chi[0] = complex<double> (sqrt(pp3 * 0.5/pp), 0); 
+      if (pp3 == 0.0)
+      {
+        chi[1] = complex<double> (-nh, 0); 
+      }
+      else
+      {
+        chi[1] = complex<double> (nh * p[1], p[2])/sqrt(2.0 * pp * pp3); 
+      }
+      fi[2] = sfomega[0] * chi[im]; 
+      fi[3] = sfomega[0] * chi[ip]; 
+      fi[4] = sfomega[1] * chi[im]; 
+      fi[5] = sfomega[1] * chi[ip]; 
+    }
+  }
+  else
+  {
+    if (p[1] == 0.0 and p[2] == 0.0 and p[3] < 0.0)
+    {
+      sqp0p3 = 0.0; 
+    }
+    else
+    {
+      sqp0p3 = sqrt(max(p[0] + p[3], 0.0)) * nsf; 
+    }
+    chi[0] = complex<double> (sqp0p3, 0.0); 
+    if (sqp0p3 == 0.0)
+    {
+      chi[1] = complex<double> (-nhel * sqrt(2.0 * p[0]), 0.0); 
+    }
+    else
+    {
+      chi[1] = complex<double> (nh * p[1], p[2])/sqp0p3; 
+    }
+    if (nh == 1)
+    {
+      fi[2] = complex<double> (0.0, 0.0); 
+      fi[3] = complex<double> (0.0, 0.0); 
+      fi[4] = chi[0]; 
+      fi[5] = chi[1]; 
+    }
+    else
+    {
+      fi[2] = chi[1]; 
+      fi[3] = chi[0]; 
+      fi[4] = complex<double> (0.0, 0.0); 
+      fi[5] = complex<double> (0.0, 0.0); 
+    }
+  }
+  return; 
+}
+
+void vxxxxx(double p[4], double vmass, int nhel, int nsv, complex<double> vc[6])
+{
+  double hel, hel0, pt, pt2, pp, pzpt, emp, sqh; 
+  int nsvahl; 
+  sqh = sqrt(0.5); 
+  hel = double(nhel); 
+  nsvahl = nsv * std::abs(hel); 
+  pt2 = (p[1] * p[1]) + (p[2] * p[2]); 
+  pp = min(p[0], sqrt(pt2 + (p[3] * p[3]))); 
+  pt = min(pp, sqrt(pt2)); 
+  vc[0] = complex<double> (p[0] * nsv, p[3] * nsv); 
+  vc[1] = complex<double> (p[1] * nsv, p[2] * nsv); 
+  if (vmass != 0.0)
+  {
+    hel0 = 1.0 - std::abs(hel); 
+    if(pp == 0.0)
+    {
+      vc[2] = complex<double> (0.0, 0.0); 
+      vc[3] = complex<double> (-hel * sqh, 0.0); 
+      vc[4] = complex<double> (0.0, nsvahl * sqh); 
+      vc[5] = complex<double> (hel0, 0.0); 
+    }
+    else
+    {
+      emp = p[0]/(vmass * pp); 
+      vc[2] = complex<double> (hel0 * pp/vmass, 0.0); 
+      vc[5] = complex<double> (hel0 * p[3] * emp + hel * pt/pp * sqh, 0.0); 
+      if (pt != 0.0)
+      {
+        pzpt = p[3]/(pp * pt) * sqh * hel; 
+        vc[3] = complex<double> (hel0 * p[1] * emp - p[1] * pzpt, -nsvahl *
+            p[2]/pt * sqh);
+        vc[4] = complex<double> (hel0 * p[2] * emp - p[2] * pzpt, nsvahl *
+            p[1]/pt * sqh);
+      }
+      else
+      {
+        vc[3] = complex<double> (-hel * sqh, 0.0); 
+        vc[4] = complex<double> (0.0, nsvahl * Sgn(sqh, p[3])); 
+      }
+    }
+  }
+  else
+  {
+    pp = p[0]; 
+    pt = sqrt((p[1] * p[1]) + (p[2] * p[2])); 
+    vc[2] = complex<double> (0.0, 0.0); 
+    vc[5] = complex<double> (hel * pt/pp * sqh, 0.0); 
+    if (pt != 0.0)
+    {
+      pzpt = p[3]/(pp * pt) * sqh * hel; 
+      vc[3] = complex<double> (-p[1] * pzpt, -nsv * p[2]/pt * sqh); 
+      vc[4] = complex<double> (-p[2] * pzpt, nsv * p[1]/pt * sqh); 
+    }
+    else
+    {
+      vc[3] = complex<double> (-hel * sqh, 0.0); 
+      vc[4] = complex<double> (0.0, nsv * Sgn(sqh, p[3])); 
+    }
+  }
+  return; 
+}
+
+void VVVVS1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +V1[0] + V2[0] + V4[0] + S5[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1] + S5[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * S5[2] * (OM3 * P3[0] * (-cI * (TMP18 * TMP30) + cI * (TMP26 *
+      TMP29)) + (-cI * (V2[2] * TMP29) + cI * (V1[2] * TMP30)));
+  V3[3] = denom * S5[2] * (OM3 * P3[1] * (-cI * (TMP18 * TMP30) + cI * (TMP26 *
+      TMP29)) + (-cI * (V2[3] * TMP29) + cI * (V1[3] * TMP30)));
+  V3[4] = denom * S5[2] * (OM3 * P3[2] * (-cI * (TMP18 * TMP30) + cI * (TMP26 *
+      TMP29)) + (-cI * (V2[4] * TMP29) + cI * (V1[4] * TMP30)));
+  V3[5] = denom * S5[2] * (OM3 * P3[3] * (-cI * (TMP18 * TMP30) + cI * (TMP26 *
+      TMP29)) + (-cI * (V2[5] * TMP29) + cI * (V1[5] * TMP30)));
+}
+
+
+void VVVS1_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP19; 
+  std::complex<double> TMP20; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP27; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  V1[0] = +V2[0] + V3[0] + S4[0]; 
+  V1[1] = +V2[1] + V3[1] + S4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP20 = (P1[0] * P3[0] - P1[1] * P3[1] - P1[2] * P3[2] - P1[3] * P3[3]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S4[2] * (OM1 * P1[0] * (TMP27 * (-cI * (TMP20) + cI *
+      (TMP19)) + (-cI * (TMP22 * TMP24) + cI * (TMP23 * TMP26))) + (TMP27 *
+      (-cI * (P2[0]) + cI * (P3[0])) + (V2[2] * (-cI * (TMP23) + cI * (TMP24))
+      + V3[2] * (-cI * (TMP26) + cI * (TMP22)))));
+  V1[3] = denom * S4[2] * (OM1 * P1[1] * (TMP27 * (-cI * (TMP20) + cI *
+      (TMP19)) + (-cI * (TMP22 * TMP24) + cI * (TMP23 * TMP26))) + (TMP27 *
+      (-cI * (P2[1]) + cI * (P3[1])) + (V2[3] * (-cI * (TMP23) + cI * (TMP24))
+      + V3[3] * (-cI * (TMP26) + cI * (TMP22)))));
+  V1[4] = denom * S4[2] * (OM1 * P1[2] * (TMP27 * (-cI * (TMP20) + cI *
+      (TMP19)) + (-cI * (TMP22 * TMP24) + cI * (TMP23 * TMP26))) + (TMP27 *
+      (-cI * (P2[2]) + cI * (P3[2])) + (V2[4] * (-cI * (TMP23) + cI * (TMP24))
+      + V3[4] * (-cI * (TMP26) + cI * (TMP22)))));
+  V1[5] = denom * S4[2] * (OM1 * P1[3] * (TMP27 * (-cI * (TMP20) + cI *
+      (TMP19)) + (-cI * (TMP22 * TMP24) + cI * (TMP23 * TMP26))) + (TMP27 *
+      (-cI * (P2[3]) + cI * (P3[3])) + (V2[5] * (-cI * (TMP23) + cI * (TMP24))
+      + V3[5] * (-cI * (TMP26) + cI * (TMP22)))));
+}
+
+
+void FFV3_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * (-2. * cI) * (F2[2] * (P1[0] * (V3[5] - V3[2]) + (P1[1] *
+      (V3[3] - cI * (V3[4])) + (P1[2] * (V3[4] + cI * (V3[3])) + P1[3] * (V3[5]
+      - V3[2])))) + (+1./2. * (M1 * (+2. * (F2[4] * (-1./2.) * (V3[2] + V3[5]))
+      - F2[5] * (V3[3] + cI * (V3[4])))) + F2[3] * (P1[0] * (V3[3] + cI *
+      (V3[4])) + (P1[1] * (-1.) * (V3[2] + V3[5]) + (P1[2] * (-1.) * (+cI *
+      (V3[2] + V3[5])) + P1[3] * (V3[3] + cI * (V3[4])))))));
+  F1[3] = denom * (-2. * cI) * (F2[2] * (P1[0] * (V3[3] - cI * (V3[4])) +
+      (P1[1] * (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[5]) + cI * (V3[2])) +
+      P1[3] * (+cI * (V3[4]) - V3[3])))) + (+1./2. * (M1 * (F2[5] * (V3[5] -
+      V3[2]) + 2. * (F2[4] * 1./2. * (+cI * (V3[4]) - V3[3])))) + F2[3] *
+      (P1[0] * (-1.) * (V3[2] + V3[5]) + (P1[1] * (V3[3] + cI * (V3[4])) +
+      (P1[2] * (V3[4] - cI * (V3[3])) + P1[3] * (V3[2] + V3[5]))))));
+  F1[4] = denom * cI * (F2[4] * (P1[0] * (-1.) * (V3[2] + V3[5]) + (P1[1] *
+      (V3[3] - cI * (V3[4])) + (P1[2] * (V3[4] + cI * (V3[3])) + P1[3] * (V3[2]
+      + V3[5])))) + (F2[5] * (P1[0] * (-1.) * (V3[3] + cI * (V3[4])) + (P1[1] *
+      (V3[2] - V3[5]) + (P1[2] * (-cI * (V3[5]) + cI * (V3[2])) + P1[3] *
+      (V3[3] + cI * (V3[4]))))) + M1 * (F2[2] * 2. * (V3[5] - V3[2]) + 2. *
+      (F2[3] * (V3[3] + cI * (V3[4]))))));
+  F1[5] = denom * (-cI) * (F2[4] * (P1[0] * (V3[3] - cI * (V3[4])) + (P1[1] *
+      (-1.) * (V3[2] + V3[5]) + (P1[2] * (+cI * (V3[2] + V3[5])) + P1[3] *
+      (V3[3] - cI * (V3[4]))))) + (F2[5] * (P1[0] * (V3[2] - V3[5]) + (P1[1] *
+      (-1.) * (V3[3] + cI * (V3[4])) + (P1[2] * (+cI * (V3[3]) - V3[4]) + P1[3]
+      * (V3[2] - V3[5])))) + M1 * (F2[2] * 2. * (+cI * (V3[4]) - V3[3]) + 2. *
+      (F2[3] * (V3[2] + V3[5])))));
+}
+
+
+void FFV4C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * 2. * cI * (F2[2] * (P1[0] * (-1.) * (V3[2] + V3[5]) + (P1[1]
+      * (V3[3] + cI * (V3[4])) + (P1[2] * (V3[4] - cI * (V3[3])) + P1[3] *
+      (V3[2] + V3[5])))) + (+1./2. * (M1 * (F2[5] * (V3[3] - cI * (V3[4])) + 2.
+      * (F2[4] * 1./2. * (V3[5] - V3[2])))) + F2[3] * (P1[0] * (+cI * (V3[4]) -
+      V3[3]) + (P1[1] * (V3[2] - V3[5]) + (P1[2] * (-cI * (V3[2]) + cI *
+      (V3[5])) + P1[3] * (V3[3] - cI * (V3[4])))))));
+  F1[3] = denom * 2. * cI * (F2[2] * (P1[0] * (-1.) * (V3[3] + cI * (V3[4])) +
+      (P1[1] * (V3[2] + V3[5]) + (P1[2] * (+cI * (V3[2] + V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))) + (+1./2. * (M1 * (+2. * (F2[4] * 1./2. *
+      (V3[3] + cI * (V3[4]))) - F2[5] * (V3[2] + V3[5]))) + F2[3] * (P1[0] *
+      (V3[5] - V3[2]) + (P1[1] * (V3[3] - cI * (V3[4])) + (P1[2] * (V3[4] + cI
+      * (V3[3])) + P1[3] * (V3[5] - V3[2]))))));
+  F1[4] = denom * (-cI) * (F2[4] * (P1[0] * (V3[2] - V3[5]) + (P1[1] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P1[2] * (+cI * (V3[3]) - V3[4]) + P1[3] *
+      (V3[2] - V3[5])))) + (F2[5] * (P1[0] * (+cI * (V3[4]) - V3[3]) + (P1[1] *
+      (V3[2] + V3[5]) + (P1[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P1[3] * (+cI
+      * (V3[4]) - V3[3])))) + M1 * (F2[2] * 2. * (V3[2] + V3[5]) + 2. * (F2[3]
+      * (V3[3] - cI * (V3[4]))))));
+  F1[5] = denom * (-cI) * (F2[4] * (P1[0] * (-1.) * (V3[3] + cI * (V3[4])) +
+      (P1[1] * (V3[2] - V3[5]) + (P1[2] * (-cI * (V3[5]) + cI * (V3[2])) +
+      P1[3] * (V3[3] + cI * (V3[4]))))) + (F2[5] * (P1[0] * (V3[2] + V3[5]) +
+      (P1[1] * (+cI * (V3[4]) - V3[3]) + (P1[2] * (-1.) * (V3[4] + cI *
+      (V3[3])) - P1[3] * (V3[2] + V3[5])))) + M1 * (F2[2] * 2. * (V3[3] + cI *
+      (V3[4])) + 2. * (F2[3] * (V3[2] - V3[5])))));
+}
+
+
+void FFV5C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP10; 
+  std::complex<double> TMP16; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP10 = (-1.) * (F1[2] * (F2[4] * (P3[0] - P3[3]) + F2[5] * (+cI * (P3[2]) -
+      P3[1])) + F1[3] * (F2[4] * (-1.) * (P3[1] + cI * (P3[2])) + F2[5] *
+      (P3[0] + P3[3])));
+  TMP16 = (-1.) * (F1[4] * (F2[2] * (P3[0] + P3[3]) + F2[3] * (P3[1] - cI *
+      (P3[2]))) + F1[5] * (F2[2] * (P3[1] + cI * (P3[2])) + F2[3] * (P3[0] -
+      P3[3])));
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * 4. * cI * (OM3 * 1./4. * P3[0] * (TMP10 + 4. * (TMP16)) +
+      (+1./4. * (F2[4] * F1[2] + F2[5] * F1[3]) + F2[2] * F1[4] + F2[3] *
+      F1[5]));
+  V3[3] = denom * (-4. * cI) * (OM3 * - 1./4. * P3[1] * (TMP10 + 4. * (TMP16))
+      + (-1./4. * (F2[5] * F1[2] + F2[4] * F1[3]) + F2[3] * F1[4] + F2[2] *
+      F1[5]));
+  V3[4] = denom * 4. * cI * (OM3 * 1./4. * P3[2] * (TMP10 + 4. * (TMP16)) +
+      (-1./4. * cI * (F2[5] * F1[2]) + 1./4. * cI * (F2[4] * F1[3]) - cI *
+      (F2[2] * F1[5]) + cI * (F2[3] * F1[4])));
+  V3[5] = denom * 4. * cI * (OM3 * 1./4. * P3[3] * (TMP10 + 4. * (TMP16)) +
+      (+1./4. * (F2[4] * F1[2]) - 1./4. * (F2[5] * F1[3]) - F2[2] * F1[4] +
+      F2[3] * F1[5]));
+}
+
+
+void FFS3_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * - cI * S3[2] * (F1[4] * (P2[0] - P2[3]) + (F1[5] * (+cI *
+      (P2[2]) - P2[1]) - F1[2] * M2));
+  F2[3] = denom * cI * S3[2] * (F1[4] * (P2[1] + cI * (P2[2])) + (F1[5] * (-1.)
+      * (P2[0] + P2[3]) + F1[3] * M2));
+  F2[4] = denom * - cI * S3[2] * (F1[2] * (-1.) * (P2[0] + P2[3]) + (F1[3] *
+      (+cI * (P2[2]) - P2[1]) + F1[4] * M2));
+  F2[5] = denom * cI * S3[2] * (F1[2] * (P2[1] + cI * (P2[2])) + (F1[3] *
+      (P2[0] - P2[3]) - F1[5] * M2));
+}
+
+
+void VVS2P0_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  std::complex<double> TMP19; 
+  std::complex<double> TMP22; 
+  std::complex<double> denom; 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  V1[0] = +V2[0] + S3[0]; 
+  V1[1] = +V2[1] + S3[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S3[2] * (-cI * (P2[0] * TMP22) + cI * (TMP19 * V2[2])); 
+  V1[3] = denom * S3[2] * (-cI * (P2[1] * TMP22) + cI * (TMP19 * V2[3])); 
+  V1[4] = denom * S3[2] * (-cI * (P2[2] * TMP22) + cI * (TMP19 * V2[4])); 
+  V1[5] = denom * S3[2] * (-cI * (P2[3] * TMP22) + cI * (TMP19 * V2[5])); 
+}
+
+
+void FFS4_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP2; 
+  std::complex<double> denom; 
+  S3[0] = +F1[0] + F2[0]; 
+  S3[1] = +F1[1] + F2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * cI * TMP2; 
+}
+
+
+void FFV5_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP13; 
+  std::complex<double> TMP8; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP13 = (F1[4] * (F2[2] * (P3[0] - P3[3]) - F2[3] * (P3[1] + cI * (P3[2]))) +
+      F1[5] * (F2[2] * (+cI * (P3[2]) - P3[1]) + F2[3] * (P3[0] + P3[3])));
+  TMP8 = (F1[2] * (F2[4] * (P3[0] + P3[3]) + F2[5] * (P3[1] + cI * (P3[2]))) +
+      F1[3] * (F2[4] * (P3[1] - cI * (P3[2])) + F2[5] * (P3[0] - P3[3])));
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-4. * cI) * (OM3 * - 1./4. * P3[0] * (TMP8 + 4. * (TMP13)) +
+      (+1./4. * (F2[4] * F1[2] + F2[5] * F1[3]) + F2[2] * F1[4] + F2[3] *
+      F1[5]));
+  V3[3] = denom * (-4. * cI) * (OM3 * - 1./4. * P3[1] * (TMP8 + 4. * (TMP13)) +
+      (-1./4. * (F2[5] * F1[2] + F2[4] * F1[3]) + F2[3] * F1[4] + F2[2] *
+      F1[5]));
+  V3[4] = denom * 4. * cI * (OM3 * 1./4. * P3[2] * (TMP8 + 4. * (TMP13)) +
+      (+1./4. * cI * (F2[5] * F1[2]) - 1./4. * cI * (F2[4] * F1[3]) - cI *
+      (F2[3] * F1[4]) + cI * (F2[2] * F1[5])));
+  V3[5] = denom * 4. * cI * (OM3 * 1./4. * P3[3] * (TMP8 + 4. * (TMP13)) +
+      (+1./4. * (F2[4] * F1[2]) - 1./4. * (F2[5] * F1[3]) - F2[2] * F1[4] +
+      F2[3] * F1[5]));
+}
+
+
+void FFS5C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP1; 
+  std::complex<double> TMP2; 
+  std::complex<double> denom; 
+  S3[0] = +F1[0] + F2[0]; 
+  S3[1] = +F1[1] + F2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * (+cI * (TMP1 + TMP2)); 
+}
+
+
+void VVVV5_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  vertex = COUP * 1./2. * (-2. * cI * (TMP27 * TMP29) + cI * (TMP25 * TMP30 +
+      TMP21 * TMP35));
+}
+
+
+void VVVVS1P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P4[4]; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> denom; 
+  V4[0] = +V1[0] + V2[0] + V3[0] + S5[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1] + S5[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * S5[2] * (-cI * (V1[2] * TMP27) + cI * (V2[2] * TMP25)); 
+  V4[3] = denom * S5[2] * (-cI * (V1[3] * TMP27) + cI * (V2[3] * TMP25)); 
+  V4[4] = denom * S5[2] * (-cI * (V1[4] * TMP27) + cI * (V2[4] * TMP25)); 
+  V4[5] = denom * S5[2] * (-cI * (V1[5] * TMP27) + cI * (V2[5] * TMP25)); 
+}
+
+
+void VVVV3P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP29; 
+  std::complex<double> denom; 
+  V3[0] = +V1[0] + V2[0] + V4[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-cI * (V2[2] * TMP29) + cI * (TMP21 * V4[2])); 
+  V3[3] = denom * (-cI * (V2[3] * TMP29) + cI * (TMP21 * V4[3])); 
+  V3[4] = denom * (-cI * (V2[4] * TMP29) + cI * (TMP21 * V4[4])); 
+  V3[5] = denom * (-cI * (V2[5] * TMP29) + cI * (TMP21 * V4[5])); 
+}
+
+
+void VVVVS2P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V2[0] = +V1[0] + V3[0] + V4[0] + S5[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1] + S5[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S5[2] * (-cI * (V3[2] * TMP29) + cI * (V1[2] * TMP35)); 
+  V2[3] = denom * S5[2] * (-cI * (V3[3] * TMP29) + cI * (V1[3] * TMP35)); 
+  V2[4] = denom * S5[2] * (-cI * (V3[4] * TMP29) + cI * (V1[4] * TMP35)); 
+  V2[5] = denom * S5[2] * (-cI * (V3[5] * TMP29) + cI * (V1[5] * TMP35)); 
+}
+
+
+void FFS1C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * - cI * S3[2] * (F1[4] * (P2[0] + P2[3]) + (F1[5] * (P2[1] +
+      cI * (P2[2])) - F1[2] * M2));
+  F2[3] = denom * cI * S3[2] * (F1[4] * (+cI * (P2[2]) - P2[1]) + (F1[5] *
+      (P2[3] - P2[0]) + F1[3] * M2));
+  F2[4] = denom * cI * S3[2] * (F1[2] * (P2[3] - P2[0]) + (F1[3] * (P2[1] + cI
+      * (P2[2])) + F1[4] * M2));
+  F2[5] = denom * - cI * S3[2] * (F1[2] * (+cI * (P2[2]) - P2[1]) + (F1[3] *
+      (P2[0] + P2[3]) - F1[5] * M2));
+}
+
+
+void VVVV3_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  V2[0] = +V1[0] + V3[0] + V4[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * (OM2 * P2[0] * (-cI * (TMP17 * TMP35) + cI * (TMP24 * TMP29))
+      + (-cI * (V3[2] * TMP29) + cI * (V1[2] * TMP35)));
+  V2[3] = denom * (OM2 * P2[1] * (-cI * (TMP17 * TMP35) + cI * (TMP24 * TMP29))
+      + (-cI * (V3[3] * TMP29) + cI * (V1[3] * TMP35)));
+  V2[4] = denom * (OM2 * P2[2] * (-cI * (TMP17 * TMP35) + cI * (TMP24 * TMP29))
+      + (-cI * (V3[4] * TMP29) + cI * (V1[4] * TMP35)));
+  V2[5] = denom * (OM2 * P2[3] * (-cI * (TMP17 * TMP35) + cI * (TMP24 * TMP29))
+      + (-cI * (V3[5] * TMP29) + cI * (V1[5] * TMP35)));
+}
+
+
+void FFV4C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * (-cI) * (F1[2] * (P2[0] * (V3[5] - V3[2]) + (P2[1] * (V3[3] -
+      cI * (V3[4])) + (P2[2] * (V3[4] + cI * (V3[3])) + P2[3] * (V3[5] -
+      V3[2])))) + (F1[3] * (P2[0] * (V3[3] + cI * (V3[4])) + (P2[1] * (-1.) *
+      (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P2[3] *
+      (V3[3] + cI * (V3[4]))))) + M2 * (F1[4] * 2. * (V3[2] + V3[5]) + 2. *
+      (F1[5] * (V3[3] + cI * (V3[4]))))));
+  F2[3] = denom * (-cI) * (F1[2] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))) + (F1[3] * (P2[0] * (-1.) * (V3[2] + V3[5]) +
+      (P2[1] * (V3[3] + cI * (V3[4])) + (P2[2] * (V3[4] - cI * (V3[3])) + P2[3]
+      * (V3[2] + V3[5])))) + M2 * (F1[4] * 2. * (V3[3] - cI * (V3[4])) + 2. *
+      (F1[5] * (V3[2] - V3[5])))));
+  F2[4] = denom * (-2. * cI) * (F1[4] * (P2[0] * (-1.) * (V3[2] + V3[5]) +
+      (P2[1] * (V3[3] - cI * (V3[4])) + (P2[2] * (V3[4] + cI * (V3[3])) + P2[3]
+      * (V3[2] + V3[5])))) + (+1./2. * (M2 * (+2. * (F1[2] * 1./2. * (V3[2] -
+      V3[5])) - F1[3] * (V3[3] + cI * (V3[4])))) + F1[5] * (P2[0] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P2[1] * (V3[2] - V3[5]) + (P2[2] * (-cI *
+      (V3[5]) + cI * (V3[2])) + P2[3] * (V3[3] + cI * (V3[4])))))));
+  F2[5] = denom * (-2. * cI) * (F1[4] * (P2[0] * (+cI * (V3[4]) - V3[3]) +
+      (P2[1] * (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) +
+      P2[3] * (+cI * (V3[4]) - V3[3])))) + (+1./2. * (M2 * (F1[3] * (V3[2] +
+      V3[5]) + 2. * (F1[2] * 1./2. * (+cI * (V3[4]) - V3[3])))) + F1[5] *
+      (P2[0] * (V3[5] - V3[2]) + (P2[1] * (V3[3] + cI * (V3[4])) + (P2[2] *
+      (V3[4] - cI * (V3[3])) + P2[3] * (V3[5] - V3[2]))))));
+}
+
+
+void FFS2C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * F1[2] * M2 * S3[2]; 
+  F2[3] = denom * cI * F1[3] * M2 * S3[2]; 
+  F2[4] = denom * cI * S3[2] * (F1[2] * (P2[3] - P2[0]) + F1[3] * (P2[1] + cI *
+      (P2[2])));
+  F2[5] = denom * - cI * S3[2] * (F1[2] * (+cI * (P2[2]) - P2[1]) + F1[3] *
+      (P2[0] + P2[3]));
+}
+
+void FFS2_4C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFS2C1_1(F1, S3, COUP1, M2, W2, F2); 
+  FFS4C1_1(F1, S3, COUP2, M2, W2, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F2[i] = F2[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+
+void FFS4_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP2; 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  vertex = COUP * - cI * TMP2 * S3[2]; 
+}
+
+
+void SSSS1_2(std::complex<double> S1[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> S2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  S2[0] = +S1[0] + S3[0] + S4[0]; 
+  S2[1] = +S1[1] + S3[1] + S4[1]; 
+  P2[0] = -S2[0].real(); 
+  P2[1] = -S2[1].real(); 
+  P2[2] = -S2[1].imag(); 
+  P2[3] = -S2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  S2[2] = denom * cI * S4[2] * S3[2] * S1[2]; 
+}
+
+
+void VVV1_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP19; 
+  std::complex<double> TMP20; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP27; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  V1[0] = +V2[0] + V3[0]; 
+  V1[1] = +V2[1] + V3[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  TMP20 = (P1[0] * P3[0] - P1[1] * P3[1] - P1[2] * P3[2] - P1[3] * P3[3]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * (OM1 * P1[0] * (TMP27 * (-cI * (TMP20) + cI * (TMP19)) + (-cI
+      * (TMP22 * TMP24) + cI * (TMP23 * TMP26))) + (TMP27 * (-cI * (P2[0]) + cI
+      * (P3[0])) + (V2[2] * (-cI * (TMP23) + cI * (TMP24)) + V3[2] * (-cI *
+      (TMP26) + cI * (TMP22)))));
+  V1[3] = denom * (OM1 * P1[1] * (TMP27 * (-cI * (TMP20) + cI * (TMP19)) + (-cI
+      * (TMP22 * TMP24) + cI * (TMP23 * TMP26))) + (TMP27 * (-cI * (P2[1]) + cI
+      * (P3[1])) + (V2[3] * (-cI * (TMP23) + cI * (TMP24)) + V3[3] * (-cI *
+      (TMP26) + cI * (TMP22)))));
+  V1[4] = denom * (OM1 * P1[2] * (TMP27 * (-cI * (TMP20) + cI * (TMP19)) + (-cI
+      * (TMP22 * TMP24) + cI * (TMP23 * TMP26))) + (TMP27 * (-cI * (P2[2]) + cI
+      * (P3[2])) + (V2[4] * (-cI * (TMP23) + cI * (TMP24)) + V3[4] * (-cI *
+      (TMP26) + cI * (TMP22)))));
+  V1[5] = denom * (OM1 * P1[3] * (TMP27 * (-cI * (TMP20) + cI * (TMP19)) + (-cI
+      * (TMP22 * TMP24) + cI * (TMP23 * TMP26))) + (TMP27 * (-cI * (P2[3]) + cI
+      * (P3[3])) + (V2[5] * (-cI * (TMP23) + cI * (TMP24)) + V3[5] * (-cI *
+      (TMP26) + cI * (TMP22)))));
+}
+
+
+void VVS1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP21; 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  vertex = COUP * - cI * TMP21 * S3[2]; 
+}
+
+
+void FFS2_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP1; 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  vertex = COUP * - cI * TMP1 * S3[2]; 
+}
+
+void FFS2_4_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex)
+{
+  std::complex<double> tmp; 
+  FFS2_0(F1, F2, S3, COUP1, vertex); 
+  FFS4_0(F1, F2, S3, COUP2, tmp); 
+  vertex = vertex + tmp; 
+}
+
+void FFV1C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * (-cI) * (F1[2] * (P2[0] * (V3[5] - V3[2]) + (P2[1] * (V3[3] -
+      cI * (V3[4])) + (P2[2] * (V3[4] + cI * (V3[3])) + P2[3] * (V3[5] -
+      V3[2])))) + (F1[3] * (P2[0] * (V3[3] + cI * (V3[4])) + (P2[1] * (-1.) *
+      (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P2[3] *
+      (V3[3] + cI * (V3[4]))))) + M2 * (F1[4] * (V3[2] + V3[5]) + F1[5] *
+      (V3[3] + cI * (V3[4])))));
+  F2[3] = denom * cI * (F1[2] * (P2[0] * (+cI * (V3[4]) - V3[3]) + (P2[1] *
+      (V3[2] - V3[5]) + (P2[2] * (-cI * (V3[2]) + cI * (V3[5])) + P2[3] *
+      (V3[3] - cI * (V3[4]))))) + (F1[3] * (P2[0] * (V3[2] + V3[5]) + (P2[1] *
+      (-1.) * (V3[3] + cI * (V3[4])) + (P2[2] * (+cI * (V3[3]) - V3[4]) - P2[3]
+      * (V3[2] + V3[5])))) + M2 * (F1[4] * (+cI * (V3[4]) - V3[3]) + F1[5] *
+      (V3[5] - V3[2]))));
+  F2[4] = denom * cI * (F1[4] * (P2[0] * (V3[2] + V3[5]) + (P2[1] * (+cI *
+      (V3[4]) - V3[3]) + (P2[2] * (-1.) * (V3[4] + cI * (V3[3])) - P2[3] *
+      (V3[2] + V3[5])))) + (F1[5] * (P2[0] * (V3[3] + cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[2]) + cI * (V3[5])) - P2[3] *
+      (V3[3] + cI * (V3[4]))))) + M2 * (F1[2] * (V3[5] - V3[2]) + F1[3] *
+      (V3[3] + cI * (V3[4])))));
+  F2[5] = denom * (-cI) * (F1[4] * (P2[0] * (+cI * (V3[4]) - V3[3]) + (P2[1] *
+      (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))) + (F1[5] * (P2[0] * (V3[5] - V3[2]) + (P2[1] *
+      (V3[3] + cI * (V3[4])) + (P2[2] * (V3[4] - cI * (V3[3])) + P2[3] * (V3[5]
+      - V3[2])))) + M2 * (F1[2] * (+cI * (V3[4]) - V3[3]) + F1[3] * (V3[2] +
+      V3[5]))));
+}
+
+
+void VVSS1P0_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  V1[0] = +V2[0] + S3[0] + S4[0]; 
+  V1[1] = +V2[1] + S3[1] + S4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * - cI * V2[2] * S4[2] * S3[2]; 
+  V1[3] = denom * - cI * V2[3] * S4[2] * S3[2]; 
+  V1[4] = denom * - cI * V2[4] * S4[2] * S3[2]; 
+  V1[5] = denom * - cI * V2[5] * S4[2] * S3[2]; 
+}
+
+
+void VVVVS2P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V1[0] = +V2[0] + V3[0] + V4[0] + S5[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1] + S5[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S5[2] * (-cI * (TMP27 * V4[2]) + cI * (V2[2] * TMP35)); 
+  V1[3] = denom * S5[2] * (-cI * (TMP27 * V4[3]) + cI * (V2[3] * TMP35)); 
+  V1[4] = denom * S5[2] * (-cI * (TMP27 * V4[4]) + cI * (V2[4] * TMP35)); 
+  V1[5] = denom * S5[2] * (-cI * (TMP27 * V4[5]) + cI * (V2[5] * TMP35)); 
+}
+
+
+void VSS1P0_1(std::complex<double> S2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> denom; 
+  P2[0] = S2[0].real(); 
+  P2[1] = S2[1].real(); 
+  P2[2] = S2[1].imag(); 
+  P2[3] = S2[0].imag(); 
+  P3[0] = S3[0].real(); 
+  P3[1] = S3[1].real(); 
+  P3[2] = S3[1].imag(); 
+  P3[3] = S3[0].imag(); 
+  V1[0] = +S2[0] + S3[0]; 
+  V1[1] = +S2[1] + S3[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S2[2] * S3[2] * (-cI * (P2[0]) + cI * (P3[0])); 
+  V1[3] = denom * S2[2] * S3[2] * (-cI * (P2[1]) + cI * (P3[1])); 
+  V1[4] = denom * S2[2] * S3[2] * (-cI * (P2[2]) + cI * (P3[2])); 
+  V1[5] = denom * S2[2] * S3[2] * (-cI * (P2[3]) + cI * (P3[3])); 
+}
+
+
+void VVSS1_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> S4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> denom; 
+  S4[0] = +V1[0] + V2[0] + S3[0]; 
+  S4[1] = +V1[1] + V2[1] + S3[1]; 
+  P4[0] = -S4[0].real(); 
+  P4[1] = -S4[1].real(); 
+  P4[2] = -S4[1].imag(); 
+  P4[3] = -S4[0].imag(); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  S4[2] = denom * cI * TMP21 * S3[2]; 
+}
+
+
+void FFV3C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP10; 
+  std::complex<double> TMP16; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP10 = (-1.) * (F1[2] * (F2[4] * (P3[0] - P3[3]) + F2[5] * (+cI * (P3[2]) -
+      P3[1])) + F1[3] * (F2[4] * (-1.) * (P3[1] + cI * (P3[2])) + F2[5] *
+      (P3[0] + P3[3])));
+  TMP16 = (-1.) * (F1[4] * (F2[2] * (P3[0] + P3[3]) + F2[3] * (P3[1] - cI *
+      (P3[2]))) + F1[5] * (F2[2] * (P3[1] + cI * (P3[2])) + F2[3] * (P3[0] -
+      P3[3])));
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-2. * cI) * (OM3 * 1./2. * P3[0] * (+2. * (TMP16) - TMP10) +
+      (-1./2. * (F2[4] * F1[2] + F2[5] * F1[3]) + F2[2] * F1[4] + F2[3] *
+      F1[5]));
+  V3[3] = denom * 2. * cI * (OM3 * 1./2. * P3[1] * (TMP10 - 2. * (TMP16)) +
+      (+1./2. * (F2[5] * F1[2] + F2[4] * F1[3]) + F2[3] * F1[4] + F2[2] *
+      F1[5]));
+  V3[4] = denom * (-2. * cI) * (OM3 * 1./2. * P3[2] * (+2. * (TMP16) - TMP10) +
+      (+1./2. * cI * (F2[5] * F1[2]) - 1./2. * cI * (F2[4] * F1[3]) - cI *
+      (F2[2] * F1[5]) + cI * (F2[3] * F1[4])));
+  V3[5] = denom * (-2. * cI) * (OM3 * 1./2. * P3[3] * (+2. * (TMP16) - TMP10) +
+      (-1./2. * (F2[4] * F1[2]) + 1./2. * (F2[5] * F1[3]) - F2[2] * F1[4] +
+      F2[3] * F1[5]));
+}
+
+
+void VVVVS2_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP31; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  V1[0] = +V2[0] + V3[0] + V4[0] + S5[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1] + S5[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP31 = (P1[0] * V4[2] - P1[1] * V4[3] - P1[2] * V4[4] - P1[3] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S5[2] * (OM1 * P1[0] * (-cI * (TMP22 * TMP35) + cI * (TMP27 *
+      TMP31)) + (-cI * (TMP27 * V4[2]) + cI * (V2[2] * TMP35)));
+  V1[3] = denom * S5[2] * (OM1 * P1[1] * (-cI * (TMP22 * TMP35) + cI * (TMP27 *
+      TMP31)) + (-cI * (TMP27 * V4[3]) + cI * (V2[3] * TMP35)));
+  V1[4] = denom * S5[2] * (OM1 * P1[2] * (-cI * (TMP22 * TMP35) + cI * (TMP27 *
+      TMP31)) + (-cI * (TMP27 * V4[4]) + cI * (V2[4] * TMP35)));
+  V1[5] = denom * S5[2] * (OM1 * P1[3] * (-cI * (TMP22 * TMP35) + cI * (TMP27 *
+      TMP31)) + (-cI * (TMP27 * V4[5]) + cI * (V2[5] * TMP35)));
+}
+
+
+void FFS5_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * - cI * S3[2] * (F2[4] * (P1[0] + P1[3]) + (F2[5] * (P1[1] +
+      cI * (P1[2])) - F2[2] * M1));
+  F1[3] = denom * cI * S3[2] * (F2[4] * (+cI * (P1[2]) - P1[1]) + (F2[5] *
+      (P1[3] - P1[0]) + F2[3] * M1));
+  F1[4] = denom * cI * S3[2] * (F2[2] * (P1[3] - P1[0]) + (F2[3] * (P1[1] + cI
+      * (P1[2])) + F2[4] * M1));
+  F1[5] = denom * - cI * S3[2] * (F2[2] * (+cI * (P1[2]) - P1[1]) + (F2[3] *
+      (P1[0] + P1[3]) - F2[5] * M1));
+}
+
+
+void FFS4C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP2; 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  vertex = COUP * - cI * TMP2 * S3[2]; 
+}
+
+
+void VVVV4P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> denom; 
+  V4[0] = +V1[0] + V2[0] + V3[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * (-cI * (V2[2] * TMP25) + cI * (V3[2] * TMP21)); 
+  V4[3] = denom * (-cI * (V2[3] * TMP25) + cI * (V3[3] * TMP21)); 
+  V4[4] = denom * (-cI * (V2[4] * TMP25) + cI * (V3[4] * TMP21)); 
+  V4[5] = denom * (-cI * (V2[5] * TMP25) + cI * (V3[5] * TMP21)); 
+}
+
+
+void VVS2_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP19; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP22; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  S3[0] = +V1[0] + V2[0]; 
+  S3[1] = +V1[1] + V2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * (-cI * (TMP19 * TMP21) + cI * (TMP17 * TMP22)); 
+}
+
+
+void FFV1_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * (F1[2] * (P2[0] * (V3[2] + V3[5]) + (P2[1] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P2[2] * (+cI * (V3[3]) - V3[4]) - P2[3] *
+      (V3[2] + V3[5])))) + (F1[3] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))) + M2 * (F1[4] * (V3[2] - V3[5]) + F1[5] * (+cI *
+      (V3[4]) - V3[3]))));
+  F2[3] = denom * (-cI) * (F1[2] * (P2[0] * (-1.) * (V3[3] + cI * (V3[4])) +
+      (P2[1] * (V3[2] + V3[5]) + (P2[2] * (+cI * (V3[2] + V3[5])) - P2[3] *
+      (V3[3] + cI * (V3[4]))))) + (F1[3] * (P2[0] * (V3[5] - V3[2]) + (P2[1] *
+      (V3[3] - cI * (V3[4])) + (P2[2] * (V3[4] + cI * (V3[3])) + P2[3] * (V3[5]
+      - V3[2])))) + M2 * (F1[4] * (V3[3] + cI * (V3[4])) - F1[5] * (V3[2] +
+      V3[5]))));
+  F2[4] = denom * (-cI) * (F1[4] * (P2[0] * (V3[5] - V3[2]) + (P2[1] * (V3[3] +
+      cI * (V3[4])) + (P2[2] * (V3[4] - cI * (V3[3])) + P2[3] * (V3[5] -
+      V3[2])))) + (F1[5] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] * (-1.) *
+      (V3[2] + V3[5]) + (P2[2] * (+cI * (V3[2] + V3[5])) + P2[3] * (V3[3] - cI
+      * (V3[4]))))) + M2 * (F1[2] * (-1.) * (V3[2] + V3[5]) + F1[3] * (+cI *
+      (V3[4]) - V3[3]))));
+  F2[5] = denom * cI * (F1[4] * (P2[0] * (-1.) * (V3[3] + cI * (V3[4])) +
+      (P2[1] * (V3[2] - V3[5]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) +
+      P2[3] * (V3[3] + cI * (V3[4]))))) + (F1[5] * (P2[0] * (V3[2] + V3[5]) +
+      (P2[1] * (+cI * (V3[4]) - V3[3]) + (P2[2] * (-1.) * (V3[4] + cI *
+      (V3[3])) - P2[3] * (V3[2] + V3[5])))) + M2 * (F1[2] * (V3[3] + cI *
+      (V3[4])) + F1[3] * (V3[2] - V3[5]))));
+}
+
+
+void SSS1_3(std::complex<double> S1[], std::complex<double> S2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> denom; 
+  S3[0] = +S1[0] + S2[0]; 
+  S3[1] = +S1[1] + S2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * cI * S2[2] * S1[2]; 
+}
+
+
+void VVVVS3_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  V1[0] = +V2[0] + V3[0] + V4[0] + S5[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1] + S5[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S5[2] * (OM1 * P1[0] * (-cI * (TMP22 * TMP35) + cI * (TMP23 *
+      TMP30)) + (-cI * (V3[2] * TMP30) + cI * (V2[2] * TMP35)));
+  V1[3] = denom * S5[2] * (OM1 * P1[1] * (-cI * (TMP22 * TMP35) + cI * (TMP23 *
+      TMP30)) + (-cI * (V3[3] * TMP30) + cI * (V2[3] * TMP35)));
+  V1[4] = denom * S5[2] * (OM1 * P1[2] * (-cI * (TMP22 * TMP35) + cI * (TMP23 *
+      TMP30)) + (-cI * (V3[4] * TMP30) + cI * (V2[4] * TMP35)));
+  V1[5] = denom * S5[2] * (OM1 * P1[3] * (-cI * (TMP22 * TMP35) + cI * (TMP23 *
+      TMP30)) + (-cI * (V3[5] * TMP30) + cI * (V2[5] * TMP35)));
+}
+
+
+void VVVV2_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  vertex = COUP * (-1.) * (-2. * cI * (TMP21 * TMP35) + cI * (TMP27 * TMP29 +
+      TMP25 * TMP30));
+}
+
+
+void VVSS1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> denom; 
+  S3[0] = +V1[0] + V2[0] + S4[0]; 
+  S3[1] = +V1[1] + V2[1] + S4[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * cI * TMP21 * S4[2]; 
+}
+
+
+void VVVV5P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V1[0] = +V2[0] + V3[0] + V4[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * 1./2. * (-2. * cI * (TMP27 * V4[2]) + cI * (V3[2] * TMP30 +
+      V2[2] * TMP35));
+  V1[3] = denom * 1./2. * (-2. * cI * (TMP27 * V4[3]) + cI * (V3[3] * TMP30 +
+      V2[3] * TMP35));
+  V1[4] = denom * 1./2. * (-2. * cI * (TMP27 * V4[4]) + cI * (V3[4] * TMP30 +
+      V2[4] * TMP35));
+  V1[5] = denom * 1./2. * (-2. * cI * (TMP27 * V4[5]) + cI * (V3[5] * TMP30 +
+      V2[5] * TMP35));
+}
+
+
+void VSS1_0(std::complex<double> V1[], std::complex<double> S2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  P2[0] = S2[0].real(); 
+  P2[1] = S2[1].real(); 
+  P2[2] = S2[1].imag(); 
+  P2[3] = S2[0].imag(); 
+  P3[0] = S3[0].real(); 
+  P3[1] = S3[1].real(); 
+  P3[2] = S3[1].imag(); 
+  P3[3] = S3[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  vertex = COUP * S2[2] * S3[2] * (-cI * (TMP17) + cI * (TMP18)); 
+}
+
+
+void FFS3C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * S3[2] * (F1[4] * (P2[0] + P2[3]) + (F1[5] * (P2[1] + cI
+      * (P2[2])) + F1[2] * M2));
+  F2[3] = denom * - cI * S3[2] * (F1[4] * (+cI * (P2[2]) - P2[1]) + (F1[5] *
+      (P2[3] - P2[0]) - F1[3] * M2));
+  F2[4] = denom * cI * S3[2] * (F1[2] * (P2[3] - P2[0]) + (F1[3] * (P2[1] + cI
+      * (P2[2])) - F1[4] * M2));
+  F2[5] = denom * - cI * S3[2] * (F1[2] * (+cI * (P2[2]) - P2[1]) + (F1[3] *
+      (P2[0] + P2[3]) + F1[5] * M2));
+}
+
+
+void FFV2_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP7; 
+  TMP7 = (F1[2] * (F2[4] * (V3[2] + V3[5]) + F2[5] * (V3[3] + cI * (V3[4]))) +
+      F1[3] * (F2[4] * (V3[3] - cI * (V3[4])) + F2[5] * (V3[2] - V3[5])));
+  vertex = COUP * - cI * TMP7; 
+}
+
+void FFV2_5_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex)
+{
+  std::complex<double> tmp; 
+  FFV2_0(F1, F2, V3, COUP1, vertex); 
+  FFV5_0(F1, F2, V3, COUP2, tmp); 
+  vertex = vertex + tmp; 
+}
+void FFV2_3_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex)
+{
+  std::complex<double> tmp; 
+  FFV2_0(F1, F2, V3, COUP1, vertex); 
+  FFV3_0(F1, F2, V3, COUP2, tmp); 
+  vertex = vertex + tmp; 
+}
+void FFV2_4_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex)
+{
+  std::complex<double> tmp; 
+  FFV2_0(F1, F2, V3, COUP1, vertex); 
+  FFV4_0(F1, F2, V3, COUP2, tmp); 
+  vertex = vertex + tmp; 
+}
+
+void VVVV1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  vertex = COUP * (-cI * (TMP27 * TMP29) + cI * (TMP25 * TMP30)); 
+}
+
+
+void FFS1_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * S3[2] * (F1[4] * (P2[0] - P2[3]) + (F1[5] * (+cI *
+      (P2[2]) - P2[1]) + F1[2] * M2));
+  F2[3] = denom * - cI * S3[2] * (F1[4] * (P2[1] + cI * (P2[2])) + (F1[5] *
+      (-1.) * (P2[0] + P2[3]) - F1[3] * M2));
+  F2[4] = denom * - cI * S3[2] * (F1[2] * (-1.) * (P2[0] + P2[3]) + (F1[3] *
+      (+cI * (P2[2]) - P2[1]) - F1[4] * M2));
+  F2[5] = denom * cI * S3[2] * (F1[2] * (P2[1] + cI * (P2[2])) + (F1[3] *
+      (P2[0] - P2[3]) + F1[5] * M2));
+}
+
+
+void FFV2C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * (F1[2] * (P2[0] * (V3[2] - V3[5]) + (P2[1] * (+cI *
+      (V3[4]) - V3[3]) + (P2[2] * (-1.) * (V3[4] + cI * (V3[3])) + P2[3] *
+      (V3[2] - V3[5])))) + F1[3] * (P2[0] * (-1.) * (V3[3] + cI * (V3[4])) +
+      (P2[1] * (V3[2] + V3[5]) + (P2[2] * (+cI * (V3[2] + V3[5])) - P2[3] *
+      (V3[3] + cI * (V3[4]))))));
+  F2[3] = denom * (-cI) * (F1[2] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))) + F1[3] * (P2[0] * (-1.) * (V3[2] + V3[5]) + (P2[1]
+      * (V3[3] + cI * (V3[4])) + (P2[2] * (V3[4] - cI * (V3[3])) + P2[3] *
+      (V3[2] + V3[5])))));
+  F2[4] = denom * cI * M2 * (F1[2] * (V3[5] - V3[2]) + F1[3] * (V3[3] + cI *
+      (V3[4])));
+  F2[5] = denom * - cI * M2 * (F1[2] * (+cI * (V3[4]) - V3[3]) + F1[3] * (V3[2]
+      + V3[5]));
+}
+
+void FFV2_5C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2C1_1(F1, V3, COUP1, M2, W2, F2); 
+  FFV5C1_1(F1, V3, COUP2, M2, W2, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F2[i] = F2[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+void FFV2_3C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2C1_1(F1, V3, COUP1, M2, W2, F2); 
+  FFV3C1_1(F1, V3, COUP2, M2, W2, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F2[i] = F2[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+void FFV2_4C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2C1_1(F1, V3, COUP1, M2, W2, F2); 
+  FFV4C1_1(F1, V3, COUP2, M2, W2, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F2[i] = F2[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+
+void FFS5_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * S3[2] * (F1[4] * (P2[0] - P2[3]) + (F1[5] * (+cI *
+      (P2[2]) - P2[1]) + F1[2] * M2));
+  F2[3] = denom * - cI * S3[2] * (F1[4] * (P2[1] + cI * (P2[2])) + (F1[5] *
+      (-1.) * (P2[0] + P2[3]) - F1[3] * M2));
+  F2[4] = denom * - cI * S3[2] * (F1[2] * (-1.) * (P2[0] + P2[3]) + (F1[3] *
+      (+cI * (P2[2]) - P2[1]) - F1[4] * M2));
+  F2[5] = denom * cI * S3[2] * (F1[2] * (P2[1] + cI * (P2[2])) + (F1[3] *
+      (P2[0] - P2[3]) + F1[5] * M2));
+}
+
+
+void VVVV4P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V1[0] = +V2[0] + V3[0] + V4[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * (-cI * (V3[2] * TMP30) + cI * (V2[2] * TMP35)); 
+  V1[3] = denom * (-cI * (V3[3] * TMP30) + cI * (V2[3] * TMP35)); 
+  V1[4] = denom * (-cI * (V3[4] * TMP30) + cI * (V2[4] * TMP35)); 
+  V1[5] = denom * (-cI * (V3[5] * TMP30) + cI * (V2[5] * TMP35)); 
+}
+
+
+void VVVV4_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP32; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  V2[0] = +V1[0] + V3[0] + V4[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP32 = (P2[0] * V4[2] - P2[1] * V4[3] - P2[2] * V4[4] - P2[3] * V4[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * (OM2 * P2[0] * (-cI * (TMP17 * TMP35) + cI * (TMP25 * TMP32))
+      + (-cI * (TMP25 * V4[2]) + cI * (V1[2] * TMP35)));
+  V2[3] = denom * (OM2 * P2[1] * (-cI * (TMP17 * TMP35) + cI * (TMP25 * TMP32))
+      + (-cI * (TMP25 * V4[3]) + cI * (V1[3] * TMP35)));
+  V2[4] = denom * (OM2 * P2[2] * (-cI * (TMP17 * TMP35) + cI * (TMP25 * TMP32))
+      + (-cI * (TMP25 * V4[4]) + cI * (V1[4] * TMP35)));
+  V2[5] = denom * (OM2 * P2[3] * (-cI * (TMP17 * TMP35) + cI * (TMP25 * TMP32))
+      + (-cI * (TMP25 * V4[5]) + cI * (V1[5] * TMP35)));
+}
+
+
+void FFV4_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * 2. * cI * (F2[2] * (P1[0] * (V3[5] - V3[2]) + (P1[1] * (V3[3]
+      - cI * (V3[4])) + (P1[2] * (V3[4] + cI * (V3[3])) + P1[3] * (V3[5] -
+      V3[2])))) + (+1./2. * (M1 * (F2[5] * (V3[3] + cI * (V3[4])) + 2. * (F2[4]
+      * 1./2. * (V3[2] + V3[5])))) + F2[3] * (P1[0] * (V3[3] + cI * (V3[4])) +
+      (P1[1] * (-1.) * (V3[2] + V3[5]) + (P1[2] * (-1.) * (+cI * (V3[2] +
+      V3[5])) + P1[3] * (V3[3] + cI * (V3[4])))))));
+  F1[3] = denom * 2. * cI * (F2[2] * (P1[0] * (V3[3] - cI * (V3[4])) + (P1[1] *
+      (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[5]) + cI * (V3[2])) + P1[3] * (+cI
+      * (V3[4]) - V3[3])))) + (+1./2. * (M1 * (F2[5] * (V3[2] - V3[5]) + 2. *
+      (F2[4] * 1./2. * (V3[3] - cI * (V3[4]))))) + F2[3] * (P1[0] * (-1.) *
+      (V3[2] + V3[5]) + (P1[1] * (V3[3] + cI * (V3[4])) + (P1[2] * (V3[4] - cI
+      * (V3[3])) + P1[3] * (V3[2] + V3[5]))))));
+  F1[4] = denom * (-cI) * (F2[4] * (P1[0] * (V3[2] + V3[5]) + (P1[1] * (+cI *
+      (V3[4]) - V3[3]) + (P1[2] * (-1.) * (V3[4] + cI * (V3[3])) - P1[3] *
+      (V3[2] + V3[5])))) + (F2[5] * (P1[0] * (V3[3] + cI * (V3[4])) + (P1[1] *
+      (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[2]) + cI * (V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))) + M1 * (F2[2] * 2. * (V3[5] - V3[2]) + 2. *
+      (F2[3] * (V3[3] + cI * (V3[4]))))));
+  F1[5] = denom * cI * (F2[4] * (P1[0] * (+cI * (V3[4]) - V3[3]) + (P1[1] *
+      (V3[2] + V3[5]) + (P1[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P1[3] * (+cI
+      * (V3[4]) - V3[3])))) + (F2[5] * (P1[0] * (V3[5] - V3[2]) + (P1[1] *
+      (V3[3] + cI * (V3[4])) + (P1[2] * (V3[4] - cI * (V3[3])) + P1[3] * (V3[5]
+      - V3[2])))) + M1 * (F2[2] * 2. * (+cI * (V3[4]) - V3[3]) + 2. * (F2[3] *
+      (V3[2] + V3[5])))));
+}
+
+
+void VVVS1P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  V2[0] = +V1[0] + V3[0] + S4[0]; 
+  V2[1] = +V1[1] + V3[1] + S4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S4[2] * (TMP25 * (-cI * (P3[0]) + cI * (P1[0])) + (V1[2] *
+      (-cI * (TMP23) + cI * (TMP24)) + V3[2] * (-cI * (TMP17) + cI * (TMP18))));
+  V2[3] = denom * S4[2] * (TMP25 * (-cI * (P3[1]) + cI * (P1[1])) + (V1[3] *
+      (-cI * (TMP23) + cI * (TMP24)) + V3[3] * (-cI * (TMP17) + cI * (TMP18))));
+  V2[4] = denom * S4[2] * (TMP25 * (-cI * (P3[2]) + cI * (P1[2])) + (V1[4] *
+      (-cI * (TMP23) + cI * (TMP24)) + V3[4] * (-cI * (TMP17) + cI * (TMP18))));
+  V2[5] = denom * S4[2] * (TMP25 * (-cI * (P3[3]) + cI * (P1[3])) + (V1[5] *
+      (-cI * (TMP23) + cI * (TMP24)) + V3[5] * (-cI * (TMP17) + cI * (TMP18))));
+}
+
+
+void FFV2P0_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * (F1[2] * (P2[0] * (V3[2] + V3[5]) + (P2[1] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P2[2] * (+cI * (V3[3]) - V3[4]) - P2[3] *
+      (V3[2] + V3[5])))) + F1[3] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))));
+  F2[3] = denom * cI * (F1[2] * (P2[0] * (V3[3] + cI * (V3[4])) + (P2[1] *
+      (-1.) * (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) +
+      P2[3] * (V3[3] + cI * (V3[4]))))) + F1[3] * (P2[0] * (V3[2] - V3[5]) +
+      (P2[1] * (+cI * (V3[4]) - V3[3]) + (P2[2] * (-1.) * (V3[4] + cI *
+      (V3[3])) + P2[3] * (V3[2] - V3[5])))));
+  F2[4] = denom * - cI * M2 * (F1[2] * (-1.) * (V3[2] + V3[5]) + F1[3] * (+cI *
+      (V3[4]) - V3[3]));
+  F2[5] = denom * cI * M2 * (F1[2] * (V3[3] + cI * (V3[4])) + F1[3] * (V3[2] -
+      V3[5]));
+}
+
+
+void FFS4P0_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * S3[2] * (F1[4] * (P2[0] - P2[3]) + F1[5] * (+cI *
+      (P2[2]) - P2[1]));
+  F2[3] = denom * - cI * S3[2] * (F1[4] * (P2[1] + cI * (P2[2])) - F1[5] *
+      (P2[0] + P2[3]));
+  F2[4] = denom * cI * F1[4] * M2 * S3[2]; 
+  F2[5] = denom * cI * F1[5] * M2 * S3[2]; 
+}
+
+
+void VVV1P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP26; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  V3[0] = +V1[0] + V2[0]; 
+  V3[1] = +V1[1] + V2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (TMP21 * (-cI * (P1[0]) + cI * (P2[0])) + (V1[2] * (-cI *
+      (TMP26) + cI * (TMP22)) + V2[2] * (-cI * (TMP17) + cI * (TMP18))));
+  V3[3] = denom * (TMP21 * (-cI * (P1[1]) + cI * (P2[1])) + (V1[3] * (-cI *
+      (TMP26) + cI * (TMP22)) + V2[3] * (-cI * (TMP17) + cI * (TMP18))));
+  V3[4] = denom * (TMP21 * (-cI * (P1[2]) + cI * (P2[2])) + (V1[4] * (-cI *
+      (TMP26) + cI * (TMP22)) + V2[4] * (-cI * (TMP17) + cI * (TMP18))));
+  V3[5] = denom * (TMP21 * (-cI * (P1[3]) + cI * (P2[3])) + (V1[5] * (-cI *
+      (TMP26) + cI * (TMP22)) + V2[5] * (-cI * (TMP17) + cI * (TMP18))));
+}
+
+
+void VVVVS1_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM4; 
+  double P4[4]; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP33; 
+  std::complex<double> TMP34; 
+  std::complex<double> denom; 
+  OM4 = 0.; 
+  if (M4 != 0.)
+    OM4 = 1./(M4 * M4); 
+  V4[0] = +V1[0] + V2[0] + V3[0] + S5[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1] + S5[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP34 = (V2[2] * P4[0] - V2[3] * P4[1] - V2[4] * P4[2] - V2[5] * P4[3]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP33 = (V1[2] * P4[0] - V1[3] * P4[1] - V1[4] * P4[2] - V1[5] * P4[3]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * S5[2] * (OM4 * P4[0] * (-cI * (TMP25 * TMP34) + cI * (TMP27 *
+      TMP33)) + (-cI * (V1[2] * TMP27) + cI * (V2[2] * TMP25)));
+  V4[3] = denom * S5[2] * (OM4 * P4[1] * (-cI * (TMP25 * TMP34) + cI * (TMP27 *
+      TMP33)) + (-cI * (V1[3] * TMP27) + cI * (V2[3] * TMP25)));
+  V4[4] = denom * S5[2] * (OM4 * P4[2] * (-cI * (TMP25 * TMP34) + cI * (TMP27 *
+      TMP33)) + (-cI * (V1[4] * TMP27) + cI * (V2[4] * TMP25)));
+  V4[5] = denom * S5[2] * (OM4 * P4[3] * (-cI * (TMP25 * TMP34) + cI * (TMP27 *
+      TMP33)) + (-cI * (V1[5] * TMP27) + cI * (V2[5] * TMP25)));
+}
+
+
+void VVVS1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S4[], std::complex<double>
+    COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP27; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  vertex = COUP * S4[2] * (TMP21 * (-cI * (TMP23) + cI * (TMP24)) + (TMP25 *
+      (-cI * (TMP26) + cI * (TMP22)) + TMP27 * (-cI * (TMP17) + cI * (TMP18))));
+}
+
+
+void FFV3_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP11; 
+  std::complex<double> TMP12; 
+  TMP11 = (F1[2] * (F2[4] * (V3[2] + V3[5]) + F2[5] * (V3[3] + cI * (V3[4]))) +
+      F1[3] * (F2[4] * (V3[3] - cI * (V3[4])) + F2[5] * (V3[2] - V3[5])));
+  TMP12 = (F1[4] * (F2[2] * (V3[2] - V3[5]) - F2[3] * (V3[3] + cI * (V3[4]))) +
+      F1[5] * (F2[2] * (+cI * (V3[4]) - V3[3]) + F2[3] * (V3[2] + V3[5])));
+  vertex = COUP * (-cI * (TMP11) + 2. * cI * (TMP12)); 
+}
+
+
+void VVVV2_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP36; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +V1[0] + V2[0] + V4[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP36 = (P3[0] * V4[2] - P3[1] * V4[3] - P3[2] * V4[4] - P3[3] * V4[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (OM3 * P3[0] * (-2. * cI * (TMP21 * TMP36) + cI * (TMP26 *
+      TMP29 + TMP18 * TMP30)) + (-cI * (V2[2] * TMP29 + V1[2] * TMP30) + 2. *
+      cI * (TMP21 * V4[2])));
+  V3[3] = denom * (OM3 * P3[1] * (-2. * cI * (TMP21 * TMP36) + cI * (TMP26 *
+      TMP29 + TMP18 * TMP30)) + (-cI * (V2[3] * TMP29 + V1[3] * TMP30) + 2. *
+      cI * (TMP21 * V4[3])));
+  V3[4] = denom * (OM3 * P3[2] * (-2. * cI * (TMP21 * TMP36) + cI * (TMP26 *
+      TMP29 + TMP18 * TMP30)) + (-cI * (V2[4] * TMP29 + V1[4] * TMP30) + 2. *
+      cI * (TMP21 * V4[4])));
+  V3[5] = denom * (OM3 * P3[3] * (-2. * cI * (TMP21 * TMP36) + cI * (TMP26 *
+      TMP29 + TMP18 * TMP30)) + (-cI * (V2[5] * TMP29 + V1[5] * TMP30) + 2. *
+      cI * (TMP21 * V4[5])));
+}
+
+
+void VVVV3_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP36; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +V1[0] + V2[0] + V4[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP36 = (P3[0] * V4[2] - P3[1] * V4[3] - P3[2] * V4[4] - P3[3] * V4[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (OM3 * P3[0] * (-cI * (TMP21 * TMP36) + cI * (TMP26 * TMP29))
+      + (-cI * (V2[2] * TMP29) + cI * (TMP21 * V4[2])));
+  V3[3] = denom * (OM3 * P3[1] * (-cI * (TMP21 * TMP36) + cI * (TMP26 * TMP29))
+      + (-cI * (V2[3] * TMP29) + cI * (TMP21 * V4[3])));
+  V3[4] = denom * (OM3 * P3[2] * (-cI * (TMP21 * TMP36) + cI * (TMP26 * TMP29))
+      + (-cI * (V2[4] * TMP29) + cI * (TMP21 * V4[4])));
+  V3[5] = denom * (OM3 * P3[3] * (-cI * (TMP21 * TMP36) + cI * (TMP26 * TMP29))
+      + (-cI * (V2[5] * TMP29) + cI * (TMP21 * V4[5])));
+}
+
+
+void FFS3_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * cI * S3[2] * (F2[4] * (P1[0] + P1[3]) + (F2[5] * (P1[1] + cI
+      * (P1[2])) + F2[2] * M1));
+  F1[3] = denom * - cI * S3[2] * (F2[4] * (+cI * (P1[2]) - P1[1]) + (F2[5] *
+      (P1[3] - P1[0]) - F2[3] * M1));
+  F1[4] = denom * cI * S3[2] * (F2[2] * (P1[3] - P1[0]) + (F2[3] * (P1[1] + cI
+      * (P1[2])) - F2[4] * M1));
+  F1[5] = denom * - cI * S3[2] * (F2[2] * (+cI * (P1[2]) - P1[1]) + (F2[3] *
+      (P1[0] + P1[3]) + F2[5] * M1));
+}
+
+
+void FFS3C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * - cI * S3[2] * (F2[4] * (P1[0] - P1[3]) + (F2[5] * (+cI *
+      (P1[2]) - P1[1]) - F2[2] * M1));
+  F1[3] = denom * cI * S3[2] * (F2[4] * (P1[1] + cI * (P1[2])) + (F2[5] * (-1.)
+      * (P1[0] + P1[3]) + F2[3] * M1));
+  F1[4] = denom * - cI * S3[2] * (F2[2] * (-1.) * (P1[0] + P1[3]) + (F2[3] *
+      (+cI * (P1[2]) - P1[1]) + F2[4] * M1));
+  F1[5] = denom * cI * S3[2] * (F2[2] * (P1[1] + cI * (P1[2])) + (F2[3] *
+      (P1[0] - P1[3]) - F2[5] * M1));
+}
+
+
+void FFV5_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * (F1[2] * (P2[0] * (V3[2] + V3[5]) + (P2[1] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P2[2] * (+cI * (V3[3]) - V3[4]) - P2[3] *
+      (V3[2] + V3[5])))) + (F1[3] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))) + M2 * (F1[4] * 4. * (V3[2] - V3[5]) + 4. * (F1[5]
+      * (+cI * (V3[4]) - V3[3])))));
+  F2[3] = denom * cI * (F1[2] * (P2[0] * (V3[3] + cI * (V3[4])) + (P2[1] *
+      (-1.) * (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) +
+      P2[3] * (V3[3] + cI * (V3[4]))))) + (F1[3] * (P2[0] * (V3[2] - V3[5]) +
+      (P2[1] * (+cI * (V3[4]) - V3[3]) + (P2[2] * (-1.) * (V3[4] + cI *
+      (V3[3])) + P2[3] * (V3[2] - V3[5])))) + M2 * (F1[4] * (-4.) * (V3[3] + cI
+      * (V3[4])) + 4. * (F1[5] * (V3[2] + V3[5])))));
+  F2[4] = denom * (-4. * cI) * (F1[4] * (P2[0] * (V3[5] - V3[2]) + (P2[1] *
+      (V3[3] + cI * (V3[4])) + (P2[2] * (V3[4] - cI * (V3[3])) + P2[3] * (V3[5]
+      - V3[2])))) + (+1./4. * (M2 * (F1[3] * (+cI * (V3[4]) - V3[3]) + 4. *
+      (F1[2] * (-1./4.) * (V3[2] + V3[5])))) + F1[5] * (P2[0] * (V3[3] - cI *
+      (V3[4])) + (P2[1] * (-1.) * (V3[2] + V3[5]) + (P2[2] * (+cI * (V3[2] +
+      V3[5])) + P2[3] * (V3[3] - cI * (V3[4])))))));
+  F2[5] = denom * (-4. * cI) * (F1[4] * (P2[0] * (V3[3] + cI * (V3[4])) +
+      (P2[1] * (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[2]) + cI * (V3[5])) -
+      P2[3] * (V3[3] + cI * (V3[4]))))) + (+1./4. * (M2 * (F1[3] * (V3[5] -
+      V3[2]) + 4. * (F1[2] * (-1./4.) * (V3[3] + cI * (V3[4]))))) + F1[5] *
+      (P2[0] * (-1.) * (V3[2] + V3[5]) + (P2[1] * (V3[3] - cI * (V3[4])) +
+      (P2[2] * (V3[4] + cI * (V3[3])) + P2[3] * (V3[2] + V3[5]))))));
+}
+
+
+void FFS1_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * - cI * S3[2] * (F2[4] * (P1[0] + P1[3]) + (F2[5] * (P1[1] +
+      cI * (P1[2])) - F2[2] * M1));
+  F1[3] = denom * cI * S3[2] * (F2[4] * (+cI * (P1[2]) - P1[1]) + (F2[5] *
+      (P1[3] - P1[0]) + F2[3] * M1));
+  F1[4] = denom * cI * S3[2] * (F2[2] * (P1[3] - P1[0]) + (F2[3] * (P1[1] + cI
+      * (P1[2])) + F2[4] * M1));
+  F1[5] = denom * - cI * S3[2] * (F2[2] * (+cI * (P1[2]) - P1[1]) + (F2[3] *
+      (P1[0] + P1[3]) - F2[5] * M1));
+}
+
+
+void FFS5C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * cI * S3[2] * (F2[4] * (P1[0] - P1[3]) + (F2[5] * (+cI *
+      (P1[2]) - P1[1]) + F2[2] * M1));
+  F1[3] = denom * - cI * S3[2] * (F2[4] * (P1[1] + cI * (P1[2])) + (F2[5] *
+      (-1.) * (P1[0] + P1[3]) - F2[3] * M1));
+  F1[4] = denom * - cI * S3[2] * (F2[2] * (-1.) * (P1[0] + P1[3]) + (F2[3] *
+      (+cI * (P1[2]) - P1[1]) - F2[4] * M1));
+  F1[5] = denom * cI * S3[2] * (F2[2] * (P1[1] + cI * (P1[2])) + (F2[3] *
+      (P1[0] - P1[3]) + F2[5] * M1));
+}
+
+
+void VVVV5_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP36; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +V1[0] + V2[0] + V4[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP36 = (P3[0] * V4[2] - P3[1] * V4[3] - P3[2] * V4[4] - P3[3] * V4[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * 1./2. * (OM3 * - P3[0] * (-2. * cI * (TMP26 * TMP29) + cI *
+      (TMP18 * TMP30 + TMP21 * TMP36)) + (-2. * cI * (V2[2] * TMP29) + cI *
+      (V1[2] * TMP30 + TMP21 * V4[2])));
+  V3[3] = denom * 1./2. * (OM3 * - P3[1] * (-2. * cI * (TMP26 * TMP29) + cI *
+      (TMP18 * TMP30 + TMP21 * TMP36)) + (-2. * cI * (V2[3] * TMP29) + cI *
+      (V1[3] * TMP30 + TMP21 * V4[3])));
+  V3[4] = denom * 1./2. * (OM3 * - P3[2] * (-2. * cI * (TMP26 * TMP29) + cI *
+      (TMP18 * TMP30 + TMP21 * TMP36)) + (-2. * cI * (V2[4] * TMP29) + cI *
+      (V1[4] * TMP30 + TMP21 * V4[4])));
+  V3[5] = denom * 1./2. * (OM3 * - P3[3] * (-2. * cI * (TMP26 * TMP29) + cI *
+      (TMP18 * TMP30 + TMP21 * TMP36)) + (-2. * cI * (V2[5] * TMP29) + cI *
+      (V1[5] * TMP30 + TMP21 * V4[5])));
+}
+
+
+void VVVV4P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V2[0] = +V1[0] + V3[0] + V4[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * (-cI * (TMP25 * V4[2]) + cI * (V1[2] * TMP35)); 
+  V2[3] = denom * (-cI * (TMP25 * V4[3]) + cI * (V1[3] * TMP35)); 
+  V2[4] = denom * (-cI * (TMP25 * V4[4]) + cI * (V1[4] * TMP35)); 
+  V2[5] = denom * (-cI * (TMP25 * V4[5]) + cI * (V1[5] * TMP35)); 
+}
+
+
+void VVVV3P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V2[0] = +V1[0] + V3[0] + V4[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * (-cI * (V3[2] * TMP29) + cI * (V1[2] * TMP35)); 
+  V2[3] = denom * (-cI * (V3[3] * TMP29) + cI * (V1[3] * TMP35)); 
+  V2[4] = denom * (-cI * (V3[4] * TMP29) + cI * (V1[4] * TMP35)); 
+  V2[5] = denom * (-cI * (V3[5] * TMP29) + cI * (V1[5] * TMP35)); 
+}
+
+
+void FFS1C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * cI * S3[2] * (F2[4] * (P1[0] - P1[3]) + (F2[5] * (+cI *
+      (P1[2]) - P1[1]) + F2[2] * M1));
+  F1[3] = denom * - cI * S3[2] * (F2[4] * (P1[1] + cI * (P1[2])) + (F2[5] *
+      (-1.) * (P1[0] + P1[3]) - F2[3] * M1));
+  F1[4] = denom * - cI * S3[2] * (F2[2] * (-1.) * (P1[0] + P1[3]) + (F2[3] *
+      (+cI * (P1[2]) - P1[1]) - F2[4] * M1));
+  F1[5] = denom * cI * S3[2] * (F2[2] * (P1[1] + cI * (P1[2])) + (F2[3] *
+      (P1[0] - P1[3]) + F2[5] * M1));
+}
+
+
+void VVVVS1_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP31; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  V1[0] = +V2[0] + V3[0] + V4[0] + S5[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1] + S5[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP31 = (P1[0] * V4[2] - P1[1] * V4[3] - P1[2] * V4[4] - P1[3] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S5[2] * (OM1 * P1[0] * (-cI * (TMP23 * TMP30) + cI * (TMP27 *
+      TMP31)) + (-cI * (TMP27 * V4[2]) + cI * (V3[2] * TMP30)));
+  V1[3] = denom * S5[2] * (OM1 * P1[1] * (-cI * (TMP23 * TMP30) + cI * (TMP27 *
+      TMP31)) + (-cI * (TMP27 * V4[3]) + cI * (V3[3] * TMP30)));
+  V1[4] = denom * S5[2] * (OM1 * P1[2] * (-cI * (TMP23 * TMP30) + cI * (TMP27 *
+      TMP31)) + (-cI * (TMP27 * V4[4]) + cI * (V3[4] * TMP30)));
+  V1[5] = denom * S5[2] * (OM1 * P1[3] * (-cI * (TMP23 * TMP30) + cI * (TMP27 *
+      TMP31)) + (-cI * (TMP27 * V4[5]) + cI * (V3[5] * TMP30)));
+}
+
+
+void VVVVS3P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP30; 
+  std::complex<double> denom; 
+  V3[0] = +V1[0] + V2[0] + V4[0] + S5[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1] + S5[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * S5[2] * (-cI * (V1[2] * TMP30) + cI * (TMP21 * V4[2])); 
+  V3[3] = denom * S5[2] * (-cI * (V1[3] * TMP30) + cI * (TMP21 * V4[3])); 
+  V3[4] = denom * S5[2] * (-cI * (V1[4] * TMP30) + cI * (TMP21 * V4[4])); 
+  V3[5] = denom * S5[2] * (-cI * (V1[5] * TMP30) + cI * (TMP21 * V4[5])); 
+}
+
+
+void FFV3_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP13; 
+  std::complex<double> TMP8; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP13 = (F1[4] * (F2[2] * (P3[0] - P3[3]) - F2[3] * (P3[1] + cI * (P3[2]))) +
+      F1[5] * (F2[2] * (+cI * (P3[2]) - P3[1]) + F2[3] * (P3[0] + P3[3])));
+  TMP8 = (F1[2] * (F2[4] * (P3[0] + P3[3]) + F2[5] * (P3[1] + cI * (P3[2]))) +
+      F1[3] * (F2[4] * (P3[1] - cI * (P3[2])) + F2[5] * (P3[0] - P3[3])));
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * 2. * cI * (OM3 * 1./2. * P3[0] * (TMP8 - 2. * (TMP13)) +
+      (-1./2. * (F2[4] * F1[2] + F2[5] * F1[3]) + F2[2] * F1[4] + F2[3] *
+      F1[5]));
+  V3[3] = denom * 2. * cI * (OM3 * 1./2. * P3[1] * (TMP8 - 2. * (TMP13)) +
+      (+1./2. * (F2[5] * F1[2] + F2[4] * F1[3]) + F2[3] * F1[4] + F2[2] *
+      F1[5]));
+  V3[4] = denom * (-2. * cI) * (OM3 * 1./2. * P3[2] * (+2. * (TMP13) - TMP8) +
+      (-1./2. * cI * (F2[5] * F1[2]) + 1./2. * cI * (F2[4] * F1[3]) - cI *
+      (F2[3] * F1[4]) + cI * (F2[2] * F1[5])));
+  V3[5] = denom * (-2. * cI) * (OM3 * 1./2. * P3[3] * (+2. * (TMP13) - TMP8) +
+      (-1./2. * (F2[4] * F1[2]) + 1./2. * (F2[5] * F1[3]) - F2[2] * F1[4] +
+      F2[3] * F1[5]));
+}
+
+
+void FFV4C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP14; 
+  std::complex<double> TMP15; 
+  TMP15 = (-1.) * (F1[4] * (F2[2] * (V3[2] + V3[5]) + F2[3] * (V3[3] - cI *
+      (V3[4]))) + F1[5] * (F2[2] * (V3[3] + cI * (V3[4])) + F2[3] * (V3[2] -
+      V3[5])));
+  TMP14 = (-1.) * (F1[2] * (F2[4] * (V3[2] - V3[5]) + F2[5] * (+cI * (V3[4]) -
+      V3[3])) + F1[3] * (F2[4] * (-1.) * (V3[3] + cI * (V3[4])) + F2[5] *
+      (V3[2] + V3[5])));
+  vertex = COUP * (-1.) * (+cI * (TMP14) + 2. * cI * (TMP15)); 
+}
+
+
+void VVVV3_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM4; 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP33; 
+  std::complex<double> TMP37; 
+  std::complex<double> denom; 
+  OM4 = 0.; 
+  if (M4 != 0.)
+    OM4 = 1./(M4 * M4); 
+  V4[0] = +V1[0] + V2[0] + V3[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP37 = (V3[2] * P4[0] - V3[3] * P4[1] - V3[4] * P4[2] - V3[5] * P4[3]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP33 = (V1[2] * P4[0] - V1[3] * P4[1] - V1[4] * P4[2] - V1[5] * P4[3]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * (OM4 * P4[0] * (-cI * (TMP21 * TMP37) + cI * (TMP27 * TMP33))
+      + (-cI * (V1[2] * TMP27) + cI * (V3[2] * TMP21)));
+  V4[3] = denom * (OM4 * P4[1] * (-cI * (TMP21 * TMP37) + cI * (TMP27 * TMP33))
+      + (-cI * (V1[3] * TMP27) + cI * (V3[3] * TMP21)));
+  V4[4] = denom * (OM4 * P4[2] * (-cI * (TMP21 * TMP37) + cI * (TMP27 * TMP33))
+      + (-cI * (V1[4] * TMP27) + cI * (V3[4] * TMP21)));
+  V4[5] = denom * (OM4 * P4[3] * (-cI * (TMP21 * TMP37) + cI * (TMP27 * TMP33))
+      + (-cI * (V1[5] * TMP27) + cI * (V3[5] * TMP21)));
+}
+
+
+void FFS2C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP1; 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  vertex = COUP * - cI * TMP1 * S3[2]; 
+}
+
+void FFS2_4C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex)
+{
+  std::complex<double> tmp; 
+  FFS2C1_0(F2, F1, S3, COUP1, vertex); 
+  FFS4C1_0(F2, F1, S3, COUP2, tmp); 
+  vertex = vertex + tmp; 
+}
+
+void VVVVS2_5(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, double M5, double W5, std::complex<double> S5[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P5[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  S5[0] = +V1[0] + V2[0] + V3[0] + V4[0]; 
+  S5[1] = +V1[1] + V2[1] + V3[1] + V4[1]; 
+  P5[0] = -S5[0].real(); 
+  P5[1] = -S5[1].real(); 
+  P5[2] = -S5[1].imag(); 
+  P5[3] = -S5[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P5[0] * P5[0]) - (P5[1] * P5[1]) - (P5[2] * P5[2]) - (P5[3] *
+      P5[3]) - M5 * (M5 - cI * W5));
+  S5[2] = denom * (-cI * (TMP21 * TMP35) + cI * (TMP27 * TMP29)); 
+}
+
+
+void FFS4_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * - cI * S3[2] * (F2[4] * (P1[0] + P1[3]) + F2[5] * (P1[1] + cI
+      * (P1[2])));
+  F1[3] = denom * cI * S3[2] * (F2[4] * (+cI * (P1[2]) - P1[1]) + F2[5] *
+      (P1[3] - P1[0]));
+  F1[4] = denom * cI * F2[4] * M1 * S3[2]; 
+  F1[5] = denom * cI * F2[5] * M1 * S3[2]; 
+}
+
+
+void SSSS1_1(std::complex<double> S2[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> S1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  S1[0] = +S2[0] + S3[0] + S4[0]; 
+  S1[1] = +S2[1] + S3[1] + S4[1]; 
+  P1[0] = -S1[0].real(); 
+  P1[1] = -S1[1].real(); 
+  P1[2] = -S1[1].imag(); 
+  P1[3] = -S1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  S1[2] = denom * cI * S4[2] * S3[2] * S2[2]; 
+}
+
+
+void VVV1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP27; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  vertex = COUP * (TMP21 * (-cI * (TMP23) + cI * (TMP24)) + (TMP25 * (-cI *
+      (TMP26) + cI * (TMP22)) + TMP27 * (-cI * (TMP17) + cI * (TMP18))));
+}
+
+
+void VVS1_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  std::complex<double> TMP22; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  V1[0] = +V2[0] + S3[0]; 
+  V1[1] = +V2[1] + S3[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S3[2] * (-cI * (V2[2]) + cI * (P1[0] * OM1 * TMP22)); 
+  V1[3] = denom * S3[2] * (-cI * (V2[3]) + cI * (P1[1] * OM1 * TMP22)); 
+  V1[4] = denom * S3[2] * (-cI * (V2[4]) + cI * (P1[2] * OM1 * TMP22)); 
+  V1[5] = denom * S3[2] * (-cI * (V2[5]) + cI * (P1[3] * OM1 * TMP22)); 
+}
+
+
+void FFS2_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * cI * F2[2] * M1 * S3[2]; 
+  F1[3] = denom * cI * F2[3] * M1 * S3[2]; 
+  F1[4] = denom * cI * S3[2] * (F2[2] * (P1[3] - P1[0]) + F2[3] * (P1[1] + cI *
+      (P1[2])));
+  F1[5] = denom * - cI * S3[2] * (F2[2] * (+cI * (P1[2]) - P1[1]) + F2[3] *
+      (P1[0] + P1[3]));
+}
+
+void FFS2_4_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFS2_1(F2, S3, COUP1, M1, W1, F1); 
+  FFS4_1(F2, S3, COUP2, M1, W1, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F1[i] = F1[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+
+void FFS5C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * - cI * S3[2] * (F1[4] * (P2[0] + P2[3]) + (F1[5] * (P2[1] +
+      cI * (P2[2])) - F1[2] * M2));
+  F2[3] = denom * cI * S3[2] * (F1[4] * (+cI * (P2[2]) - P2[1]) + (F1[5] *
+      (P2[3] - P2[0]) + F1[3] * M2));
+  F2[4] = denom * cI * S3[2] * (F1[2] * (P2[3] - P2[0]) + (F1[3] * (P2[1] + cI
+      * (P2[2])) + F1[4] * M2));
+  F2[5] = denom * - cI * S3[2] * (F1[2] * (+cI * (P2[2]) - P2[1]) + (F1[3] *
+      (P2[0] + P2[3]) - F1[5] * M2));
+}
+
+
+void FFV1C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP5; 
+  TMP5 = (-1.) * (F1[2] * (F2[4] * (V3[2] - V3[5]) + F2[5] * (+cI * (V3[4]) -
+      V3[3])) + (F1[3] * (F2[4] * (-1.) * (V3[3] + cI * (V3[4])) + F2[5] *
+      (V3[2] + V3[5])) + (F1[4] * (F2[2] * (V3[2] + V3[5]) + F2[3] * (V3[3] -
+      cI * (V3[4]))) + F1[5] * (F2[2] * (V3[3] + cI * (V3[4])) + F2[3] * (V3[2]
+      - V3[5])))));
+  vertex = COUP * - cI * TMP5; 
+}
+
+
+void VVS1P0_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  V1[0] = +V2[0] + S3[0]; 
+  V1[1] = +V2[1] + S3[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * - cI * V2[2] * S3[2]; 
+  V1[3] = denom * - cI * V2[3] * S3[2]; 
+  V1[4] = denom * - cI * V2[4] * S3[2]; 
+  V1[5] = denom * - cI * V2[5] * S3[2]; 
+}
+
+
+void VVVV3P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V1[0] = +V2[0] + V3[0] + V4[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * (-cI * (TMP27 * V4[2]) + cI * (V2[2] * TMP35)); 
+  V1[3] = denom * (-cI * (TMP27 * V4[3]) + cI * (V2[3] * TMP35)); 
+  V1[4] = denom * (-cI * (TMP27 * V4[4]) + cI * (V2[4] * TMP35)); 
+  V1[5] = denom * (-cI * (TMP27 * V4[5]) + cI * (V2[5] * TMP35)); 
+}
+
+
+void VVVS1P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP27; 
+  std::complex<double> denom; 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  V1[0] = +V2[0] + V3[0] + S4[0]; 
+  V1[1] = +V2[1] + V3[1] + S4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S4[2] * (TMP27 * (-cI * (P2[0]) + cI * (P3[0])) + (V2[2] *
+      (-cI * (TMP23) + cI * (TMP24)) + V3[2] * (-cI * (TMP26) + cI * (TMP22))));
+  V1[3] = denom * S4[2] * (TMP27 * (-cI * (P2[1]) + cI * (P3[1])) + (V2[3] *
+      (-cI * (TMP23) + cI * (TMP24)) + V3[3] * (-cI * (TMP26) + cI * (TMP22))));
+  V1[4] = denom * S4[2] * (TMP27 * (-cI * (P2[2]) + cI * (P3[2])) + (V2[4] *
+      (-cI * (TMP23) + cI * (TMP24)) + V3[4] * (-cI * (TMP26) + cI * (TMP22))));
+  V1[5] = denom * S4[2] * (TMP27 * (-cI * (P2[3]) + cI * (P3[3])) + (V2[5] *
+      (-cI * (TMP23) + cI * (TMP24)) + V3[5] * (-cI * (TMP26) + cI * (TMP22))));
+}
+
+
+void VVVV2_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM4; 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP33; 
+  std::complex<double> TMP34; 
+  std::complex<double> TMP37; 
+  std::complex<double> denom; 
+  OM4 = 0.; 
+  if (M4 != 0.)
+    OM4 = 1./(M4 * M4); 
+  V4[0] = +V1[0] + V2[0] + V3[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP34 = (V2[2] * P4[0] - V2[3] * P4[1] - V2[4] * P4[2] - V2[5] * P4[3]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP37 = (V3[2] * P4[0] - V3[3] * P4[1] - V3[4] * P4[2] - V3[5] * P4[3]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP33 = (V1[2] * P4[0] - V1[3] * P4[1] - V1[4] * P4[2] - V1[5] * P4[3]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * (OM4 * P4[0] * (-2. * cI * (TMP21 * TMP37) + cI * (TMP27 *
+      TMP33 + TMP25 * TMP34)) + (-cI * (V1[2] * TMP27 + V2[2] * TMP25) + 2. *
+      cI * (V3[2] * TMP21)));
+  V4[3] = denom * (OM4 * P4[1] * (-2. * cI * (TMP21 * TMP37) + cI * (TMP27 *
+      TMP33 + TMP25 * TMP34)) + (-cI * (V1[3] * TMP27 + V2[3] * TMP25) + 2. *
+      cI * (V3[3] * TMP21)));
+  V4[4] = denom * (OM4 * P4[2] * (-2. * cI * (TMP21 * TMP37) + cI * (TMP27 *
+      TMP33 + TMP25 * TMP34)) + (-cI * (V1[4] * TMP27 + V2[4] * TMP25) + 2. *
+      cI * (V3[4] * TMP21)));
+  V4[5] = denom * (OM4 * P4[3] * (-2. * cI * (TMP21 * TMP37) + cI * (TMP27 *
+      TMP33 + TMP25 * TMP34)) + (-cI * (V1[5] * TMP27 + V2[5] * TMP25) + 2. *
+      cI * (V3[5] * TMP21)));
+}
+
+
+void FFS2C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP1; 
+  std::complex<double> denom; 
+  S3[0] = +F1[0] + F2[0]; 
+  S3[1] = +F1[1] + F2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * cI * TMP1; 
+}
+
+void FFS2_4C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> S3[])
+{
+  std::complex<double> Stmp[3]; 
+  int i; 
+  FFS2C1_3(F2, F1, COUP1, M3, W3, S3); 
+  FFS4C1_3(F2, F1, COUP2, M3, W3, Stmp); 
+  i = 2; 
+  while (i < 3)
+  {
+    S3[i] = S3[i] + Stmp[i]; 
+    i++; 
+  }
+}
+
+void FFV5C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP14; 
+  std::complex<double> TMP15; 
+  TMP15 = (-1.) * (F1[4] * (F2[2] * (V3[2] + V3[5]) + F2[3] * (V3[3] - cI *
+      (V3[4]))) + F1[5] * (F2[2] * (V3[3] + cI * (V3[4])) + F2[3] * (V3[2] -
+      V3[5])));
+  TMP14 = (-1.) * (F1[2] * (F2[4] * (V3[2] - V3[5]) + F2[5] * (+cI * (V3[4]) -
+      V3[3])) + F1[3] * (F2[4] * (-1.) * (V3[3] + cI * (V3[4])) + F2[5] *
+      (V3[2] + V3[5])));
+  vertex = COUP * (-1.) * (+cI * (TMP14) + 4. * cI * (TMP15)); 
+}
+
+
+void VVVV1_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM4; 
+  double P4[4]; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP33; 
+  std::complex<double> TMP34; 
+  std::complex<double> denom; 
+  OM4 = 0.; 
+  if (M4 != 0.)
+    OM4 = 1./(M4 * M4); 
+  V4[0] = +V1[0] + V2[0] + V3[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP34 = (V2[2] * P4[0] - V2[3] * P4[1] - V2[4] * P4[2] - V2[5] * P4[3]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP33 = (V1[2] * P4[0] - V1[3] * P4[1] - V1[4] * P4[2] - V1[5] * P4[3]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * (OM4 * P4[0] * (-cI * (TMP25 * TMP34) + cI * (TMP27 * TMP33))
+      + (-cI * (V1[2] * TMP27) + cI * (V2[2] * TMP25)));
+  V4[3] = denom * (OM4 * P4[1] * (-cI * (TMP25 * TMP34) + cI * (TMP27 * TMP33))
+      + (-cI * (V1[3] * TMP27) + cI * (V2[3] * TMP25)));
+  V4[4] = denom * (OM4 * P4[2] * (-cI * (TMP25 * TMP34) + cI * (TMP27 * TMP33))
+      + (-cI * (V1[4] * TMP27) + cI * (V2[4] * TMP25)));
+  V4[5] = denom * (OM4 * P4[3] * (-cI * (TMP25 * TMP34) + cI * (TMP27 * TMP33))
+      + (-cI * (V1[5] * TMP27) + cI * (V2[5] * TMP25)));
+}
+
+
+void VVVVS2_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    S5[], std::complex<double> COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP35; 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  vertex = COUP * S5[2] * (-cI * (TMP27 * TMP29) + cI * (TMP21 * TMP35)); 
+}
+
+
+void VVV1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP20; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP28; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +V1[0] + V2[0]; 
+  V3[1] = +V1[1] + V2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP28 = (P2[0] * P3[0] - P2[1] * P3[1] - P2[2] * P3[2] - P2[3] * P3[3]); 
+  TMP20 = (P1[0] * P3[0] - P1[1] * P3[1] - P1[2] * P3[2] - P1[3] * P3[3]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (OM3 * P3[0] * (TMP21 * (-cI * (TMP28) + cI * (TMP20)) + (-cI
+      * (TMP18 * TMP22) + cI * (TMP17 * TMP26))) + (TMP21 * (-cI * (P1[0]) + cI
+      * (P2[0])) + (V1[2] * (-cI * (TMP26) + cI * (TMP22)) + V2[2] * (-cI *
+      (TMP17) + cI * (TMP18)))));
+  V3[3] = denom * (OM3 * P3[1] * (TMP21 * (-cI * (TMP28) + cI * (TMP20)) + (-cI
+      * (TMP18 * TMP22) + cI * (TMP17 * TMP26))) + (TMP21 * (-cI * (P1[1]) + cI
+      * (P2[1])) + (V1[3] * (-cI * (TMP26) + cI * (TMP22)) + V2[3] * (-cI *
+      (TMP17) + cI * (TMP18)))));
+  V3[4] = denom * (OM3 * P3[2] * (TMP21 * (-cI * (TMP28) + cI * (TMP20)) + (-cI
+      * (TMP18 * TMP22) + cI * (TMP17 * TMP26))) + (TMP21 * (-cI * (P1[2]) + cI
+      * (P2[2])) + (V1[4] * (-cI * (TMP26) + cI * (TMP22)) + V2[4] * (-cI *
+      (TMP17) + cI * (TMP18)))));
+  V3[5] = denom * (OM3 * P3[3] * (TMP21 * (-cI * (TMP28) + cI * (TMP20)) + (-cI
+      * (TMP18 * TMP22) + cI * (TMP17 * TMP26))) + (TMP21 * (-cI * (P1[3]) + cI
+      * (P2[3])) + (V1[5] * (-cI * (TMP26) + cI * (TMP22)) + V2[5] * (-cI *
+      (TMP17) + cI * (TMP18)))));
+}
+
+
+void VVS1_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> denom; 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  V2[0] = +V1[0] + S3[0]; 
+  V2[1] = +V1[1] + S3[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S3[2] * (-cI * (V1[2]) + cI * (P2[0] * TMP17 * OM2)); 
+  V2[3] = denom * S3[2] * (-cI * (V1[3]) + cI * (P2[1] * TMP17 * OM2)); 
+  V2[4] = denom * S3[2] * (-cI * (V1[4]) + cI * (P2[2] * TMP17 * OM2)); 
+  V2[5] = denom * S3[2] * (-cI * (V1[5]) + cI * (P2[3] * TMP17 * OM2)); 
+}
+
+
+void FFS4C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP2; 
+  std::complex<double> denom; 
+  S3[0] = +F1[0] + F2[0]; 
+  S3[1] = +F1[1] + F2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * cI * TMP2; 
+}
+
+
+void FFS2_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * F1[2] * M2 * S3[2]; 
+  F2[3] = denom * cI * F1[3] * M2 * S3[2]; 
+  F2[4] = denom * - cI * S3[2] * (F1[2] * (-1.) * (P2[0] + P2[3]) + F1[3] *
+      (+cI * (P2[2]) - P2[1]));
+  F2[5] = denom * cI * S3[2] * (F1[2] * (P2[1] + cI * (P2[2])) + F1[3] * (P2[0]
+      - P2[3]));
+}
+
+void FFS2_4_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFS2_2(F1, S3, COUP1, M2, W2, F2); 
+  FFS4_2(F1, S3, COUP2, M2, W2, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F2[i] = F2[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+
+void VVS2_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP19; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  V2[0] = +V1[0] + S3[0]; 
+  V2[1] = +V1[1] + S3[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S3[2] * (-cI * (P1[0] * TMP17) + cI * (V1[2] * TMP19)); 
+  V2[3] = denom * S3[2] * (-cI * (P1[1] * TMP17) + cI * (V1[3] * TMP19)); 
+  V2[4] = denom * S3[2] * (-cI * (P1[2] * TMP17) + cI * (V1[4] * TMP19)); 
+  V2[5] = denom * S3[2] * (-cI * (P1[3] * TMP17) + cI * (V1[5] * TMP19)); 
+}
+
+
+void FFV1C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP6; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP6 = (-1.) * (F1[2] * (F2[4] * (P3[0] - P3[3]) + F2[5] * (+cI * (P3[2]) -
+      P3[1])) + (F1[3] * (F2[4] * (-1.) * (P3[1] + cI * (P3[2])) + F2[5] *
+      (P3[0] + P3[3])) + (F1[4] * (F2[2] * (P3[0] + P3[3]) + F2[3] * (P3[1] -
+      cI * (P3[2]))) + F1[5] * (F2[2] * (P3[1] + cI * (P3[2])) + F2[3] * (P3[0]
+      - P3[3])))));
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-cI) * (-F2[4] * F1[2] - F2[5] * F1[3] - F2[2] * F1[4] -
+      F2[3] * F1[5] - P3[0] * OM3 * TMP6);
+  V3[3] = denom * (-cI) * (F2[3] * F1[4] + F2[2] * F1[5] - F2[5] * F1[2] -
+      F2[4] * F1[3] - P3[1] * OM3 * TMP6);
+  V3[4] = denom * (-cI) * (-cI * (F2[4] * F1[3] + F2[3] * F1[4]) + cI * (F2[5]
+      * F1[2] + F2[2] * F1[5]) - P3[2] * OM3 * TMP6);
+  V3[5] = denom * (-cI) * (F2[5] * F1[3] + F2[2] * F1[4] - F2[4] * F1[2] -
+      F2[3] * F1[5] - P3[3] * OM3 * TMP6);
+}
+
+
+void FFV1_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * cI * (F2[2] * (P1[0] * (V3[5] - V3[2]) + (P1[1] * (V3[3] - cI
+      * (V3[4])) + (P1[2] * (V3[4] + cI * (V3[3])) + P1[3] * (V3[5] - V3[2]))))
+      + (F2[3] * (P1[0] * (V3[3] + cI * (V3[4])) + (P1[1] * (-1.) * (V3[2] +
+      V3[5]) + (P1[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P1[3] * (V3[3] + cI *
+      (V3[4]))))) + M1 * (F2[4] * (V3[2] + V3[5]) + F2[5] * (V3[3] + cI *
+      (V3[4])))));
+  F1[3] = denom * (-cI) * (F2[2] * (P1[0] * (+cI * (V3[4]) - V3[3]) + (P1[1] *
+      (V3[2] - V3[5]) + (P1[2] * (-cI * (V3[2]) + cI * (V3[5])) + P1[3] *
+      (V3[3] - cI * (V3[4]))))) + (F2[3] * (P1[0] * (V3[2] + V3[5]) + (P1[1] *
+      (-1.) * (V3[3] + cI * (V3[4])) + (P1[2] * (+cI * (V3[3]) - V3[4]) - P1[3]
+      * (V3[2] + V3[5])))) + M1 * (F2[4] * (+cI * (V3[4]) - V3[3]) + F2[5] *
+      (V3[5] - V3[2]))));
+  F1[4] = denom * (-cI) * (F2[4] * (P1[0] * (V3[2] + V3[5]) + (P1[1] * (+cI *
+      (V3[4]) - V3[3]) + (P1[2] * (-1.) * (V3[4] + cI * (V3[3])) - P1[3] *
+      (V3[2] + V3[5])))) + (F2[5] * (P1[0] * (V3[3] + cI * (V3[4])) + (P1[1] *
+      (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[2]) + cI * (V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))) + M1 * (F2[2] * (V3[5] - V3[2]) + F2[3] *
+      (V3[3] + cI * (V3[4])))));
+  F1[5] = denom * cI * (F2[4] * (P1[0] * (+cI * (V3[4]) - V3[3]) + (P1[1] *
+      (V3[2] + V3[5]) + (P1[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P1[3] * (+cI
+      * (V3[4]) - V3[3])))) + (F2[5] * (P1[0] * (V3[5] - V3[2]) + (P1[1] *
+      (V3[3] + cI * (V3[4])) + (P1[2] * (V3[4] - cI * (V3[3])) + P1[3] * (V3[5]
+      - V3[2])))) + M1 * (F2[2] * (+cI * (V3[4]) - V3[3]) + F2[3] * (V3[2] +
+      V3[5]))));
+}
+
+
+void VVVV3P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP27; 
+  std::complex<double> denom; 
+  V4[0] = +V1[0] + V2[0] + V3[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * (-cI * (V1[2] * TMP27) + cI * (V3[2] * TMP21)); 
+  V4[3] = denom * (-cI * (V1[3] * TMP27) + cI * (V3[3] * TMP21)); 
+  V4[4] = denom * (-cI * (V1[4] * TMP27) + cI * (V3[4] * TMP21)); 
+  V4[5] = denom * (-cI * (V1[5] * TMP27) + cI * (V3[5] * TMP21)); 
+}
+
+
+void SSS1_0(std::complex<double> S1[], std::complex<double> S2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  vertex = COUP * - cI * S3[2] * S2[2] * S1[2]; 
+}
+
+
+void VVVS1_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> S4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  double P4[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP27; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  S4[0] = +V1[0] + V2[0] + V3[0]; 
+  S4[1] = +V1[1] + V2[1] + V3[1]; 
+  P4[0] = -S4[0].real(); 
+  P4[1] = -S4[1].real(); 
+  P4[2] = -S4[1].imag(); 
+  P4[3] = -S4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  S4[2] = denom * (TMP21 * (-cI * (TMP24) + cI * (TMP23)) + (TMP25 * (-cI *
+      (TMP22) + cI * (TMP26)) + TMP27 * (-cI * (TMP18) + cI * (TMP17))));
+}
+
+
+void VVVVS3_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    S5[], std::complex<double> COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  vertex = COUP * S5[2] * (-cI * (TMP25 * TMP30) + cI * (TMP21 * TMP35)); 
+}
+
+
+void VVVV1P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP29; 
+  std::complex<double> denom; 
+  V2[0] = +V1[0] + V3[0] + V4[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * (-cI * (V3[2] * TMP29) + cI * (TMP25 * V4[2])); 
+  V2[3] = denom * (-cI * (V3[3] * TMP29) + cI * (TMP25 * V4[3])); 
+  V2[4] = denom * (-cI * (V3[4] * TMP29) + cI * (TMP25 * V4[4])); 
+  V2[5] = denom * (-cI * (V3[5] * TMP29) + cI * (TMP25 * V4[5])); 
+}
+
+
+void VVSS1_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> denom; 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  V2[0] = +V1[0] + S3[0] + S4[0]; 
+  V2[1] = +V1[1] + S3[1] + S4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S3[2] * S4[2] * (-cI * (V1[2]) + cI * (P2[0] * TMP17 * OM2)); 
+  V2[3] = denom * S3[2] * S4[2] * (-cI * (V1[3]) + cI * (P2[1] * TMP17 * OM2)); 
+  V2[4] = denom * S3[2] * S4[2] * (-cI * (V1[4]) + cI * (P2[2] * TMP17 * OM2)); 
+  V2[5] = denom * S3[2] * S4[2] * (-cI * (V1[5]) + cI * (P2[3] * TMP17 * OM2)); 
+}
+
+
+void VSS1_1(std::complex<double> S2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP19; 
+  std::complex<double> TMP20; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  P2[0] = S2[0].real(); 
+  P2[1] = S2[1].real(); 
+  P2[2] = S2[1].imag(); 
+  P2[3] = S2[0].imag(); 
+  P3[0] = S3[0].real(); 
+  P3[1] = S3[1].real(); 
+  P3[2] = S3[1].imag(); 
+  P3[3] = S3[0].imag(); 
+  V1[0] = +S2[0] + S3[0]; 
+  V1[1] = +S2[1] + S3[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  TMP20 = (P1[0] * P3[0] - P1[1] * P3[1] - P1[2] * P3[2] - P1[3] * P3[3]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S2[2] * S3[2] * (OM1 * P1[0] * (-cI * (TMP20) + cI * (TMP19))
+      + (-cI * (P2[0]) + cI * (P3[0])));
+  V1[3] = denom * S2[2] * S3[2] * (OM1 * P1[1] * (-cI * (TMP20) + cI * (TMP19))
+      + (-cI * (P2[1]) + cI * (P3[1])));
+  V1[4] = denom * S2[2] * S3[2] * (OM1 * P1[2] * (-cI * (TMP20) + cI * (TMP19))
+      + (-cI * (P2[2]) + cI * (P3[2])));
+  V1[5] = denom * S2[2] * S3[2] * (OM1 * P1[3] * (-cI * (TMP20) + cI * (TMP19))
+      + (-cI * (P2[3]) + cI * (P3[3])));
+}
+
+
+void VVVS1P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP26; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  V3[0] = +V1[0] + V2[0] + S4[0]; 
+  V3[1] = +V1[1] + V2[1] + S4[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * S4[2] * (TMP21 * (-cI * (P1[0]) + cI * (P2[0])) + (V1[2] *
+      (-cI * (TMP26) + cI * (TMP22)) + V2[2] * (-cI * (TMP17) + cI * (TMP18))));
+  V3[3] = denom * S4[2] * (TMP21 * (-cI * (P1[1]) + cI * (P2[1])) + (V1[3] *
+      (-cI * (TMP26) + cI * (TMP22)) + V2[3] * (-cI * (TMP17) + cI * (TMP18))));
+  V3[4] = denom * S4[2] * (TMP21 * (-cI * (P1[2]) + cI * (P2[2])) + (V1[4] *
+      (-cI * (TMP26) + cI * (TMP22)) + V2[4] * (-cI * (TMP17) + cI * (TMP18))));
+  V3[5] = denom * S4[2] * (TMP21 * (-cI * (P1[3]) + cI * (P2[3])) + (V1[5] *
+      (-cI * (TMP26) + cI * (TMP22)) + V2[5] * (-cI * (TMP17) + cI * (TMP18))));
+}
+
+
+void FFV2_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP8; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP8 = (F1[2] * (F2[4] * (P3[0] + P3[3]) + F2[5] * (P3[1] + cI * (P3[2]))) +
+      F1[3] * (F2[4] * (P3[1] - cI * (P3[2])) + F2[5] * (P3[0] - P3[3])));
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-cI) * (F2[4] * F1[2] + F2[5] * F1[3] - P3[0] * OM3 * TMP8); 
+  V3[3] = denom * (-cI) * (-F2[5] * F1[2] - F2[4] * F1[3] - P3[1] * OM3 *
+      TMP8);
+  V3[4] = denom * (-cI) * (-cI * (F2[5] * F1[2]) + cI * (F2[4] * F1[3]) - P3[2]
+      * OM3 * TMP8);
+  V3[5] = denom * (-cI) * (F2[5] * F1[3] - F2[4] * F1[2] - P3[3] * OM3 * TMP8); 
+}
+
+void FFV2_5_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[])
+{
+  std::complex<double> Vtmp[6]; 
+  int i; 
+  FFV2_3(F1, F2, COUP1, M3, W3, V3); 
+  FFV5_3(F1, F2, COUP2, M3, W3, Vtmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    V3[i] = V3[i] + Vtmp[i]; 
+    i++; 
+  }
+}
+void FFV2_3_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[])
+{
+  std::complex<double> Vtmp[6]; 
+  int i; 
+  FFV2_3(F1, F2, COUP1, M3, W3, V3); 
+  FFV3_3(F1, F2, COUP2, M3, W3, Vtmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    V3[i] = V3[i] + Vtmp[i]; 
+    i++; 
+  }
+}
+void FFV2_4_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[])
+{
+  std::complex<double> Vtmp[6]; 
+  int i; 
+  FFV2_3(F1, F2, COUP1, M3, W3, V3); 
+  FFV4_3(F1, F2, COUP2, M3, W3, Vtmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    V3[i] = V3[i] + Vtmp[i]; 
+    i++; 
+  }
+}
+
+void VVVV1_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP31; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  V1[0] = +V2[0] + V3[0] + V4[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP31 = (P1[0] * V4[2] - P1[1] * V4[3] - P1[2] * V4[4] - P1[3] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * (OM1 * P1[0] * (-cI * (TMP23 * TMP30) + cI * (TMP27 * TMP31))
+      + (-cI * (TMP27 * V4[2]) + cI * (V3[2] * TMP30)));
+  V1[3] = denom * (OM1 * P1[1] * (-cI * (TMP23 * TMP30) + cI * (TMP27 * TMP31))
+      + (-cI * (TMP27 * V4[3]) + cI * (V3[3] * TMP30)));
+  V1[4] = denom * (OM1 * P1[2] * (-cI * (TMP23 * TMP30) + cI * (TMP27 * TMP31))
+      + (-cI * (TMP27 * V4[4]) + cI * (V3[4] * TMP30)));
+  V1[5] = denom * (OM1 * P1[3] * (-cI * (TMP23 * TMP30) + cI * (TMP27 * TMP31))
+      + (-cI * (TMP27 * V4[5]) + cI * (V3[5] * TMP30)));
+}
+
+
+void VVVVS2_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP36; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +V1[0] + V2[0] + V4[0] + S5[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1] + S5[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP36 = (P3[0] * V4[2] - P3[1] * V4[3] - P3[2] * V4[4] - P3[3] * V4[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * S5[2] * (OM3 * P3[0] * (-cI * (TMP21 * TMP36) + cI * (TMP26 *
+      TMP29)) + (-cI * (V2[2] * TMP29) + cI * (TMP21 * V4[2])));
+  V3[3] = denom * S5[2] * (OM3 * P3[1] * (-cI * (TMP21 * TMP36) + cI * (TMP26 *
+      TMP29)) + (-cI * (V2[3] * TMP29) + cI * (TMP21 * V4[3])));
+  V3[4] = denom * S5[2] * (OM3 * P3[2] * (-cI * (TMP21 * TMP36) + cI * (TMP26 *
+      TMP29)) + (-cI * (V2[4] * TMP29) + cI * (TMP21 * V4[4])));
+  V3[5] = denom * S5[2] * (OM3 * P3[3] * (-cI * (TMP21 * TMP36) + cI * (TMP26 *
+      TMP29)) + (-cI * (V2[5] * TMP29) + cI * (TMP21 * V4[5])));
+}
+
+
+void VVVVS1P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  std::complex<double> denom; 
+  V3[0] = +V1[0] + V2[0] + V4[0] + S5[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1] + S5[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * S5[2] * (-cI * (V2[2] * TMP29) + cI * (V1[2] * TMP30)); 
+  V3[3] = denom * S5[2] * (-cI * (V2[3] * TMP29) + cI * (V1[3] * TMP30)); 
+  V3[4] = denom * S5[2] * (-cI * (V2[4] * TMP29) + cI * (V1[4] * TMP30)); 
+  V3[5] = denom * S5[2] * (-cI * (V2[5] * TMP29) + cI * (V1[5] * TMP30)); 
+}
+
+
+void FFV2C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP9; 
+  TMP9 = (-1.) * (F1[2] * (F2[4] * (V3[2] - V3[5]) + F2[5] * (+cI * (V3[4]) -
+      V3[3])) + F1[3] * (F2[4] * (-1.) * (V3[3] + cI * (V3[4])) + F2[5] *
+      (V3[2] + V3[5])));
+  vertex = COUP * - cI * TMP9; 
+}
+
+void FFV2_5C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex)
+{
+  std::complex<double> tmp; 
+  FFV2C1_0(F2, F1, V3, COUP1, vertex); 
+  FFV5C1_0(F2, F1, V3, COUP2, tmp); 
+  vertex = vertex + tmp; 
+}
+void FFV2_3C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex)
+{
+  std::complex<double> tmp; 
+  FFV2C1_0(F2, F1, V3, COUP1, vertex); 
+  FFV3C1_0(F2, F1, V3, COUP2, tmp); 
+  vertex = vertex + tmp; 
+}
+void FFV2_4C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP1, std::complex<double>
+    COUP2, std::complex<double> & vertex)
+{
+  std::complex<double> tmp; 
+  FFV2C1_0(F2, F1, V3, COUP1, vertex); 
+  FFV4C1_0(F2, F1, V3, COUP2, tmp); 
+  vertex = vertex + tmp; 
+}
+
+void FFS5_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP1; 
+  std::complex<double> TMP2; 
+  std::complex<double> denom; 
+  S3[0] = +F1[0] + F2[0]; 
+  S3[1] = +F1[1] + F2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * (+cI * (TMP1 + TMP2)); 
+}
+
+
+void VVVV1P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P4[4]; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> denom; 
+  V4[0] = +V1[0] + V2[0] + V3[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * (-cI * (V1[2] * TMP27) + cI * (V2[2] * TMP25)); 
+  V4[3] = denom * (-cI * (V1[3] * TMP27) + cI * (V2[3] * TMP25)); 
+  V4[4] = denom * (-cI * (V1[4] * TMP27) + cI * (V2[4] * TMP25)); 
+  V4[5] = denom * (-cI * (V1[5] * TMP27) + cI * (V2[5] * TMP25)); 
+}
+
+
+void VVVV4_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  V1[0] = +V2[0] + V3[0] + V4[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * (OM1 * P1[0] * (-cI * (TMP22 * TMP35) + cI * (TMP23 * TMP30))
+      + (-cI * (V3[2] * TMP30) + cI * (V2[2] * TMP35)));
+  V1[3] = denom * (OM1 * P1[1] * (-cI * (TMP22 * TMP35) + cI * (TMP23 * TMP30))
+      + (-cI * (V3[3] * TMP30) + cI * (V2[3] * TMP35)));
+  V1[4] = denom * (OM1 * P1[2] * (-cI * (TMP22 * TMP35) + cI * (TMP23 * TMP30))
+      + (-cI * (V3[4] * TMP30) + cI * (V2[4] * TMP35)));
+  V1[5] = denom * (OM1 * P1[3] * (-cI * (TMP22 * TMP35) + cI * (TMP23 * TMP30))
+      + (-cI * (V3[5] * TMP30) + cI * (V2[5] * TMP35)));
+}
+
+
+void FFV4_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP11; 
+  std::complex<double> TMP12; 
+  TMP11 = (F1[2] * (F2[4] * (V3[2] + V3[5]) + F2[5] * (V3[3] + cI * (V3[4]))) +
+      F1[3] * (F2[4] * (V3[3] - cI * (V3[4])) + F2[5] * (V3[2] - V3[5])));
+  TMP12 = (F1[4] * (F2[2] * (V3[2] - V3[5]) - F2[3] * (V3[3] + cI * (V3[4]))) +
+      F1[5] * (F2[2] * (+cI * (V3[4]) - V3[3]) + F2[3] * (V3[2] + V3[5])));
+  vertex = COUP * (-1.) * (+cI * (TMP11) + 2. * cI * (TMP12)); 
+}
+
+
+void VVS2_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  std::complex<double> TMP19; 
+  std::complex<double> TMP22; 
+  std::complex<double> denom; 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  V1[0] = +V2[0] + S3[0]; 
+  V1[1] = +V2[1] + S3[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S3[2] * (-cI * (P2[0] * TMP22) + cI * (TMP19 * V2[2])); 
+  V1[3] = denom * S3[2] * (-cI * (P2[1] * TMP22) + cI * (TMP19 * V2[3])); 
+  V1[4] = denom * S3[2] * (-cI * (P2[2] * TMP22) + cI * (TMP19 * V2[4])); 
+  V1[5] = denom * S3[2] * (-cI * (P2[3] * TMP22) + cI * (TMP19 * V2[5])); 
+}
+
+
+void FFV2P0_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * cI * M1 * (F2[4] * (V3[2] + V3[5]) + F2[5] * (V3[3] + cI *
+      (V3[4])));
+  F1[3] = denom * - cI * M1 * (F2[4] * (+cI * (V3[4]) - V3[3]) + F2[5] * (V3[5]
+      - V3[2]));
+  F1[4] = denom * (-cI) * (F2[4] * (P1[0] * (V3[2] + V3[5]) + (P1[1] * (+cI *
+      (V3[4]) - V3[3]) + (P1[2] * (-1.) * (V3[4] + cI * (V3[3])) - P1[3] *
+      (V3[2] + V3[5])))) + F2[5] * (P1[0] * (V3[3] + cI * (V3[4])) + (P1[1] *
+      (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[2]) + cI * (V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))));
+  F1[5] = denom * (-cI) * (F2[4] * (P1[0] * (V3[3] - cI * (V3[4])) + (P1[1] *
+      (-1.) * (V3[2] + V3[5]) + (P1[2] * (+cI * (V3[2] + V3[5])) + P1[3] *
+      (V3[3] - cI * (V3[4]))))) + F2[5] * (P1[0] * (V3[2] - V3[5]) + (P1[1] *
+      (-1.) * (V3[3] + cI * (V3[4])) + (P1[2] * (+cI * (V3[3]) - V3[4]) + P1[3]
+      * (V3[2] - V3[5])))));
+}
+
+
+void VVV1P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  V2[0] = +V1[0] + V3[0]; 
+  V2[1] = +V1[1] + V3[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * (TMP25 * (-cI * (P3[0]) + cI * (P1[0])) + (V1[2] * (-cI *
+      (TMP23) + cI * (TMP24)) + V3[2] * (-cI * (TMP17) + cI * (TMP18))));
+  V2[3] = denom * (TMP25 * (-cI * (P3[1]) + cI * (P1[1])) + (V1[3] * (-cI *
+      (TMP23) + cI * (TMP24)) + V3[3] * (-cI * (TMP17) + cI * (TMP18))));
+  V2[4] = denom * (TMP25 * (-cI * (P3[2]) + cI * (P1[2])) + (V1[4] * (-cI *
+      (TMP23) + cI * (TMP24)) + V3[4] * (-cI * (TMP17) + cI * (TMP18))));
+  V2[5] = denom * (TMP25 * (-cI * (P3[3]) + cI * (P1[3])) + (V1[5] * (-cI *
+      (TMP23) + cI * (TMP24)) + V3[5] * (-cI * (TMP17) + cI * (TMP18))));
+}
+
+
+void VVVVS1_5(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, double M5, double W5, std::complex<double> S5[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P5[4]; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  std::complex<double> denom; 
+  S5[0] = +V1[0] + V2[0] + V3[0] + V4[0]; 
+  S5[1] = +V1[1] + V2[1] + V3[1] + V4[1]; 
+  P5[0] = -S5[0].real(); 
+  P5[1] = -S5[1].real(); 
+  P5[2] = -S5[1].imag(); 
+  P5[3] = -S5[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  denom = COUP/((P5[0] * P5[0]) - (P5[1] * P5[1]) - (P5[2] * P5[2]) - (P5[3] *
+      P5[3]) - M5 * (M5 - cI * W5));
+  S5[2] = denom * (-cI * (TMP25 * TMP30) + cI * (TMP27 * TMP29)); 
+}
+
+
+void VVVS1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP20; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP28; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +V1[0] + V2[0] + S4[0]; 
+  V3[1] = +V1[1] + V2[1] + S4[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP28 = (P2[0] * P3[0] - P2[1] * P3[1] - P2[2] * P3[2] - P2[3] * P3[3]); 
+  TMP20 = (P1[0] * P3[0] - P1[1] * P3[1] - P1[2] * P3[2] - P1[3] * P3[3]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * S4[2] * (OM3 * P3[0] * (TMP21 * (-cI * (TMP28) + cI *
+      (TMP20)) + (-cI * (TMP18 * TMP22) + cI * (TMP17 * TMP26))) + (TMP21 *
+      (-cI * (P1[0]) + cI * (P2[0])) + (V1[2] * (-cI * (TMP26) + cI * (TMP22))
+      + V2[2] * (-cI * (TMP17) + cI * (TMP18)))));
+  V3[3] = denom * S4[2] * (OM3 * P3[1] * (TMP21 * (-cI * (TMP28) + cI *
+      (TMP20)) + (-cI * (TMP18 * TMP22) + cI * (TMP17 * TMP26))) + (TMP21 *
+      (-cI * (P1[1]) + cI * (P2[1])) + (V1[3] * (-cI * (TMP26) + cI * (TMP22))
+      + V2[3] * (-cI * (TMP17) + cI * (TMP18)))));
+  V3[4] = denom * S4[2] * (OM3 * P3[2] * (TMP21 * (-cI * (TMP28) + cI *
+      (TMP20)) + (-cI * (TMP18 * TMP22) + cI * (TMP17 * TMP26))) + (TMP21 *
+      (-cI * (P1[2]) + cI * (P2[2])) + (V1[4] * (-cI * (TMP26) + cI * (TMP22))
+      + V2[4] * (-cI * (TMP17) + cI * (TMP18)))));
+  V3[5] = denom * S4[2] * (OM3 * P3[3] * (TMP21 * (-cI * (TMP28) + cI *
+      (TMP20)) + (-cI * (TMP18 * TMP22) + cI * (TMP17 * TMP26))) + (TMP21 *
+      (-cI * (P1[3]) + cI * (P2[3])) + (V1[5] * (-cI * (TMP26) + cI * (TMP22))
+      + V2[5] * (-cI * (TMP17) + cI * (TMP18)))));
+}
+
+
+void VVVVS1P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP29; 
+  std::complex<double> denom; 
+  V2[0] = +V1[0] + V3[0] + V4[0] + S5[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1] + S5[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S5[2] * (-cI * (V3[2] * TMP29) + cI * (TMP25 * V4[2])); 
+  V2[3] = denom * S5[2] * (-cI * (V3[3] * TMP29) + cI * (TMP25 * V4[3])); 
+  V2[4] = denom * S5[2] * (-cI * (V3[4] * TMP29) + cI * (TMP25 * V4[4])); 
+  V2[5] = denom * S5[2] * (-cI * (V3[5] * TMP29) + cI * (TMP25 * V4[5])); 
+}
+
+
+void VVVV2_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP32; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  V2[0] = +V1[0] + V3[0] + V4[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP32 = (P2[0] * V4[2] - P2[1] * V4[3] - P2[2] * V4[4] - P2[3] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * (OM2 * P2[0] * (-2. * cI * (TMP17 * TMP35) + cI * (TMP24 *
+      TMP29 + TMP25 * TMP32)) + (-cI * (V3[2] * TMP29 + TMP25 * V4[2]) + 2. *
+      cI * (V1[2] * TMP35)));
+  V2[3] = denom * (OM2 * P2[1] * (-2. * cI * (TMP17 * TMP35) + cI * (TMP24 *
+      TMP29 + TMP25 * TMP32)) + (-cI * (V3[3] * TMP29 + TMP25 * V4[3]) + 2. *
+      cI * (V1[3] * TMP35)));
+  V2[4] = denom * (OM2 * P2[2] * (-2. * cI * (TMP17 * TMP35) + cI * (TMP24 *
+      TMP29 + TMP25 * TMP32)) + (-cI * (V3[4] * TMP29 + TMP25 * V4[4]) + 2. *
+      cI * (V1[4] * TMP35)));
+  V2[5] = denom * (OM2 * P2[3] * (-2. * cI * (TMP17 * TMP35) + cI * (TMP24 *
+      TMP29 + TMP25 * TMP32)) + (-cI * (V3[5] * TMP29 + TMP25 * V4[5]) + 2. *
+      cI * (V1[5] * TMP35)));
+}
+
+
+void FFV5C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * (-cI) * (F1[2] * (P2[0] * (V3[5] - V3[2]) + (P2[1] * (V3[3] -
+      cI * (V3[4])) + (P2[2] * (V3[4] + cI * (V3[3])) + P2[3] * (V3[5] -
+      V3[2])))) + (F1[3] * (P2[0] * (V3[3] + cI * (V3[4])) + (P2[1] * (-1.) *
+      (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P2[3] *
+      (V3[3] + cI * (V3[4]))))) + M2 * (F1[4] * 4. * (V3[2] + V3[5]) + 4. *
+      (F1[5] * (V3[3] + cI * (V3[4]))))));
+  F2[3] = denom * (-cI) * (F1[2] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))) + (F1[3] * (P2[0] * (-1.) * (V3[2] + V3[5]) +
+      (P2[1] * (V3[3] + cI * (V3[4])) + (P2[2] * (V3[4] - cI * (V3[3])) + P2[3]
+      * (V3[2] + V3[5])))) + M2 * (F1[4] * 4. * (V3[3] - cI * (V3[4])) + 4. *
+      (F1[5] * (V3[2] - V3[5])))));
+  F2[4] = denom * (-4. * cI) * (F1[4] * (P2[0] * (-1.) * (V3[2] + V3[5]) +
+      (P2[1] * (V3[3] - cI * (V3[4])) + (P2[2] * (V3[4] + cI * (V3[3])) + P2[3]
+      * (V3[2] + V3[5])))) + (+1./4. * (M2 * (+4. * (F1[2] * 1./4. * (V3[2] -
+      V3[5])) - F1[3] * (V3[3] + cI * (V3[4])))) + F1[5] * (P2[0] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P2[1] * (V3[2] - V3[5]) + (P2[2] * (-cI *
+      (V3[5]) + cI * (V3[2])) + P2[3] * (V3[3] + cI * (V3[4])))))));
+  F2[5] = denom * (-4. * cI) * (F1[4] * (P2[0] * (+cI * (V3[4]) - V3[3]) +
+      (P2[1] * (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) +
+      P2[3] * (+cI * (V3[4]) - V3[3])))) + (+1./4. * (M2 * (F1[3] * (V3[2] +
+      V3[5]) + 4. * (F1[2] * 1./4. * (+cI * (V3[4]) - V3[3])))) + F1[5] *
+      (P2[0] * (V3[5] - V3[2]) + (P2[1] * (V3[3] + cI * (V3[4])) + (P2[2] *
+      (V3[4] - cI * (V3[3])) + P2[3] * (V3[5] - V3[2]))))));
+}
+
+
+void VVSS1_1(std::complex<double> V2[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  std::complex<double> TMP22; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  V1[0] = +V2[0] + S3[0] + S4[0]; 
+  V1[1] = +V2[1] + S3[1] + S4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S3[2] * S4[2] * (-cI * (V2[2]) + cI * (P1[0] * OM1 * TMP22)); 
+  V1[3] = denom * S3[2] * S4[2] * (-cI * (V2[3]) + cI * (P1[1] * OM1 * TMP22)); 
+  V1[4] = denom * S3[2] * S4[2] * (-cI * (V2[4]) + cI * (P1[2] * OM1 * TMP22)); 
+  V1[5] = denom * S3[2] * S4[2] * (-cI * (V2[5]) + cI * (P1[3] * OM1 * TMP22)); 
+}
+
+
+void FFS3_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP1; 
+  std::complex<double> TMP2; 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  vertex = COUP * S3[2] * (-cI * (TMP1) + cI * (TMP2)); 
+}
+
+
+void VSS1_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> S2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> denom; 
+  P3[0] = S3[0].real(); 
+  P3[1] = S3[1].real(); 
+  P3[2] = S3[1].imag(); 
+  P3[3] = S3[0].imag(); 
+  S2[0] = +V1[0] + S3[0]; 
+  S2[1] = +V1[1] + S3[1]; 
+  P2[0] = -S2[0].real(); 
+  P2[1] = -S2[1].real(); 
+  P2[2] = -S2[1].imag(); 
+  P2[3] = -S2[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  S2[2] = denom * S3[2] * (-cI * (TMP18) + cI * (TMP17)); 
+}
+
+
+void FFS3C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP1; 
+  std::complex<double> TMP2; 
+  std::complex<double> denom; 
+  S3[0] = +F1[0] + F2[0]; 
+  S3[1] = +F1[1] + F2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * (-cI * (TMP2) + cI * (TMP1)); 
+}
+
+
+void FFV5_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * 4. * cI * (F2[2] * (P1[0] * (V3[5] - V3[2]) + (P1[1] * (V3[3]
+      - cI * (V3[4])) + (P1[2] * (V3[4] + cI * (V3[3])) + P1[3] * (V3[5] -
+      V3[2])))) + (+1./4. * (M1 * (F2[5] * (V3[3] + cI * (V3[4])) + 4. * (F2[4]
+      * 1./4. * (V3[2] + V3[5])))) + F2[3] * (P1[0] * (V3[3] + cI * (V3[4])) +
+      (P1[1] * (-1.) * (V3[2] + V3[5]) + (P1[2] * (-1.) * (+cI * (V3[2] +
+      V3[5])) + P1[3] * (V3[3] + cI * (V3[4])))))));
+  F1[3] = denom * 4. * cI * (F2[2] * (P1[0] * (V3[3] - cI * (V3[4])) + (P1[1] *
+      (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[5]) + cI * (V3[2])) + P1[3] * (+cI
+      * (V3[4]) - V3[3])))) + (+1./4. * (M1 * (F2[5] * (V3[2] - V3[5]) + 4. *
+      (F2[4] * 1./4. * (V3[3] - cI * (V3[4]))))) + F2[3] * (P1[0] * (-1.) *
+      (V3[2] + V3[5]) + (P1[1] * (V3[3] + cI * (V3[4])) + (P1[2] * (V3[4] - cI
+      * (V3[3])) + P1[3] * (V3[2] + V3[5]))))));
+  F1[4] = denom * (-cI) * (F2[4] * (P1[0] * (V3[2] + V3[5]) + (P1[1] * (+cI *
+      (V3[4]) - V3[3]) + (P1[2] * (-1.) * (V3[4] + cI * (V3[3])) - P1[3] *
+      (V3[2] + V3[5])))) + (F2[5] * (P1[0] * (V3[3] + cI * (V3[4])) + (P1[1] *
+      (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[2]) + cI * (V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))) + M1 * (F2[2] * 4. * (V3[5] - V3[2]) + 4. *
+      (F2[3] * (V3[3] + cI * (V3[4]))))));
+  F1[5] = denom * cI * (F2[4] * (P1[0] * (+cI * (V3[4]) - V3[3]) + (P1[1] *
+      (V3[2] + V3[5]) + (P1[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P1[3] * (+cI
+      * (V3[4]) - V3[3])))) + (F2[5] * (P1[0] * (V3[5] - V3[2]) + (P1[1] *
+      (V3[3] + cI * (V3[4])) + (P1[2] * (V3[4] - cI * (V3[3])) + P1[3] * (V3[5]
+      - V3[2])))) + M1 * (F2[2] * 4. * (+cI * (V3[4]) - V3[3]) + 4. * (F2[3] *
+      (V3[2] + V3[5])))));
+}
+
+
+void VVVV1_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P2[4]; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP32; 
+  std::complex<double> denom; 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  V2[0] = +V1[0] + V3[0] + V4[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP32 = (P2[0] * V4[2] - P2[1] * V4[3] - P2[2] * V4[4] - P2[3] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * (OM2 * P2[0] * (-cI * (TMP25 * TMP32) + cI * (TMP24 * TMP29))
+      + (-cI * (V3[2] * TMP29) + cI * (TMP25 * V4[2])));
+  V2[3] = denom * (OM2 * P2[1] * (-cI * (TMP25 * TMP32) + cI * (TMP24 * TMP29))
+      + (-cI * (V3[3] * TMP29) + cI * (TMP25 * V4[3])));
+  V2[4] = denom * (OM2 * P2[2] * (-cI * (TMP25 * TMP32) + cI * (TMP24 * TMP29))
+      + (-cI * (V3[4] * TMP29) + cI * (TMP25 * V4[4])));
+  V2[5] = denom * (OM2 * P2[3] * (-cI * (TMP25 * TMP32) + cI * (TMP24 * TMP29))
+      + (-cI * (V3[5] * TMP29) + cI * (TMP25 * V4[5])));
+}
+
+
+void FFS1_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP0; 
+  TMP0 = (F2[2] * F1[2] + F2[3] * F1[3] + F2[4] * F1[4] + F2[5] * F1[5]); 
+  vertex = COUP * - cI * TMP0 * S3[2]; 
+}
+
+
+void VVVVS1P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP30; 
+  std::complex<double> denom; 
+  V1[0] = +V2[0] + V3[0] + V4[0] + S5[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1] + S5[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S5[2] * (-cI * (TMP27 * V4[2]) + cI * (V3[2] * TMP30)); 
+  V1[3] = denom * S5[2] * (-cI * (TMP27 * V4[3]) + cI * (V3[3] * TMP30)); 
+  V1[4] = denom * S5[2] * (-cI * (TMP27 * V4[4]) + cI * (V3[4] * TMP30)); 
+  V1[5] = denom * S5[2] * (-cI * (TMP27 * V4[5]) + cI * (V3[5] * TMP30)); 
+}
+
+
+void FFV2C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP10; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP10 = (-1.) * (F1[2] * (F2[4] * (P3[0] - P3[3]) + F2[5] * (+cI * (P3[2]) -
+      P3[1])) + F1[3] * (F2[4] * (-1.) * (P3[1] + cI * (P3[2])) + F2[5] *
+      (P3[0] + P3[3])));
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-cI) * (-F2[4] * F1[2] - F2[5] * F1[3] - P3[0] * OM3 *
+      TMP10);
+  V3[3] = denom * (-cI) * (-F2[5] * F1[2] - F2[4] * F1[3] - P3[1] * OM3 *
+      TMP10);
+  V3[4] = denom * (-cI) * (-cI * (F2[4] * F1[3]) + cI * (F2[5] * F1[2]) - P3[2]
+      * OM3 * TMP10);
+  V3[5] = denom * (-cI) * (F2[5] * F1[3] - F2[4] * F1[2] - P3[3] * OM3 *
+      TMP10);
+}
+
+void FFV2_5C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[])
+{
+  std::complex<double> Vtmp[6]; 
+  int i; 
+  FFV2C1_3(F2, F1, COUP1, M3, W3, V3); 
+  FFV5C1_3(F2, F1, COUP2, M3, W3, Vtmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    V3[i] = V3[i] + Vtmp[i]; 
+    i++; 
+  }
+}
+void FFV2_3C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[])
+{
+  std::complex<double> Vtmp[6]; 
+  int i; 
+  FFV2C1_3(F2, F1, COUP1, M3, W3, V3); 
+  FFV3C1_3(F2, F1, COUP2, M3, W3, Vtmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    V3[i] = V3[i] + Vtmp[i]; 
+    i++; 
+  }
+}
+void FFV2_4C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> V3[])
+{
+  std::complex<double> Vtmp[6]; 
+  int i; 
+  FFV2C1_3(F2, F1, COUP1, M3, W3, V3); 
+  FFV4C1_3(F2, F1, COUP2, M3, W3, Vtmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    V3[i] = V3[i] + Vtmp[i]; 
+    i++; 
+  }
+}
+
+void VVVV5_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP32; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  V2[0] = +V1[0] + V3[0] + V4[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP32 = (P2[0] * V4[2] - P2[1] * V4[3] - P2[2] * V4[4] - P2[3] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * 1./2. * (OM2 * - P2[0] * (-2. * cI * (TMP24 * TMP29) + cI *
+      (TMP25 * TMP32 + TMP17 * TMP35)) + (-2. * cI * (V3[2] * TMP29) + cI *
+      (TMP25 * V4[2] + V1[2] * TMP35)));
+  V2[3] = denom * 1./2. * (OM2 * - P2[1] * (-2. * cI * (TMP24 * TMP29) + cI *
+      (TMP25 * TMP32 + TMP17 * TMP35)) + (-2. * cI * (V3[3] * TMP29) + cI *
+      (TMP25 * V4[3] + V1[3] * TMP35)));
+  V2[4] = denom * 1./2. * (OM2 * - P2[2] * (-2. * cI * (TMP24 * TMP29) + cI *
+      (TMP25 * TMP32 + TMP17 * TMP35)) + (-2. * cI * (V3[4] * TMP29) + cI *
+      (TMP25 * V4[4] + V1[4] * TMP35)));
+  V2[5] = denom * 1./2. * (OM2 * - P2[3] * (-2. * cI * (TMP24 * TMP29) + cI *
+      (TMP25 * TMP32 + TMP17 * TMP35)) + (-2. * cI * (V3[5] * TMP29) + cI *
+      (TMP25 * V4[5] + V1[5] * TMP35)));
+}
+
+
+void VVVV4P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP30; 
+  std::complex<double> denom; 
+  V3[0] = +V1[0] + V2[0] + V4[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-cI * (V1[2] * TMP30) + cI * (TMP21 * V4[2])); 
+  V3[3] = denom * (-cI * (V1[3] * TMP30) + cI * (TMP21 * V4[3])); 
+  V3[4] = denom * (-cI * (V1[4] * TMP30) + cI * (TMP21 * V4[4])); 
+  V3[5] = denom * (-cI * (V1[5] * TMP30) + cI * (TMP21 * V4[5])); 
+}
+
+
+void VVVV4_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM4; 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP34; 
+  std::complex<double> TMP37; 
+  std::complex<double> denom; 
+  OM4 = 0.; 
+  if (M4 != 0.)
+    OM4 = 1./(M4 * M4); 
+  V4[0] = +V1[0] + V2[0] + V3[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP34 = (V2[2] * P4[0] - V2[3] * P4[1] - V2[4] * P4[2] - V2[5] * P4[3]); 
+  TMP37 = (V3[2] * P4[0] - V3[3] * P4[1] - V3[4] * P4[2] - V3[5] * P4[3]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * (OM4 * P4[0] * (-cI * (TMP21 * TMP37) + cI * (TMP25 * TMP34))
+      + (-cI * (V2[2] * TMP25) + cI * (V3[2] * TMP21)));
+  V4[3] = denom * (OM4 * P4[1] * (-cI * (TMP21 * TMP37) + cI * (TMP25 * TMP34))
+      + (-cI * (V2[3] * TMP25) + cI * (V3[3] * TMP21)));
+  V4[4] = denom * (OM4 * P4[2] * (-cI * (TMP21 * TMP37) + cI * (TMP25 * TMP34))
+      + (-cI * (V2[4] * TMP25) + cI * (V3[4] * TMP21)));
+  V4[5] = denom * (OM4 * P4[3] * (-cI * (TMP21 * TMP37) + cI * (TMP25 * TMP34))
+      + (-cI * (V2[5] * TMP25) + cI * (V3[5] * TMP21)));
+}
+
+
+void FFV4_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP13; 
+  std::complex<double> TMP8; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP13 = (F1[4] * (F2[2] * (P3[0] - P3[3]) - F2[3] * (P3[1] + cI * (P3[2]))) +
+      F1[5] * (F2[2] * (+cI * (P3[2]) - P3[1]) + F2[3] * (P3[0] + P3[3])));
+  TMP8 = (F1[2] * (F2[4] * (P3[0] + P3[3]) + F2[5] * (P3[1] + cI * (P3[2]))) +
+      F1[3] * (F2[4] * (P3[1] - cI * (P3[2])) + F2[5] * (P3[0] - P3[3])));
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-2. * cI) * (OM3 * - 1./2. * P3[0] * (TMP8 + 2. * (TMP13)) +
+      (+1./2. * (F2[4] * F1[2] + F2[5] * F1[3]) + F2[2] * F1[4] + F2[3] *
+      F1[5]));
+  V3[3] = denom * (-2. * cI) * (OM3 * - 1./2. * P3[1] * (TMP8 + 2. * (TMP13)) +
+      (-1./2. * (F2[5] * F1[2] + F2[4] * F1[3]) + F2[3] * F1[4] + F2[2] *
+      F1[5]));
+  V3[4] = denom * 2. * cI * (OM3 * 1./2. * P3[2] * (TMP8 + 2. * (TMP13)) +
+      (+1./2. * cI * (F2[5] * F1[2]) - 1./2. * cI * (F2[4] * F1[3]) - cI *
+      (F2[3] * F1[4]) + cI * (F2[2] * F1[5])));
+  V3[5] = denom * 2. * cI * (OM3 * 1./2. * P3[3] * (TMP8 + 2. * (TMP13)) +
+      (+1./2. * (F2[4] * F1[2]) - 1./2. * (F2[5] * F1[3]) - F2[2] * F1[4] +
+      F2[3] * F1[5]));
+}
+
+
+void VVVVS2P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP27; 
+  std::complex<double> denom; 
+  V4[0] = +V1[0] + V2[0] + V3[0] + S5[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1] + S5[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * S5[2] * (-cI * (V1[2] * TMP27) + cI * (V3[2] * TMP21)); 
+  V4[3] = denom * S5[2] * (-cI * (V1[3] * TMP27) + cI * (V3[3] * TMP21)); 
+  V4[4] = denom * S5[2] * (-cI * (V1[4] * TMP27) + cI * (V3[4] * TMP21)); 
+  V4[5] = denom * S5[2] * (-cI * (V1[5] * TMP27) + cI * (V3[5] * TMP21)); 
+}
+
+
+void VVSS1P0_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  V2[0] = +V1[0] + S3[0] + S4[0]; 
+  V2[1] = +V1[1] + S3[1] + S4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * - cI * V1[2] * S4[2] * S3[2]; 
+  V2[3] = denom * - cI * V1[3] * S4[2] * S3[2]; 
+  V2[4] = denom * - cI * V1[4] * S4[2] * S3[2]; 
+  V2[5] = denom * - cI * V1[5] * S4[2] * S3[2]; 
+}
+
+
+void FFS1C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP0; 
+  std::complex<double> denom; 
+  S3[0] = +F1[0] + F2[0]; 
+  S3[1] = +F1[1] + F2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP0 = (F2[2] * F1[2] + F2[3] * F1[3] + F2[4] * F1[4] + F2[5] * F1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * cI * TMP0; 
+}
+
+
+void VVV1P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP27; 
+  std::complex<double> denom; 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  V1[0] = +V2[0] + V3[0]; 
+  V1[1] = +V2[1] + V3[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * (TMP27 * (-cI * (P2[0]) + cI * (P3[0])) + (V2[2] * (-cI *
+      (TMP23) + cI * (TMP24)) + V3[2] * (-cI * (TMP26) + cI * (TMP22))));
+  V1[3] = denom * (TMP27 * (-cI * (P2[1]) + cI * (P3[1])) + (V2[3] * (-cI *
+      (TMP23) + cI * (TMP24)) + V3[3] * (-cI * (TMP26) + cI * (TMP22))));
+  V1[4] = denom * (TMP27 * (-cI * (P2[2]) + cI * (P3[2])) + (V2[4] * (-cI *
+      (TMP23) + cI * (TMP24)) + V3[4] * (-cI * (TMP26) + cI * (TMP22))));
+  V1[5] = denom * (TMP27 * (-cI * (P2[3]) + cI * (P3[3])) + (V2[5] * (-cI *
+      (TMP23) + cI * (TMP24)) + V3[5] * (-cI * (TMP26) + cI * (TMP22))));
+}
+
+
+void VVVVS1_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P2[4]; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP32; 
+  std::complex<double> denom; 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  V2[0] = +V1[0] + V3[0] + V4[0] + S5[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1] + S5[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP32 = (P2[0] * V4[2] - P2[1] * V4[3] - P2[2] * V4[4] - P2[3] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S5[2] * (OM2 * P2[0] * (-cI * (TMP25 * TMP32) + cI * (TMP24 *
+      TMP29)) + (-cI * (V3[2] * TMP29) + cI * (TMP25 * V4[2])));
+  V2[3] = denom * S5[2] * (OM2 * P2[1] * (-cI * (TMP25 * TMP32) + cI * (TMP24 *
+      TMP29)) + (-cI * (V3[3] * TMP29) + cI * (TMP25 * V4[3])));
+  V2[4] = denom * S5[2] * (OM2 * P2[2] * (-cI * (TMP25 * TMP32) + cI * (TMP24 *
+      TMP29)) + (-cI * (V3[4] * TMP29) + cI * (TMP25 * V4[4])));
+  V2[5] = denom * S5[2] * (OM2 * P2[3] * (-cI * (TMP25 * TMP32) + cI * (TMP24 *
+      TMP29)) + (-cI * (V3[5] * TMP29) + cI * (TMP25 * V4[5])));
+}
+
+
+void VVVVS3P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V2[0] = +V1[0] + V3[0] + V4[0] + S5[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1] + S5[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S5[2] * (-cI * (TMP25 * V4[2]) + cI * (V1[2] * TMP35)); 
+  V2[3] = denom * S5[2] * (-cI * (TMP25 * V4[3]) + cI * (V1[3] * TMP35)); 
+  V2[4] = denom * S5[2] * (-cI * (TMP25 * V4[4]) + cI * (V1[4] * TMP35)); 
+  V2[5] = denom * S5[2] * (-cI * (TMP25 * V4[5]) + cI * (V1[5] * TMP35)); 
+}
+
+
+void FFV3_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * (F1[2] * (P2[0] * (V3[2] + V3[5]) + (P2[1] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P2[2] * (+cI * (V3[3]) - V3[4]) - P2[3] *
+      (V3[2] + V3[5])))) + (F1[3] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))) + M2 * (F1[4] * 2. * (V3[5] - V3[2]) + 2. * (F1[5]
+      * (V3[3] - cI * (V3[4]))))));
+  F2[3] = denom * cI * (F1[2] * (P2[0] * (V3[3] + cI * (V3[4])) + (P2[1] *
+      (-1.) * (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) +
+      P2[3] * (V3[3] + cI * (V3[4]))))) + (F1[3] * (P2[0] * (V3[2] - V3[5]) +
+      (P2[1] * (+cI * (V3[4]) - V3[3]) + (P2[2] * (-1.) * (V3[4] + cI *
+      (V3[3])) + P2[3] * (V3[2] - V3[5])))) + M2 * (F1[4] * 2. * (V3[3] + cI *
+      (V3[4])) - 2. * (F1[5] * (V3[2] + V3[5])))));
+  F2[4] = denom * 2. * cI * (F1[4] * (P2[0] * (V3[5] - V3[2]) + (P2[1] * (V3[3]
+      + cI * (V3[4])) + (P2[2] * (V3[4] - cI * (V3[3])) + P2[3] * (V3[5] -
+      V3[2])))) + (+1./2. * (M2 * (F1[3] * (V3[3] - cI * (V3[4])) + 2. * (F1[2]
+      * 1./2. * (V3[2] + V3[5])))) + F1[5] * (P2[0] * (V3[3] - cI * (V3[4])) +
+      (P2[1] * (-1.) * (V3[2] + V3[5]) + (P2[2] * (+cI * (V3[2] + V3[5])) +
+      P2[3] * (V3[3] - cI * (V3[4])))))));
+  F2[5] = denom * 2. * cI * (F1[4] * (P2[0] * (V3[3] + cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[2]) + cI * (V3[5])) - P2[3] *
+      (V3[3] + cI * (V3[4]))))) + (+1./2. * (M2 * (F1[3] * (V3[2] - V3[5]) + 2.
+      * (F1[2] * 1./2. * (V3[3] + cI * (V3[4]))))) + F1[5] * (P2[0] * (-1.) *
+      (V3[2] + V3[5]) + (P2[1] * (V3[3] - cI * (V3[4])) + (P2[2] * (V3[4] + cI
+      * (V3[3])) + P2[3] * (V3[2] + V3[5]))))));
+}
+
+
+void FFV4C1_3(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP10; 
+  std::complex<double> TMP16; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP10 = (-1.) * (F1[2] * (F2[4] * (P3[0] - P3[3]) + F2[5] * (+cI * (P3[2]) -
+      P3[1])) + F1[3] * (F2[4] * (-1.) * (P3[1] + cI * (P3[2])) + F2[5] *
+      (P3[0] + P3[3])));
+  TMP16 = (-1.) * (F1[4] * (F2[2] * (P3[0] + P3[3]) + F2[3] * (P3[1] - cI *
+      (P3[2]))) + F1[5] * (F2[2] * (P3[1] + cI * (P3[2])) + F2[3] * (P3[0] -
+      P3[3])));
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * 2. * cI * (OM3 * 1./2. * P3[0] * (TMP10 + 2. * (TMP16)) +
+      (+1./2. * (F2[4] * F1[2] + F2[5] * F1[3]) + F2[2] * F1[4] + F2[3] *
+      F1[5]));
+  V3[3] = denom * (-2. * cI) * (OM3 * - 1./2. * P3[1] * (TMP10 + 2. * (TMP16))
+      + (-1./2. * (F2[5] * F1[2] + F2[4] * F1[3]) + F2[3] * F1[4] + F2[2] *
+      F1[5]));
+  V3[4] = denom * 2. * cI * (OM3 * 1./2. * P3[2] * (TMP10 + 2. * (TMP16)) +
+      (-1./2. * cI * (F2[5] * F1[2]) + 1./2. * cI * (F2[4] * F1[3]) - cI *
+      (F2[2] * F1[5]) + cI * (F2[3] * F1[4])));
+  V3[5] = denom * 2. * cI * (OM3 * 1./2. * P3[3] * (TMP10 + 2. * (TMP16)) +
+      (+1./2. * (F2[4] * F1[2]) - 1./2. * (F2[5] * F1[3]) - F2[2] * F1[4] +
+      F2[3] * F1[5]));
+}
+
+
+void VVVVS2_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM4; 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP33; 
+  std::complex<double> TMP37; 
+  std::complex<double> denom; 
+  OM4 = 0.; 
+  if (M4 != 0.)
+    OM4 = 1./(M4 * M4); 
+  V4[0] = +V1[0] + V2[0] + V3[0] + S5[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1] + S5[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP37 = (V3[2] * P4[0] - V3[3] * P4[1] - V3[4] * P4[2] - V3[5] * P4[3]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP33 = (V1[2] * P4[0] - V1[3] * P4[1] - V1[4] * P4[2] - V1[5] * P4[3]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * S5[2] * (OM4 * P4[0] * (-cI * (TMP21 * TMP37) + cI * (TMP27 *
+      TMP33)) + (-cI * (V1[2] * TMP27) + cI * (V3[2] * TMP21)));
+  V4[3] = denom * S5[2] * (OM4 * P4[1] * (-cI * (TMP21 * TMP37) + cI * (TMP27 *
+      TMP33)) + (-cI * (V1[3] * TMP27) + cI * (V3[3] * TMP21)));
+  V4[4] = denom * S5[2] * (OM4 * P4[2] * (-cI * (TMP21 * TMP37) + cI * (TMP27 *
+      TMP33)) + (-cI * (V1[4] * TMP27) + cI * (V3[4] * TMP21)));
+  V4[5] = denom * S5[2] * (OM4 * P4[3] * (-cI * (TMP21 * TMP37) + cI * (TMP27 *
+      TMP33)) + (-cI * (V1[5] * TMP27) + cI * (V3[5] * TMP21)));
+}
+
+
+void FFS3_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP1; 
+  std::complex<double> TMP2; 
+  std::complex<double> denom; 
+  S3[0] = +F1[0] + F2[0]; 
+  S3[1] = +F1[1] + F2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * (-cI * (TMP2) + cI * (TMP1)); 
+}
+
+
+void VVS2P0_2(std::complex<double> V1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP19; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  V2[0] = +V1[0] + S3[0]; 
+  V2[1] = +V1[1] + S3[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S3[2] * (-cI * (P1[0] * TMP17) + cI * (V1[2] * TMP19)); 
+  V2[3] = denom * S3[2] * (-cI * (P1[1] * TMP17) + cI * (V1[3] * TMP19)); 
+  V2[4] = denom * S3[2] * (-cI * (P1[2] * TMP17) + cI * (V1[4] * TMP19)); 
+  V2[5] = denom * S3[2] * (-cI * (P1[3] * TMP17) + cI * (V1[5] * TMP19)); 
+}
+
+
+void FFS4_2(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * S3[2] * (F1[4] * (P2[0] - P2[3]) + F1[5] * (+cI *
+      (P2[2]) - P2[1]));
+  F2[3] = denom * - cI * S3[2] * (F1[4] * (P2[1] + cI * (P2[2])) - F1[5] *
+      (P2[0] + P2[3]));
+  F2[4] = denom * cI * F1[4] * M2 * S3[2]; 
+  F2[5] = denom * cI * F1[5] * M2 * S3[2]; 
+}
+
+
+void SSSS1_0(std::complex<double> S1[], std::complex<double> S2[],
+    std::complex<double> S3[], std::complex<double> S4[], std::complex<double>
+    COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  vertex = COUP * - cI * S4[2] * S3[2] * S2[2] * S1[2]; 
+}
+
+
+void FFS1_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP0; 
+  std::complex<double> denom; 
+  S3[0] = +F1[0] + F2[0]; 
+  S3[1] = +F1[1] + F2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP0 = (F2[2] * F1[2] + F2[3] * F1[3] + F2[4] * F1[4] + F2[5] * F1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * cI * TMP0; 
+}
+
+
+void VVVVS3_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP36; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +V1[0] + V2[0] + V4[0] + S5[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1] + S5[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP36 = (P3[0] * V4[2] - P3[1] * V4[3] - P3[2] * V4[4] - P3[3] * V4[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * S5[2] * (OM3 * P3[0] * (-cI * (TMP21 * TMP36) + cI * (TMP18 *
+      TMP30)) + (-cI * (V1[2] * TMP30) + cI * (TMP21 * V4[2])));
+  V3[3] = denom * S5[2] * (OM3 * P3[1] * (-cI * (TMP21 * TMP36) + cI * (TMP18 *
+      TMP30)) + (-cI * (V1[3] * TMP30) + cI * (TMP21 * V4[3])));
+  V3[4] = denom * S5[2] * (OM3 * P3[2] * (-cI * (TMP21 * TMP36) + cI * (TMP18 *
+      TMP30)) + (-cI * (V1[4] * TMP30) + cI * (TMP21 * V4[4])));
+  V3[5] = denom * S5[2] * (OM3 * P3[3] * (-cI * (TMP21 * TMP36) + cI * (TMP18 *
+      TMP30)) + (-cI * (V1[5] * TMP30) + cI * (TMP21 * V4[5])));
+}
+
+
+void FFS5C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP1; 
+  std::complex<double> TMP2; 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  vertex = COUP * - S3[2] * (+cI * (TMP1 + TMP2)); 
+}
+
+
+void VVVV5_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP31; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  V1[0] = +V2[0] + V3[0] + V4[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP31 = (P1[0] * V4[2] - P1[1] * V4[3] - P1[2] * V4[4] - P1[3] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * 1./2. * (OM1 * - P1[0] * (-2. * cI * (TMP27 * TMP31) + cI *
+      (TMP23 * TMP30 + TMP22 * TMP35)) + (-2. * cI * (TMP27 * V4[2]) + cI *
+      (V3[2] * TMP30 + V2[2] * TMP35)));
+  V1[3] = denom * 1./2. * (OM1 * - P1[1] * (-2. * cI * (TMP27 * TMP31) + cI *
+      (TMP23 * TMP30 + TMP22 * TMP35)) + (-2. * cI * (TMP27 * V4[3]) + cI *
+      (V3[3] * TMP30 + V2[3] * TMP35)));
+  V1[4] = denom * 1./2. * (OM1 * - P1[2] * (-2. * cI * (TMP27 * TMP31) + cI *
+      (TMP23 * TMP30 + TMP22 * TMP35)) + (-2. * cI * (TMP27 * V4[4]) + cI *
+      (V3[4] * TMP30 + V2[4] * TMP35)));
+  V1[5] = denom * 1./2. * (OM1 * - P1[3] * (-2. * cI * (TMP27 * TMP31) + cI *
+      (TMP23 * TMP30 + TMP22 * TMP35)) + (-2. * cI * (TMP27 * V4[5]) + cI *
+      (V3[5] * TMP30 + V2[5] * TMP35)));
+}
+
+
+void VVVVS2P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP29; 
+  std::complex<double> denom; 
+  V3[0] = +V1[0] + V2[0] + V4[0] + S5[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1] + S5[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * S5[2] * (-cI * (V2[2] * TMP29) + cI * (TMP21 * V4[2])); 
+  V3[3] = denom * S5[2] * (-cI * (V2[3] * TMP29) + cI * (TMP21 * V4[3])); 
+  V3[4] = denom * S5[2] * (-cI * (V2[4] * TMP29) + cI * (TMP21 * V4[4])); 
+  V3[5] = denom * S5[2] * (-cI * (V2[5] * TMP29) + cI * (TMP21 * V4[5])); 
+}
+
+
+void VVVV3_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP35; 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  vertex = COUP * (-cI * (TMP27 * TMP29) + cI * (TMP21 * TMP35)); 
+}
+
+
+void FFV1P0_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> denom; 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-cI) * (F2[4] * F1[2] + F2[5] * F1[3] + F2[2] * F1[4] +
+      F2[3] * F1[5]);
+  V3[3] = denom * (-cI) * (F2[3] * F1[4] + F2[2] * F1[5] - F2[5] * F1[2] -
+      F2[4] * F1[3]);
+  V3[4] = denom * (-cI) * (-cI * (F2[5] * F1[2] + F2[2] * F1[5]) + cI * (F2[4]
+      * F1[3] + F2[3] * F1[4]));
+  V3[5] = denom * (-cI) * (F2[5] * F1[3] + F2[2] * F1[4] - F2[4] * F1[2] -
+      F2[3] * F1[5]);
+}
+
+
+void FFS1C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP0; 
+  TMP0 = (F2[2] * F1[2] + F2[3] * F1[3] + F2[4] * F1[4] + F2[5] * F1[5]); 
+  vertex = COUP * - cI * TMP0 * S3[2]; 
+}
+
+
+void VVVVS3P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M1, double W1, std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V1[0] = +V2[0] + V3[0] + V4[0] + S5[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1] + S5[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * S5[2] * (-cI * (V3[2] * TMP30) + cI * (V2[2] * TMP35)); 
+  V1[3] = denom * S5[2] * (-cI * (V3[3] * TMP30) + cI * (V2[3] * TMP35)); 
+  V1[4] = denom * S5[2] * (-cI * (V3[4] * TMP30) + cI * (V2[4] * TMP35)); 
+  V1[5] = denom * S5[2] * (-cI * (V3[5] * TMP30) + cI * (V2[5] * TMP35)); 
+}
+
+
+void VVVV2P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V1[0] = +V2[0] + V3[0] + V4[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * (-1.) * (-2. * cI * (V2[2] * TMP35) + cI * (TMP27 * V4[2] +
+      V3[2] * TMP30));
+  V1[3] = denom * (-1.) * (-2. * cI * (V2[3] * TMP35) + cI * (TMP27 * V4[3] +
+      V3[3] * TMP30));
+  V1[4] = denom * (-1.) * (-2. * cI * (V2[4] * TMP35) + cI * (TMP27 * V4[4] +
+      V3[4] * TMP30));
+  V1[5] = denom * (-1.) * (-2. * cI * (V2[5] * TMP35) + cI * (TMP27 * V4[5] +
+      V3[5] * TMP30));
+}
+
+
+void FFS2C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * cI * F2[2] * M1 * S3[2]; 
+  F1[3] = denom * cI * F2[3] * M1 * S3[2]; 
+  F1[4] = denom * - cI * S3[2] * (F2[2] * (-1.) * (P1[0] + P1[3]) + F2[3] *
+      (+cI * (P1[2]) - P1[1]));
+  F1[5] = denom * cI * S3[2] * (F2[2] * (P1[1] + cI * (P1[2])) + F2[3] * (P1[0]
+      - P1[3]));
+}
+
+void FFS2_4C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFS2C1_2(F2, S3, COUP1, M1, W1, F1); 
+  FFS4C1_2(F2, S3, COUP2, M1, W1, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F1[i] = F1[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+
+void VVVV1P0_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP30; 
+  std::complex<double> denom; 
+  V1[0] = +V2[0] + V3[0] + V4[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * (-cI * (TMP27 * V4[2]) + cI * (V3[2] * TMP30)); 
+  V1[3] = denom * (-cI * (TMP27 * V4[3]) + cI * (V3[3] * TMP30)); 
+  V1[4] = denom * (-cI * (TMP27 * V4[4]) + cI * (V3[4] * TMP30)); 
+  V1[5] = denom * (-cI * (TMP27 * V4[5]) + cI * (V3[5] * TMP30)); 
+}
+
+
+void FFV3C1_1(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * (F1[2] * (P2[0] * (V3[2] - V3[5]) + (P2[1] * (+cI *
+      (V3[4]) - V3[3]) + (P2[2] * (-1.) * (V3[4] + cI * (V3[3])) + P2[3] *
+      (V3[2] - V3[5])))) + (F1[3] * (P2[0] * (-1.) * (V3[3] + cI * (V3[4])) +
+      (P2[1] * (V3[2] + V3[5]) + (P2[2] * (+cI * (V3[2] + V3[5])) - P2[3] *
+      (V3[3] + cI * (V3[4]))))) + M2 * (F1[4] * 2. * (V3[2] + V3[5]) + 2. *
+      (F1[5] * (V3[3] + cI * (V3[4]))))));
+  F2[3] = denom * (-cI) * (F1[2] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))) + (F1[3] * (P2[0] * (-1.) * (V3[2] + V3[5]) +
+      (P2[1] * (V3[3] + cI * (V3[4])) + (P2[2] * (V3[4] - cI * (V3[3])) + P2[3]
+      * (V3[2] + V3[5])))) + M2 * (F1[4] * 2. * (+cI * (V3[4]) - V3[3]) + 2. *
+      (F1[5] * (V3[5] - V3[2])))));
+  F2[4] = denom * 2. * cI * (F1[4] * (P2[0] * (-1.) * (V3[2] + V3[5]) + (P2[1]
+      * (V3[3] - cI * (V3[4])) + (P2[2] * (V3[4] + cI * (V3[3])) + P2[3] *
+      (V3[2] + V3[5])))) + (+1./2. * (M2 * (F1[3] * (V3[3] + cI * (V3[4])) + 2.
+      * (F1[2] * 1./2. * (V3[5] - V3[2])))) + F1[5] * (P2[0] * (-1.) * (V3[3] +
+      cI * (V3[4])) + (P2[1] * (V3[2] - V3[5]) + (P2[2] * (-cI * (V3[5]) + cI *
+      (V3[2])) + P2[3] * (V3[3] + cI * (V3[4])))))));
+  F2[5] = denom * 2. * cI * (F1[4] * (P2[0] * (+cI * (V3[4]) - V3[3]) + (P2[1]
+      * (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P2[3] *
+      (+cI * (V3[4]) - V3[3])))) + (+1./2. * (M2 * (+2. * (F1[2] * 1./2. *
+      (V3[3] - cI * (V3[4]))) - F1[3] * (V3[2] + V3[5]))) + F1[5] * (P2[0] *
+      (V3[5] - V3[2]) + (P2[1] * (V3[3] + cI * (V3[4])) + (P2[2] * (V3[4] - cI
+      * (V3[3])) + P2[3] * (V3[5] - V3[2]))))));
+}
+
+
+void SSSS1_3(std::complex<double> S1[], std::complex<double> S2[],
+    std::complex<double> S4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> denom; 
+  S3[0] = +S1[0] + S2[0] + S4[0]; 
+  S3[1] = +S1[1] + S2[1] + S4[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * cI * S4[2] * S2[2] * S1[2]; 
+}
+
+
+void VVVVS3_5(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, double M5, double W5, std::complex<double> S5[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P5[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  S5[0] = +V1[0] + V2[0] + V3[0] + V4[0]; 
+  S5[1] = +V1[1] + V2[1] + V3[1] + V4[1]; 
+  P5[0] = -S5[0].real(); 
+  P5[1] = -S5[1].real(); 
+  P5[2] = -S5[1].imag(); 
+  P5[3] = -S5[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  denom = COUP/((P5[0] * P5[0]) - (P5[1] * P5[1]) - (P5[2] * P5[2]) - (P5[3] *
+      P5[3]) - M5 * (M5 - cI * W5));
+  S5[2] = denom * (-cI * (TMP21 * TMP35) + cI * (TMP25 * TMP30)); 
+}
+
+
+void VVS1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> denom; 
+  S3[0] = +V1[0] + V2[0]; 
+  S3[1] = +V1[1] + V2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * cI * TMP21; 
+}
+
+
+void VVVVS1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    S5[], std::complex<double> COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  vertex = COUP * S5[2] * (-cI * (TMP27 * TMP29) + cI * (TMP25 * TMP30)); 
+}
+
+
+void FFS4C1_2(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * cI * S3[2] * (F2[4] * (P1[0] - P1[3]) + F2[5] * (+cI *
+      (P1[2]) - P1[1]));
+  F1[3] = denom * - cI * S3[2] * (F2[4] * (P1[1] + cI * (P1[2])) - F2[5] *
+      (P1[0] + P1[3]));
+  F1[4] = denom * cI * F2[4] * M1 * S3[2]; 
+  F1[5] = denom * cI * F2[5] * M1 * S3[2]; 
+}
+
+
+void FFS2_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP1; 
+  std::complex<double> denom; 
+  S3[0] = +F1[0] + F2[0]; 
+  S3[1] = +F1[1] + F2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * cI * TMP1; 
+}
+
+void FFS2_4_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M3, double
+    W3, std::complex<double> S3[])
+{
+  std::complex<double> Stmp[3]; 
+  int i; 
+  FFS2_3(F1, F2, COUP1, M3, W3, S3); 
+  FFS4_3(F1, F2, COUP2, M3, W3, Stmp); 
+  i = 2; 
+  while (i < 3)
+  {
+    S3[i] = S3[i] + Stmp[i]; 
+    i++; 
+  }
+}
+
+void FFV1C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * (-cI) * (F2[2] * (P1[0] * (V3[2] + V3[5]) + (P1[1] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P1[2] * (+cI * (V3[3]) - V3[4]) - P1[3] *
+      (V3[2] + V3[5])))) + (F2[3] * (P1[0] * (V3[3] - cI * (V3[4])) + (P1[1] *
+      (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[5]) + cI * (V3[2])) + P1[3] * (+cI
+      * (V3[4]) - V3[3])))) + M1 * (F2[4] * (V3[2] - V3[5]) + F2[5] * (+cI *
+      (V3[4]) - V3[3]))));
+  F1[3] = denom * cI * (F2[2] * (P1[0] * (-1.) * (V3[3] + cI * (V3[4])) +
+      (P1[1] * (V3[2] + V3[5]) + (P1[2] * (+cI * (V3[2] + V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))) + (F2[3] * (P1[0] * (V3[5] - V3[2]) + (P1[1] *
+      (V3[3] - cI * (V3[4])) + (P1[2] * (V3[4] + cI * (V3[3])) + P1[3] * (V3[5]
+      - V3[2])))) + M1 * (F2[4] * (V3[3] + cI * (V3[4])) - F2[5] * (V3[2] +
+      V3[5]))));
+  F1[4] = denom * cI * (F2[4] * (P1[0] * (V3[5] - V3[2]) + (P1[1] * (V3[3] + cI
+      * (V3[4])) + (P1[2] * (V3[4] - cI * (V3[3])) + P1[3] * (V3[5] - V3[2]))))
+      + (F2[5] * (P1[0] * (V3[3] - cI * (V3[4])) + (P1[1] * (-1.) * (V3[2] +
+      V3[5]) + (P1[2] * (+cI * (V3[2] + V3[5])) + P1[3] * (V3[3] - cI *
+      (V3[4]))))) + M1 * (F2[2] * (-1.) * (V3[2] + V3[5]) + F2[3] * (+cI *
+      (V3[4]) - V3[3]))));
+  F1[5] = denom * (-cI) * (F2[4] * (P1[0] * (-1.) * (V3[3] + cI * (V3[4])) +
+      (P1[1] * (V3[2] - V3[5]) + (P1[2] * (-cI * (V3[5]) + cI * (V3[2])) +
+      P1[3] * (V3[3] + cI * (V3[4]))))) + (F2[5] * (P1[0] * (V3[2] + V3[5]) +
+      (P1[1] * (+cI * (V3[4]) - V3[3]) + (P1[2] * (-1.) * (V3[4] + cI *
+      (V3[3])) - P1[3] * (V3[2] + V3[5])))) + M1 * (F2[2] * (V3[3] + cI *
+      (V3[4])) + F2[3] * (V3[2] - V3[5]))));
+}
+
+
+void VVV1_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP19; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP28; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  V2[0] = +V1[0] + V3[0]; 
+  V2[1] = +V1[1] + V3[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP28 = (P2[0] * P3[0] - P2[1] * P3[1] - P2[2] * P3[2] - P2[3] * P3[3]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * (OM2 * P2[0] * (TMP25 * (-cI * (TMP19) + cI * (TMP28)) + (-cI
+      * (TMP18 * TMP24) + cI * (TMP17 * TMP23))) + (TMP25 * (-cI * (P3[0]) + cI
+      * (P1[0])) + (V1[2] * (-cI * (TMP23) + cI * (TMP24)) + V3[2] * (-cI *
+      (TMP17) + cI * (TMP18)))));
+  V2[3] = denom * (OM2 * P2[1] * (TMP25 * (-cI * (TMP19) + cI * (TMP28)) + (-cI
+      * (TMP18 * TMP24) + cI * (TMP17 * TMP23))) + (TMP25 * (-cI * (P3[1]) + cI
+      * (P1[1])) + (V1[3] * (-cI * (TMP23) + cI * (TMP24)) + V3[3] * (-cI *
+      (TMP17) + cI * (TMP18)))));
+  V2[4] = denom * (OM2 * P2[2] * (TMP25 * (-cI * (TMP19) + cI * (TMP28)) + (-cI
+      * (TMP18 * TMP24) + cI * (TMP17 * TMP23))) + (TMP25 * (-cI * (P3[2]) + cI
+      * (P1[2])) + (V1[4] * (-cI * (TMP23) + cI * (TMP24)) + V3[4] * (-cI *
+      (TMP17) + cI * (TMP18)))));
+  V2[5] = denom * (OM2 * P2[3] * (TMP25 * (-cI * (TMP19) + cI * (TMP28)) + (-cI
+      * (TMP18 * TMP24) + cI * (TMP17 * TMP23))) + (TMP25 * (-cI * (P3[3]) + cI
+      * (P1[3])) + (V1[5] * (-cI * (TMP23) + cI * (TMP24)) + V3[5] * (-cI *
+      (TMP17) + cI * (TMP18)))));
+}
+
+
+void FFV1_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP3; 
+  TMP3 = (F1[2] * (F2[4] * (V3[2] + V3[5]) + F2[5] * (V3[3] + cI * (V3[4]))) +
+      (F1[3] * (F2[4] * (V3[3] - cI * (V3[4])) + F2[5] * (V3[2] - V3[5])) +
+      (F1[4] * (F2[2] * (V3[2] - V3[5]) - F2[3] * (V3[3] + cI * (V3[4]))) +
+      F1[5] * (F2[2] * (+cI * (V3[4]) - V3[3]) + F2[3] * (V3[2] + V3[5])))));
+  vertex = COUP * - cI * TMP3; 
+}
+
+
+void SSS1_1(std::complex<double> S2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> S1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  S1[0] = +S2[0] + S3[0]; 
+  S1[1] = +S2[1] + S3[1]; 
+  P1[0] = -S1[0].real(); 
+  P1[1] = -S1[1].real(); 
+  P1[2] = -S1[1].imag(); 
+  P1[3] = -S1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  S1[2] = denom * cI * S3[2] * S2[2]; 
+}
+
+
+void VVVV1P0_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P3[4]; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  std::complex<double> denom; 
+  V3[0] = +V1[0] + V2[0] + V4[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-cI * (V2[2] * TMP29) + cI * (V1[2] * TMP30)); 
+  V3[3] = denom * (-cI * (V2[3] * TMP29) + cI * (V1[3] * TMP30)); 
+  V3[4] = denom * (-cI * (V2[4] * TMP29) + cI * (V1[4] * TMP30)); 
+  V3[5] = denom * (-cI * (V2[5] * TMP29) + cI * (V1[5] * TMP30)); 
+}
+
+
+void VVVVS3P0_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> denom; 
+  V4[0] = +V1[0] + V2[0] + V3[0] + S5[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1] + S5[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * S5[2] * (-cI * (V2[2] * TMP25) + cI * (V3[2] * TMP21)); 
+  V4[3] = denom * S5[2] * (-cI * (V2[3] * TMP25) + cI * (V3[3] * TMP21)); 
+  V4[4] = denom * S5[2] * (-cI * (V2[4] * TMP25) + cI * (V3[4] * TMP21)); 
+  V4[5] = denom * S5[2] * (-cI * (V2[5] * TMP25) + cI * (V3[5] * TMP21)); 
+}
+
+
+void VVVV2P0_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  V2[0] = +V1[0] + V3[0] + V4[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * (-1.) * (-2. * cI * (V1[2] * TMP35) + cI * (V3[2] * TMP29 +
+      TMP25 * V4[2]));
+  V2[3] = denom * (-1.) * (-2. * cI * (V1[3] * TMP35) + cI * (V3[3] * TMP29 +
+      TMP25 * V4[3]));
+  V2[4] = denom * (-1.) * (-2. * cI * (V1[4] * TMP35) + cI * (V3[4] * TMP29 +
+      TMP25 * V4[4]));
+  V2[5] = denom * (-1.) * (-2. * cI * (V1[5] * TMP35) + cI * (V3[5] * TMP29 +
+      TMP25 * V4[5]));
+}
+
+
+void FFV2_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * (F1[2] * (P2[0] * (V3[2] + V3[5]) + (P2[1] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P2[2] * (+cI * (V3[3]) - V3[4]) - P2[3] *
+      (V3[2] + V3[5])))) + F1[3] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))));
+  F2[3] = denom * cI * (F1[2] * (P2[0] * (V3[3] + cI * (V3[4])) + (P2[1] *
+      (-1.) * (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) +
+      P2[3] * (V3[3] + cI * (V3[4]))))) + F1[3] * (P2[0] * (V3[2] - V3[5]) +
+      (P2[1] * (+cI * (V3[4]) - V3[3]) + (P2[2] * (-1.) * (V3[4] + cI *
+      (V3[3])) + P2[3] * (V3[2] - V3[5])))));
+  F2[4] = denom * - cI * M2 * (F1[2] * (-1.) * (V3[2] + V3[5]) + F1[3] * (+cI *
+      (V3[4]) - V3[3]));
+  F2[5] = denom * cI * M2 * (F1[2] * (V3[3] + cI * (V3[4])) + F1[3] * (V3[2] -
+      V3[5]));
+}
+
+void FFV2_5_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2_2(F1, V3, COUP1, M2, W2, F2); 
+  FFV5_2(F1, V3, COUP2, M2, W2, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F2[i] = F2[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+void FFV2_3_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2_2(F1, V3, COUP1, M2, W2, F2); 
+  FFV3_2(F1, V3, COUP2, M2, W2, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F2[i] = F2[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+void FFV2_4_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M2, double
+    W2, std::complex<double> F2[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2_2(F1, V3, COUP1, M2, W2, F2); 
+  FFV4_2(F1, V3, COUP2, M2, W2, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F2[i] = F2[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+
+void FFV3C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * (-2. * cI) * (F2[2] * (P1[0] * (-1.) * (V3[2] + V3[5]) +
+      (P1[1] * (V3[3] + cI * (V3[4])) + (P1[2] * (V3[4] - cI * (V3[3])) + P1[3]
+      * (V3[2] + V3[5])))) + (+1./2. * (M1 * (F2[5] * (+cI * (V3[4]) - V3[3]) +
+      2. * (F2[4] * 1./2. * (V3[2] - V3[5])))) + F2[3] * (P1[0] * (+cI *
+      (V3[4]) - V3[3]) + (P1[1] * (V3[2] - V3[5]) + (P1[2] * (-cI * (V3[2]) +
+      cI * (V3[5])) + P1[3] * (V3[3] - cI * (V3[4])))))));
+  F1[3] = denom * (-2. * cI) * (F2[2] * (P1[0] * (-1.) * (V3[3] + cI * (V3[4]))
+      + (P1[1] * (V3[2] + V3[5]) + (P1[2] * (+cI * (V3[2] + V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))) + (+1./2. * (M1 * (F2[5] * (V3[2] + V3[5]) + 2.
+      * (F2[4] * (-1./2.) * (V3[3] + cI * (V3[4]))))) + F2[3] * (P1[0] * (V3[5]
+      - V3[2]) + (P1[1] * (V3[3] - cI * (V3[4])) + (P1[2] * (V3[4] + cI *
+      (V3[3])) + P1[3] * (V3[5] - V3[2]))))));
+  F1[4] = denom * cI * (F2[4] * (P1[0] * (V3[5] - V3[2]) + (P1[1] * (V3[3] + cI
+      * (V3[4])) + (P1[2] * (V3[4] - cI * (V3[3])) + P1[3] * (V3[5] - V3[2]))))
+      + (F2[5] * (P1[0] * (V3[3] - cI * (V3[4])) + (P1[1] * (-1.) * (V3[2] +
+      V3[5]) + (P1[2] * (+cI * (V3[2] + V3[5])) + P1[3] * (V3[3] - cI *
+      (V3[4]))))) + M1 * (F2[2] * 2. * (V3[2] + V3[5]) + 2. * (F2[3] * (V3[3] -
+      cI * (V3[4]))))));
+  F1[5] = denom * cI * (F2[4] * (P1[0] * (V3[3] + cI * (V3[4])) + (P1[1] *
+      (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[2]) + cI * (V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))) + (F2[5] * (P1[0] * (-1.) * (V3[2] + V3[5]) +
+      (P1[1] * (V3[3] - cI * (V3[4])) + (P1[2] * (V3[4] + cI * (V3[3])) + P1[3]
+      * (V3[2] + V3[5])))) + M1 * (F2[2] * 2. * (V3[3] + cI * (V3[4])) + 2. *
+      (F2[3] * (V3[2] - V3[5])))));
+}
+
+
+void VVVVS2_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  V2[0] = +V1[0] + V3[0] + V4[0] + S5[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1] + S5[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S5[2] * (OM2 * P2[0] * (-cI * (TMP17 * TMP35) + cI * (TMP24 *
+      TMP29)) + (-cI * (V3[2] * TMP29) + cI * (V1[2] * TMP35)));
+  V2[3] = denom * S5[2] * (OM2 * P2[1] * (-cI * (TMP17 * TMP35) + cI * (TMP24 *
+      TMP29)) + (-cI * (V3[3] * TMP29) + cI * (V1[3] * TMP35)));
+  V2[4] = denom * S5[2] * (OM2 * P2[2] * (-cI * (TMP17 * TMP35) + cI * (TMP24 *
+      TMP29)) + (-cI * (V3[4] * TMP29) + cI * (V1[4] * TMP35)));
+  V2[5] = denom * S5[2] * (OM2 * P2[3] * (-cI * (TMP17 * TMP35) + cI * (TMP24 *
+      TMP29)) + (-cI * (V3[5] * TMP29) + cI * (V1[5] * TMP35)));
+}
+
+
+void FFS2P0_1(std::complex<double> F2[], std::complex<double> S3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + S3[0]; 
+  F1[1] = +F2[1] + S3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * cI * F2[2] * M1 * S3[2]; 
+  F1[3] = denom * cI * F2[3] * M1 * S3[2]; 
+  F1[4] = denom * cI * S3[2] * (F2[2] * (P1[3] - P1[0]) + F2[3] * (P1[1] + cI *
+      (P1[2])));
+  F1[5] = denom * - cI * S3[2] * (F2[2] * (+cI * (P1[2]) - P1[1]) + F2[3] *
+      (P1[0] + P1[3]));
+}
+
+
+void FFS5_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP1; 
+  std::complex<double> TMP2; 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  vertex = COUP * - S3[2] * (+cI * (TMP1 + TMP2)); 
+}
+
+
+void FFS4C1_1(std::complex<double> F1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + S3[0]; 
+  F2[1] = +F1[1] + S3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * - cI * S3[2] * (F1[4] * (P2[0] + P2[3]) + F1[5] * (P2[1] + cI
+      * (P2[2])));
+  F2[3] = denom * cI * S3[2] * (F1[4] * (+cI * (P2[2]) - P2[1]) + F1[5] *
+      (P2[3] - P2[0]));
+  F2[4] = denom * cI * F1[4] * M2 * S3[2]; 
+  F2[5] = denom * cI * F1[5] * M2 * S3[2]; 
+}
+
+
+void VVVVS3_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> S5[], std::complex<double>
+    COUP, double M4, double W4, std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM4; 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP34; 
+  std::complex<double> TMP37; 
+  std::complex<double> denom; 
+  OM4 = 0.; 
+  if (M4 != 0.)
+    OM4 = 1./(M4 * M4); 
+  V4[0] = +V1[0] + V2[0] + V3[0] + S5[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1] + S5[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP34 = (V2[2] * P4[0] - V2[3] * P4[1] - V2[4] * P4[2] - V2[5] * P4[3]); 
+  TMP37 = (V3[2] * P4[0] - V3[3] * P4[1] - V3[4] * P4[2] - V3[5] * P4[3]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * S5[2] * (OM4 * P4[0] * (-cI * (TMP21 * TMP37) + cI * (TMP25 *
+      TMP34)) + (-cI * (V2[2] * TMP25) + cI * (V3[2] * TMP21)));
+  V4[3] = denom * S5[2] * (OM4 * P4[1] * (-cI * (TMP21 * TMP37) + cI * (TMP25 *
+      TMP34)) + (-cI * (V2[3] * TMP25) + cI * (V3[3] * TMP21)));
+  V4[4] = denom * S5[2] * (OM4 * P4[2] * (-cI * (TMP21 * TMP37) + cI * (TMP25 *
+      TMP34)) + (-cI * (V2[4] * TMP25) + cI * (V3[4] * TMP21)));
+  V4[5] = denom * S5[2] * (OM4 * P4[3] * (-cI * (TMP21 * TMP37) + cI * (TMP25 *
+      TMP34)) + (-cI * (V2[5] * TMP25) + cI * (V3[5] * TMP21)));
+}
+
+
+void VVVV4_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> V4[], std::complex<double>
+    COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP35; 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  vertex = COUP * (-cI * (TMP25 * TMP30) + cI * (TMP21 * TMP35)); 
+}
+
+
+void SSS1_2(std::complex<double> S1[], std::complex<double> S3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> S2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  S2[0] = +S1[0] + S3[0]; 
+  S2[1] = +S1[1] + S3[1]; 
+  P2[0] = -S2[0].real(); 
+  P2[1] = -S2[1].real(); 
+  P2[2] = -S2[1].imag(); 
+  P2[3] = -S2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  S2[2] = denom * cI * S3[2] * S1[2]; 
+}
+
+
+void VVS2_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP19; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP22; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  P2[0] = V2[0].real(); 
+  P2[1] = V2[1].real(); 
+  P2[2] = V2[1].imag(); 
+  P2[3] = V2[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  vertex = COUP * S3[2] * (-cI * (TMP17 * TMP22) + cI * (TMP19 * TMP21)); 
+}
+
+
+void FFV1_3(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP4; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +F1[0] + F2[0]; 
+  V3[1] = +F1[1] + F2[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP4 = (F1[2] * (F2[4] * (P3[0] + P3[3]) + F2[5] * (P3[1] + cI * (P3[2]))) +
+      (F1[3] * (F2[4] * (P3[1] - cI * (P3[2])) + F2[5] * (P3[0] - P3[3])) +
+      (F1[4] * (F2[2] * (P3[0] - P3[3]) - F2[3] * (P3[1] + cI * (P3[2]))) +
+      F1[5] * (F2[2] * (+cI * (P3[2]) - P3[1]) + F2[3] * (P3[0] + P3[3])))));
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (-cI) * (F2[4] * F1[2] + F2[5] * F1[3] + F2[2] * F1[4] +
+      F2[3] * F1[5] - P3[0] * OM3 * TMP4);
+  V3[3] = denom * (-cI) * (F2[3] * F1[4] + F2[2] * F1[5] - F2[5] * F1[2] -
+      F2[4] * F1[3] - P3[1] * OM3 * TMP4);
+  V3[4] = denom * (-cI) * (-cI * (F2[5] * F1[2] + F2[2] * F1[5]) + cI * (F2[4]
+      * F1[3] + F2[3] * F1[4]) - P3[2] * OM3 * TMP4);
+  V3[5] = denom * (-cI) * (F2[5] * F1[3] + F2[2] * F1[4] - F2[4] * F1[2] -
+      F2[3] * F1[5] - P3[3] * OM3 * TMP4);
+}
+
+
+void FFV3C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP14; 
+  std::complex<double> TMP15; 
+  TMP15 = (-1.) * (F1[4] * (F2[2] * (V3[2] + V3[5]) + F2[3] * (V3[3] - cI *
+      (V3[4]))) + F1[5] * (F2[2] * (V3[3] + cI * (V3[4])) + F2[3] * (V3[2] -
+      V3[5])));
+  TMP14 = (-1.) * (F1[2] * (F2[4] * (V3[2] - V3[5]) + F2[5] * (+cI * (V3[4]) -
+      V3[3])) + F1[3] * (F2[4] * (-1.) * (V3[3] + cI * (V3[4])) + F2[5] *
+      (V3[2] + V3[5])));
+  vertex = COUP * (-cI * (TMP14) + 2. * cI * (TMP15)); 
+}
+
+
+void FFV5C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * 4. * cI * (F2[2] * (P1[0] * (-1.) * (V3[2] + V3[5]) + (P1[1]
+      * (V3[3] + cI * (V3[4])) + (P1[2] * (V3[4] - cI * (V3[3])) + P1[3] *
+      (V3[2] + V3[5])))) + (+1./4. * (M1 * (F2[5] * (V3[3] - cI * (V3[4])) + 4.
+      * (F2[4] * 1./4. * (V3[5] - V3[2])))) + F2[3] * (P1[0] * (+cI * (V3[4]) -
+      V3[3]) + (P1[1] * (V3[2] - V3[5]) + (P1[2] * (-cI * (V3[2]) + cI *
+      (V3[5])) + P1[3] * (V3[3] - cI * (V3[4])))))));
+  F1[3] = denom * 4. * cI * (F2[2] * (P1[0] * (-1.) * (V3[3] + cI * (V3[4])) +
+      (P1[1] * (V3[2] + V3[5]) + (P1[2] * (+cI * (V3[2] + V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))) + (+1./4. * (M1 * (+4. * (F2[4] * 1./4. *
+      (V3[3] + cI * (V3[4]))) - F2[5] * (V3[2] + V3[5]))) + F2[3] * (P1[0] *
+      (V3[5] - V3[2]) + (P1[1] * (V3[3] - cI * (V3[4])) + (P1[2] * (V3[4] + cI
+      * (V3[3])) + P1[3] * (V3[5] - V3[2]))))));
+  F1[4] = denom * (-cI) * (F2[4] * (P1[0] * (V3[2] - V3[5]) + (P1[1] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P1[2] * (+cI * (V3[3]) - V3[4]) + P1[3] *
+      (V3[2] - V3[5])))) + (F2[5] * (P1[0] * (+cI * (V3[4]) - V3[3]) + (P1[1] *
+      (V3[2] + V3[5]) + (P1[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P1[3] * (+cI
+      * (V3[4]) - V3[3])))) + M1 * (F2[2] * 4. * (V3[2] + V3[5]) + 4. * (F2[3]
+      * (V3[3] - cI * (V3[4]))))));
+  F1[5] = denom * (-cI) * (F2[4] * (P1[0] * (-1.) * (V3[3] + cI * (V3[4])) +
+      (P1[1] * (V3[2] - V3[5]) + (P1[2] * (-cI * (V3[5]) + cI * (V3[2])) +
+      P1[3] * (V3[3] + cI * (V3[4]))))) + (F2[5] * (P1[0] * (V3[2] + V3[5]) +
+      (P1[1] * (+cI * (V3[4]) - V3[3]) + (P1[2] * (-1.) * (V3[4] + cI *
+      (V3[3])) - P1[3] * (V3[2] + V3[5])))) + M1 * (F2[2] * 4. * (V3[3] + cI *
+      (V3[4])) + 4. * (F2[3] * (V3[2] - V3[5])))));
+}
+
+
+void VVVS1_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> S4[], std::complex<double> COUP, double M2, double W2,
+    std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P1[4]; 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP19; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP24; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP28; 
+  std::complex<double> denom; 
+  P1[0] = V1[0].real(); 
+  P1[1] = V1[1].real(); 
+  P1[2] = V1[1].imag(); 
+  P1[3] = V1[0].imag(); 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  P3[0] = V3[0].real(); 
+  P3[1] = V3[1].real(); 
+  P3[2] = V3[1].imag(); 
+  P3[3] = V3[0].imag(); 
+  V2[0] = +V1[0] + V3[0] + S4[0]; 
+  V2[1] = +V1[1] + V3[1] + S4[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP28 = (P2[0] * P3[0] - P2[1] * P3[1] - P2[2] * P3[2] - P2[3] * P3[3]); 
+  TMP19 = (P1[0] * P2[0] - P1[1] * P2[1] - P1[2] * P2[2] - P1[3] * P2[3]); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  TMP24 = (P2[0] * V3[2] - P2[1] * V3[3] - P2[2] * V3[4] - P2[3] * V3[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S4[2] * (OM2 * P2[0] * (TMP25 * (-cI * (TMP19) + cI *
+      (TMP28)) + (-cI * (TMP18 * TMP24) + cI * (TMP17 * TMP23))) + (TMP25 *
+      (-cI * (P3[0]) + cI * (P1[0])) + (V1[2] * (-cI * (TMP23) + cI * (TMP24))
+      + V3[2] * (-cI * (TMP17) + cI * (TMP18)))));
+  V2[3] = denom * S4[2] * (OM2 * P2[1] * (TMP25 * (-cI * (TMP19) + cI *
+      (TMP28)) + (-cI * (TMP18 * TMP24) + cI * (TMP17 * TMP23))) + (TMP25 *
+      (-cI * (P3[1]) + cI * (P1[1])) + (V1[3] * (-cI * (TMP23) + cI * (TMP24))
+      + V3[3] * (-cI * (TMP17) + cI * (TMP18)))));
+  V2[4] = denom * S4[2] * (OM2 * P2[2] * (TMP25 * (-cI * (TMP19) + cI *
+      (TMP28)) + (-cI * (TMP18 * TMP24) + cI * (TMP17 * TMP23))) + (TMP25 *
+      (-cI * (P3[2]) + cI * (P1[2])) + (V1[4] * (-cI * (TMP23) + cI * (TMP24))
+      + V3[4] * (-cI * (TMP17) + cI * (TMP18)))));
+  V2[5] = denom * S4[2] * (OM2 * P2[3] * (TMP25 * (-cI * (TMP19) + cI *
+      (TMP28)) + (-cI * (TMP18 * TMP24) + cI * (TMP17 * TMP23))) + (TMP25 *
+      (-cI * (P3[3]) + cI * (P1[3])) + (V1[5] * (-cI * (TMP23) + cI * (TMP24))
+      + V3[5] * (-cI * (TMP17) + cI * (TMP18)))));
+}
+
+
+void VVVVS3_2(std::complex<double> V1[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> S5[], std::complex<double>
+    COUP, double M2, double W2, std::complex<double> V2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM2; 
+  double P2[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP32; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM2 = 0.; 
+  if (M2 != 0.)
+    OM2 = 1./(M2 * M2); 
+  V2[0] = +V1[0] + V3[0] + V4[0] + S5[0]; 
+  V2[1] = +V1[1] + V3[1] + V4[1] + S5[1]; 
+  P2[0] = -V2[0].real(); 
+  P2[1] = -V2[1].real(); 
+  P2[2] = -V2[1].imag(); 
+  P2[3] = -V2[0].imag(); 
+  TMP32 = (P2[0] * V4[2] - P2[1] * V4[3] - P2[2] * V4[4] - P2[3] * V4[5]); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  V2[2] = denom * S5[2] * (OM2 * P2[0] * (-cI * (TMP17 * TMP35) + cI * (TMP25 *
+      TMP32)) + (-cI * (TMP25 * V4[2]) + cI * (V1[2] * TMP35)));
+  V2[3] = denom * S5[2] * (OM2 * P2[1] * (-cI * (TMP17 * TMP35) + cI * (TMP25 *
+      TMP32)) + (-cI * (TMP25 * V4[3]) + cI * (V1[3] * TMP35)));
+  V2[4] = denom * S5[2] * (OM2 * P2[2] * (-cI * (TMP17 * TMP35) + cI * (TMP25 *
+      TMP32)) + (-cI * (TMP25 * V4[4]) + cI * (V1[4] * TMP35)));
+  V2[5] = denom * S5[2] * (OM2 * P2[3] * (-cI * (TMP17 * TMP35) + cI * (TMP25 *
+      TMP32)) + (-cI * (TMP25 * V4[5]) + cI * (V1[5] * TMP35)));
+}
+
+
+void VVVV2_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP23; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP31; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  V1[0] = +V2[0] + V3[0] + V4[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP23 = (P1[0] * V3[2] - P1[1] * V3[3] - P1[2] * V3[4] - P1[3] * V3[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP31 = (P1[0] * V4[2] - P1[1] * V4[3] - P1[2] * V4[4] - P1[3] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * (OM1 * P1[0] * (-2. * cI * (TMP22 * TMP35) + cI * (TMP27 *
+      TMP31 + TMP23 * TMP30)) + (-cI * (TMP27 * V4[2] + V3[2] * TMP30) + 2. *
+      cI * (V2[2] * TMP35)));
+  V1[3] = denom * (OM1 * P1[1] * (-2. * cI * (TMP22 * TMP35) + cI * (TMP27 *
+      TMP31 + TMP23 * TMP30)) + (-cI * (TMP27 * V4[3] + V3[3] * TMP30) + 2. *
+      cI * (V2[3] * TMP35)));
+  V1[4] = denom * (OM1 * P1[2] * (-2. * cI * (TMP22 * TMP35) + cI * (TMP27 *
+      TMP31 + TMP23 * TMP30)) + (-cI * (TMP27 * V4[4] + V3[4] * TMP30) + 2. *
+      cI * (V2[4] * TMP35)));
+  V1[5] = denom * (OM1 * P1[3] * (-2. * cI * (TMP22 * TMP35) + cI * (TMP27 *
+      TMP31 + TMP23 * TMP30)) + (-cI * (TMP27 * V4[5] + V3[5] * TMP30) + 2. *
+      cI * (V2[5] * TMP35)));
+}
+
+
+void VVVV3_1(std::complex<double> V2[], std::complex<double> V3[],
+    std::complex<double> V4[], std::complex<double> COUP, double M1, double W1,
+    std::complex<double> V1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM1; 
+  double P1[4]; 
+  std::complex<double> TMP22; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP31; 
+  std::complex<double> TMP35; 
+  std::complex<double> denom; 
+  OM1 = 0.; 
+  if (M1 != 0.)
+    OM1 = 1./(M1 * M1); 
+  V1[0] = +V2[0] + V3[0] + V4[0]; 
+  V1[1] = +V2[1] + V3[1] + V4[1]; 
+  P1[0] = -V1[0].real(); 
+  P1[1] = -V1[1].real(); 
+  P1[2] = -V1[1].imag(); 
+  P1[3] = -V1[0].imag(); 
+  TMP35 = (V3[2] * V4[2] - V3[3] * V4[3] - V3[4] * V4[4] - V3[5] * V4[5]); 
+  TMP31 = (P1[0] * V4[2] - P1[1] * V4[3] - P1[2] * V4[4] - P1[3] * V4[5]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP22 = (P1[0] * V2[2] - P1[1] * V2[3] - P1[2] * V2[4] - P1[3] * V2[5]); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  V1[2] = denom * (OM1 * P1[0] * (-cI * (TMP22 * TMP35) + cI * (TMP27 * TMP31))
+      + (-cI * (TMP27 * V4[2]) + cI * (V2[2] * TMP35)));
+  V1[3] = denom * (OM1 * P1[1] * (-cI * (TMP22 * TMP35) + cI * (TMP27 * TMP31))
+      + (-cI * (TMP27 * V4[3]) + cI * (V2[3] * TMP35)));
+  V1[4] = denom * (OM1 * P1[2] * (-cI * (TMP22 * TMP35) + cI * (TMP27 * TMP31))
+      + (-cI * (TMP27 * V4[4]) + cI * (V2[4] * TMP35)));
+  V1[5] = denom * (OM1 * P1[3] * (-cI * (TMP22 * TMP35) + cI * (TMP27 * TMP31))
+      + (-cI * (TMP27 * V4[5]) + cI * (V2[5] * TMP35)));
+}
+
+
+void VVSS1_0(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> S3[], std::complex<double> S4[], std::complex<double>
+    COUP, std::complex<double> & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP21; 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  vertex = COUP * - cI * TMP21 * S4[2] * S3[2]; 
+}
+
+
+void VSS1_3(std::complex<double> V1[], std::complex<double> S2[],
+    std::complex<double> COUP, double M3, double W3, std::complex<double> S3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  double P3[4]; 
+  std::complex<double> TMP17; 
+  std::complex<double> TMP18; 
+  std::complex<double> denom; 
+  P2[0] = S2[0].real(); 
+  P2[1] = S2[1].real(); 
+  P2[2] = S2[1].imag(); 
+  P2[3] = S2[0].imag(); 
+  S3[0] = +V1[0] + S2[0]; 
+  S3[1] = +V1[1] + S2[1]; 
+  P3[0] = -S3[0].real(); 
+  P3[1] = -S3[1].real(); 
+  P3[2] = -S3[1].imag(); 
+  P3[3] = -S3[0].imag(); 
+  TMP17 = (P2[0] * V1[2] - P2[1] * V1[3] - P2[2] * V1[4] - P2[3] * V1[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  S3[2] = denom * S2[2] * (-cI * (TMP18) + cI * (TMP17)); 
+}
+
+
+void FFS3C1_0(std::complex<double> F2[], std::complex<double> F1[],
+    std::complex<double> S3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP1; 
+  std::complex<double> TMP2; 
+  TMP2 = (F2[4] * F1[4] + F2[5] * F1[5]); 
+  TMP1 = (F2[2] * F1[2] + F2[3] * F1[3]); 
+  vertex = COUP * S3[2] * (-cI * (TMP1) + cI * (TMP2)); 
+}
+
+
+void FFV5_0(std::complex<double> F1[], std::complex<double> F2[],
+    std::complex<double> V3[], std::complex<double> COUP, std::complex<double>
+    & vertex)
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  std::complex<double> TMP11; 
+  std::complex<double> TMP12; 
+  TMP11 = (F1[2] * (F2[4] * (V3[2] + V3[5]) + F2[5] * (V3[3] + cI * (V3[4]))) +
+      F1[3] * (F2[4] * (V3[3] - cI * (V3[4])) + F2[5] * (V3[2] - V3[5])));
+  TMP12 = (F1[4] * (F2[2] * (V3[2] - V3[5]) - F2[3] * (V3[3] + cI * (V3[4]))) +
+      F1[5] * (F2[2] * (+cI * (V3[4]) - V3[3]) + F2[3] * (V3[2] + V3[5])));
+  vertex = COUP * (-1.) * (+cI * (TMP11) + 4. * cI * (TMP12)); 
+}
+
+
+void FFV2_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * cI * M1 * (F2[4] * (V3[2] + V3[5]) + F2[5] * (V3[3] + cI *
+      (V3[4])));
+  F1[3] = denom * - cI * M1 * (F2[4] * (+cI * (V3[4]) - V3[3]) + F2[5] * (V3[5]
+      - V3[2]));
+  F1[4] = denom * (-cI) * (F2[4] * (P1[0] * (V3[2] + V3[5]) + (P1[1] * (+cI *
+      (V3[4]) - V3[3]) + (P1[2] * (-1.) * (V3[4] + cI * (V3[3])) - P1[3] *
+      (V3[2] + V3[5])))) + F2[5] * (P1[0] * (V3[3] + cI * (V3[4])) + (P1[1] *
+      (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[2]) + cI * (V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))));
+  F1[5] = denom * (-cI) * (F2[4] * (P1[0] * (V3[3] - cI * (V3[4])) + (P1[1] *
+      (-1.) * (V3[2] + V3[5]) + (P1[2] * (+cI * (V3[2] + V3[5])) + P1[3] *
+      (V3[3] - cI * (V3[4]))))) + F2[5] * (P1[0] * (V3[2] - V3[5]) + (P1[1] *
+      (-1.) * (V3[3] + cI * (V3[4])) + (P1[2] * (+cI * (V3[3]) - V3[4]) + P1[3]
+      * (V3[2] - V3[5])))));
+}
+
+void FFV2_5_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2_1(F2, V3, COUP1, M1, W1, F1); 
+  FFV5_1(F2, V3, COUP2, M1, W1, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F1[i] = F1[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+void FFV2_3_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2_1(F2, V3, COUP1, M1, W1, F1); 
+  FFV3_1(F2, V3, COUP2, M1, W1, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F1[i] = F1[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+void FFV2_4_1(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2_1(F2, V3, COUP1, M1, W1, F1); 
+  FFV4_1(F2, V3, COUP2, M1, W1, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F1[i] = F1[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+
+void VVVV1_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP26; 
+  std::complex<double> TMP29; 
+  std::complex<double> TMP30; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +V1[0] + V2[0] + V4[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP29 = (V1[2] * V4[2] - V1[3] * V4[3] - V1[4] * V4[4] - V1[5] * V4[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP26 = (P3[0] * V2[2] - P3[1] * V2[3] - P3[2] * V2[4] - P3[3] * V2[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (OM3 * P3[0] * (-cI * (TMP18 * TMP30) + cI * (TMP26 * TMP29))
+      + (-cI * (V2[2] * TMP29) + cI * (V1[2] * TMP30)));
+  V3[3] = denom * (OM3 * P3[1] * (-cI * (TMP18 * TMP30) + cI * (TMP26 * TMP29))
+      + (-cI * (V2[3] * TMP29) + cI * (V1[3] * TMP30)));
+  V3[4] = denom * (OM3 * P3[2] * (-cI * (TMP18 * TMP30) + cI * (TMP26 * TMP29))
+      + (-cI * (V2[4] * TMP29) + cI * (V1[4] * TMP30)));
+  V3[5] = denom * (OM3 * P3[3] * (-cI * (TMP18 * TMP30) + cI * (TMP26 * TMP29))
+      + (-cI * (V2[5] * TMP29) + cI * (V1[5] * TMP30)));
+}
+
+
+void SSSS1_4(std::complex<double> S1[], std::complex<double> S2[],
+    std::complex<double> S3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> S4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P4[4]; 
+  std::complex<double> denom; 
+  S4[0] = +S1[0] + S2[0] + S3[0]; 
+  S4[1] = +S1[1] + S2[1] + S3[1]; 
+  P4[0] = -S4[0].real(); 
+  P4[1] = -S4[1].real(); 
+  P4[2] = -S4[1].imag(); 
+  P4[3] = -S4[0].imag(); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  S4[2] = denom * cI * S3[2] * S2[2] * S1[2]; 
+}
+
+
+void FFV2C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP, double M1, double W1, std::complex<double> F1[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P1[4]; 
+  std::complex<double> denom; 
+  F1[0] = +F2[0] + V3[0]; 
+  F1[1] = +F2[1] + V3[1]; 
+  P1[0] = -F1[0].real(); 
+  P1[1] = -F1[1].real(); 
+  P1[2] = -F1[1].imag(); 
+  P1[3] = -F1[0].imag(); 
+  denom = COUP/((P1[0] * P1[0]) - (P1[1] * P1[1]) - (P1[2] * P1[2]) - (P1[3] *
+      P1[3]) - M1 * (M1 - cI * W1));
+  F1[2] = denom * - cI * M1 * (F2[4] * (V3[2] - V3[5]) + F2[5] * (+cI * (V3[4])
+      - V3[3]));
+  F1[3] = denom * cI * M1 * (F2[4] * (V3[3] + cI * (V3[4])) - F2[5] * (V3[2] +
+      V3[5]));
+  F1[4] = denom * (-cI) * (F2[4] * (P1[0] * (V3[2] - V3[5]) + (P1[1] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P1[2] * (+cI * (V3[3]) - V3[4]) + P1[3] *
+      (V3[2] - V3[5])))) + F2[5] * (P1[0] * (+cI * (V3[4]) - V3[3]) + (P1[1] *
+      (V3[2] + V3[5]) + (P1[2] * (-1.) * (+cI * (V3[2] + V3[5])) + P1[3] * (+cI
+      * (V3[4]) - V3[3])))));
+  F1[5] = denom * cI * (F2[4] * (P1[0] * (V3[3] + cI * (V3[4])) + (P1[1] *
+      (V3[5] - V3[2]) + (P1[2] * (-cI * (V3[2]) + cI * (V3[5])) - P1[3] *
+      (V3[3] + cI * (V3[4]))))) + F2[5] * (P1[0] * (-1.) * (V3[2] + V3[5]) +
+      (P1[1] * (V3[3] - cI * (V3[4])) + (P1[2] * (V3[4] + cI * (V3[3])) + P1[3]
+      * (V3[2] + V3[5])))));
+}
+
+void FFV2_5C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2C1_2(F2, V3, COUP1, M1, W1, F1); 
+  FFV5C1_2(F2, V3, COUP2, M1, W1, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F1[i] = F1[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+void FFV2_3C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2C1_2(F2, V3, COUP1, M1, W1, F1); 
+  FFV3C1_2(F2, V3, COUP2, M1, W1, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F1[i] = F1[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+void FFV2_4C1_2(std::complex<double> F2[], std::complex<double> V3[],
+    std::complex<double> COUP1, std::complex<double> COUP2, double M1, double
+    W1, std::complex<double> F1[])
+{
+  std::complex<double> Ftmp[6]; 
+  int i; 
+  FFV2C1_2(F2, V3, COUP1, M1, W1, F1); 
+  FFV4C1_2(F2, V3, COUP2, M1, W1, Ftmp); 
+  i = 2; 
+  while (i < 6)
+  {
+    F1[i] = F1[i] + Ftmp[i]; 
+    i++; 
+  }
+}
+
+void VVVV5_4(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V3[], std::complex<double> COUP, double M4, double W4,
+    std::complex<double> V4[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM4; 
+  double P4[4]; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP25; 
+  std::complex<double> TMP27; 
+  std::complex<double> TMP33; 
+  std::complex<double> TMP34; 
+  std::complex<double> TMP37; 
+  std::complex<double> denom; 
+  OM4 = 0.; 
+  if (M4 != 0.)
+    OM4 = 1./(M4 * M4); 
+  V4[0] = +V1[0] + V2[0] + V3[0]; 
+  V4[1] = +V1[1] + V2[1] + V3[1]; 
+  P4[0] = -V4[0].real(); 
+  P4[1] = -V4[1].real(); 
+  P4[2] = -V4[1].imag(); 
+  P4[3] = -V4[0].imag(); 
+  TMP25 = (V3[2] * V1[2] - V3[3] * V1[3] - V3[4] * V1[4] - V3[5] * V1[5]); 
+  TMP34 = (V2[2] * P4[0] - V2[3] * P4[1] - V2[4] * P4[2] - V2[5] * P4[3]); 
+  TMP27 = (V3[2] * V2[2] - V3[3] * V2[3] - V3[4] * V2[4] - V3[5] * V2[5]); 
+  TMP37 = (V3[2] * P4[0] - V3[3] * P4[1] - V3[4] * P4[2] - V3[5] * P4[3]); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP33 = (V1[2] * P4[0] - V1[3] * P4[1] - V1[4] * P4[2] - V1[5] * P4[3]); 
+  denom = COUP/((P4[0] * P4[0]) - (P4[1] * P4[1]) - (P4[2] * P4[2]) - (P4[3] *
+      P4[3]) - M4 * (M4 - cI * W4));
+  V4[2] = denom * 1./2. * (OM4 * - P4[0] * (-2. * cI * (TMP27 * TMP33) + cI *
+      (TMP25 * TMP34 + TMP21 * TMP37)) + (-2. * cI * (V1[2] * TMP27) + cI *
+      (V2[2] * TMP25 + V3[2] * TMP21)));
+  V4[3] = denom * 1./2. * (OM4 * - P4[1] * (-2. * cI * (TMP27 * TMP33) + cI *
+      (TMP25 * TMP34 + TMP21 * TMP37)) + (-2. * cI * (V1[3] * TMP27) + cI *
+      (V2[3] * TMP25 + V3[3] * TMP21)));
+  V4[4] = denom * 1./2. * (OM4 * - P4[2] * (-2. * cI * (TMP27 * TMP33) + cI *
+      (TMP25 * TMP34 + TMP21 * TMP37)) + (-2. * cI * (V1[4] * TMP27) + cI *
+      (V2[4] * TMP25 + V3[4] * TMP21)));
+  V4[5] = denom * 1./2. * (OM4 * - P4[3] * (-2. * cI * (TMP27 * TMP33) + cI *
+      (TMP25 * TMP34 + TMP21 * TMP37)) + (-2. * cI * (V1[5] * TMP27) + cI *
+      (V2[5] * TMP25 + V3[5] * TMP21)));
+}
+
+
+void VVVV4_3(std::complex<double> V1[], std::complex<double> V2[],
+    std::complex<double> V4[], std::complex<double> COUP, double M3, double W3,
+    std::complex<double> V3[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double OM3; 
+  double P3[4]; 
+  std::complex<double> TMP18; 
+  std::complex<double> TMP21; 
+  std::complex<double> TMP30; 
+  std::complex<double> TMP36; 
+  std::complex<double> denom; 
+  OM3 = 0.; 
+  if (M3 != 0.)
+    OM3 = 1./(M3 * M3); 
+  V3[0] = +V1[0] + V2[0] + V4[0]; 
+  V3[1] = +V1[1] + V2[1] + V4[1]; 
+  P3[0] = -V3[0].real(); 
+  P3[1] = -V3[1].real(); 
+  P3[2] = -V3[1].imag(); 
+  P3[3] = -V3[0].imag(); 
+  TMP21 = (V1[2] * V2[2] - V1[3] * V2[3] - V1[4] * V2[4] - V1[5] * V2[5]); 
+  TMP30 = (V2[2] * V4[2] - V2[3] * V4[3] - V2[4] * V4[4] - V2[5] * V4[5]); 
+  TMP36 = (P3[0] * V4[2] - P3[1] * V4[3] - P3[2] * V4[4] - P3[3] * V4[5]); 
+  TMP18 = (P3[0] * V1[2] - P3[1] * V1[3] - P3[2] * V1[4] - P3[3] * V1[5]); 
+  denom = COUP/((P3[0] * P3[0]) - (P3[1] * P3[1]) - (P3[2] * P3[2]) - (P3[3] *
+      P3[3]) - M3 * (M3 - cI * W3));
+  V3[2] = denom * (OM3 * P3[0] * (-cI * (TMP21 * TMP36) + cI * (TMP18 * TMP30))
+      + (-cI * (V1[2] * TMP30) + cI * (TMP21 * V4[2])));
+  V3[3] = denom * (OM3 * P3[1] * (-cI * (TMP21 * TMP36) + cI * (TMP18 * TMP30))
+      + (-cI * (V1[3] * TMP30) + cI * (TMP21 * V4[3])));
+  V3[4] = denom * (OM3 * P3[2] * (-cI * (TMP21 * TMP36) + cI * (TMP18 * TMP30))
+      + (-cI * (V1[4] * TMP30) + cI * (TMP21 * V4[4])));
+  V3[5] = denom * (OM3 * P3[3] * (-cI * (TMP21 * TMP36) + cI * (TMP18 * TMP30))
+      + (-cI * (V1[5] * TMP30) + cI * (TMP21 * V4[5])));
+}
+
+
+void FFV4_2(std::complex<double> F1[], std::complex<double> V3[],
+    std::complex<double> COUP, double M2, double W2, std::complex<double> F2[])
+{
+  static std::complex<double> cI = std::complex<double> (0., 1.); 
+  double P2[4]; 
+  std::complex<double> denom; 
+  F2[0] = +F1[0] + V3[0]; 
+  F2[1] = +F1[1] + V3[1]; 
+  P2[0] = -F2[0].real(); 
+  P2[1] = -F2[1].real(); 
+  P2[2] = -F2[1].imag(); 
+  P2[3] = -F2[0].imag(); 
+  denom = COUP/((P2[0] * P2[0]) - (P2[1] * P2[1]) - (P2[2] * P2[2]) - (P2[3] *
+      P2[3]) - M2 * (M2 - cI * W2));
+  F2[2] = denom * cI * (F1[2] * (P2[0] * (V3[2] + V3[5]) + (P2[1] * (-1.) *
+      (V3[3] + cI * (V3[4])) + (P2[2] * (+cI * (V3[3]) - V3[4]) - P2[3] *
+      (V3[2] + V3[5])))) + (F1[3] * (P2[0] * (V3[3] - cI * (V3[4])) + (P2[1] *
+      (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[5]) + cI * (V3[2])) + P2[3] * (+cI
+      * (V3[4]) - V3[3])))) + M2 * (F1[4] * 2. * (V3[2] - V3[5]) + 2. * (F1[5]
+      * (+cI * (V3[4]) - V3[3])))));
+  F2[3] = denom * cI * (F1[2] * (P2[0] * (V3[3] + cI * (V3[4])) + (P2[1] *
+      (-1.) * (V3[2] + V3[5]) + (P2[2] * (-1.) * (+cI * (V3[2] + V3[5])) +
+      P2[3] * (V3[3] + cI * (V3[4]))))) + (F1[3] * (P2[0] * (V3[2] - V3[5]) +
+      (P2[1] * (+cI * (V3[4]) - V3[3]) + (P2[2] * (-1.) * (V3[4] + cI *
+      (V3[3])) + P2[3] * (V3[2] - V3[5])))) + M2 * (F1[4] * (-2.) * (V3[3] + cI
+      * (V3[4])) + 2. * (F1[5] * (V3[2] + V3[5])))));
+  F2[4] = denom * (-2. * cI) * (F1[4] * (P2[0] * (V3[5] - V3[2]) + (P2[1] *
+      (V3[3] + cI * (V3[4])) + (P2[2] * (V3[4] - cI * (V3[3])) + P2[3] * (V3[5]
+      - V3[2])))) + (+1./2. * (M2 * (F1[3] * (+cI * (V3[4]) - V3[3]) + 2. *
+      (F1[2] * (-1./2.) * (V3[2] + V3[5])))) + F1[5] * (P2[0] * (V3[3] - cI *
+      (V3[4])) + (P2[1] * (-1.) * (V3[2] + V3[5]) + (P2[2] * (+cI * (V3[2] +
+      V3[5])) + P2[3] * (V3[3] - cI * (V3[4])))))));
+  F2[5] = denom * (-2. * cI) * (F1[4] * (P2[0] * (V3[3] + cI * (V3[4])) +
+      (P2[1] * (V3[5] - V3[2]) + (P2[2] * (-cI * (V3[2]) + cI * (V3[5])) -
+      P2[3] * (V3[3] + cI * (V3[4]))))) + (+1./2. * (M2 * (F1[3] * (V3[5] -
+      V3[2]) + 2. * (F1[2] * (-1./2.) * (V3[3] + cI * (V3[4]))))) + F1[5] *
+      (P2[0] * (-1.) * (V3[2] + V3[5]) + (P2[1] * (V3[3] - cI * (V3[4])) +
+      (P2[2] * (V3[4] + cI * (V3[3])) + P2[3] * (V3[2] + V3[5]))))));
+}
+
+
+}  // end namespace $(namespace)s_MDMSM
+
diff -rupN Pythia/src/Parameters_MDMSM.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Parameters_MDMSM.cc
--- Pythia/src/Parameters_MDMSM.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Parameters_MDMSM.cc	2021-03-08 16:53:53.151483602 +1000
@@ -0,0 +1,661 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include <iostream> 
+#include "Parameters_MDMSM.h"
+#include "Pythia8/PythiaStdlib.h"
+
+using namespace Pythia8; 
+
+// Initialize static instance
+Parameters_MDMSM * Parameters_MDMSM::instance = 0; 
+
+// Function to get static instance - only one instance per program
+Parameters_MDMSM * Parameters_MDMSM::getInstance()
+{
+  if (instance == 0)
+    instance = new Parameters_MDMSM(); 
+
+  return instance; 
+}
+
+void Parameters_MDMSM::setIndependentParameters(ParticleData * & pd, Couplings
+    * & csm, SusyLesHouches * & slhaPtr)
+{
+  mdl_wY = pd->mWidth(99902); 
+  mdl_Wchi = pd->mWidth(52); 
+  mdl_WH = pd->mWidth(25); 
+  mdl_WT = pd->mWidth(6); 
+  mdl_WW = pd->mWidth(24); 
+  mdl_WZ = pd->mWidth(23); 
+  mdl_mY = pd->m0(99902); 
+  mdl_mchi = pd->m0(52); 
+  mdl_MH = pd->m0(25); 
+  mdl_MB = pd->m0(5); 
+  mdl_MS = pd->m0(3); 
+  mdl_MD = pd->m0(1); 
+  mdl_MT = pd->m0(6); 
+  mdl_MC = pd->m0(4); 
+  mdl_MU = pd->m0(2); 
+  mdl_MTA = pd->m0(15); 
+  mdl_MMU = pd->m0(13); 
+  mdl_Me = pd->m0(11); 
+  mdl_MZ = pd->m0(23); 
+  mdl_ymtau = pd->mRun(15, pd->m0(24)); 
+  mdl_ymm = pd->mRun(13, pd->m0(24)); 
+  mdl_yme = pd->mRun(11, pd->m0(24)); 
+  mdl_ymt = pd->mRun(6, pd->m0(24)); 
+  mdl_ymb = pd->mRun(5, pd->m0(24)); 
+  mdl_ymc = pd->mRun(4, pd->m0(24)); 
+  mdl_yms = pd->mRun(3, pd->m0(24)); 
+  mdl_ymup = pd->mRun(2, pd->m0(24)); 
+  mdl_ymdo = pd->mRun(1, pd->m0(24)); 
+  mdl_Gf = M_PI * csm->alphaEM(((pd->m0(23)) * (pd->m0(23)))) * ((pd->m0(23)) *
+      (pd->m0(23)))/(sqrt(2.) * ((pd->m0(24)) * (pd->m0(24))) * (((pd->m0(23))
+      * (pd->m0(23))) - ((pd->m0(24)) * (pd->m0(24)))));
+  aEWM1 = 1./csm->alphaEM(((pd->m0(23)) * (pd->m0(23)))); 
+  if( !slhaPtr->getEntry<double> ("dmint", 4, mdl_gggY2))
+  {
+    cout <<  "Warning, setting mdl_gggY2 to 1.000000e+00" << endl; 
+    mdl_gggY2 = 1.000000e+00; 
+  }
+  if( !slhaPtr->getEntry<double> ("dmint", 3, mdl_gggY1))
+  {
+    cout <<  "Warning, setting mdl_gggY1 to 1.000000e+00" << endl; 
+    mdl_gggY1 = 1.000000e+00; 
+  }
+  if( !slhaPtr->getEntry<double> ("dmint", 2, mdl_cY))
+  {
+    cout <<  "Warning, setting mdl_cY to 1.000000e+00" << endl; 
+    mdl_cY = 1.000000e+00; 
+  }
+  if( !slhaPtr->getEntry<double> ("dmint", 1, mdl_gchi))
+  {
+    cout <<  "Warning, setting mdl_gchi to 1.000000e+00" << endl; 
+    mdl_gchi = 1.000000e+00; 
+  }
+  ZERO = 0.; 
+  mdl_MZ__exp__2 = ((mdl_MZ) * (mdl_MZ)); 
+  mdl_MZ__exp__4 = ((mdl_MZ) * (mdl_MZ) * (mdl_MZ) * (mdl_MZ)); 
+  mdl_sqrt__2 = sqrt(2.); 
+  mdl_MH__exp__2 = ((mdl_MH) * (mdl_MH)); 
+  mdl_complexi = std::complex<double> (0., 1.); 
+  mdl_aEW = 1./aEWM1; 
+  mdl_MW = sqrt(mdl_MZ__exp__2/2. + sqrt(mdl_MZ__exp__4/4. - (mdl_aEW * M_PI *
+      mdl_MZ__exp__2)/(mdl_Gf * mdl_sqrt__2)));
+  mdl_sqrt__aEW = sqrt(mdl_aEW); 
+  mdl_ee = 2. * mdl_sqrt__aEW * sqrt(M_PI); 
+  mdl_MW__exp__2 = ((mdl_MW) * (mdl_MW)); 
+  mdl_sw2 = 1. - mdl_MW__exp__2/mdl_MZ__exp__2; 
+  mdl_cw = sqrt(1. - mdl_sw2); 
+  mdl_sqrt__sw2 = sqrt(mdl_sw2); 
+  mdl_sw = mdl_sqrt__sw2; 
+  mdl_g1 = mdl_ee/mdl_cw; 
+  mdl_gw = mdl_ee/mdl_sw; 
+  mdl_vev = (2. * mdl_MW * mdl_sw)/mdl_ee; 
+  mdl_vev__exp__2 = ((mdl_vev) * (mdl_vev)); 
+  mdl_lam = mdl_MH__exp__2/(2. * mdl_vev__exp__2); 
+  mdl_yb = (mdl_ymb * mdl_sqrt__2)/mdl_vev; 
+  mdl_yc = (mdl_ymc * mdl_sqrt__2)/mdl_vev; 
+  mdl_ydo = (mdl_ymdo * mdl_sqrt__2)/mdl_vev; 
+  mdl_ye = (mdl_yme * mdl_sqrt__2)/mdl_vev; 
+  mdl_ym = (mdl_ymm * mdl_sqrt__2)/mdl_vev; 
+  mdl_ys = (mdl_yms * mdl_sqrt__2)/mdl_vev; 
+  mdl_yt = (mdl_ymt * mdl_sqrt__2)/mdl_vev; 
+  mdl_ytau = (mdl_ymtau * mdl_sqrt__2)/mdl_vev; 
+  mdl_yup = (mdl_ymup * mdl_sqrt__2)/mdl_vev; 
+  mdl_muH = sqrt(mdl_lam * mdl_vev__exp__2); 
+  mdl_I1b11 = mdl_ydo; 
+  mdl_I1b22 = mdl_ys; 
+  mdl_I1b33 = mdl_yb; 
+  mdl_I2b11 = mdl_yup; 
+  mdl_I2b22 = mdl_yc; 
+  mdl_I2b33 = mdl_yt; 
+  mdl_I3b11 = mdl_yup; 
+  mdl_I3b22 = mdl_yc; 
+  mdl_I3b33 = mdl_yt; 
+  mdl_I4b11 = mdl_ydo; 
+  mdl_I4b22 = mdl_ys; 
+  mdl_I4b33 = mdl_yb; 
+  mdl_ee__exp__2 = ((mdl_ee) * (mdl_ee)); 
+  mdl_sw__exp__2 = ((mdl_sw) * (mdl_sw)); 
+  mdl_cw__exp__2 = ((mdl_cw) * (mdl_cw)); 
+  if (mdl_mchi < 0)
+    mdl_Wchi = -abs(mdl_Wchi); 
+}
+void Parameters_MDMSM::setIndependentCouplings()
+{
+  GC_13 = mdl_complexi * mdl_gchi; 
+  GC_14 = 8. * mdl_complexi * mdl_gggY1; 
+  GC_1 = -(mdl_ee * mdl_complexi)/3.; 
+  GC_2 = (2. * mdl_ee * mdl_complexi)/3.; 
+  GC_3 = -(mdl_ee * mdl_complexi); 
+  GC_4 = mdl_ee * mdl_complexi; 
+  GC_5 = mdl_ee__exp__2 * mdl_complexi; 
+  GC_6 = 2. * mdl_ee__exp__2 * mdl_complexi; 
+  GC_7 = -mdl_ee__exp__2/(2. * mdl_cw); 
+  GC_8 = (mdl_ee__exp__2 * mdl_complexi)/(2. * mdl_cw); 
+  GC_9 = mdl_ee__exp__2/(2. * mdl_cw); 
+  GC_17 = mdl_I1b11; 
+  GC_18 = mdl_I1b22; 
+  GC_19 = mdl_I1b33; 
+  GC_20 = -mdl_I2b11; 
+  GC_21 = -mdl_I2b22; 
+  GC_22 = -mdl_I2b33; 
+  GC_23 = mdl_I3b11; 
+  GC_24 = mdl_I3b22; 
+  GC_25 = mdl_I3b33; 
+  GC_26 = -mdl_I4b11; 
+  GC_27 = -mdl_I4b22; 
+  GC_28 = -mdl_I4b33; 
+  GC_29 = -2. * mdl_complexi * mdl_lam; 
+  GC_30 = -4. * mdl_complexi * mdl_lam; 
+  GC_31 = -6. * mdl_complexi * mdl_lam; 
+  GC_32 = (mdl_ee__exp__2 * mdl_complexi)/(2. * mdl_sw__exp__2); 
+  GC_33 = -((mdl_ee__exp__2 * mdl_complexi)/mdl_sw__exp__2); 
+  GC_34 = (mdl_cw__exp__2 * mdl_ee__exp__2 * mdl_complexi)/mdl_sw__exp__2; 
+  GC_35 = -mdl_ee/(2. * mdl_sw); 
+  GC_36 = -(mdl_ee * mdl_complexi)/(2. * mdl_sw); 
+  GC_37 = (mdl_ee * mdl_complexi)/(2. * mdl_sw); 
+  GC_38 = (mdl_ee * mdl_complexi)/(mdl_sw * mdl_sqrt__2); 
+  GC_39 = -(mdl_cw * mdl_ee * mdl_complexi)/(2. * mdl_sw); 
+  GC_40 = (mdl_cw * mdl_ee * mdl_complexi)/(2. * mdl_sw); 
+  GC_41 = -((mdl_cw * mdl_ee * mdl_complexi)/mdl_sw); 
+  GC_42 = (mdl_cw * mdl_ee * mdl_complexi)/mdl_sw; 
+  GC_43 = -mdl_ee__exp__2/(2. * mdl_sw); 
+  GC_44 = -(mdl_ee__exp__2 * mdl_complexi)/(2. * mdl_sw); 
+  GC_45 = mdl_ee__exp__2/(2. * mdl_sw); 
+  GC_46 = (-2. * mdl_cw * mdl_ee__exp__2 * mdl_complexi)/mdl_sw; 
+  GC_47 = -(mdl_ee * mdl_complexi * mdl_sw)/(6. * mdl_cw); 
+  GC_48 = (mdl_ee * mdl_complexi * mdl_sw)/(2. * mdl_cw); 
+  GC_49 = -(mdl_cw * mdl_ee)/(2. * mdl_sw) - (mdl_ee * mdl_sw)/(2. * mdl_cw); 
+  GC_50 = -(mdl_cw * mdl_ee * mdl_complexi)/(2. * mdl_sw) + (mdl_ee *
+      mdl_complexi * mdl_sw)/(2. * mdl_cw);
+  GC_51 = (mdl_cw * mdl_ee * mdl_complexi)/(2. * mdl_sw) + (mdl_ee *
+      mdl_complexi * mdl_sw)/(2. * mdl_cw);
+  GC_52 = (mdl_cw * mdl_ee__exp__2 * mdl_complexi)/mdl_sw - (mdl_ee__exp__2 *
+      mdl_complexi * mdl_sw)/mdl_cw;
+  GC_53 = -(mdl_ee__exp__2 * mdl_complexi) + (mdl_cw__exp__2 * mdl_ee__exp__2 *
+      mdl_complexi)/(2. * mdl_sw__exp__2) + (mdl_ee__exp__2 * mdl_complexi *
+      mdl_sw__exp__2)/(2. * mdl_cw__exp__2);
+  GC_54 = mdl_ee__exp__2 * mdl_complexi + (mdl_cw__exp__2 * mdl_ee__exp__2 *
+      mdl_complexi)/(2. * mdl_sw__exp__2) + (mdl_ee__exp__2 * mdl_complexi *
+      mdl_sw__exp__2)/(2. * mdl_cw__exp__2);
+  GC_55 = -(mdl_ee__exp__2 * mdl_vev)/(2. * mdl_cw); 
+  GC_56 = (mdl_ee__exp__2 * mdl_vev)/(2. * mdl_cw); 
+  GC_57 = -2. * mdl_complexi * mdl_lam * mdl_vev; 
+  GC_58 = -6. * mdl_complexi * mdl_lam * mdl_vev; 
+  GC_59 = -(mdl_ee__exp__2 * mdl_vev)/(4. * mdl_sw__exp__2); 
+  GC_60 = -(mdl_ee__exp__2 * mdl_complexi * mdl_vev)/(4. * mdl_sw__exp__2); 
+  GC_61 = (mdl_ee__exp__2 * mdl_complexi * mdl_vev)/(2. * mdl_sw__exp__2); 
+  GC_62 = (mdl_ee__exp__2 * mdl_vev)/(4. * mdl_sw__exp__2); 
+  GC_63 = -(mdl_ee__exp__2 * mdl_vev)/(2. * mdl_sw); 
+  GC_64 = (mdl_ee__exp__2 * mdl_vev)/(2. * mdl_sw); 
+  GC_65 = -(mdl_ee__exp__2 * mdl_vev)/(4. * mdl_cw) - (mdl_cw * mdl_ee__exp__2
+      * mdl_vev)/(4. * mdl_sw__exp__2);
+  GC_66 = (mdl_ee__exp__2 * mdl_vev)/(4. * mdl_cw) - (mdl_cw * mdl_ee__exp__2 *
+      mdl_vev)/(4. * mdl_sw__exp__2);
+  GC_67 = -(mdl_ee__exp__2 * mdl_vev)/(4. * mdl_cw) + (mdl_cw * mdl_ee__exp__2
+      * mdl_vev)/(4. * mdl_sw__exp__2);
+  GC_68 = (mdl_ee__exp__2 * mdl_vev)/(4. * mdl_cw) + (mdl_cw * mdl_ee__exp__2 *
+      mdl_vev)/(4. * mdl_sw__exp__2);
+  GC_69 = -(mdl_ee__exp__2 * mdl_complexi * mdl_vev)/2. - (mdl_cw__exp__2 *
+      mdl_ee__exp__2 * mdl_complexi * mdl_vev)/(4. * mdl_sw__exp__2) -
+      (mdl_ee__exp__2 * mdl_complexi * mdl_sw__exp__2 * mdl_vev)/(4. *
+      mdl_cw__exp__2);
+  GC_70 = mdl_ee__exp__2 * mdl_complexi * mdl_vev + (mdl_cw__exp__2 *
+      mdl_ee__exp__2 * mdl_complexi * mdl_vev)/(2. * mdl_sw__exp__2) +
+      (mdl_ee__exp__2 * mdl_complexi * mdl_sw__exp__2 * mdl_vev)/(2. *
+      mdl_cw__exp__2);
+  GC_71 = -(mdl_yb/mdl_sqrt__2); 
+  GC_72 = -((mdl_complexi * mdl_yb)/mdl_sqrt__2); 
+  GC_73 = mdl_cY * mdl_complexi * mdl_yb; 
+  GC_74 = -((mdl_complexi * mdl_yc)/mdl_sqrt__2); 
+  GC_75 = mdl_yc/mdl_sqrt__2; 
+  GC_76 = mdl_cY * mdl_complexi * mdl_yc; 
+  GC_77 = -(mdl_ydo/mdl_sqrt__2); 
+  GC_78 = -((mdl_complexi * mdl_ydo)/mdl_sqrt__2); 
+  GC_79 = mdl_cY * mdl_complexi * mdl_ydo; 
+  GC_80 = -mdl_ye; 
+  GC_81 = mdl_ye; 
+  GC_82 = -(mdl_ye/mdl_sqrt__2); 
+  GC_83 = -((mdl_complexi * mdl_ye)/mdl_sqrt__2); 
+  GC_84 = mdl_cY * mdl_complexi * mdl_ye; 
+  GC_85 = -mdl_ym; 
+  GC_86 = mdl_ym; 
+  GC_87 = -(mdl_ym/mdl_sqrt__2); 
+  GC_88 = -((mdl_complexi * mdl_ym)/mdl_sqrt__2); 
+  GC_89 = mdl_cY * mdl_complexi * mdl_ym; 
+  GC_90 = -(mdl_ys/mdl_sqrt__2); 
+  GC_91 = -((mdl_complexi * mdl_ys)/mdl_sqrt__2); 
+  GC_92 = mdl_cY * mdl_complexi * mdl_ys; 
+  GC_93 = -((mdl_complexi * mdl_yt)/mdl_sqrt__2); 
+  GC_94 = mdl_yt/mdl_sqrt__2; 
+  GC_95 = mdl_cY * mdl_complexi * mdl_yt; 
+  GC_96 = -mdl_ytau; 
+  GC_97 = mdl_ytau; 
+  GC_98 = -(mdl_ytau/mdl_sqrt__2); 
+  GC_99 = -((mdl_complexi * mdl_ytau)/mdl_sqrt__2); 
+  GC_100 = -((mdl_complexi * mdl_yup)/mdl_sqrt__2); 
+  GC_101 = mdl_yup/mdl_sqrt__2; 
+  GC_102 = mdl_cY * mdl_complexi * mdl_yup; 
+  if (mdl_mchi < 0)
+    mdl_Wchi = -abs(mdl_Wchi); 
+}
+
+void Parameters_MDMSM::setDependentParameters(ParticleData * & pd, Couplings *
+    & csm, SusyLesHouches * & slhaPtr, double alpS)
+{
+  aS = alpS; 
+  mdl_sqrt__aS = sqrt(aS); 
+  G = 2. * mdl_sqrt__aS * sqrt(M_PI); 
+  mdl_G__exp__2 = ((G) * (G)); 
+  if (mdl_mchi < 0)
+    mdl_Wchi = -abs(mdl_Wchi); 
+}
+
+
+void Parameters_MDMSM::setDependentCouplings()
+{
+  GC_15 = 8. * G * mdl_gggY1; 
+  GC_11 = mdl_complexi * G; 
+  GC_12 = mdl_complexi * mdl_G__exp__2; 
+  GC_16 = -8. * mdl_complexi * mdl_G__exp__2 * mdl_gggY1; 
+  GC_10 = -G; 
+  if (mdl_mchi < 0)
+    mdl_Wchi = -abs(mdl_Wchi); 
+}
+
+// Routines for printing out parameters
+void Parameters_MDMSM::printIndependentParameters()
+{
+  cout <<  "MDMSM model parameters independent of event kinematics:" << endl; 
+  cout << setw(20) <<  "mdl_wY " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_wY << endl;
+  cout << setw(20) <<  "mdl_Wchi " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_Wchi << endl;
+  cout << setw(20) <<  "mdl_WH " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_WH << endl;
+  cout << setw(20) <<  "mdl_WT " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_WT << endl;
+  cout << setw(20) <<  "mdl_WW " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_WW << endl;
+  cout << setw(20) <<  "mdl_WZ " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_WZ << endl;
+  cout << setw(20) <<  "mdl_mY " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_mY << endl;
+  cout << setw(20) <<  "mdl_mchi " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_mchi << endl;
+  cout << setw(20) <<  "mdl_MH " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MH << endl;
+  cout << setw(20) <<  "mdl_MB " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MB << endl;
+  cout << setw(20) <<  "mdl_MS " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MS << endl;
+  cout << setw(20) <<  "mdl_MD " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MD << endl;
+  cout << setw(20) <<  "mdl_MT " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MT << endl;
+  cout << setw(20) <<  "mdl_MC " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MC << endl;
+  cout << setw(20) <<  "mdl_MU " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MU << endl;
+  cout << setw(20) <<  "mdl_MTA " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MTA << endl;
+  cout << setw(20) <<  "mdl_MMU " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MMU << endl;
+  cout << setw(20) <<  "mdl_Me " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_Me << endl;
+  cout << setw(20) <<  "mdl_MZ " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MZ << endl;
+  cout << setw(20) <<  "mdl_ymtau " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ymtau << endl;
+  cout << setw(20) <<  "mdl_ymm " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ymm << endl;
+  cout << setw(20) <<  "mdl_yme " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_yme << endl;
+  cout << setw(20) <<  "mdl_ymt " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ymt << endl;
+  cout << setw(20) <<  "mdl_ymb " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ymb << endl;
+  cout << setw(20) <<  "mdl_ymc " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ymc << endl;
+  cout << setw(20) <<  "mdl_yms " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_yms << endl;
+  cout << setw(20) <<  "mdl_ymup " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ymup << endl;
+  cout << setw(20) <<  "mdl_ymdo " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ymdo << endl;
+  cout << setw(20) <<  "mdl_Gf " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_Gf << endl;
+  cout << setw(20) <<  "aEWM1 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << aEWM1 << endl;
+  cout << setw(20) <<  "mdl_gggY2 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_gggY2 << endl;
+  cout << setw(20) <<  "mdl_gggY1 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_gggY1 << endl;
+  cout << setw(20) <<  "mdl_cY " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_cY << endl;
+  cout << setw(20) <<  "mdl_gchi " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_gchi << endl;
+  cout << setw(20) <<  "ZERO " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << ZERO << endl;
+  cout << setw(20) <<  "mdl_MZ__exp__2 " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_MZ__exp__2 << endl;
+  cout << setw(20) <<  "mdl_MZ__exp__4 " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_MZ__exp__4 << endl;
+  cout << setw(20) <<  "mdl_sqrt__2 " <<  "= " << setiosflags(ios::scientific)
+      << setw(10) << mdl_sqrt__2 << endl;
+  cout << setw(20) <<  "mdl_MH__exp__2 " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_MH__exp__2 << endl;
+  cout << setw(20) <<  "mdl_complexi " <<  "= " << setiosflags(ios::scientific)
+      << setw(10) << mdl_complexi << endl;
+  cout << setw(20) <<  "mdl_aEW " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_aEW << endl;
+  cout << setw(20) <<  "mdl_MW " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_MW << endl;
+  cout << setw(20) <<  "mdl_sqrt__aEW " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_sqrt__aEW << endl;
+  cout << setw(20) <<  "mdl_ee " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ee << endl;
+  cout << setw(20) <<  "mdl_MW__exp__2 " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_MW__exp__2 << endl;
+  cout << setw(20) <<  "mdl_sw2 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_sw2 << endl;
+  cout << setw(20) <<  "mdl_cw " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_cw << endl;
+  cout << setw(20) <<  "mdl_sqrt__sw2 " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_sqrt__sw2 << endl;
+  cout << setw(20) <<  "mdl_sw " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_sw << endl;
+  cout << setw(20) <<  "mdl_g1 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_g1 << endl;
+  cout << setw(20) <<  "mdl_gw " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_gw << endl;
+  cout << setw(20) <<  "mdl_vev " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_vev << endl;
+  cout << setw(20) <<  "mdl_vev__exp__2 " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_vev__exp__2 << endl;
+  cout << setw(20) <<  "mdl_lam " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_lam << endl;
+  cout << setw(20) <<  "mdl_yb " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_yb << endl;
+  cout << setw(20) <<  "mdl_yc " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_yc << endl;
+  cout << setw(20) <<  "mdl_ydo " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ydo << endl;
+  cout << setw(20) <<  "mdl_ye " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ye << endl;
+  cout << setw(20) <<  "mdl_ym " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ym << endl;
+  cout << setw(20) <<  "mdl_ys " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ys << endl;
+  cout << setw(20) <<  "mdl_yt " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_yt << endl;
+  cout << setw(20) <<  "mdl_ytau " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_ytau << endl;
+  cout << setw(20) <<  "mdl_yup " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_yup << endl;
+  cout << setw(20) <<  "mdl_muH " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_muH << endl;
+  cout << setw(20) <<  "mdl_I1b11 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I1b11 << endl;
+  cout << setw(20) <<  "mdl_I1b22 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I1b22 << endl;
+  cout << setw(20) <<  "mdl_I1b33 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I1b33 << endl;
+  cout << setw(20) <<  "mdl_I2b11 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I2b11 << endl;
+  cout << setw(20) <<  "mdl_I2b22 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I2b22 << endl;
+  cout << setw(20) <<  "mdl_I2b33 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I2b33 << endl;
+  cout << setw(20) <<  "mdl_I3b11 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I3b11 << endl;
+  cout << setw(20) <<  "mdl_I3b22 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I3b22 << endl;
+  cout << setw(20) <<  "mdl_I3b33 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I3b33 << endl;
+  cout << setw(20) <<  "mdl_I4b11 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I4b11 << endl;
+  cout << setw(20) <<  "mdl_I4b22 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I4b22 << endl;
+  cout << setw(20) <<  "mdl_I4b33 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << mdl_I4b33 << endl;
+  cout << setw(20) <<  "mdl_ee__exp__2 " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_ee__exp__2 << endl;
+  cout << setw(20) <<  "mdl_sw__exp__2 " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_sw__exp__2 << endl;
+  cout << setw(20) <<  "mdl_cw__exp__2 " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_cw__exp__2 << endl;
+}
+void Parameters_MDMSM::printIndependentCouplings()
+{
+  cout <<  "MDMSM model couplings independent of event kinematics:" << endl; 
+  cout << setw(20) <<  "GC_13 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_13 << endl;
+  cout << setw(20) <<  "GC_14 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_14 << endl;
+  cout << setw(20) <<  "GC_1 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_1 << endl;
+  cout << setw(20) <<  "GC_2 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_2 << endl;
+  cout << setw(20) <<  "GC_3 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_3 << endl;
+  cout << setw(20) <<  "GC_4 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_4 << endl;
+  cout << setw(20) <<  "GC_5 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_5 << endl;
+  cout << setw(20) <<  "GC_6 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_6 << endl;
+  cout << setw(20) <<  "GC_7 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_7 << endl;
+  cout << setw(20) <<  "GC_8 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_8 << endl;
+  cout << setw(20) <<  "GC_9 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_9 << endl;
+  cout << setw(20) <<  "GC_17 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_17 << endl;
+  cout << setw(20) <<  "GC_18 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_18 << endl;
+  cout << setw(20) <<  "GC_19 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_19 << endl;
+  cout << setw(20) <<  "GC_20 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_20 << endl;
+  cout << setw(20) <<  "GC_21 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_21 << endl;
+  cout << setw(20) <<  "GC_22 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_22 << endl;
+  cout << setw(20) <<  "GC_23 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_23 << endl;
+  cout << setw(20) <<  "GC_24 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_24 << endl;
+  cout << setw(20) <<  "GC_25 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_25 << endl;
+  cout << setw(20) <<  "GC_26 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_26 << endl;
+  cout << setw(20) <<  "GC_27 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_27 << endl;
+  cout << setw(20) <<  "GC_28 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_28 << endl;
+  cout << setw(20) <<  "GC_29 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_29 << endl;
+  cout << setw(20) <<  "GC_30 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_30 << endl;
+  cout << setw(20) <<  "GC_31 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_31 << endl;
+  cout << setw(20) <<  "GC_32 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_32 << endl;
+  cout << setw(20) <<  "GC_33 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_33 << endl;
+  cout << setw(20) <<  "GC_34 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_34 << endl;
+  cout << setw(20) <<  "GC_35 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_35 << endl;
+  cout << setw(20) <<  "GC_36 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_36 << endl;
+  cout << setw(20) <<  "GC_37 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_37 << endl;
+  cout << setw(20) <<  "GC_38 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_38 << endl;
+  cout << setw(20) <<  "GC_39 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_39 << endl;
+  cout << setw(20) <<  "GC_40 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_40 << endl;
+  cout << setw(20) <<  "GC_41 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_41 << endl;
+  cout << setw(20) <<  "GC_42 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_42 << endl;
+  cout << setw(20) <<  "GC_43 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_43 << endl;
+  cout << setw(20) <<  "GC_44 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_44 << endl;
+  cout << setw(20) <<  "GC_45 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_45 << endl;
+  cout << setw(20) <<  "GC_46 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_46 << endl;
+  cout << setw(20) <<  "GC_47 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_47 << endl;
+  cout << setw(20) <<  "GC_48 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_48 << endl;
+  cout << setw(20) <<  "GC_49 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_49 << endl;
+  cout << setw(20) <<  "GC_50 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_50 << endl;
+  cout << setw(20) <<  "GC_51 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_51 << endl;
+  cout << setw(20) <<  "GC_52 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_52 << endl;
+  cout << setw(20) <<  "GC_53 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_53 << endl;
+  cout << setw(20) <<  "GC_54 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_54 << endl;
+  cout << setw(20) <<  "GC_55 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_55 << endl;
+  cout << setw(20) <<  "GC_56 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_56 << endl;
+  cout << setw(20) <<  "GC_57 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_57 << endl;
+  cout << setw(20) <<  "GC_58 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_58 << endl;
+  cout << setw(20) <<  "GC_59 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_59 << endl;
+  cout << setw(20) <<  "GC_60 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_60 << endl;
+  cout << setw(20) <<  "GC_61 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_61 << endl;
+  cout << setw(20) <<  "GC_62 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_62 << endl;
+  cout << setw(20) <<  "GC_63 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_63 << endl;
+  cout << setw(20) <<  "GC_64 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_64 << endl;
+  cout << setw(20) <<  "GC_65 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_65 << endl;
+  cout << setw(20) <<  "GC_66 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_66 << endl;
+  cout << setw(20) <<  "GC_67 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_67 << endl;
+  cout << setw(20) <<  "GC_68 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_68 << endl;
+  cout << setw(20) <<  "GC_69 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_69 << endl;
+  cout << setw(20) <<  "GC_70 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_70 << endl;
+  cout << setw(20) <<  "GC_71 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_71 << endl;
+  cout << setw(20) <<  "GC_72 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_72 << endl;
+  cout << setw(20) <<  "GC_73 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_73 << endl;
+  cout << setw(20) <<  "GC_74 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_74 << endl;
+  cout << setw(20) <<  "GC_75 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_75 << endl;
+  cout << setw(20) <<  "GC_76 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_76 << endl;
+  cout << setw(20) <<  "GC_77 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_77 << endl;
+  cout << setw(20) <<  "GC_78 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_78 << endl;
+  cout << setw(20) <<  "GC_79 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_79 << endl;
+  cout << setw(20) <<  "GC_80 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_80 << endl;
+  cout << setw(20) <<  "GC_81 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_81 << endl;
+  cout << setw(20) <<  "GC_82 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_82 << endl;
+  cout << setw(20) <<  "GC_83 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_83 << endl;
+  cout << setw(20) <<  "GC_84 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_84 << endl;
+  cout << setw(20) <<  "GC_85 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_85 << endl;
+  cout << setw(20) <<  "GC_86 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_86 << endl;
+  cout << setw(20) <<  "GC_87 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_87 << endl;
+  cout << setw(20) <<  "GC_88 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_88 << endl;
+  cout << setw(20) <<  "GC_89 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_89 << endl;
+  cout << setw(20) <<  "GC_90 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_90 << endl;
+  cout << setw(20) <<  "GC_91 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_91 << endl;
+  cout << setw(20) <<  "GC_92 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_92 << endl;
+  cout << setw(20) <<  "GC_93 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_93 << endl;
+  cout << setw(20) <<  "GC_94 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_94 << endl;
+  cout << setw(20) <<  "GC_95 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_95 << endl;
+  cout << setw(20) <<  "GC_96 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_96 << endl;
+  cout << setw(20) <<  "GC_97 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_97 << endl;
+  cout << setw(20) <<  "GC_98 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_98 << endl;
+  cout << setw(20) <<  "GC_99 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_99 << endl;
+  cout << setw(20) <<  "GC_100 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_100 << endl;
+  cout << setw(20) <<  "GC_101 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_101 << endl;
+  cout << setw(20) <<  "GC_102 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_102 << endl;
+}
+void Parameters_MDMSM::printDependentParameters()
+{
+  cout <<  "MDMSM model parameters dependent on event kinematics:" << endl; 
+  cout << setw(20) <<  "aS " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << aS << endl;
+  cout << setw(20) <<  "mdl_sqrt__aS " <<  "= " << setiosflags(ios::scientific)
+      << setw(10) << mdl_sqrt__aS << endl;
+  cout << setw(20) <<  "G " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << G << endl;
+  cout << setw(20) <<  "mdl_G__exp__2 " <<  "= " <<
+      setiosflags(ios::scientific) << setw(10) << mdl_G__exp__2 << endl;
+}
+void Parameters_MDMSM::printDependentCouplings()
+{
+  cout <<  "MDMSM model couplings dependent on event kinematics:" << endl; 
+  cout << setw(20) <<  "GC_15 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_15 << endl;
+  cout << setw(20) <<  "GC_11 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_11 << endl;
+  cout << setw(20) <<  "GC_12 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_12 << endl;
+  cout << setw(20) <<  "GC_16 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_16 << endl;
+  cout << setw(20) <<  "GC_10 " <<  "= " << setiosflags(ios::scientific) <<
+      setw(10) << GC_10 << endl;
+}
+
+
diff -rupN Pythia/src/ProcessContainer.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/ProcessContainer.cc
--- Pythia/src/ProcessContainer.cc	2015-09-24 01:35:08.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/ProcessContainer.cc	2021-03-08 16:53:53.551505493 +1000
@@ -19,6 +19,16 @@
 #include "Pythia8/SigmaNewGaugeBosons.h"
 #include "Pythia8/SigmaQCD.h"
 #include "Pythia8/SigmaSUSY.h"
+#include "Sigma_MDMSM_gd_xchixchid.h"
+#include "Sigma_MDMSM_uux_xchixchig.h"
+#include "Sigma_MDMSM_gs_xchixchis.h"
+#include "Sigma_MDMSM_ddx_xchixchig.h"
+#include "Sigma_MDMSM_gu_xchixchiu.h"
+#include "Sigma_MDMSM_gg_xchixchig.h"
+#include "Sigma_MDMSM_gc_xchixchic.h"
+#include "Sigma_MDMSM_gg_xchixchi.h"
+#include "Sigma_MDMSM_ssx_xchixchig.h"
+#include "Sigma_MDMSM_ccx_xchixchig.h"
 
 namespace Pythia8 {
 
@@ -1923,6 +1933,49 @@ bool SetupContainers::init(vector<Proces
 
   } // End of SUSY processes.
 
+  // Set up requested objects for MDMSM processes. Added by GAMBIT.
+  bool MDMSM = settings.flag("MDMSM:all");
+  if (MDMSM || settings.flag("MDMSM:gd2xchixchid")) {
+    sigmaPtr = new Sigma_MDMSM_gd_xchixchid();
+    containerPtrs.push_back( new ProcessContainer(sigmaPtr) );
+  }
+  if (MDMSM || settings.flag("MDMSM:uux2xchixchig")) {
+    sigmaPtr = new Sigma_MDMSM_uux_xchixchig();
+    containerPtrs.push_back( new ProcessContainer(sigmaPtr) );
+  }
+  if (MDMSM || settings.flag("MDMSM:gs2xchixchis")) {
+    sigmaPtr = new Sigma_MDMSM_gs_xchixchis();
+    containerPtrs.push_back( new ProcessContainer(sigmaPtr) );
+  }
+  if (MDMSM || settings.flag("MDMSM:ddx2xchixchig")) {
+    sigmaPtr = new Sigma_MDMSM_ddx_xchixchig();
+    containerPtrs.push_back( new ProcessContainer(sigmaPtr) );
+  }
+  if (MDMSM || settings.flag("MDMSM:gu2xchixchiu")) {
+    sigmaPtr = new Sigma_MDMSM_gu_xchixchiu();
+    containerPtrs.push_back( new ProcessContainer(sigmaPtr) );
+  }
+  if (MDMSM || settings.flag("MDMSM:gg2xchixchig")) {
+    sigmaPtr = new Sigma_MDMSM_gg_xchixchig();
+    containerPtrs.push_back( new ProcessContainer(sigmaPtr) );
+  }
+  if (MDMSM || settings.flag("MDMSM:gc2xchixchic")) {
+    sigmaPtr = new Sigma_MDMSM_gc_xchixchic();
+    containerPtrs.push_back( new ProcessContainer(sigmaPtr) );
+  }
+  if (MDMSM || settings.flag("MDMSM:gg2xchixchi")) {
+    sigmaPtr = new Sigma_MDMSM_gg_xchixchi();
+    containerPtrs.push_back( new ProcessContainer(sigmaPtr) );
+  }
+  if (MDMSM || settings.flag("MDMSM:ssx2xchixchig")) {
+    sigmaPtr = new Sigma_MDMSM_ssx_xchixchig();
+    containerPtrs.push_back( new ProcessContainer(sigmaPtr) );
+  }
+  if (MDMSM || settings.flag("MDMSM:ccx2xchixchig")) {
+    sigmaPtr = new Sigma_MDMSM_ccx_xchixchig();
+    containerPtrs.push_back( new ProcessContainer(sigmaPtr) );
+  }
+
   // Set up requested objects for New-Gauge-Boson processes.
   if (settings.flag("NewGaugeBoson:ffbar2gmZZprime")) {
     sigmaPtr = new Sigma1ffbar2gmZZprime();
diff -rupN Pythia/src/Sigma_MDMSM_ccx_xchixchig.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_ccx_xchixchig.cc
--- Pythia/src/Sigma_MDMSM_ccx_xchixchig.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_ccx_xchixchig.cc	2021-03-08 16:53:44.411004458 +1000
@@ -0,0 +1,328 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "Sigma_MDMSM_ccx_xchixchig.h"
+#include "HelAmps_MDMSM.h"
+
+using namespace Pythia8_MDMSM; 
+
+namespace Pythia8 
+{
+
+//==========================================================================
+// Class member functions for calculating the matrix elements for
+// Process: c c~ > ~chi ~chi g NP<=2 WEIGHTED<=3 @2
+
+//--------------------------------------------------------------------------
+// Initialize process.
+
+void Sigma_MDMSM_ccx_xchixchig::initProc() 
+{
+  // Instantiate the model class and set parameters that stay fixed during run
+  pars = Parameters_MDMSM::getInstance(); 
+  pars->setIndependentParameters(particleDataPtr, couplingsPtr, slhaPtr); 
+  pars->setIndependentCouplings(); 
+  // Set massive/massless matrix elements for c/b/mu/tau
+  mcME = particleDataPtr->m0(4); 
+  mbME = particleDataPtr->m0(5); 
+  mmuME = particleDataPtr->m0(13); 
+  mtauME = particleDataPtr->m0(15); 
+  jamp2[0] = new double[1]; 
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, part independent of incoming flavour.
+
+void Sigma_MDMSM_ccx_xchixchig::sigmaKin() 
+{
+  // Set the parameters which change event by event
+  pars->setDependentParameters(particleDataPtr, couplingsPtr, slhaPtr, alpS); 
+  pars->setDependentCouplings(); 
+  // Reset color flows
+  for(int i = 0; i < 1; i++ )
+    jamp2[0][i] = 0.; 
+
+  // Local variables and constants
+  const int ncomb = 32; 
+  static bool goodhel[ncomb] = {ncomb * false}; 
+  static int ntry = 0, sum_hel = 0, ngood = 0; 
+  static int igood[ncomb]; 
+  static int jhel; 
+  double t[nprocesses]; 
+  // Helicities for the process
+  static const int helicities[ncomb][nexternal] = {{-1, -1, -1, -1, -1}, {-1,
+      -1, -1, -1, 1}, {-1, -1, -1, 1, -1}, {-1, -1, -1, 1, 1}, {-1, -1, 1, -1,
+      -1}, {-1, -1, 1, -1, 1}, {-1, -1, 1, 1, -1}, {-1, -1, 1, 1, 1}, {-1, 1,
+      -1, -1, -1}, {-1, 1, -1, -1, 1}, {-1, 1, -1, 1, -1}, {-1, 1, -1, 1, 1},
+      {-1, 1, 1, -1, -1}, {-1, 1, 1, -1, 1}, {-1, 1, 1, 1, -1}, {-1, 1, 1, 1,
+      1}, {1, -1, -1, -1, -1}, {1, -1, -1, -1, 1}, {1, -1, -1, 1, -1}, {1, -1,
+      -1, 1, 1}, {1, -1, 1, -1, -1}, {1, -1, 1, -1, 1}, {1, -1, 1, 1, -1}, {1,
+      -1, 1, 1, 1}, {1, 1, -1, -1, -1}, {1, 1, -1, -1, 1}, {1, 1, -1, 1, -1},
+      {1, 1, -1, 1, 1}, {1, 1, 1, -1, -1}, {1, 1, 1, -1, 1}, {1, 1, 1, 1, -1},
+      {1, 1, 1, 1, 1}};
+  // Denominators: spins, colors and identical particles
+  const int denominators[nprocesses] = {72, 72}; 
+
+  ntry = ntry + 1; 
+
+  // Reset the matrix elements
+  for(int i = 0; i < nprocesses; i++ )
+  {
+    matrix_element[i] = 0.; 
+    t[i] = 0.; 
+  }
+
+  // Define permutation
+  int perm[nexternal]; 
+  for(int i = 0; i < nexternal; i++ )
+  {
+    perm[i] = i; 
+  }
+
+  // For now, call setupForME() here
+  id1 = 4; 
+  id2 = -4; 
+  if( !setupForME())
+  {
+    return; 
+  }
+
+  if (sum_hel == 0 || ntry < 10)
+  {
+    // Calculate the matrix element for all helicities
+    for(int ihel = 0; ihel < ncomb; ihel++ )
+    {
+      if (goodhel[ihel] || ntry < 2)
+      {
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        t[0] = matrix_2_ccx_xchixchig(); 
+        // Mirror initial state momenta for mirror process
+        perm[0] = 1; 
+        perm[1] = 0; 
+        // Calculate wavefunctions
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        // Mirror back
+        perm[0] = 0; 
+        perm[1] = 1; 
+        // Calculate matrix elements
+        t[1] = matrix_2_ccx_xchixchig(); 
+        double tsum = 0; 
+        for(int iproc = 0; iproc < nprocesses; iproc++ )
+        {
+          matrix_element[iproc] += t[iproc]; 
+          tsum += t[iproc]; 
+        }
+        // Store which helicities give non-zero result
+        if (tsum != 0. && !goodhel[ihel])
+        {
+          goodhel[ihel] = true; 
+          ngood++; 
+          igood[ngood] = ihel; 
+        }
+      }
+    }
+    jhel = 0; 
+    sum_hel = min(sum_hel, ngood); 
+  }
+  else
+  {
+    // Only use the "good" helicities
+    for(int j = 0; j < sum_hel; j++ )
+    {
+      jhel++; 
+      if (jhel >= ngood)
+        jhel = 0; 
+      double hwgt = double(ngood)/double(sum_hel); 
+      int ihel = igood[jhel]; 
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      t[0] = matrix_2_ccx_xchixchig(); 
+      // Mirror initial state momenta for mirror process
+      perm[0] = 1; 
+      perm[1] = 0; 
+      // Calculate wavefunctions
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      // Mirror back
+      perm[0] = 0; 
+      perm[1] = 1; 
+      // Calculate matrix elements
+      t[1] = matrix_2_ccx_xchixchig(); 
+      for(int iproc = 0; iproc < nprocesses; iproc++ )
+      {
+        matrix_element[iproc] += t[iproc] * hwgt; 
+      }
+    }
+  }
+
+  for (int i = 0; i < nprocesses; i++ )
+    matrix_element[i] /= denominators[i]; 
+
+
+
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, including incoming flavour dependence.
+
+double Sigma_MDMSM_ccx_xchixchig::sigmaHat() 
+{
+  // Select between the different processes
+  if(id1 == -4 && id2 == 4)
+  {
+    // Add matrix elements for processes with beams (-4, 4)
+    return matrix_element[1]; 
+  }
+  else if(id1 == 4 && id2 == -4)
+  {
+    // Add matrix elements for processes with beams (4, -4)
+    return matrix_element[0]; 
+  }
+  else
+  {
+    // Return 0 if not correct initial state assignment
+    return 0.; 
+  }
+}
+
+//--------------------------------------------------------------------------
+// Select identity, colour and anticolour.
+
+void Sigma_MDMSM_ccx_xchixchig::setIdColAcol() 
+{
+  if(id1 == -4 && id2 == 4)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, 21}}; 
+    vector<double> probs; 
+    double sum = matrix_element[1]; 
+    probs.push_back(matrix_element[1]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 4 && id2 == -4)
+  {
+    // Pick one of the flavor combinations (52, 52, 21)
+    int flavors[1][3] = {{52, 52, 21}}; 
+    vector<double> probs; 
+    double sum = matrix_element[0]; 
+    probs.push_back(matrix_element[0]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  setId(id1, id2, id3, id4, id5); 
+  // Pick color flow
+  int ncolor[1] = {1}; 
+  if((id1 == 4 && id2 == -4 && id3 == 52 && id4 == 52 && id5 == 21))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{2, 0, 0, 1, 0, 0, 0, 0, 2, 1}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == -4 && id2 == 4 && id3 == 52 && id4 == 52 && id5 == 21))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{0, 1, 2, 0, 0, 0, 0, 0, 2, 1}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+}
+
+//--------------------------------------------------------------------------
+// Evaluate weight for angles of decay products in process
+
+double Sigma_MDMSM_ccx_xchixchig::weightDecay(Event& process, int iResBeg, int
+    iResEnd)
+{
+  // Just use isotropic decay (default)
+  return 1.; 
+}
+
+//==========================================================================
+// Private class member functions
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2 for each subprocess
+
+void Sigma_MDMSM_ccx_xchixchig::calculate_wavefunctions(const int perm[], const
+    int hel[])
+{
+  // Calculate wavefunctions for all processes
+  double p[nexternal][4]; 
+  int i; 
+
+  // Convert Pythia 4-vectors to double[]
+  for(i = 0; i < nexternal; i++ )
+  {
+    p[i][0] = pME[i].e(); 
+    p[i][1] = pME[i].px(); 
+    p[i][2] = pME[i].py(); 
+    p[i][3] = pME[i].pz(); 
+  }
+
+  // Calculate all wavefunctions
+  ixxxxx(p[perm[0]], mME[0], hel[0], +1, w[0]); 
+  oxxxxx(p[perm[1]], mME[1], hel[1], -1, w[1]); 
+  ixxxxx(p[perm[2]], mME[2], hel[2], -1, w[2]); 
+  oxxxxx(p[perm[3]], mME[3], hel[3], +1, w[3]); 
+  vxxxxx(p[perm[4]], mME[4], hel[4], +1, w[4]); 
+  FFV1P0_3(w[0], w[1], pars->GC_11, pars->ZERO, pars->ZERO, w[5]); 
+  FFS1_3(w[2], w[3], pars->GC_13, pars->mdl_mY, pars->mdl_wY, w[6]); 
+
+  // Calculate all amplitudes
+  // Amplitude(s) for diagram number 0
+  VVS2_0(w[4], w[5], w[6], pars->GC_14, amp[0]); 
+
+
+}
+double Sigma_MDMSM_ccx_xchixchig::matrix_2_ccx_xchixchig() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = +amp[0]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+
+}  // end namespace Pythia8
diff -rupN Pythia/src/Sigma_MDMSM_ddx_xchixchig.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_ddx_xchixchig.cc
--- Pythia/src/Sigma_MDMSM_ddx_xchixchig.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_ddx_xchixchig.cc	2021-03-08 16:53:44.463007314 +1000
@@ -0,0 +1,328 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "Sigma_MDMSM_ddx_xchixchig.h"
+#include "HelAmps_MDMSM.h"
+
+using namespace Pythia8_MDMSM; 
+
+namespace Pythia8 
+{
+
+//==========================================================================
+// Class member functions for calculating the matrix elements for
+// Process: d d~ > ~chi ~chi g NP<=2 WEIGHTED<=3 @2
+
+//--------------------------------------------------------------------------
+// Initialize process.
+
+void Sigma_MDMSM_ddx_xchixchig::initProc() 
+{
+  // Instantiate the model class and set parameters that stay fixed during run
+  pars = Parameters_MDMSM::getInstance(); 
+  pars->setIndependentParameters(particleDataPtr, couplingsPtr, slhaPtr); 
+  pars->setIndependentCouplings(); 
+  // Set massive/massless matrix elements for c/b/mu/tau
+  mcME = particleDataPtr->m0(4); 
+  mbME = particleDataPtr->m0(5); 
+  mmuME = particleDataPtr->m0(13); 
+  mtauME = particleDataPtr->m0(15); 
+  jamp2[0] = new double[1]; 
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, part independent of incoming flavour.
+
+void Sigma_MDMSM_ddx_xchixchig::sigmaKin() 
+{
+  // Set the parameters which change event by event
+  pars->setDependentParameters(particleDataPtr, couplingsPtr, slhaPtr, alpS); 
+  pars->setDependentCouplings(); 
+  // Reset color flows
+  for(int i = 0; i < 1; i++ )
+    jamp2[0][i] = 0.; 
+
+  // Local variables and constants
+  const int ncomb = 32; 
+  static bool goodhel[ncomb] = {ncomb * false}; 
+  static int ntry = 0, sum_hel = 0, ngood = 0; 
+  static int igood[ncomb]; 
+  static int jhel; 
+  double t[nprocesses]; 
+  // Helicities for the process
+  static const int helicities[ncomb][nexternal] = {{-1, -1, -1, -1, -1}, {-1,
+      -1, -1, -1, 1}, {-1, -1, -1, 1, -1}, {-1, -1, -1, 1, 1}, {-1, -1, 1, -1,
+      -1}, {-1, -1, 1, -1, 1}, {-1, -1, 1, 1, -1}, {-1, -1, 1, 1, 1}, {-1, 1,
+      -1, -1, -1}, {-1, 1, -1, -1, 1}, {-1, 1, -1, 1, -1}, {-1, 1, -1, 1, 1},
+      {-1, 1, 1, -1, -1}, {-1, 1, 1, -1, 1}, {-1, 1, 1, 1, -1}, {-1, 1, 1, 1,
+      1}, {1, -1, -1, -1, -1}, {1, -1, -1, -1, 1}, {1, -1, -1, 1, -1}, {1, -1,
+      -1, 1, 1}, {1, -1, 1, -1, -1}, {1, -1, 1, -1, 1}, {1, -1, 1, 1, -1}, {1,
+      -1, 1, 1, 1}, {1, 1, -1, -1, -1}, {1, 1, -1, -1, 1}, {1, 1, -1, 1, -1},
+      {1, 1, -1, 1, 1}, {1, 1, 1, -1, -1}, {1, 1, 1, -1, 1}, {1, 1, 1, 1, -1},
+      {1, 1, 1, 1, 1}};
+  // Denominators: spins, colors and identical particles
+  const int denominators[nprocesses] = {72, 72}; 
+
+  ntry = ntry + 1; 
+
+  // Reset the matrix elements
+  for(int i = 0; i < nprocesses; i++ )
+  {
+    matrix_element[i] = 0.; 
+    t[i] = 0.; 
+  }
+
+  // Define permutation
+  int perm[nexternal]; 
+  for(int i = 0; i < nexternal; i++ )
+  {
+    perm[i] = i; 
+  }
+
+  // For now, call setupForME() here
+  id1 = 1; 
+  id2 = -1; 
+  if( !setupForME())
+  {
+    return; 
+  }
+
+  if (sum_hel == 0 || ntry < 10)
+  {
+    // Calculate the matrix element for all helicities
+    for(int ihel = 0; ihel < ncomb; ihel++ )
+    {
+      if (goodhel[ihel] || ntry < 2)
+      {
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        t[0] = matrix_2_ddx_xchixchig(); 
+        // Mirror initial state momenta for mirror process
+        perm[0] = 1; 
+        perm[1] = 0; 
+        // Calculate wavefunctions
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        // Mirror back
+        perm[0] = 0; 
+        perm[1] = 1; 
+        // Calculate matrix elements
+        t[1] = matrix_2_ddx_xchixchig(); 
+        double tsum = 0; 
+        for(int iproc = 0; iproc < nprocesses; iproc++ )
+        {
+          matrix_element[iproc] += t[iproc]; 
+          tsum += t[iproc]; 
+        }
+        // Store which helicities give non-zero result
+        if (tsum != 0. && !goodhel[ihel])
+        {
+          goodhel[ihel] = true; 
+          ngood++; 
+          igood[ngood] = ihel; 
+        }
+      }
+    }
+    jhel = 0; 
+    sum_hel = min(sum_hel, ngood); 
+  }
+  else
+  {
+    // Only use the "good" helicities
+    for(int j = 0; j < sum_hel; j++ )
+    {
+      jhel++; 
+      if (jhel >= ngood)
+        jhel = 0; 
+      double hwgt = double(ngood)/double(sum_hel); 
+      int ihel = igood[jhel]; 
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      t[0] = matrix_2_ddx_xchixchig(); 
+      // Mirror initial state momenta for mirror process
+      perm[0] = 1; 
+      perm[1] = 0; 
+      // Calculate wavefunctions
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      // Mirror back
+      perm[0] = 0; 
+      perm[1] = 1; 
+      // Calculate matrix elements
+      t[1] = matrix_2_ddx_xchixchig(); 
+      for(int iproc = 0; iproc < nprocesses; iproc++ )
+      {
+        matrix_element[iproc] += t[iproc] * hwgt; 
+      }
+    }
+  }
+
+  for (int i = 0; i < nprocesses; i++ )
+    matrix_element[i] /= denominators[i]; 
+
+
+
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, including incoming flavour dependence.
+
+double Sigma_MDMSM_ddx_xchixchig::sigmaHat() 
+{
+  // Select between the different processes
+  if(id1 == -1 && id2 == 1)
+  {
+    // Add matrix elements for processes with beams (-1, 1)
+    return matrix_element[1]; 
+  }
+  else if(id1 == 1 && id2 == -1)
+  {
+    // Add matrix elements for processes with beams (1, -1)
+    return matrix_element[0]; 
+  }
+  else
+  {
+    // Return 0 if not correct initial state assignment
+    return 0.; 
+  }
+}
+
+//--------------------------------------------------------------------------
+// Select identity, colour and anticolour.
+
+void Sigma_MDMSM_ddx_xchixchig::setIdColAcol() 
+{
+  if(id1 == -1 && id2 == 1)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, 21}}; 
+    vector<double> probs; 
+    double sum = matrix_element[1]; 
+    probs.push_back(matrix_element[1]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 1 && id2 == -1)
+  {
+    // Pick one of the flavor combinations (52, 52, 21)
+    int flavors[1][3] = {{52, 52, 21}}; 
+    vector<double> probs; 
+    double sum = matrix_element[0]; 
+    probs.push_back(matrix_element[0]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  setId(id1, id2, id3, id4, id5); 
+  // Pick color flow
+  int ncolor[1] = {1}; 
+  if((id1 == 1 && id2 == -1 && id3 == 52 && id4 == 52 && id5 == 21))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{2, 0, 0, 1, 0, 0, 0, 0, 2, 1}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == -1 && id2 == 1 && id3 == 52 && id4 == 52 && id5 == 21))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{0, 1, 2, 0, 0, 0, 0, 0, 2, 1}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+}
+
+//--------------------------------------------------------------------------
+// Evaluate weight for angles of decay products in process
+
+double Sigma_MDMSM_ddx_xchixchig::weightDecay(Event& process, int iResBeg, int
+    iResEnd)
+{
+  // Just use isotropic decay (default)
+  return 1.; 
+}
+
+//==========================================================================
+// Private class member functions
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2 for each subprocess
+
+void Sigma_MDMSM_ddx_xchixchig::calculate_wavefunctions(const int perm[], const
+    int hel[])
+{
+  // Calculate wavefunctions for all processes
+  double p[nexternal][4]; 
+  int i; 
+
+  // Convert Pythia 4-vectors to double[]
+  for(i = 0; i < nexternal; i++ )
+  {
+    p[i][0] = pME[i].e(); 
+    p[i][1] = pME[i].px(); 
+    p[i][2] = pME[i].py(); 
+    p[i][3] = pME[i].pz(); 
+  }
+
+  // Calculate all wavefunctions
+  ixxxxx(p[perm[0]], mME[0], hel[0], +1, w[0]); 
+  oxxxxx(p[perm[1]], mME[1], hel[1], -1, w[1]); 
+  ixxxxx(p[perm[2]], mME[2], hel[2], -1, w[2]); 
+  oxxxxx(p[perm[3]], mME[3], hel[3], +1, w[3]); 
+  vxxxxx(p[perm[4]], mME[4], hel[4], +1, w[4]); 
+  FFV1P0_3(w[0], w[1], pars->GC_11, pars->ZERO, pars->ZERO, w[5]); 
+  FFS1_3(w[2], w[3], pars->GC_13, pars->mdl_mY, pars->mdl_wY, w[6]); 
+
+  // Calculate all amplitudes
+  // Amplitude(s) for diagram number 0
+  VVS2_0(w[4], w[5], w[6], pars->GC_14, amp[0]); 
+
+
+}
+double Sigma_MDMSM_ddx_xchixchig::matrix_2_ddx_xchixchig() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = +amp[0]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+
+}  // end namespace Pythia8
diff -rupN Pythia/src/Sigma_MDMSM_gc_xchixchic.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gc_xchixchic.cc
--- Pythia/src/Sigma_MDMSM_gc_xchixchic.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gc_xchixchic.cc	2021-03-08 16:53:44.158990622 +1000
@@ -0,0 +1,430 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "Sigma_MDMSM_gc_xchixchic.h"
+#include "HelAmps_MDMSM.h"
+
+using namespace Pythia8_MDMSM; 
+
+namespace Pythia8 
+{
+
+//==========================================================================
+// Class member functions for calculating the matrix elements for
+// Process: g c > ~chi ~chi c NP<=2 WEIGHTED<=3 @2
+// Process: g c~ > ~chi ~chi c~ NP<=2 WEIGHTED<=3 @2
+
+//--------------------------------------------------------------------------
+// Initialize process.
+
+void Sigma_MDMSM_gc_xchixchic::initProc() 
+{
+  // Instantiate the model class and set parameters that stay fixed during run
+  pars = Parameters_MDMSM::getInstance(); 
+  pars->setIndependentParameters(particleDataPtr, couplingsPtr, slhaPtr); 
+  pars->setIndependentCouplings(); 
+  // Set massive/massless matrix elements for c/b/mu/tau
+  mcME = particleDataPtr->m0(4); 
+  mbME = particleDataPtr->m0(5); 
+  mmuME = particleDataPtr->m0(13); 
+  mtauME = particleDataPtr->m0(15); 
+  jamp2[0] = new double[1]; 
+  jamp2[1] = new double[1]; 
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, part independent of incoming flavour.
+
+void Sigma_MDMSM_gc_xchixchic::sigmaKin() 
+{
+  // Set the parameters which change event by event
+  pars->setDependentParameters(particleDataPtr, couplingsPtr, slhaPtr, alpS); 
+  pars->setDependentCouplings(); 
+  // Reset color flows
+  for(int i = 0; i < 1; i++ )
+    jamp2[0][i] = 0.; 
+  for(int i = 0; i < 1; i++ )
+    jamp2[1][i] = 0.; 
+
+  // Local variables and constants
+  const int ncomb = 32; 
+  static bool goodhel[ncomb] = {ncomb * false}; 
+  static int ntry = 0, sum_hel = 0, ngood = 0; 
+  static int igood[ncomb]; 
+  static int jhel; 
+  double t[nprocesses]; 
+  // Helicities for the process
+  static const int helicities[ncomb][nexternal] = {{-1, -1, -1, -1, -1}, {-1,
+      -1, -1, -1, 1}, {-1, -1, -1, 1, -1}, {-1, -1, -1, 1, 1}, {-1, -1, 1, -1,
+      -1}, {-1, -1, 1, -1, 1}, {-1, -1, 1, 1, -1}, {-1, -1, 1, 1, 1}, {-1, 1,
+      -1, -1, -1}, {-1, 1, -1, -1, 1}, {-1, 1, -1, 1, -1}, {-1, 1, -1, 1, 1},
+      {-1, 1, 1, -1, -1}, {-1, 1, 1, -1, 1}, {-1, 1, 1, 1, -1}, {-1, 1, 1, 1,
+      1}, {1, -1, -1, -1, -1}, {1, -1, -1, -1, 1}, {1, -1, -1, 1, -1}, {1, -1,
+      -1, 1, 1}, {1, -1, 1, -1, -1}, {1, -1, 1, -1, 1}, {1, -1, 1, 1, -1}, {1,
+      -1, 1, 1, 1}, {1, 1, -1, -1, -1}, {1, 1, -1, -1, 1}, {1, 1, -1, 1, -1},
+      {1, 1, -1, 1, 1}, {1, 1, 1, -1, -1}, {1, 1, 1, -1, 1}, {1, 1, 1, 1, -1},
+      {1, 1, 1, 1, 1}};
+  // Denominators: spins, colors and identical particles
+  const int denominators[nprocesses] = {192, 192, 192, 192}; 
+
+  ntry = ntry + 1; 
+
+  // Reset the matrix elements
+  for(int i = 0; i < nprocesses; i++ )
+  {
+    matrix_element[i] = 0.; 
+    t[i] = 0.; 
+  }
+
+  // Define permutation
+  int perm[nexternal]; 
+  for(int i = 0; i < nexternal; i++ )
+  {
+    perm[i] = i; 
+  }
+
+  // For now, call setupForME() here
+  id1 = 21; 
+  id2 = 4; 
+  if( !setupForME())
+  {
+    return; 
+  }
+
+  if (sum_hel == 0 || ntry < 10)
+  {
+    // Calculate the matrix element for all helicities
+    for(int ihel = 0; ihel < ncomb; ihel++ )
+    {
+      if (goodhel[ihel] || ntry < 2)
+      {
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        t[0] = matrix_2_gc_xchixchic(); 
+        t[1] = matrix_2_gcx_xchixchicx(); 
+        // Mirror initial state momenta for mirror process
+        perm[0] = 1; 
+        perm[1] = 0; 
+        // Calculate wavefunctions
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        // Mirror back
+        perm[0] = 0; 
+        perm[1] = 1; 
+        // Calculate matrix elements
+        t[2] = matrix_2_gc_xchixchic(); 
+        t[3] = matrix_2_gcx_xchixchicx(); 
+        double tsum = 0; 
+        for(int iproc = 0; iproc < nprocesses; iproc++ )
+        {
+          matrix_element[iproc] += t[iproc]; 
+          tsum += t[iproc]; 
+        }
+        // Store which helicities give non-zero result
+        if (tsum != 0. && !goodhel[ihel])
+        {
+          goodhel[ihel] = true; 
+          ngood++; 
+          igood[ngood] = ihel; 
+        }
+      }
+    }
+    jhel = 0; 
+    sum_hel = min(sum_hel, ngood); 
+  }
+  else
+  {
+    // Only use the "good" helicities
+    for(int j = 0; j < sum_hel; j++ )
+    {
+      jhel++; 
+      if (jhel >= ngood)
+        jhel = 0; 
+      double hwgt = double(ngood)/double(sum_hel); 
+      int ihel = igood[jhel]; 
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      t[0] = matrix_2_gc_xchixchic(); 
+      t[1] = matrix_2_gcx_xchixchicx(); 
+      // Mirror initial state momenta for mirror process
+      perm[0] = 1; 
+      perm[1] = 0; 
+      // Calculate wavefunctions
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      // Mirror back
+      perm[0] = 0; 
+      perm[1] = 1; 
+      // Calculate matrix elements
+      t[2] = matrix_2_gc_xchixchic(); 
+      t[3] = matrix_2_gcx_xchixchicx(); 
+      for(int iproc = 0; iproc < nprocesses; iproc++ )
+      {
+        matrix_element[iproc] += t[iproc] * hwgt; 
+      }
+    }
+  }
+
+  for (int i = 0; i < nprocesses; i++ )
+    matrix_element[i] /= denominators[i]; 
+
+
+
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, including incoming flavour dependence.
+
+double Sigma_MDMSM_gc_xchixchic::sigmaHat() 
+{
+  // Select between the different processes
+  if(id1 == -4 && id2 == 21)
+  {
+    // Add matrix elements for processes with beams (-4, 21)
+    return matrix_element[3]; 
+  }
+  else if(id1 == 4 && id2 == 21)
+  {
+    // Add matrix elements for processes with beams (4, 21)
+    return matrix_element[2]; 
+  }
+  else if(id1 == 21 && id2 == -4)
+  {
+    // Add matrix elements for processes with beams (21, -4)
+    return matrix_element[1]; 
+  }
+  else if(id1 == 21 && id2 == 4)
+  {
+    // Add matrix elements for processes with beams (21, 4)
+    return matrix_element[0]; 
+  }
+  else
+  {
+    // Return 0 if not correct initial state assignment
+    return 0.; 
+  }
+}
+
+//--------------------------------------------------------------------------
+// Select identity, colour and anticolour.
+
+void Sigma_MDMSM_gc_xchixchic::setIdColAcol() 
+{
+  if(id1 == -4 && id2 == 21)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, -4}}; 
+    vector<double> probs; 
+    double sum = matrix_element[3]; 
+    probs.push_back(matrix_element[3]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 4 && id2 == 21)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, 4}}; 
+    vector<double> probs; 
+    double sum = matrix_element[2]; 
+    probs.push_back(matrix_element[2]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 21 && id2 == -4)
+  {
+    // Pick one of the flavor combinations (52, 52, -4)
+    int flavors[1][3] = {{52, 52, -4}}; 
+    vector<double> probs; 
+    double sum = matrix_element[1]; 
+    probs.push_back(matrix_element[1]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 21 && id2 == 4)
+  {
+    // Pick one of the flavor combinations (52, 52, 4)
+    int flavors[1][3] = {{52, 52, 4}}; 
+    vector<double> probs; 
+    double sum = matrix_element[0]; 
+    probs.push_back(matrix_element[0]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  setId(id1, id2, id3, id4, id5); 
+  // Pick color flow
+  int ncolor[2] = {1, 1}; 
+  if((id1 == 21 && id2 == 4 && id3 == 52 && id4 == 52 && id5 == 4))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{1, 2, 2, 0, 0, 0, 0, 0, 1, 0}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == 21 && id2 == -4 && id3 == 52 && id4 == 52 && id5 == -4))
+  {
+    vector<double> probs; 
+    double sum = jamp2[1][0]; 
+    for(int i = 0; i < ncolor[1]; i++ )
+      probs.push_back(jamp2[1][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{1, 2, 0, 1, 0, 0, 0, 0, 0, 2}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == 4 && id2 == 21 && id3 == 52 && id4 == 52 && id5 == 4))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{2, 0, 1, 2, 0, 0, 0, 0, 1, 0}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == -4 && id2 == 21 && id3 == 52 && id4 == 52 && id5 == -4))
+  {
+    vector<double> probs; 
+    double sum = jamp2[1][0]; 
+    for(int i = 0; i < ncolor[1]; i++ )
+      probs.push_back(jamp2[1][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{0, 1, 1, 2, 0, 0, 0, 0, 0, 2}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+}
+
+//--------------------------------------------------------------------------
+// Evaluate weight for angles of decay products in process
+
+double Sigma_MDMSM_gc_xchixchic::weightDecay(Event& process, int iResBeg, int
+    iResEnd)
+{
+  // Just use isotropic decay (default)
+  return 1.; 
+}
+
+//==========================================================================
+// Private class member functions
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2 for each subprocess
+
+void Sigma_MDMSM_gc_xchixchic::calculate_wavefunctions(const int perm[], const
+    int hel[])
+{
+  // Calculate wavefunctions for all processes
+  double p[nexternal][4]; 
+  int i; 
+
+  // Convert Pythia 4-vectors to double[]
+  for(i = 0; i < nexternal; i++ )
+  {
+    p[i][0] = pME[i].e(); 
+    p[i][1] = pME[i].px(); 
+    p[i][2] = pME[i].py(); 
+    p[i][3] = pME[i].pz(); 
+  }
+
+  // Calculate all wavefunctions
+  vxxxxx(p[perm[0]], mME[0], hel[0], -1, w[0]); 
+  ixxxxx(p[perm[1]], mME[1], hel[1], +1, w[1]); 
+  ixxxxx(p[perm[2]], mME[2], hel[2], -1, w[2]); 
+  oxxxxx(p[perm[3]], mME[3], hel[3], +1, w[3]); 
+  oxxxxx(p[perm[4]], mME[4], hel[4], +1, w[4]); 
+  FFV1P0_3(w[1], w[4], pars->GC_11, pars->ZERO, pars->ZERO, w[5]); 
+  FFS1_3(w[2], w[3], pars->GC_13, pars->mdl_mY, pars->mdl_wY, w[6]); 
+  oxxxxx(p[perm[1]], mME[1], hel[1], -1, w[7]); 
+  ixxxxx(p[perm[4]], mME[4], hel[4], -1, w[8]); 
+  FFV1P0_3(w[8], w[7], pars->GC_11, pars->ZERO, pars->ZERO, w[9]); 
+
+  // Calculate all amplitudes
+  // Amplitude(s) for diagram number 0
+  VVS2_0(w[0], w[5], w[6], pars->GC_14, amp[0]); 
+  VVS2_0(w[0], w[9], w[6], pars->GC_14, amp[1]); 
+
+
+}
+double Sigma_MDMSM_gc_xchixchic::matrix_2_gc_xchixchic() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = +amp[0]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+double Sigma_MDMSM_gc_xchixchic::matrix_2_gcx_xchixchicx() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = -amp[1]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[1][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+
+}  // end namespace Pythia8
diff -rupN Pythia/src/Sigma_MDMSM_gd_xchixchid.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gd_xchixchid.cc
--- Pythia/src/Sigma_MDMSM_gd_xchixchid.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gd_xchixchid.cc	2021-03-08 16:53:44.238995014 +1000
@@ -0,0 +1,430 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "Sigma_MDMSM_gd_xchixchid.h"
+#include "HelAmps_MDMSM.h"
+
+using namespace Pythia8_MDMSM; 
+
+namespace Pythia8 
+{
+
+//==========================================================================
+// Class member functions for calculating the matrix elements for
+// Process: g d > ~chi ~chi d NP<=2 WEIGHTED<=3 @2
+// Process: g d~ > ~chi ~chi d~ NP<=2 WEIGHTED<=3 @2
+
+//--------------------------------------------------------------------------
+// Initialize process.
+
+void Sigma_MDMSM_gd_xchixchid::initProc() 
+{
+  // Instantiate the model class and set parameters that stay fixed during run
+  pars = Parameters_MDMSM::getInstance(); 
+  pars->setIndependentParameters(particleDataPtr, couplingsPtr, slhaPtr); 
+  pars->setIndependentCouplings(); 
+  // Set massive/massless matrix elements for c/b/mu/tau
+  mcME = particleDataPtr->m0(4); 
+  mbME = particleDataPtr->m0(5); 
+  mmuME = particleDataPtr->m0(13); 
+  mtauME = particleDataPtr->m0(15); 
+  jamp2[0] = new double[1]; 
+  jamp2[1] = new double[1]; 
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, part independent of incoming flavour.
+
+void Sigma_MDMSM_gd_xchixchid::sigmaKin() 
+{
+  // Set the parameters which change event by event
+  pars->setDependentParameters(particleDataPtr, couplingsPtr, slhaPtr, alpS); 
+  pars->setDependentCouplings(); 
+  // Reset color flows
+  for(int i = 0; i < 1; i++ )
+    jamp2[0][i] = 0.; 
+  for(int i = 0; i < 1; i++ )
+    jamp2[1][i] = 0.; 
+
+  // Local variables and constants
+  const int ncomb = 32; 
+  static bool goodhel[ncomb] = {ncomb * false}; 
+  static int ntry = 0, sum_hel = 0, ngood = 0; 
+  static int igood[ncomb]; 
+  static int jhel; 
+  double t[nprocesses]; 
+  // Helicities for the process
+  static const int helicities[ncomb][nexternal] = {{-1, -1, -1, -1, -1}, {-1,
+      -1, -1, -1, 1}, {-1, -1, -1, 1, -1}, {-1, -1, -1, 1, 1}, {-1, -1, 1, -1,
+      -1}, {-1, -1, 1, -1, 1}, {-1, -1, 1, 1, -1}, {-1, -1, 1, 1, 1}, {-1, 1,
+      -1, -1, -1}, {-1, 1, -1, -1, 1}, {-1, 1, -1, 1, -1}, {-1, 1, -1, 1, 1},
+      {-1, 1, 1, -1, -1}, {-1, 1, 1, -1, 1}, {-1, 1, 1, 1, -1}, {-1, 1, 1, 1,
+      1}, {1, -1, -1, -1, -1}, {1, -1, -1, -1, 1}, {1, -1, -1, 1, -1}, {1, -1,
+      -1, 1, 1}, {1, -1, 1, -1, -1}, {1, -1, 1, -1, 1}, {1, -1, 1, 1, -1}, {1,
+      -1, 1, 1, 1}, {1, 1, -1, -1, -1}, {1, 1, -1, -1, 1}, {1, 1, -1, 1, -1},
+      {1, 1, -1, 1, 1}, {1, 1, 1, -1, -1}, {1, 1, 1, -1, 1}, {1, 1, 1, 1, -1},
+      {1, 1, 1, 1, 1}};
+  // Denominators: spins, colors and identical particles
+  const int denominators[nprocesses] = {192, 192, 192, 192}; 
+
+  ntry = ntry + 1; 
+
+  // Reset the matrix elements
+  for(int i = 0; i < nprocesses; i++ )
+  {
+    matrix_element[i] = 0.; 
+    t[i] = 0.; 
+  }
+
+  // Define permutation
+  int perm[nexternal]; 
+  for(int i = 0; i < nexternal; i++ )
+  {
+    perm[i] = i; 
+  }
+
+  // For now, call setupForME() here
+  id1 = 21; 
+  id2 = 1; 
+  if( !setupForME())
+  {
+    return; 
+  }
+
+  if (sum_hel == 0 || ntry < 10)
+  {
+    // Calculate the matrix element for all helicities
+    for(int ihel = 0; ihel < ncomb; ihel++ )
+    {
+      if (goodhel[ihel] || ntry < 2)
+      {
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        t[0] = matrix_2_gd_xchixchid(); 
+        t[1] = matrix_2_gdx_xchixchidx(); 
+        // Mirror initial state momenta for mirror process
+        perm[0] = 1; 
+        perm[1] = 0; 
+        // Calculate wavefunctions
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        // Mirror back
+        perm[0] = 0; 
+        perm[1] = 1; 
+        // Calculate matrix elements
+        t[2] = matrix_2_gd_xchixchid(); 
+        t[3] = matrix_2_gdx_xchixchidx(); 
+        double tsum = 0; 
+        for(int iproc = 0; iproc < nprocesses; iproc++ )
+        {
+          matrix_element[iproc] += t[iproc]; 
+          tsum += t[iproc]; 
+        }
+        // Store which helicities give non-zero result
+        if (tsum != 0. && !goodhel[ihel])
+        {
+          goodhel[ihel] = true; 
+          ngood++; 
+          igood[ngood] = ihel; 
+        }
+      }
+    }
+    jhel = 0; 
+    sum_hel = min(sum_hel, ngood); 
+  }
+  else
+  {
+    // Only use the "good" helicities
+    for(int j = 0; j < sum_hel; j++ )
+    {
+      jhel++; 
+      if (jhel >= ngood)
+        jhel = 0; 
+      double hwgt = double(ngood)/double(sum_hel); 
+      int ihel = igood[jhel]; 
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      t[0] = matrix_2_gd_xchixchid(); 
+      t[1] = matrix_2_gdx_xchixchidx(); 
+      // Mirror initial state momenta for mirror process
+      perm[0] = 1; 
+      perm[1] = 0; 
+      // Calculate wavefunctions
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      // Mirror back
+      perm[0] = 0; 
+      perm[1] = 1; 
+      // Calculate matrix elements
+      t[2] = matrix_2_gd_xchixchid(); 
+      t[3] = matrix_2_gdx_xchixchidx(); 
+      for(int iproc = 0; iproc < nprocesses; iproc++ )
+      {
+        matrix_element[iproc] += t[iproc] * hwgt; 
+      }
+    }
+  }
+
+  for (int i = 0; i < nprocesses; i++ )
+    matrix_element[i] /= denominators[i]; 
+
+
+
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, including incoming flavour dependence.
+
+double Sigma_MDMSM_gd_xchixchid::sigmaHat() 
+{
+  // Select between the different processes
+  if(id1 == -1 && id2 == 21)
+  {
+    // Add matrix elements for processes with beams (-1, 21)
+    return matrix_element[3]; 
+  }
+  else if(id1 == 1 && id2 == 21)
+  {
+    // Add matrix elements for processes with beams (1, 21)
+    return matrix_element[2]; 
+  }
+  else if(id1 == 21 && id2 == -1)
+  {
+    // Add matrix elements for processes with beams (21, -1)
+    return matrix_element[1]; 
+  }
+  else if(id1 == 21 && id2 == 1)
+  {
+    // Add matrix elements for processes with beams (21, 1)
+    return matrix_element[0]; 
+  }
+  else
+  {
+    // Return 0 if not correct initial state assignment
+    return 0.; 
+  }
+}
+
+//--------------------------------------------------------------------------
+// Select identity, colour and anticolour.
+
+void Sigma_MDMSM_gd_xchixchid::setIdColAcol() 
+{
+  if(id1 == -1 && id2 == 21)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, -1}}; 
+    vector<double> probs; 
+    double sum = matrix_element[3]; 
+    probs.push_back(matrix_element[3]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 1 && id2 == 21)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, 1}}; 
+    vector<double> probs; 
+    double sum = matrix_element[2]; 
+    probs.push_back(matrix_element[2]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 21 && id2 == -1)
+  {
+    // Pick one of the flavor combinations (52, 52, -1)
+    int flavors[1][3] = {{52, 52, -1}}; 
+    vector<double> probs; 
+    double sum = matrix_element[1]; 
+    probs.push_back(matrix_element[1]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 21 && id2 == 1)
+  {
+    // Pick one of the flavor combinations (52, 52, 1)
+    int flavors[1][3] = {{52, 52, 1}}; 
+    vector<double> probs; 
+    double sum = matrix_element[0]; 
+    probs.push_back(matrix_element[0]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  setId(id1, id2, id3, id4, id5); 
+  // Pick color flow
+  int ncolor[2] = {1, 1}; 
+  if((id1 == 21 && id2 == 1 && id3 == 52 && id4 == 52 && id5 == 1))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{1, 2, 2, 0, 0, 0, 0, 0, 1, 0}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == 21 && id2 == -1 && id3 == 52 && id4 == 52 && id5 == -1))
+  {
+    vector<double> probs; 
+    double sum = jamp2[1][0]; 
+    for(int i = 0; i < ncolor[1]; i++ )
+      probs.push_back(jamp2[1][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{1, 2, 0, 1, 0, 0, 0, 0, 0, 2}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == 1 && id2 == 21 && id3 == 52 && id4 == 52 && id5 == 1))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{2, 0, 1, 2, 0, 0, 0, 0, 1, 0}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == -1 && id2 == 21 && id3 == 52 && id4 == 52 && id5 == -1))
+  {
+    vector<double> probs; 
+    double sum = jamp2[1][0]; 
+    for(int i = 0; i < ncolor[1]; i++ )
+      probs.push_back(jamp2[1][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{0, 1, 1, 2, 0, 0, 0, 0, 0, 2}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+}
+
+//--------------------------------------------------------------------------
+// Evaluate weight for angles of decay products in process
+
+double Sigma_MDMSM_gd_xchixchid::weightDecay(Event& process, int iResBeg, int
+    iResEnd)
+{
+  // Just use isotropic decay (default)
+  return 1.; 
+}
+
+//==========================================================================
+// Private class member functions
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2 for each subprocess
+
+void Sigma_MDMSM_gd_xchixchid::calculate_wavefunctions(const int perm[], const
+    int hel[])
+{
+  // Calculate wavefunctions for all processes
+  double p[nexternal][4]; 
+  int i; 
+
+  // Convert Pythia 4-vectors to double[]
+  for(i = 0; i < nexternal; i++ )
+  {
+    p[i][0] = pME[i].e(); 
+    p[i][1] = pME[i].px(); 
+    p[i][2] = pME[i].py(); 
+    p[i][3] = pME[i].pz(); 
+  }
+
+  // Calculate all wavefunctions
+  vxxxxx(p[perm[0]], mME[0], hel[0], -1, w[0]); 
+  ixxxxx(p[perm[1]], mME[1], hel[1], +1, w[1]); 
+  ixxxxx(p[perm[2]], mME[2], hel[2], -1, w[2]); 
+  oxxxxx(p[perm[3]], mME[3], hel[3], +1, w[3]); 
+  oxxxxx(p[perm[4]], mME[4], hel[4], +1, w[4]); 
+  FFV1P0_3(w[1], w[4], pars->GC_11, pars->ZERO, pars->ZERO, w[5]); 
+  FFS1_3(w[2], w[3], pars->GC_13, pars->mdl_mY, pars->mdl_wY, w[6]); 
+  oxxxxx(p[perm[1]], mME[1], hel[1], -1, w[7]); 
+  ixxxxx(p[perm[4]], mME[4], hel[4], -1, w[8]); 
+  FFV1P0_3(w[8], w[7], pars->GC_11, pars->ZERO, pars->ZERO, w[9]); 
+
+  // Calculate all amplitudes
+  // Amplitude(s) for diagram number 0
+  VVS2_0(w[0], w[5], w[6], pars->GC_14, amp[0]); 
+  VVS2_0(w[0], w[9], w[6], pars->GC_14, amp[1]); 
+
+
+}
+double Sigma_MDMSM_gd_xchixchid::matrix_2_gd_xchixchid() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = +amp[0]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+double Sigma_MDMSM_gd_xchixchid::matrix_2_gdx_xchixchidx() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = -amp[1]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[1][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+
+}  // end namespace Pythia8
diff -rupN Pythia/src/Sigma_MDMSM_gg_xchixchi.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gg_xchixchi.cc
--- Pythia/src/Sigma_MDMSM_gg_xchixchi.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gg_xchixchi.cc	2021-03-08 16:53:44.010982495 +1000
@@ -0,0 +1,272 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "Sigma_MDMSM_gg_xchixchi.h"
+#include "HelAmps_MDMSM.h"
+
+using namespace Pythia8_MDMSM; 
+
+namespace Pythia8 
+{
+
+//==========================================================================
+// Class member functions for calculating the matrix elements for
+// Process: g g > ~chi ~chi NP<=2 WEIGHTED<=2 @1
+
+//--------------------------------------------------------------------------
+// Initialize process.
+
+void Sigma_MDMSM_gg_xchixchi::initProc() 
+{
+  // Instantiate the model class and set parameters that stay fixed during run
+  pars = Parameters_MDMSM::getInstance(); 
+  pars->setIndependentParameters(particleDataPtr, couplingsPtr, slhaPtr); 
+  pars->setIndependentCouplings(); 
+  // Set massive/massless matrix elements for c/b/mu/tau
+  mcME = particleDataPtr->m0(4); 
+  mbME = particleDataPtr->m0(5); 
+  mmuME = particleDataPtr->m0(13); 
+  mtauME = particleDataPtr->m0(15); 
+  jamp2[0] = new double[1]; 
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, part independent of incoming flavour.
+
+void Sigma_MDMSM_gg_xchixchi::sigmaKin() 
+{
+  // Set the parameters which change event by event
+  pars->setDependentParameters(particleDataPtr, couplingsPtr, slhaPtr, alpS); 
+  pars->setDependentCouplings(); 
+  // Reset color flows
+  for(int i = 0; i < 1; i++ )
+    jamp2[0][i] = 0.; 
+
+  // Local variables and constants
+  const int ncomb = 16; 
+  static bool goodhel[ncomb] = {ncomb * false}; 
+  static int ntry = 0, sum_hel = 0, ngood = 0; 
+  static int igood[ncomb]; 
+  static int jhel; 
+  double t[nprocesses]; 
+  // Helicities for the process
+  static const int helicities[ncomb][nexternal] = {{-1, -1, -1, -1}, {-1, -1,
+      -1, 1}, {-1, -1, 1, -1}, {-1, -1, 1, 1}, {-1, 1, -1, -1}, {-1, 1, -1, 1},
+      {-1, 1, 1, -1}, {-1, 1, 1, 1}, {1, -1, -1, -1}, {1, -1, -1, 1}, {1, -1,
+      1, -1}, {1, -1, 1, 1}, {1, 1, -1, -1}, {1, 1, -1, 1}, {1, 1, 1, -1}, {1,
+      1, 1, 1}};
+  // Denominators: spins, colors and identical particles
+  const int denominators[nprocesses] = {512}; 
+
+  ntry = ntry + 1; 
+
+  // Reset the matrix elements
+  for(int i = 0; i < nprocesses; i++ )
+  {
+    matrix_element[i] = 0.; 
+    t[i] = 0.; 
+  }
+
+  // Define permutation
+  int perm[nexternal]; 
+  for(int i = 0; i < nexternal; i++ )
+  {
+    perm[i] = i; 
+  }
+
+  // For now, call setupForME() here
+  id1 = 21; 
+  id2 = 21; 
+  if( !setupForME())
+  {
+    return; 
+  }
+
+  if (sum_hel == 0 || ntry < 10)
+  {
+    // Calculate the matrix element for all helicities
+    for(int ihel = 0; ihel < ncomb; ihel++ )
+    {
+      if (goodhel[ihel] || ntry < 2)
+      {
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        t[0] = matrix_1_gg_xchixchi(); 
+
+        double tsum = 0; 
+        for(int iproc = 0; iproc < nprocesses; iproc++ )
+        {
+          matrix_element[iproc] += t[iproc]; 
+          tsum += t[iproc]; 
+        }
+        // Store which helicities give non-zero result
+        if (tsum != 0. && !goodhel[ihel])
+        {
+          goodhel[ihel] = true; 
+          ngood++; 
+          igood[ngood] = ihel; 
+        }
+      }
+    }
+    jhel = 0; 
+    sum_hel = min(sum_hel, ngood); 
+  }
+  else
+  {
+    // Only use the "good" helicities
+    for(int j = 0; j < sum_hel; j++ )
+    {
+      jhel++; 
+      if (jhel >= ngood)
+        jhel = 0; 
+      double hwgt = double(ngood)/double(sum_hel); 
+      int ihel = igood[jhel]; 
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      t[0] = matrix_1_gg_xchixchi(); 
+
+      for(int iproc = 0; iproc < nprocesses; iproc++ )
+      {
+        matrix_element[iproc] += t[iproc] * hwgt; 
+      }
+    }
+  }
+
+  for (int i = 0; i < nprocesses; i++ )
+    matrix_element[i] /= denominators[i]; 
+
+
+
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, including incoming flavour dependence.
+
+double Sigma_MDMSM_gg_xchixchi::sigmaHat() 
+{
+  // Select between the different processes
+  if(id1 == 21 && id2 == 21)
+  {
+    // Add matrix elements for processes with beams (21, 21)
+    return matrix_element[0]; 
+  }
+  else
+  {
+    // Return 0 if not correct initial state assignment
+    return 0.; 
+  }
+}
+
+//--------------------------------------------------------------------------
+// Select identity, colour and anticolour.
+
+void Sigma_MDMSM_gg_xchixchi::setIdColAcol() 
+{
+  if(id1 == 21 && id2 == 21)
+  {
+    // Pick one of the flavor combinations (52, 52)
+    int flavors[1][2] = {{52, 52}}; 
+    vector<double> probs; 
+    double sum = matrix_element[0]; 
+    probs.push_back(matrix_element[0]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+  }
+  setId(id1, id2, id3, id4); 
+  // Pick color flow
+  int ncolor[1] = {1}; 
+  if((id1 == 21 && id2 == 21 && id3 == 52 && id4 == 52))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][8] = {{2, 1, 1, 2, 0, 0, 0, 0}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7]);
+  }
+}
+
+//--------------------------------------------------------------------------
+// Evaluate weight for angles of decay products in process
+
+double Sigma_MDMSM_gg_xchixchi::weightDecay(Event& process, int iResBeg, int
+    iResEnd)
+{
+  // Just use isotropic decay (default)
+  return 1.; 
+}
+
+//==========================================================================
+// Private class member functions
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2 for each subprocess
+
+void Sigma_MDMSM_gg_xchixchi::calculate_wavefunctions(const int perm[], const
+    int hel[])
+{
+  // Calculate wavefunctions for all processes
+  double p[nexternal][4]; 
+  int i; 
+
+  // Convert Pythia 4-vectors to double[]
+  for(i = 0; i < nexternal; i++ )
+  {
+    p[i][0] = pME[i].e(); 
+    p[i][1] = pME[i].px(); 
+    p[i][2] = pME[i].py(); 
+    p[i][3] = pME[i].pz(); 
+  }
+
+  // Calculate all wavefunctions
+  vxxxxx(p[perm[0]], mME[0], hel[0], -1, w[0]); 
+  vxxxxx(p[perm[1]], mME[1], hel[1], -1, w[1]); 
+  ixxxxx(p[perm[2]], mME[2], hel[2], -1, w[2]); 
+  oxxxxx(p[perm[3]], mME[3], hel[3], +1, w[3]); 
+  VVS2_3(w[0], w[1], pars->GC_14, pars->mdl_mY, pars->mdl_wY, w[4]); 
+
+  // Calculate all amplitudes
+  // Amplitude(s) for diagram number 0
+  FFS1_0(w[2], w[3], w[4], pars->GC_13, amp[0]); 
+
+
+}
+double Sigma_MDMSM_gg_xchixchi::matrix_1_gg_xchixchi() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{2}}; 
+
+  // Calculate color flows
+  jamp[0] = +2. * (+amp[0]); 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+
+}  // end namespace Pythia8
diff -rupN Pythia/src/Sigma_MDMSM_gg_xchixchig.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gg_xchixchig.cc
--- Pythia/src/Sigma_MDMSM_gg_xchixchig.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gg_xchixchig.cc	2021-03-08 16:53:43.966980078 +1000
@@ -0,0 +1,293 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "Sigma_MDMSM_gg_xchixchig.h"
+#include "HelAmps_MDMSM.h"
+
+using namespace Pythia8_MDMSM; 
+
+namespace Pythia8 
+{
+
+//==========================================================================
+// Class member functions for calculating the matrix elements for
+// Process: g g > ~chi ~chi g NP<=2 WEIGHTED<=3 @2
+
+//--------------------------------------------------------------------------
+// Initialize process.
+
+void Sigma_MDMSM_gg_xchixchig::initProc() 
+{
+  // Instantiate the model class and set parameters that stay fixed during run
+  pars = Parameters_MDMSM::getInstance(); 
+  pars->setIndependentParameters(particleDataPtr, couplingsPtr, slhaPtr); 
+  pars->setIndependentCouplings(); 
+  // Set massive/massless matrix elements for c/b/mu/tau
+  mcME = particleDataPtr->m0(4); 
+  mbME = particleDataPtr->m0(5); 
+  mmuME = particleDataPtr->m0(13); 
+  mtauME = particleDataPtr->m0(15); 
+  jamp2[0] = new double[2]; 
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, part independent of incoming flavour.
+
+void Sigma_MDMSM_gg_xchixchig::sigmaKin() 
+{
+  // Set the parameters which change event by event
+  pars->setDependentParameters(particleDataPtr, couplingsPtr, slhaPtr, alpS); 
+  pars->setDependentCouplings(); 
+  // Reset color flows
+  for(int i = 0; i < 2; i++ )
+    jamp2[0][i] = 0.; 
+
+  // Local variables and constants
+  const int ncomb = 32; 
+  static bool goodhel[ncomb] = {ncomb * false}; 
+  static int ntry = 0, sum_hel = 0, ngood = 0; 
+  static int igood[ncomb]; 
+  static int jhel; 
+  double t[nprocesses]; 
+  // Helicities for the process
+  static const int helicities[ncomb][nexternal] = {{-1, -1, -1, -1, -1}, {-1,
+      -1, -1, -1, 1}, {-1, -1, -1, 1, -1}, {-1, -1, -1, 1, 1}, {-1, -1, 1, -1,
+      -1}, {-1, -1, 1, -1, 1}, {-1, -1, 1, 1, -1}, {-1, -1, 1, 1, 1}, {-1, 1,
+      -1, -1, -1}, {-1, 1, -1, -1, 1}, {-1, 1, -1, 1, -1}, {-1, 1, -1, 1, 1},
+      {-1, 1, 1, -1, -1}, {-1, 1, 1, -1, 1}, {-1, 1, 1, 1, -1}, {-1, 1, 1, 1,
+      1}, {1, -1, -1, -1, -1}, {1, -1, -1, -1, 1}, {1, -1, -1, 1, -1}, {1, -1,
+      -1, 1, 1}, {1, -1, 1, -1, -1}, {1, -1, 1, -1, 1}, {1, -1, 1, 1, -1}, {1,
+      -1, 1, 1, 1}, {1, 1, -1, -1, -1}, {1, 1, -1, -1, 1}, {1, 1, -1, 1, -1},
+      {1, 1, -1, 1, 1}, {1, 1, 1, -1, -1}, {1, 1, 1, -1, 1}, {1, 1, 1, 1, -1},
+      {1, 1, 1, 1, 1}};
+  // Denominators: spins, colors and identical particles
+  const int denominators[nprocesses] = {512}; 
+
+  ntry = ntry + 1; 
+
+  // Reset the matrix elements
+  for(int i = 0; i < nprocesses; i++ )
+  {
+    matrix_element[i] = 0.; 
+    t[i] = 0.; 
+  }
+
+  // Define permutation
+  int perm[nexternal]; 
+  for(int i = 0; i < nexternal; i++ )
+  {
+    perm[i] = i; 
+  }
+
+  // For now, call setupForME() here
+  id1 = 21; 
+  id2 = 21; 
+  if( !setupForME())
+  {
+    return; 
+  }
+
+  if (sum_hel == 0 || ntry < 10)
+  {
+    // Calculate the matrix element for all helicities
+    for(int ihel = 0; ihel < ncomb; ihel++ )
+    {
+      if (goodhel[ihel] || ntry < 2)
+      {
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        t[0] = matrix_2_gg_xchixchig(); 
+
+        double tsum = 0; 
+        for(int iproc = 0; iproc < nprocesses; iproc++ )
+        {
+          matrix_element[iproc] += t[iproc]; 
+          tsum += t[iproc]; 
+        }
+        // Store which helicities give non-zero result
+        if (tsum != 0. && !goodhel[ihel])
+        {
+          goodhel[ihel] = true; 
+          ngood++; 
+          igood[ngood] = ihel; 
+        }
+      }
+    }
+    jhel = 0; 
+    sum_hel = min(sum_hel, ngood); 
+  }
+  else
+  {
+    // Only use the "good" helicities
+    for(int j = 0; j < sum_hel; j++ )
+    {
+      jhel++; 
+      if (jhel >= ngood)
+        jhel = 0; 
+      double hwgt = double(ngood)/double(sum_hel); 
+      int ihel = igood[jhel]; 
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      t[0] = matrix_2_gg_xchixchig(); 
+
+      for(int iproc = 0; iproc < nprocesses; iproc++ )
+      {
+        matrix_element[iproc] += t[iproc] * hwgt; 
+      }
+    }
+  }
+
+  for (int i = 0; i < nprocesses; i++ )
+    matrix_element[i] /= denominators[i]; 
+
+
+
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, including incoming flavour dependence.
+
+double Sigma_MDMSM_gg_xchixchig::sigmaHat() 
+{
+  // Select between the different processes
+  if(id1 == 21 && id2 == 21)
+  {
+    // Add matrix elements for processes with beams (21, 21)
+    return matrix_element[0]; 
+  }
+  else
+  {
+    // Return 0 if not correct initial state assignment
+    return 0.; 
+  }
+}
+
+//--------------------------------------------------------------------------
+// Select identity, colour and anticolour.
+
+void Sigma_MDMSM_gg_xchixchig::setIdColAcol() 
+{
+  if(id1 == 21 && id2 == 21)
+  {
+    // Pick one of the flavor combinations (52, 52, 21)
+    int flavors[1][3] = {{52, 52, 21}}; 
+    vector<double> probs; 
+    double sum = matrix_element[0]; 
+    probs.push_back(matrix_element[0]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  setId(id1, id2, id3, id4, id5); 
+  // Pick color flow
+  int ncolor[1] = {2}; 
+  if((id1 == 21 && id2 == 21 && id3 == 52 && id4 == 52 && id5 == 21))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0] + jamp2[0][1]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[2][10] = {{3, 1, 1, 2, 0, 0, 0, 0, 3, 2}, {2, 1, 3, 2, 0,
+        0, 0, 0, 3, 1}};
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+}
+
+//--------------------------------------------------------------------------
+// Evaluate weight for angles of decay products in process
+
+double Sigma_MDMSM_gg_xchixchig::weightDecay(Event& process, int iResBeg, int
+    iResEnd)
+{
+  // Just use isotropic decay (default)
+  return 1.; 
+}
+
+//==========================================================================
+// Private class member functions
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2 for each subprocess
+
+void Sigma_MDMSM_gg_xchixchig::calculate_wavefunctions(const int perm[], const
+    int hel[])
+{
+  // Calculate wavefunctions for all processes
+  double p[nexternal][4]; 
+  int i; 
+
+  // Convert Pythia 4-vectors to double[]
+  for(i = 0; i < nexternal; i++ )
+  {
+    p[i][0] = pME[i].e(); 
+    p[i][1] = pME[i].px(); 
+    p[i][2] = pME[i].py(); 
+    p[i][3] = pME[i].pz(); 
+  }
+
+  // Calculate all wavefunctions
+  vxxxxx(p[perm[0]], mME[0], hel[0], -1, w[0]); 
+  vxxxxx(p[perm[1]], mME[1], hel[1], -1, w[1]); 
+  ixxxxx(p[perm[2]], mME[2], hel[2], -1, w[2]); 
+  oxxxxx(p[perm[3]], mME[3], hel[3], +1, w[3]); 
+  vxxxxx(p[perm[4]], mME[4], hel[4], +1, w[4]); 
+  VVV1P0_1(w[0], w[1], pars->GC_10, pars->ZERO, pars->ZERO, w[5]); 
+  FFS1_3(w[2], w[3], pars->GC_13, pars->mdl_mY, pars->mdl_wY, w[6]); 
+  VVV1P0_1(w[0], w[4], pars->GC_10, pars->ZERO, pars->ZERO, w[7]); 
+  VVV1P0_1(w[1], w[4], pars->GC_10, pars->ZERO, pars->ZERO, w[8]); 
+  VVVS1_4(w[0], w[1], w[4], pars->GC_15, pars->mdl_mY, pars->mdl_wY, w[9]); 
+
+  // Calculate all amplitudes
+  // Amplitude(s) for diagram number 0
+  VVS2_0(w[5], w[4], w[6], pars->GC_14, amp[0]); 
+  VVS2_0(w[7], w[1], w[6], pars->GC_14, amp[1]); 
+  VVS2_0(w[0], w[8], w[6], pars->GC_14, amp[2]); 
+  FFS1_0(w[2], w[3], w[9], pars->GC_13, amp[3]); 
+
+
+}
+double Sigma_MDMSM_gg_xchixchig::matrix_2_gg_xchixchig() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 4; 
+  const int ncolor = 2; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {3, 3}; 
+  static const double cf[ncolor][ncolor] = {{7, -2}, {-2, 7}}; 
+
+  // Calculate color flows
+  jamp[0] = +2. * (-std::complex<double> (0, 1) * amp[0] + std::complex<double>
+      (0, 1) * amp[1] - std::complex<double> (0, 1) * amp[2] -
+      std::complex<double> (0, 1) * amp[3]);
+  jamp[1] = +2. * (+std::complex<double> (0, 1) * amp[0] - std::complex<double>
+      (0, 1) * amp[1] + std::complex<double> (0, 1) * amp[2] +
+      std::complex<double> (0, 1) * amp[3]);
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+
+}  // end namespace Pythia8
diff -rupN Pythia/src/Sigma_MDMSM_gs_xchixchis.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gs_xchixchis.cc
--- Pythia/src/Sigma_MDMSM_gs_xchixchis.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gs_xchixchis.cc	2021-03-08 16:53:44.306998748 +1000
@@ -0,0 +1,430 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "Sigma_MDMSM_gs_xchixchis.h"
+#include "HelAmps_MDMSM.h"
+
+using namespace Pythia8_MDMSM; 
+
+namespace Pythia8 
+{
+
+//==========================================================================
+// Class member functions for calculating the matrix elements for
+// Process: g s > ~chi ~chi s NP<=2 WEIGHTED<=3 @2
+// Process: g s~ > ~chi ~chi s~ NP<=2 WEIGHTED<=3 @2
+
+//--------------------------------------------------------------------------
+// Initialize process.
+
+void Sigma_MDMSM_gs_xchixchis::initProc() 
+{
+  // Instantiate the model class and set parameters that stay fixed during run
+  pars = Parameters_MDMSM::getInstance(); 
+  pars->setIndependentParameters(particleDataPtr, couplingsPtr, slhaPtr); 
+  pars->setIndependentCouplings(); 
+  // Set massive/massless matrix elements for c/b/mu/tau
+  mcME = particleDataPtr->m0(4); 
+  mbME = particleDataPtr->m0(5); 
+  mmuME = particleDataPtr->m0(13); 
+  mtauME = particleDataPtr->m0(15); 
+  jamp2[0] = new double[1]; 
+  jamp2[1] = new double[1]; 
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, part independent of incoming flavour.
+
+void Sigma_MDMSM_gs_xchixchis::sigmaKin() 
+{
+  // Set the parameters which change event by event
+  pars->setDependentParameters(particleDataPtr, couplingsPtr, slhaPtr, alpS); 
+  pars->setDependentCouplings(); 
+  // Reset color flows
+  for(int i = 0; i < 1; i++ )
+    jamp2[0][i] = 0.; 
+  for(int i = 0; i < 1; i++ )
+    jamp2[1][i] = 0.; 
+
+  // Local variables and constants
+  const int ncomb = 32; 
+  static bool goodhel[ncomb] = {ncomb * false}; 
+  static int ntry = 0, sum_hel = 0, ngood = 0; 
+  static int igood[ncomb]; 
+  static int jhel; 
+  double t[nprocesses]; 
+  // Helicities for the process
+  static const int helicities[ncomb][nexternal] = {{-1, -1, -1, -1, -1}, {-1,
+      -1, -1, -1, 1}, {-1, -1, -1, 1, -1}, {-1, -1, -1, 1, 1}, {-1, -1, 1, -1,
+      -1}, {-1, -1, 1, -1, 1}, {-1, -1, 1, 1, -1}, {-1, -1, 1, 1, 1}, {-1, 1,
+      -1, -1, -1}, {-1, 1, -1, -1, 1}, {-1, 1, -1, 1, -1}, {-1, 1, -1, 1, 1},
+      {-1, 1, 1, -1, -1}, {-1, 1, 1, -1, 1}, {-1, 1, 1, 1, -1}, {-1, 1, 1, 1,
+      1}, {1, -1, -1, -1, -1}, {1, -1, -1, -1, 1}, {1, -1, -1, 1, -1}, {1, -1,
+      -1, 1, 1}, {1, -1, 1, -1, -1}, {1, -1, 1, -1, 1}, {1, -1, 1, 1, -1}, {1,
+      -1, 1, 1, 1}, {1, 1, -1, -1, -1}, {1, 1, -1, -1, 1}, {1, 1, -1, 1, -1},
+      {1, 1, -1, 1, 1}, {1, 1, 1, -1, -1}, {1, 1, 1, -1, 1}, {1, 1, 1, 1, -1},
+      {1, 1, 1, 1, 1}};
+  // Denominators: spins, colors and identical particles
+  const int denominators[nprocesses] = {192, 192, 192, 192}; 
+
+  ntry = ntry + 1; 
+
+  // Reset the matrix elements
+  for(int i = 0; i < nprocesses; i++ )
+  {
+    matrix_element[i] = 0.; 
+    t[i] = 0.; 
+  }
+
+  // Define permutation
+  int perm[nexternal]; 
+  for(int i = 0; i < nexternal; i++ )
+  {
+    perm[i] = i; 
+  }
+
+  // For now, call setupForME() here
+  id1 = 21; 
+  id2 = 3; 
+  if( !setupForME())
+  {
+    return; 
+  }
+
+  if (sum_hel == 0 || ntry < 10)
+  {
+    // Calculate the matrix element for all helicities
+    for(int ihel = 0; ihel < ncomb; ihel++ )
+    {
+      if (goodhel[ihel] || ntry < 2)
+      {
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        t[0] = matrix_2_gs_xchixchis(); 
+        t[1] = matrix_2_gsx_xchixchisx(); 
+        // Mirror initial state momenta for mirror process
+        perm[0] = 1; 
+        perm[1] = 0; 
+        // Calculate wavefunctions
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        // Mirror back
+        perm[0] = 0; 
+        perm[1] = 1; 
+        // Calculate matrix elements
+        t[2] = matrix_2_gs_xchixchis(); 
+        t[3] = matrix_2_gsx_xchixchisx(); 
+        double tsum = 0; 
+        for(int iproc = 0; iproc < nprocesses; iproc++ )
+        {
+          matrix_element[iproc] += t[iproc]; 
+          tsum += t[iproc]; 
+        }
+        // Store which helicities give non-zero result
+        if (tsum != 0. && !goodhel[ihel])
+        {
+          goodhel[ihel] = true; 
+          ngood++; 
+          igood[ngood] = ihel; 
+        }
+      }
+    }
+    jhel = 0; 
+    sum_hel = min(sum_hel, ngood); 
+  }
+  else
+  {
+    // Only use the "good" helicities
+    for(int j = 0; j < sum_hel; j++ )
+    {
+      jhel++; 
+      if (jhel >= ngood)
+        jhel = 0; 
+      double hwgt = double(ngood)/double(sum_hel); 
+      int ihel = igood[jhel]; 
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      t[0] = matrix_2_gs_xchixchis(); 
+      t[1] = matrix_2_gsx_xchixchisx(); 
+      // Mirror initial state momenta for mirror process
+      perm[0] = 1; 
+      perm[1] = 0; 
+      // Calculate wavefunctions
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      // Mirror back
+      perm[0] = 0; 
+      perm[1] = 1; 
+      // Calculate matrix elements
+      t[2] = matrix_2_gs_xchixchis(); 
+      t[3] = matrix_2_gsx_xchixchisx(); 
+      for(int iproc = 0; iproc < nprocesses; iproc++ )
+      {
+        matrix_element[iproc] += t[iproc] * hwgt; 
+      }
+    }
+  }
+
+  for (int i = 0; i < nprocesses; i++ )
+    matrix_element[i] /= denominators[i]; 
+
+
+
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, including incoming flavour dependence.
+
+double Sigma_MDMSM_gs_xchixchis::sigmaHat() 
+{
+  // Select between the different processes
+  if(id1 == -3 && id2 == 21)
+  {
+    // Add matrix elements for processes with beams (-3, 21)
+    return matrix_element[3]; 
+  }
+  else if(id1 == 3 && id2 == 21)
+  {
+    // Add matrix elements for processes with beams (3, 21)
+    return matrix_element[2]; 
+  }
+  else if(id1 == 21 && id2 == -3)
+  {
+    // Add matrix elements for processes with beams (21, -3)
+    return matrix_element[1]; 
+  }
+  else if(id1 == 21 && id2 == 3)
+  {
+    // Add matrix elements for processes with beams (21, 3)
+    return matrix_element[0]; 
+  }
+  else
+  {
+    // Return 0 if not correct initial state assignment
+    return 0.; 
+  }
+}
+
+//--------------------------------------------------------------------------
+// Select identity, colour and anticolour.
+
+void Sigma_MDMSM_gs_xchixchis::setIdColAcol() 
+{
+  if(id1 == -3 && id2 == 21)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, -3}}; 
+    vector<double> probs; 
+    double sum = matrix_element[3]; 
+    probs.push_back(matrix_element[3]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 3 && id2 == 21)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, 3}}; 
+    vector<double> probs; 
+    double sum = matrix_element[2]; 
+    probs.push_back(matrix_element[2]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 21 && id2 == -3)
+  {
+    // Pick one of the flavor combinations (52, 52, -3)
+    int flavors[1][3] = {{52, 52, -3}}; 
+    vector<double> probs; 
+    double sum = matrix_element[1]; 
+    probs.push_back(matrix_element[1]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 21 && id2 == 3)
+  {
+    // Pick one of the flavor combinations (52, 52, 3)
+    int flavors[1][3] = {{52, 52, 3}}; 
+    vector<double> probs; 
+    double sum = matrix_element[0]; 
+    probs.push_back(matrix_element[0]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  setId(id1, id2, id3, id4, id5); 
+  // Pick color flow
+  int ncolor[2] = {1, 1}; 
+  if((id1 == 21 && id2 == 3 && id3 == 52 && id4 == 52 && id5 == 3))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{1, 2, 2, 0, 0, 0, 0, 0, 1, 0}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == 21 && id2 == -3 && id3 == 52 && id4 == 52 && id5 == -3))
+  {
+    vector<double> probs; 
+    double sum = jamp2[1][0]; 
+    for(int i = 0; i < ncolor[1]; i++ )
+      probs.push_back(jamp2[1][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{1, 2, 0, 1, 0, 0, 0, 0, 0, 2}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == 3 && id2 == 21 && id3 == 52 && id4 == 52 && id5 == 3))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{2, 0, 1, 2, 0, 0, 0, 0, 1, 0}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == -3 && id2 == 21 && id3 == 52 && id4 == 52 && id5 == -3))
+  {
+    vector<double> probs; 
+    double sum = jamp2[1][0]; 
+    for(int i = 0; i < ncolor[1]; i++ )
+      probs.push_back(jamp2[1][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{0, 1, 1, 2, 0, 0, 0, 0, 0, 2}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+}
+
+//--------------------------------------------------------------------------
+// Evaluate weight for angles of decay products in process
+
+double Sigma_MDMSM_gs_xchixchis::weightDecay(Event& process, int iResBeg, int
+    iResEnd)
+{
+  // Just use isotropic decay (default)
+  return 1.; 
+}
+
+//==========================================================================
+// Private class member functions
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2 for each subprocess
+
+void Sigma_MDMSM_gs_xchixchis::calculate_wavefunctions(const int perm[], const
+    int hel[])
+{
+  // Calculate wavefunctions for all processes
+  double p[nexternal][4]; 
+  int i; 
+
+  // Convert Pythia 4-vectors to double[]
+  for(i = 0; i < nexternal; i++ )
+  {
+    p[i][0] = pME[i].e(); 
+    p[i][1] = pME[i].px(); 
+    p[i][2] = pME[i].py(); 
+    p[i][3] = pME[i].pz(); 
+  }
+
+  // Calculate all wavefunctions
+  vxxxxx(p[perm[0]], mME[0], hel[0], -1, w[0]); 
+  ixxxxx(p[perm[1]], mME[1], hel[1], +1, w[1]); 
+  ixxxxx(p[perm[2]], mME[2], hel[2], -1, w[2]); 
+  oxxxxx(p[perm[3]], mME[3], hel[3], +1, w[3]); 
+  oxxxxx(p[perm[4]], mME[4], hel[4], +1, w[4]); 
+  FFV1P0_3(w[1], w[4], pars->GC_11, pars->ZERO, pars->ZERO, w[5]); 
+  FFS1_3(w[2], w[3], pars->GC_13, pars->mdl_mY, pars->mdl_wY, w[6]); 
+  oxxxxx(p[perm[1]], mME[1], hel[1], -1, w[7]); 
+  ixxxxx(p[perm[4]], mME[4], hel[4], -1, w[8]); 
+  FFV1P0_3(w[8], w[7], pars->GC_11, pars->ZERO, pars->ZERO, w[9]); 
+
+  // Calculate all amplitudes
+  // Amplitude(s) for diagram number 0
+  VVS2_0(w[0], w[5], w[6], pars->GC_14, amp[0]); 
+  VVS2_0(w[0], w[9], w[6], pars->GC_14, amp[1]); 
+
+
+}
+double Sigma_MDMSM_gs_xchixchis::matrix_2_gs_xchixchis() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = +amp[0]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+double Sigma_MDMSM_gs_xchixchis::matrix_2_gsx_xchixchisx() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = -amp[1]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[1][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+
+}  // end namespace Pythia8
diff -rupN Pythia/src/Sigma_MDMSM_gu_xchixchiu.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gu_xchixchiu.cc
--- Pythia/src/Sigma_MDMSM_gu_xchixchiu.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_gu_xchixchiu.cc	2021-03-08 16:53:44.082986449 +1000
@@ -0,0 +1,430 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "Sigma_MDMSM_gu_xchixchiu.h"
+#include "HelAmps_MDMSM.h"
+
+using namespace Pythia8_MDMSM; 
+
+namespace Pythia8 
+{
+
+//==========================================================================
+// Class member functions for calculating the matrix elements for
+// Process: g u > ~chi ~chi u NP<=2 WEIGHTED<=3 @2
+// Process: g u~ > ~chi ~chi u~ NP<=2 WEIGHTED<=3 @2
+
+//--------------------------------------------------------------------------
+// Initialize process.
+
+void Sigma_MDMSM_gu_xchixchiu::initProc() 
+{
+  // Instantiate the model class and set parameters that stay fixed during run
+  pars = Parameters_MDMSM::getInstance(); 
+  pars->setIndependentParameters(particleDataPtr, couplingsPtr, slhaPtr); 
+  pars->setIndependentCouplings(); 
+  // Set massive/massless matrix elements for c/b/mu/tau
+  mcME = particleDataPtr->m0(4); 
+  mbME = particleDataPtr->m0(5); 
+  mmuME = particleDataPtr->m0(13); 
+  mtauME = particleDataPtr->m0(15); 
+  jamp2[0] = new double[1]; 
+  jamp2[1] = new double[1]; 
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, part independent of incoming flavour.
+
+void Sigma_MDMSM_gu_xchixchiu::sigmaKin() 
+{
+  // Set the parameters which change event by event
+  pars->setDependentParameters(particleDataPtr, couplingsPtr, slhaPtr, alpS); 
+  pars->setDependentCouplings(); 
+  // Reset color flows
+  for(int i = 0; i < 1; i++ )
+    jamp2[0][i] = 0.; 
+  for(int i = 0; i < 1; i++ )
+    jamp2[1][i] = 0.; 
+
+  // Local variables and constants
+  const int ncomb = 32; 
+  static bool goodhel[ncomb] = {ncomb * false}; 
+  static int ntry = 0, sum_hel = 0, ngood = 0; 
+  static int igood[ncomb]; 
+  static int jhel; 
+  double t[nprocesses]; 
+  // Helicities for the process
+  static const int helicities[ncomb][nexternal] = {{-1, -1, -1, -1, -1}, {-1,
+      -1, -1, -1, 1}, {-1, -1, -1, 1, -1}, {-1, -1, -1, 1, 1}, {-1, -1, 1, -1,
+      -1}, {-1, -1, 1, -1, 1}, {-1, -1, 1, 1, -1}, {-1, -1, 1, 1, 1}, {-1, 1,
+      -1, -1, -1}, {-1, 1, -1, -1, 1}, {-1, 1, -1, 1, -1}, {-1, 1, -1, 1, 1},
+      {-1, 1, 1, -1, -1}, {-1, 1, 1, -1, 1}, {-1, 1, 1, 1, -1}, {-1, 1, 1, 1,
+      1}, {1, -1, -1, -1, -1}, {1, -1, -1, -1, 1}, {1, -1, -1, 1, -1}, {1, -1,
+      -1, 1, 1}, {1, -1, 1, -1, -1}, {1, -1, 1, -1, 1}, {1, -1, 1, 1, -1}, {1,
+      -1, 1, 1, 1}, {1, 1, -1, -1, -1}, {1, 1, -1, -1, 1}, {1, 1, -1, 1, -1},
+      {1, 1, -1, 1, 1}, {1, 1, 1, -1, -1}, {1, 1, 1, -1, 1}, {1, 1, 1, 1, -1},
+      {1, 1, 1, 1, 1}};
+  // Denominators: spins, colors and identical particles
+  const int denominators[nprocesses] = {192, 192, 192, 192}; 
+
+  ntry = ntry + 1; 
+
+  // Reset the matrix elements
+  for(int i = 0; i < nprocesses; i++ )
+  {
+    matrix_element[i] = 0.; 
+    t[i] = 0.; 
+  }
+
+  // Define permutation
+  int perm[nexternal]; 
+  for(int i = 0; i < nexternal; i++ )
+  {
+    perm[i] = i; 
+  }
+
+  // For now, call setupForME() here
+  id1 = 21; 
+  id2 = 2; 
+  if( !setupForME())
+  {
+    return; 
+  }
+
+  if (sum_hel == 0 || ntry < 10)
+  {
+    // Calculate the matrix element for all helicities
+    for(int ihel = 0; ihel < ncomb; ihel++ )
+    {
+      if (goodhel[ihel] || ntry < 2)
+      {
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        t[0] = matrix_2_gu_xchixchiu(); 
+        t[1] = matrix_2_gux_xchixchiux(); 
+        // Mirror initial state momenta for mirror process
+        perm[0] = 1; 
+        perm[1] = 0; 
+        // Calculate wavefunctions
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        // Mirror back
+        perm[0] = 0; 
+        perm[1] = 1; 
+        // Calculate matrix elements
+        t[2] = matrix_2_gu_xchixchiu(); 
+        t[3] = matrix_2_gux_xchixchiux(); 
+        double tsum = 0; 
+        for(int iproc = 0; iproc < nprocesses; iproc++ )
+        {
+          matrix_element[iproc] += t[iproc]; 
+          tsum += t[iproc]; 
+        }
+        // Store which helicities give non-zero result
+        if (tsum != 0. && !goodhel[ihel])
+        {
+          goodhel[ihel] = true; 
+          ngood++; 
+          igood[ngood] = ihel; 
+        }
+      }
+    }
+    jhel = 0; 
+    sum_hel = min(sum_hel, ngood); 
+  }
+  else
+  {
+    // Only use the "good" helicities
+    for(int j = 0; j < sum_hel; j++ )
+    {
+      jhel++; 
+      if (jhel >= ngood)
+        jhel = 0; 
+      double hwgt = double(ngood)/double(sum_hel); 
+      int ihel = igood[jhel]; 
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      t[0] = matrix_2_gu_xchixchiu(); 
+      t[1] = matrix_2_gux_xchixchiux(); 
+      // Mirror initial state momenta for mirror process
+      perm[0] = 1; 
+      perm[1] = 0; 
+      // Calculate wavefunctions
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      // Mirror back
+      perm[0] = 0; 
+      perm[1] = 1; 
+      // Calculate matrix elements
+      t[2] = matrix_2_gu_xchixchiu(); 
+      t[3] = matrix_2_gux_xchixchiux(); 
+      for(int iproc = 0; iproc < nprocesses; iproc++ )
+      {
+        matrix_element[iproc] += t[iproc] * hwgt; 
+      }
+    }
+  }
+
+  for (int i = 0; i < nprocesses; i++ )
+    matrix_element[i] /= denominators[i]; 
+
+
+
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, including incoming flavour dependence.
+
+double Sigma_MDMSM_gu_xchixchiu::sigmaHat() 
+{
+  // Select between the different processes
+  if(id1 == -2 && id2 == 21)
+  {
+    // Add matrix elements for processes with beams (-2, 21)
+    return matrix_element[3]; 
+  }
+  else if(id1 == 2 && id2 == 21)
+  {
+    // Add matrix elements for processes with beams (2, 21)
+    return matrix_element[2]; 
+  }
+  else if(id1 == 21 && id2 == -2)
+  {
+    // Add matrix elements for processes with beams (21, -2)
+    return matrix_element[1]; 
+  }
+  else if(id1 == 21 && id2 == 2)
+  {
+    // Add matrix elements for processes with beams (21, 2)
+    return matrix_element[0]; 
+  }
+  else
+  {
+    // Return 0 if not correct initial state assignment
+    return 0.; 
+  }
+}
+
+//--------------------------------------------------------------------------
+// Select identity, colour and anticolour.
+
+void Sigma_MDMSM_gu_xchixchiu::setIdColAcol() 
+{
+  if(id1 == -2 && id2 == 21)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, -2}}; 
+    vector<double> probs; 
+    double sum = matrix_element[3]; 
+    probs.push_back(matrix_element[3]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 2 && id2 == 21)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, 2}}; 
+    vector<double> probs; 
+    double sum = matrix_element[2]; 
+    probs.push_back(matrix_element[2]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 21 && id2 == -2)
+  {
+    // Pick one of the flavor combinations (52, 52, -2)
+    int flavors[1][3] = {{52, 52, -2}}; 
+    vector<double> probs; 
+    double sum = matrix_element[1]; 
+    probs.push_back(matrix_element[1]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 21 && id2 == 2)
+  {
+    // Pick one of the flavor combinations (52, 52, 2)
+    int flavors[1][3] = {{52, 52, 2}}; 
+    vector<double> probs; 
+    double sum = matrix_element[0]; 
+    probs.push_back(matrix_element[0]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  setId(id1, id2, id3, id4, id5); 
+  // Pick color flow
+  int ncolor[2] = {1, 1}; 
+  if((id1 == 21 && id2 == 2 && id3 == 52 && id4 == 52 && id5 == 2))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{1, 2, 2, 0, 0, 0, 0, 0, 1, 0}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == 21 && id2 == -2 && id3 == 52 && id4 == 52 && id5 == -2))
+  {
+    vector<double> probs; 
+    double sum = jamp2[1][0]; 
+    for(int i = 0; i < ncolor[1]; i++ )
+      probs.push_back(jamp2[1][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{1, 2, 0, 1, 0, 0, 0, 0, 0, 2}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == 2 && id2 == 21 && id3 == 52 && id4 == 52 && id5 == 2))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{2, 0, 1, 2, 0, 0, 0, 0, 1, 0}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == -2 && id2 == 21 && id3 == 52 && id4 == 52 && id5 == -2))
+  {
+    vector<double> probs; 
+    double sum = jamp2[1][0]; 
+    for(int i = 0; i < ncolor[1]; i++ )
+      probs.push_back(jamp2[1][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{0, 1, 1, 2, 0, 0, 0, 0, 0, 2}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+}
+
+//--------------------------------------------------------------------------
+// Evaluate weight for angles of decay products in process
+
+double Sigma_MDMSM_gu_xchixchiu::weightDecay(Event& process, int iResBeg, int
+    iResEnd)
+{
+  // Just use isotropic decay (default)
+  return 1.; 
+}
+
+//==========================================================================
+// Private class member functions
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2 for each subprocess
+
+void Sigma_MDMSM_gu_xchixchiu::calculate_wavefunctions(const int perm[], const
+    int hel[])
+{
+  // Calculate wavefunctions for all processes
+  double p[nexternal][4]; 
+  int i; 
+
+  // Convert Pythia 4-vectors to double[]
+  for(i = 0; i < nexternal; i++ )
+  {
+    p[i][0] = pME[i].e(); 
+    p[i][1] = pME[i].px(); 
+    p[i][2] = pME[i].py(); 
+    p[i][3] = pME[i].pz(); 
+  }
+
+  // Calculate all wavefunctions
+  vxxxxx(p[perm[0]], mME[0], hel[0], -1, w[0]); 
+  ixxxxx(p[perm[1]], mME[1], hel[1], +1, w[1]); 
+  ixxxxx(p[perm[2]], mME[2], hel[2], -1, w[2]); 
+  oxxxxx(p[perm[3]], mME[3], hel[3], +1, w[3]); 
+  oxxxxx(p[perm[4]], mME[4], hel[4], +1, w[4]); 
+  FFV1P0_3(w[1], w[4], pars->GC_11, pars->ZERO, pars->ZERO, w[5]); 
+  FFS1_3(w[2], w[3], pars->GC_13, pars->mdl_mY, pars->mdl_wY, w[6]); 
+  oxxxxx(p[perm[1]], mME[1], hel[1], -1, w[7]); 
+  ixxxxx(p[perm[4]], mME[4], hel[4], -1, w[8]); 
+  FFV1P0_3(w[8], w[7], pars->GC_11, pars->ZERO, pars->ZERO, w[9]); 
+
+  // Calculate all amplitudes
+  // Amplitude(s) for diagram number 0
+  VVS2_0(w[0], w[5], w[6], pars->GC_14, amp[0]); 
+  VVS2_0(w[0], w[9], w[6], pars->GC_14, amp[1]); 
+
+
+}
+double Sigma_MDMSM_gu_xchixchiu::matrix_2_gu_xchixchiu() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = +amp[0]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+double Sigma_MDMSM_gu_xchixchiu::matrix_2_gux_xchixchiux() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = -amp[1]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[1][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+
+}  // end namespace Pythia8
diff -rupN Pythia/src/Sigma_MDMSM_ssx_xchixchig.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_ssx_xchixchig.cc
--- Pythia/src/Sigma_MDMSM_ssx_xchixchig.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_ssx_xchixchig.cc	2021-03-08 16:53:44.515010169 +1000
@@ -0,0 +1,328 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "Sigma_MDMSM_ssx_xchixchig.h"
+#include "HelAmps_MDMSM.h"
+
+using namespace Pythia8_MDMSM; 
+
+namespace Pythia8 
+{
+
+//==========================================================================
+// Class member functions for calculating the matrix elements for
+// Process: s s~ > ~chi ~chi g NP<=2 WEIGHTED<=3 @2
+
+//--------------------------------------------------------------------------
+// Initialize process.
+
+void Sigma_MDMSM_ssx_xchixchig::initProc() 
+{
+  // Instantiate the model class and set parameters that stay fixed during run
+  pars = Parameters_MDMSM::getInstance(); 
+  pars->setIndependentParameters(particleDataPtr, couplingsPtr, slhaPtr); 
+  pars->setIndependentCouplings(); 
+  // Set massive/massless matrix elements for c/b/mu/tau
+  mcME = particleDataPtr->m0(4); 
+  mbME = particleDataPtr->m0(5); 
+  mmuME = particleDataPtr->m0(13); 
+  mtauME = particleDataPtr->m0(15); 
+  jamp2[0] = new double[1]; 
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, part independent of incoming flavour.
+
+void Sigma_MDMSM_ssx_xchixchig::sigmaKin() 
+{
+  // Set the parameters which change event by event
+  pars->setDependentParameters(particleDataPtr, couplingsPtr, slhaPtr, alpS); 
+  pars->setDependentCouplings(); 
+  // Reset color flows
+  for(int i = 0; i < 1; i++ )
+    jamp2[0][i] = 0.; 
+
+  // Local variables and constants
+  const int ncomb = 32; 
+  static bool goodhel[ncomb] = {ncomb * false}; 
+  static int ntry = 0, sum_hel = 0, ngood = 0; 
+  static int igood[ncomb]; 
+  static int jhel; 
+  double t[nprocesses]; 
+  // Helicities for the process
+  static const int helicities[ncomb][nexternal] = {{-1, -1, -1, -1, -1}, {-1,
+      -1, -1, -1, 1}, {-1, -1, -1, 1, -1}, {-1, -1, -1, 1, 1}, {-1, -1, 1, -1,
+      -1}, {-1, -1, 1, -1, 1}, {-1, -1, 1, 1, -1}, {-1, -1, 1, 1, 1}, {-1, 1,
+      -1, -1, -1}, {-1, 1, -1, -1, 1}, {-1, 1, -1, 1, -1}, {-1, 1, -1, 1, 1},
+      {-1, 1, 1, -1, -1}, {-1, 1, 1, -1, 1}, {-1, 1, 1, 1, -1}, {-1, 1, 1, 1,
+      1}, {1, -1, -1, -1, -1}, {1, -1, -1, -1, 1}, {1, -1, -1, 1, -1}, {1, -1,
+      -1, 1, 1}, {1, -1, 1, -1, -1}, {1, -1, 1, -1, 1}, {1, -1, 1, 1, -1}, {1,
+      -1, 1, 1, 1}, {1, 1, -1, -1, -1}, {1, 1, -1, -1, 1}, {1, 1, -1, 1, -1},
+      {1, 1, -1, 1, 1}, {1, 1, 1, -1, -1}, {1, 1, 1, -1, 1}, {1, 1, 1, 1, -1},
+      {1, 1, 1, 1, 1}};
+  // Denominators: spins, colors and identical particles
+  const int denominators[nprocesses] = {72, 72}; 
+
+  ntry = ntry + 1; 
+
+  // Reset the matrix elements
+  for(int i = 0; i < nprocesses; i++ )
+  {
+    matrix_element[i] = 0.; 
+    t[i] = 0.; 
+  }
+
+  // Define permutation
+  int perm[nexternal]; 
+  for(int i = 0; i < nexternal; i++ )
+  {
+    perm[i] = i; 
+  }
+
+  // For now, call setupForME() here
+  id1 = 3; 
+  id2 = -3; 
+  if( !setupForME())
+  {
+    return; 
+  }
+
+  if (sum_hel == 0 || ntry < 10)
+  {
+    // Calculate the matrix element for all helicities
+    for(int ihel = 0; ihel < ncomb; ihel++ )
+    {
+      if (goodhel[ihel] || ntry < 2)
+      {
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        t[0] = matrix_2_ssx_xchixchig(); 
+        // Mirror initial state momenta for mirror process
+        perm[0] = 1; 
+        perm[1] = 0; 
+        // Calculate wavefunctions
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        // Mirror back
+        perm[0] = 0; 
+        perm[1] = 1; 
+        // Calculate matrix elements
+        t[1] = matrix_2_ssx_xchixchig(); 
+        double tsum = 0; 
+        for(int iproc = 0; iproc < nprocesses; iproc++ )
+        {
+          matrix_element[iproc] += t[iproc]; 
+          tsum += t[iproc]; 
+        }
+        // Store which helicities give non-zero result
+        if (tsum != 0. && !goodhel[ihel])
+        {
+          goodhel[ihel] = true; 
+          ngood++; 
+          igood[ngood] = ihel; 
+        }
+      }
+    }
+    jhel = 0; 
+    sum_hel = min(sum_hel, ngood); 
+  }
+  else
+  {
+    // Only use the "good" helicities
+    for(int j = 0; j < sum_hel; j++ )
+    {
+      jhel++; 
+      if (jhel >= ngood)
+        jhel = 0; 
+      double hwgt = double(ngood)/double(sum_hel); 
+      int ihel = igood[jhel]; 
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      t[0] = matrix_2_ssx_xchixchig(); 
+      // Mirror initial state momenta for mirror process
+      perm[0] = 1; 
+      perm[1] = 0; 
+      // Calculate wavefunctions
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      // Mirror back
+      perm[0] = 0; 
+      perm[1] = 1; 
+      // Calculate matrix elements
+      t[1] = matrix_2_ssx_xchixchig(); 
+      for(int iproc = 0; iproc < nprocesses; iproc++ )
+      {
+        matrix_element[iproc] += t[iproc] * hwgt; 
+      }
+    }
+  }
+
+  for (int i = 0; i < nprocesses; i++ )
+    matrix_element[i] /= denominators[i]; 
+
+
+
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, including incoming flavour dependence.
+
+double Sigma_MDMSM_ssx_xchixchig::sigmaHat() 
+{
+  // Select between the different processes
+  if(id1 == -3 && id2 == 3)
+  {
+    // Add matrix elements for processes with beams (-3, 3)
+    return matrix_element[1]; 
+  }
+  else if(id1 == 3 && id2 == -3)
+  {
+    // Add matrix elements for processes with beams (3, -3)
+    return matrix_element[0]; 
+  }
+  else
+  {
+    // Return 0 if not correct initial state assignment
+    return 0.; 
+  }
+}
+
+//--------------------------------------------------------------------------
+// Select identity, colour and anticolour.
+
+void Sigma_MDMSM_ssx_xchixchig::setIdColAcol() 
+{
+  if(id1 == -3 && id2 == 3)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, 21}}; 
+    vector<double> probs; 
+    double sum = matrix_element[1]; 
+    probs.push_back(matrix_element[1]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 3 && id2 == -3)
+  {
+    // Pick one of the flavor combinations (52, 52, 21)
+    int flavors[1][3] = {{52, 52, 21}}; 
+    vector<double> probs; 
+    double sum = matrix_element[0]; 
+    probs.push_back(matrix_element[0]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  setId(id1, id2, id3, id4, id5); 
+  // Pick color flow
+  int ncolor[1] = {1}; 
+  if((id1 == 3 && id2 == -3 && id3 == 52 && id4 == 52 && id5 == 21))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{2, 0, 0, 1, 0, 0, 0, 0, 2, 1}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == -3 && id2 == 3 && id3 == 52 && id4 == 52 && id5 == 21))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{0, 1, 2, 0, 0, 0, 0, 0, 2, 1}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+}
+
+//--------------------------------------------------------------------------
+// Evaluate weight for angles of decay products in process
+
+double Sigma_MDMSM_ssx_xchixchig::weightDecay(Event& process, int iResBeg, int
+    iResEnd)
+{
+  // Just use isotropic decay (default)
+  return 1.; 
+}
+
+//==========================================================================
+// Private class member functions
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2 for each subprocess
+
+void Sigma_MDMSM_ssx_xchixchig::calculate_wavefunctions(const int perm[], const
+    int hel[])
+{
+  // Calculate wavefunctions for all processes
+  double p[nexternal][4]; 
+  int i; 
+
+  // Convert Pythia 4-vectors to double[]
+  for(i = 0; i < nexternal; i++ )
+  {
+    p[i][0] = pME[i].e(); 
+    p[i][1] = pME[i].px(); 
+    p[i][2] = pME[i].py(); 
+    p[i][3] = pME[i].pz(); 
+  }
+
+  // Calculate all wavefunctions
+  ixxxxx(p[perm[0]], mME[0], hel[0], +1, w[0]); 
+  oxxxxx(p[perm[1]], mME[1], hel[1], -1, w[1]); 
+  ixxxxx(p[perm[2]], mME[2], hel[2], -1, w[2]); 
+  oxxxxx(p[perm[3]], mME[3], hel[3], +1, w[3]); 
+  vxxxxx(p[perm[4]], mME[4], hel[4], +1, w[4]); 
+  FFV1P0_3(w[0], w[1], pars->GC_11, pars->ZERO, pars->ZERO, w[5]); 
+  FFS1_3(w[2], w[3], pars->GC_13, pars->mdl_mY, pars->mdl_wY, w[6]); 
+
+  // Calculate all amplitudes
+  // Amplitude(s) for diagram number 0
+  VVS2_0(w[4], w[5], w[6], pars->GC_14, amp[0]); 
+
+
+}
+double Sigma_MDMSM_ssx_xchixchig::matrix_2_ssx_xchixchig() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = +amp[0]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+
+}  // end namespace Pythia8
diff -rupN Pythia/src/Sigma_MDMSM_uux_xchixchig.cc /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_uux_xchixchig.cc
--- Pythia/src/Sigma_MDMSM_uux_xchixchig.cc	1970-01-01 10:00:00.000000000 +1000
+++ /home/christopher/GAMBIT/TestExtraColliderProcesses/PushtoGadi/gambit/gum/Outputs/MDMSM/MadGraph5_aMC/Pythia_patched/src/Sigma_MDMSM_uux_xchixchig.cc	2021-03-08 16:53:44.359001603 +1000
@@ -0,0 +1,328 @@
+//==========================================================================
+// This file has been automatically generated for Pythia 8 by
+// MadGraph5_aMC@NLO v. 2.8.3.2, 2021-02-02
+// By the MadGraph5_aMC@NLO Development Team
+// Visit launchpad.net/madgraph5 and amcatnlo.web.cern.ch
+//==========================================================================
+
+#include "Sigma_MDMSM_uux_xchixchig.h"
+#include "HelAmps_MDMSM.h"
+
+using namespace Pythia8_MDMSM; 
+
+namespace Pythia8 
+{
+
+//==========================================================================
+// Class member functions for calculating the matrix elements for
+// Process: u u~ > ~chi ~chi g NP<=2 WEIGHTED<=3 @2
+
+//--------------------------------------------------------------------------
+// Initialize process.
+
+void Sigma_MDMSM_uux_xchixchig::initProc() 
+{
+  // Instantiate the model class and set parameters that stay fixed during run
+  pars = Parameters_MDMSM::getInstance(); 
+  pars->setIndependentParameters(particleDataPtr, couplingsPtr, slhaPtr); 
+  pars->setIndependentCouplings(); 
+  // Set massive/massless matrix elements for c/b/mu/tau
+  mcME = particleDataPtr->m0(4); 
+  mbME = particleDataPtr->m0(5); 
+  mmuME = particleDataPtr->m0(13); 
+  mtauME = particleDataPtr->m0(15); 
+  jamp2[0] = new double[1]; 
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, part independent of incoming flavour.
+
+void Sigma_MDMSM_uux_xchixchig::sigmaKin() 
+{
+  // Set the parameters which change event by event
+  pars->setDependentParameters(particleDataPtr, couplingsPtr, slhaPtr, alpS); 
+  pars->setDependentCouplings(); 
+  // Reset color flows
+  for(int i = 0; i < 1; i++ )
+    jamp2[0][i] = 0.; 
+
+  // Local variables and constants
+  const int ncomb = 32; 
+  static bool goodhel[ncomb] = {ncomb * false}; 
+  static int ntry = 0, sum_hel = 0, ngood = 0; 
+  static int igood[ncomb]; 
+  static int jhel; 
+  double t[nprocesses]; 
+  // Helicities for the process
+  static const int helicities[ncomb][nexternal] = {{-1, -1, -1, -1, -1}, {-1,
+      -1, -1, -1, 1}, {-1, -1, -1, 1, -1}, {-1, -1, -1, 1, 1}, {-1, -1, 1, -1,
+      -1}, {-1, -1, 1, -1, 1}, {-1, -1, 1, 1, -1}, {-1, -1, 1, 1, 1}, {-1, 1,
+      -1, -1, -1}, {-1, 1, -1, -1, 1}, {-1, 1, -1, 1, -1}, {-1, 1, -1, 1, 1},
+      {-1, 1, 1, -1, -1}, {-1, 1, 1, -1, 1}, {-1, 1, 1, 1, -1}, {-1, 1, 1, 1,
+      1}, {1, -1, -1, -1, -1}, {1, -1, -1, -1, 1}, {1, -1, -1, 1, -1}, {1, -1,
+      -1, 1, 1}, {1, -1, 1, -1, -1}, {1, -1, 1, -1, 1}, {1, -1, 1, 1, -1}, {1,
+      -1, 1, 1, 1}, {1, 1, -1, -1, -1}, {1, 1, -1, -1, 1}, {1, 1, -1, 1, -1},
+      {1, 1, -1, 1, 1}, {1, 1, 1, -1, -1}, {1, 1, 1, -1, 1}, {1, 1, 1, 1, -1},
+      {1, 1, 1, 1, 1}};
+  // Denominators: spins, colors and identical particles
+  const int denominators[nprocesses] = {72, 72}; 
+
+  ntry = ntry + 1; 
+
+  // Reset the matrix elements
+  for(int i = 0; i < nprocesses; i++ )
+  {
+    matrix_element[i] = 0.; 
+    t[i] = 0.; 
+  }
+
+  // Define permutation
+  int perm[nexternal]; 
+  for(int i = 0; i < nexternal; i++ )
+  {
+    perm[i] = i; 
+  }
+
+  // For now, call setupForME() here
+  id1 = 2; 
+  id2 = -2; 
+  if( !setupForME())
+  {
+    return; 
+  }
+
+  if (sum_hel == 0 || ntry < 10)
+  {
+    // Calculate the matrix element for all helicities
+    for(int ihel = 0; ihel < ncomb; ihel++ )
+    {
+      if (goodhel[ihel] || ntry < 2)
+      {
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        t[0] = matrix_2_uux_xchixchig(); 
+        // Mirror initial state momenta for mirror process
+        perm[0] = 1; 
+        perm[1] = 0; 
+        // Calculate wavefunctions
+        calculate_wavefunctions(perm, helicities[ihel]); 
+        // Mirror back
+        perm[0] = 0; 
+        perm[1] = 1; 
+        // Calculate matrix elements
+        t[1] = matrix_2_uux_xchixchig(); 
+        double tsum = 0; 
+        for(int iproc = 0; iproc < nprocesses; iproc++ )
+        {
+          matrix_element[iproc] += t[iproc]; 
+          tsum += t[iproc]; 
+        }
+        // Store which helicities give non-zero result
+        if (tsum != 0. && !goodhel[ihel])
+        {
+          goodhel[ihel] = true; 
+          ngood++; 
+          igood[ngood] = ihel; 
+        }
+      }
+    }
+    jhel = 0; 
+    sum_hel = min(sum_hel, ngood); 
+  }
+  else
+  {
+    // Only use the "good" helicities
+    for(int j = 0; j < sum_hel; j++ )
+    {
+      jhel++; 
+      if (jhel >= ngood)
+        jhel = 0; 
+      double hwgt = double(ngood)/double(sum_hel); 
+      int ihel = igood[jhel]; 
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      t[0] = matrix_2_uux_xchixchig(); 
+      // Mirror initial state momenta for mirror process
+      perm[0] = 1; 
+      perm[1] = 0; 
+      // Calculate wavefunctions
+      calculate_wavefunctions(perm, helicities[ihel]); 
+      // Mirror back
+      perm[0] = 0; 
+      perm[1] = 1; 
+      // Calculate matrix elements
+      t[1] = matrix_2_uux_xchixchig(); 
+      for(int iproc = 0; iproc < nprocesses; iproc++ )
+      {
+        matrix_element[iproc] += t[iproc] * hwgt; 
+      }
+    }
+  }
+
+  for (int i = 0; i < nprocesses; i++ )
+    matrix_element[i] /= denominators[i]; 
+
+
+
+}
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2, including incoming flavour dependence.
+
+double Sigma_MDMSM_uux_xchixchig::sigmaHat() 
+{
+  // Select between the different processes
+  if(id1 == -2 && id2 == 2)
+  {
+    // Add matrix elements for processes with beams (-2, 2)
+    return matrix_element[1]; 
+  }
+  else if(id1 == 2 && id2 == -2)
+  {
+    // Add matrix elements for processes with beams (2, -2)
+    return matrix_element[0]; 
+  }
+  else
+  {
+    // Return 0 if not correct initial state assignment
+    return 0.; 
+  }
+}
+
+//--------------------------------------------------------------------------
+// Select identity, colour and anticolour.
+
+void Sigma_MDMSM_uux_xchixchig::setIdColAcol() 
+{
+  if(id1 == -2 && id2 == 2)
+  {
+    // Pick one of the flavor combinations
+    int flavors[1][3] = {{52, 52, 21}}; 
+    vector<double> probs; 
+    double sum = matrix_element[1]; 
+    probs.push_back(matrix_element[1]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  else if(id1 == 2 && id2 == -2)
+  {
+    // Pick one of the flavor combinations (52, 52, 21)
+    int flavors[1][3] = {{52, 52, 21}}; 
+    vector<double> probs; 
+    double sum = matrix_element[0]; 
+    probs.push_back(matrix_element[0]/sum); 
+    int choice = rndmPtr->pick(probs); 
+    id3 = flavors[choice][0]; 
+    id4 = flavors[choice][1]; 
+    id5 = flavors[choice][2]; 
+  }
+  setId(id1, id2, id3, id4, id5); 
+  // Pick color flow
+  int ncolor[1] = {1}; 
+  if((id1 == 2 && id2 == -2 && id3 == 52 && id4 == 52 && id5 == 21))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{2, 0, 0, 1, 0, 0, 0, 0, 2, 1}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+  else if((id1 == -2 && id2 == 2 && id3 == 52 && id4 == 52 && id5 == 21))
+  {
+    vector<double> probs; 
+    double sum = jamp2[0][0]; 
+    for(int i = 0; i < ncolor[0]; i++ )
+      probs.push_back(jamp2[0][i]/sum); 
+    int ic = rndmPtr->pick(probs); 
+    static int colors[1][10] = {{0, 1, 2, 0, 0, 0, 0, 0, 2, 1}}; 
+    setColAcol(colors[ic][0], colors[ic][1], colors[ic][2], colors[ic][3],
+        colors[ic][4], colors[ic][5], colors[ic][6], colors[ic][7],
+        colors[ic][8], colors[ic][9]);
+  }
+}
+
+//--------------------------------------------------------------------------
+// Evaluate weight for angles of decay products in process
+
+double Sigma_MDMSM_uux_xchixchig::weightDecay(Event& process, int iResBeg, int
+    iResEnd)
+{
+  // Just use isotropic decay (default)
+  return 1.; 
+}
+
+//==========================================================================
+// Private class member functions
+
+//--------------------------------------------------------------------------
+// Evaluate |M|^2 for each subprocess
+
+void Sigma_MDMSM_uux_xchixchig::calculate_wavefunctions(const int perm[], const
+    int hel[])
+{
+  // Calculate wavefunctions for all processes
+  double p[nexternal][4]; 
+  int i; 
+
+  // Convert Pythia 4-vectors to double[]
+  for(i = 0; i < nexternal; i++ )
+  {
+    p[i][0] = pME[i].e(); 
+    p[i][1] = pME[i].px(); 
+    p[i][2] = pME[i].py(); 
+    p[i][3] = pME[i].pz(); 
+  }
+
+  // Calculate all wavefunctions
+  ixxxxx(p[perm[0]], mME[0], hel[0], +1, w[0]); 
+  oxxxxx(p[perm[1]], mME[1], hel[1], -1, w[1]); 
+  ixxxxx(p[perm[2]], mME[2], hel[2], -1, w[2]); 
+  oxxxxx(p[perm[3]], mME[3], hel[3], +1, w[3]); 
+  vxxxxx(p[perm[4]], mME[4], hel[4], +1, w[4]); 
+  FFV1P0_3(w[0], w[1], pars->GC_11, pars->ZERO, pars->ZERO, w[5]); 
+  FFS1_3(w[2], w[3], pars->GC_13, pars->mdl_mY, pars->mdl_wY, w[6]); 
+
+  // Calculate all amplitudes
+  // Amplitude(s) for diagram number 0
+  VVS2_0(w[4], w[5], w[6], pars->GC_14, amp[0]); 
+
+
+}
+double Sigma_MDMSM_uux_xchixchig::matrix_2_uux_xchixchig() 
+{
+  int i, j; 
+  // Local variables
+  const int ngraphs = 1; 
+  const int ncolor = 1; 
+  std::complex<double> ztemp; 
+  std::complex<double> jamp[ncolor]; 
+  // The color matrix;
+  static const double denom[ncolor] = {1}; 
+  static const double cf[ncolor][ncolor] = {{4}}; 
+
+  // Calculate color flows
+  jamp[0] = +amp[0]; 
+
+  // Sum and square the color flows to get the matrix element
+  double matrix = 0; 
+  for(i = 0; i < ncolor; i++ )
+  {
+    ztemp = 0.; 
+    for(j = 0; j < ncolor; j++ )
+      ztemp = ztemp + cf[i][j] * jamp[j]; 
+    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
+  }
+
+  // Store the leading color flows for choice of color
+  for(i = 0; i < ncolor; i++ )
+    jamp2[0][i] += real(jamp[i] * conj(jamp[i])); 
+
+  return matrix; 
+}
+
+
+}  // end namespace Pythia8
