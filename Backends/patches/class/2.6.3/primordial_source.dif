*** ../../Backends/installed/class/2.6.3/source/primordial.c	2017-10-24 14:42:41.000000000 +0100
--- ../../Backends/include/gambit/Backends/backend_types/class_types/gambit_update/primordial.c	2018-08-30 12:56:31.000000000 +0100
***************
*** 79,87 ****
  
    /** - if ln(k) is not in the interpolation range, return an error, unless
        we are in the case of a analytic spectrum, for which a direct computation is possible */
! 
    if ((lnk > ppm->lnk[ppm->lnk_size-1]) || (lnk < ppm->lnk[0])) {
! 
      class_test(ppm->primordial_spec_type != analytic_Pk,
                 ppm->error_message,
                 "k=%e out of range [%e : %e]",exp(lnk),exp(ppm->lnk[0]),exp(ppm->lnk[ppm->lnk_size-1]));
--- 79,87 ----
  
    /** - if ln(k) is not in the interpolation range, return an error, unless
        we are in the case of a analytic spectrum, for which a direct computation is possible */
! 								 
    if ((lnk > ppm->lnk[ppm->lnk_size-1]) || (lnk < ppm->lnk[0])) {
! 		
      class_test(ppm->primordial_spec_type != analytic_Pk,
                 ppm->error_message,
                 "k=%e out of range [%e : %e]",exp(lnk),exp(ppm->lnk[0]),exp(ppm->lnk[ppm->lnk_size-1]));
***************
*** 128,134 ****
        }
      }
    }
- 
    /** - otherwise, interpolate in the pre-computed table */
  
    else {
--- 128,133 ----
***************
*** 148,154 ****
                 ppm->error_message);
  
      /* if mode==logarithmic, output is already in the correct format. Otherwise, apply necessary transformation. */
! 
      if (mode == linear) {
  
        for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
--- 147,153 ----
                 ppm->error_message);
  
      /* if mode==logarithmic, output is already in the correct format. Otherwise, apply necessary transformation. */
! 	  
      if (mode == linear) {
  
        for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
***************
*** 169,175 ****
        }
      }
    }
- 
    return _SUCCESS_;
  
  }
--- 168,173 ----
***************
*** 211,217 ****
    }
    else {
      if (ppm->primordial_verbose > 0)
!       printf("Computing primordial spectra");
    }
  
    /** - get kmin and kmax from perturbation structure. Test that they make sense. */
--- 209,215 ----
    }
    else {
      if (ppm->primordial_verbose > 0)
!       printf("Computing primordial spectra \n");
    }
  
    /** - get kmin and kmax from perturbation structure. Test that they make sense. */
***************
*** 241,264 ****
               ppr->k_per_decade_primordial);
  
    /** - allocate and fill values of \f$ \ln{k}\f$'s */
  
!   class_call(primordial_get_lnk_list(ppm,
!                                      k_min,
!                                      k_max,
!                                      ppr->k_per_decade_primordial
!                                      ),
               ppm->error_message,
               ppm->error_message);
! 
    /** - define indices and allocate tables in primordial structure */
  
!   class_call(primordial_indices(ppt,
!                                 ppm),
               ppm->error_message,
               ppm->error_message);
! 
    /** - deal with case of analytic primordial spectra (with amplitudes, tilts, runnings, etc.) */
- 
    if (ppm->primordial_spec_type == analytic_Pk) {
  
      if (ppm->primordial_verbose > 0)
--- 239,266 ----
               ppr->k_per_decade_primordial);
  
    /** - allocate and fill values of \f$ \ln{k}\f$'s */
+   // SH: skip if the power spectrum is filled by GAMBIT
+   if ( ppm->primordial_spec_type != gambit_Pk) {
  
!     class_call(primordial_get_lnk_list(ppm,
!                                        k_min,
!                                        k_max,
!                                        ppr->k_per_decade_primordial
!                                        ),
               ppm->error_message,
               ppm->error_message);
!   }
    /** - define indices and allocate tables in primordial structure */
+   // SH: skip if the power spectrum is filled by GAMBIT
+   if ( ppm->primordial_spec_type != gambit_Pk) {
  
! 	class_call(primordial_indices(ppt,
! 								  ppm),
               ppm->error_message,
               ppm->error_message);
!   }
! 	
    /** - deal with case of analytic primordial spectra (with amplitudes, tilts, runnings, etc.) */
    if (ppm->primordial_spec_type == analytic_Pk) {
  
      if (ppm->primordial_verbose > 0)
***************
*** 393,399 ****
                        ppm->error_message,
                        primordial_free(ppm));
    }
! 
    else {
  
      class_test(0==0,
--- 395,417 ----
                        ppm->error_message,
                        primordial_free(ppm));
    }
!   /* ----------------   SH ---------------- */
! 	
!   else if (ppm->primordial_spec_type == gambit_Pk) {
! 	  
!     class_test(ppt->has_scalars == _FALSE_,
! 				 ppm->error_message,
! 				 "external Pk module cannot work if you do not ask for scalar modes");
! 	  
!     class_test(ppt->has_vectors == _TRUE_,
! 				 ppm->error_message,
! 				 "external Pk module cannot work if you ask for vector modes");
! 		
!    /* ------------------------------------- */
! 	  
! 	  
! 	  
!   }
    else {
  
      class_test(0==0,
***************
*** 405,411 ****
    /** - compute second derivative of each \f$ \ln{P_k} \f$ versus lnk with spline, in view of interpolation */
  
    for (index_md = 0; index_md < ppm->md_size; index_md++) {
! 
      class_call(array_spline_table_lines(ppm->lnk,
                                          ppm->lnk_size,
                                          ppm->lnpk[index_md],
--- 423,429 ----
    /** - compute second derivative of each \f$ \ln{P_k} \f$ versus lnk with spline, in view of interpolation */
  
    for (index_md = 0; index_md < ppm->md_size; index_md++) {
! 		
      class_call(array_spline_table_lines(ppm->lnk,
                                          ppm->lnk_size,
                                          ppm->lnpk[index_md],
***************
*** 439,449 ****
                                            ppt->index_md_scalars,
                                            logarithmic,
                                            log(ppm->k_pivot)+dlnk,
- 
                                            &lnpk_plus),
                   ppm->error_message,
                   ppm->error_message);
! 
        class_call(primordial_spectrum_at_k(ppm,
                                            ppt->index_md_scalars,
                                            logarithmic,
--- 457,466 ----
                                            ppt->index_md_scalars,
                                            logarithmic,
                                            log(ppm->k_pivot)+dlnk,
                                            &lnpk_plus),
                   ppm->error_message,
                   ppm->error_message);
! 		
        class_call(primordial_spectrum_at_k(ppm,
                                            ppt->index_md_scalars,
                                            logarithmic,
***************
*** 451,457 ****
                                            &lnpk_minus),
                   ppm->error_message,
                   ppm->error_message);
! 
        ppm->A_s = exp(lnpk_pivot);
        ppm->n_s = (lnpk_plus-lnpk_minus)/(2.*dlnk)+1.;
        ppm->alpha_s = (lnpk_plus-2.*lnpk_pivot+lnpk_minus)/pow(dlnk,2);
--- 468,474 ----
                                            &lnpk_minus),
                   ppm->error_message,
                   ppm->error_message);
! 		
        ppm->A_s = exp(lnpk_pivot);
        ppm->n_s = (lnpk_plus-lnpk_minus)/(2.*dlnk)+1.;
        ppm->alpha_s = (lnpk_plus-2.*lnpk_pivot+lnpk_minus)/pow(dlnk,2);
***************
*** 493,502 ****
  
        ppm->beta_s = (lnpk_plusplus-2.*lnpk_plus+2.*lnpk_minus-lnpk_minusminus)/pow(dlnk,3);
  
-       if (ppm->primordial_verbose > 0)
-         printf(" -> A_s=%g  n_s=%g  alpha_s=%g\n",ppm->A_s,ppm->n_s,ppm->alpha_s);
- 
      }
  
      if (ppt->has_tensors == _TRUE_) {
  
--- 510,519 ----
  
        ppm->beta_s = (lnpk_plusplus-2.*lnpk_plus+2.*lnpk_minus-lnpk_minusminus)/pow(dlnk,3);
  
      }
+ 	  
+ 	if (ppm->primordial_verbose > 0)
+ 	  printf(" -> A_s=%g  n_s=%g  alpha_s=%g\n",ppm->A_s,ppm->n_s,ppm->alpha_s);
  
      if (ppt->has_tensors == _TRUE_) {
  
