*** ../../Backends/installed/class/2.6.3/source/primordial.c	2018-09-10 17:06:10.000000000 +0100
--- ../../Backends/include/gambit/Backends/backend_types/class_types/gambit_update/primordial_with_smash.c	2018-09-15 23:31:58.000000000 +0100
***************
*** 63,69 ****
  
    int index_ic1,index_ic2,index_ic1_ic2;
    double lnk;
-   int last_index;
  
    /** - infer ln(k) from input. In linear mode, reject negative value of input k value. */
  
--- 63,68 ----
***************
*** 79,87 ****
  
    /** - if ln(k) is not in the interpolation range, return an error, unless
        we are in the case of a analytic spectrum, for which a direct computation is possible */
! 
    if ((lnk > ppm->lnk[ppm->lnk_size-1]) || (lnk < ppm->lnk[0])) {
! 
      class_test(ppm->primordial_spec_type != analytic_Pk,
                 ppm->error_message,
                 "k=%e out of range [%e : %e]",exp(lnk),exp(ppm->lnk[0]),exp(ppm->lnk[ppm->lnk_size-1]));
--- 78,86 ----
  
    /** - if ln(k) is not in the interpolation range, return an error, unless
        we are in the case of a analytic spectrum, for which a direct computation is possible */
! 								 
    if ((lnk > ppm->lnk[ppm->lnk_size-1]) || (lnk < ppm->lnk[0])) {
! 		
      class_test(ppm->primordial_spec_type != analytic_Pk,
                 ppm->error_message,
                 "k=%e out of range [%e : %e]",exp(lnk),exp(ppm->lnk[0]),exp(ppm->lnk[ppm->lnk_size-1]));
***************
*** 128,134 ****
        }
      }
    }
- 
    /** - otherwise, interpolate in the pre-computed table */
  
    else {
--- 127,132 ----
***************
*** 140,146 ****
                                          ppm->ddlnpk[index_md],
                                          ppm->ic_ic_size[index_md],
                                          lnk,
!                                         &last_index,
                                          output,
                                          ppm->ic_ic_size[index_md],
                                          ppm->error_message),
--- 138,144 ----
                                          ppm->ddlnpk[index_md],
                                          ppm->ic_ic_size[index_md],
                                          lnk,
!                                         &ppm->last_index,
                                          output,
                                          ppm->ic_ic_size[index_md],
                                          ppm->error_message),
***************
*** 148,154 ****
                 ppm->error_message);
  
      /* if mode==logarithmic, output is already in the correct format. Otherwise, apply necessary transformation. */
! 
      if (mode == linear) {
  
        for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
--- 146,152 ----
                 ppm->error_message);
  
      /* if mode==logarithmic, output is already in the correct format. Otherwise, apply necessary transformation. */
! 	  
      if (mode == linear) {
  
        for (index_ic1 = 0; index_ic1 < ppm->ic_size[index_md]; index_ic1++) {
***************
*** 169,175 ****
        }
      }
    }
- 
    return _SUCCESS_;
  
  }
--- 167,172 ----
***************
*** 197,202 ****
--- 194,202 ----
    int index_md,index_ic1,index_ic2,index_ic1_ic2,index_k;
    double pk,pk1,pk2;
    double dlnk,lnpk_pivot,lnpk_minus,lnpk_plus,lnpk_minusminus,lnpk_plusplus;
+ 	
+ 	int pot_index; // SCH: related to smash inflation
+ 	double dchidrho;// SCH: related to smash inflation
    /* uncomment if you use optional test below
       (for correlated isocurvature modes) */
    //double cos_delta_k;
***************
*** 211,217 ****
    }
    else {
      if (ppm->primordial_verbose > 0)
!       printf("Computing primordial spectra");
    }
  
    /** - get kmin and kmax from perturbation structure. Test that they make sense. */
--- 211,217 ----
    }
    else {
      if (ppm->primordial_verbose > 0)
!       printf("Computing primordial spectra \n");
    }
  
    /** - get kmin and kmax from perturbation structure. Test that they make sense. */
***************
*** 241,264 ****
               ppr->k_per_decade_primordial);
  
    /** - allocate and fill values of \f$ \ln{k}\f$'s */
  
!   class_call(primordial_get_lnk_list(ppm,
!                                      k_min,
!                                      k_max,
!                                      ppr->k_per_decade_primordial
!                                      ),
               ppm->error_message,
               ppm->error_message);
! 
    /** - define indices and allocate tables in primordial structure */
  
!   class_call(primordial_indices(ppt,
!                                 ppm),
               ppm->error_message,
               ppm->error_message);
  
    /** - deal with case of analytic primordial spectra (with amplitudes, tilts, runnings, etc.) */
- 
    if (ppm->primordial_spec_type == analytic_Pk) {
  
      if (ppm->primordial_verbose > 0)
--- 241,270 ----
               ppr->k_per_decade_primordial);
  
    /** - allocate and fill values of \f$ \ln{k}\f$'s */
+   // SH: skip if the power spectrum is filled by GAMBIT
+   if ( ppm->primordial_spec_type != gambit_Pk) {
  
!     class_call(primordial_get_lnk_list(ppm,
!                                        k_min,
!                                        k_max,
!                                        ppr->k_per_decade_primordial
!                                        ),
               ppm->error_message,
               ppm->error_message);
!   }
    /** - define indices and allocate tables in primordial structure */
+   // SH: skip if the power spectrum is filled by GAMBIT
+   if ( ppm->primordial_spec_type != gambit_Pk) {
  
! 	class_call(primordial_indices(ppt,
! 								  ppm),
               ppm->error_message,
               ppm->error_message);
+   }
+ 	printf(" we are outside setting primordial stuff\n");
  
+ 	
    /** - deal with case of analytic primordial spectra (with amplitudes, tilts, runnings, etc.) */
    if (ppm->primordial_spec_type == analytic_Pk) {
  
      if (ppm->primordial_verbose > 0)
***************
*** 362,373 ****
--- 368,488 ----
      if (ppm->primordial_verbose > 0)
        printf(" (simulating inflation)\n");
  
+ 		if ( ppm->potential == smash_inflation ){
+ 			
+ 			printf("creating smash inflation arrays\n");
+ 
+ 			ppm->last_index = 0;
+ 			// silly at the moment - fix soon.
+ 			ppm->max_pot_smash = 10000;
+ 			
+ 			class_alloc(ppm->rho_array,ppm->max_pot_smash*sizeof(double),ppm->error_message);
+ 			class_alloc(ppm->chi_array,ppm->max_pot_smash*sizeof(double),ppm->error_message);
+ 			class_alloc(ppm->d0V_array,ppm->max_pot_smash*sizeof(double),ppm->error_message);
+ 			class_alloc(ppm->d1V_array,ppm->max_pot_smash*sizeof(double),ppm->error_message);
+ 			class_alloc(ppm->d2V_array,ppm->max_pot_smash*sizeof(double),ppm->error_message);
+ 			class_alloc(ppm->d3V_array,ppm->max_pot_smash*sizeof(double),ppm->error_message);
+ 
+ 			class_alloc(ppm->ddd0V_array,ppm->max_pot_smash*sizeof(double),ppm->error_message);
+ 			class_alloc(ppm->ddd1V_array,ppm->max_pot_smash*sizeof(double),ppm->error_message);
+ 			class_alloc(ppm->ddd2V_array,ppm->max_pot_smash*sizeof(double),ppm->error_message);
+ 			class_alloc(ppm->ddd3V_array,ppm->max_pot_smash*sizeof(double),ppm->error_message);
+ 			
+ 			ppm->V0 = pow(10.,ppm->V0);
+ 			ppm->V1 = pow(10.,ppm->V1);
+ 			ppm->V3 = pow(10.,ppm->V3);
+ 			
+ //			printf("ppm->V0=%e, and ppm->V1=%e, and ppm->V3=%e\n",ppm->V0,ppm->V1,ppm->V3);
+ 			
+ 			for (pot_index = 0; pot_index<ppm->max_pot_smash; pot_index++){
+ 				ppm->rho_array[pot_index] = 5.*ppm->V2 - (double)pot_index*(1e-3)*ppm->V2;
+ 				// \xi 		= ppm->V0
+ 				// \beta 	= ppm->V1
+ 				// \phi_0 = ppm->V2
+ 				// \lambda= ppm->V3
+ 				ppm->chi_array[pot_index] = ((sqrt(1.+6.*ppm->V0/ppm->V1)*
+ 																		 asinh(sqrt(1.+6.*ppm->V0/ppm->V1)*
+ 																					 sqrt(ppm->V0)*ppm->rho_array[pot_index]) -
+ 																		 sqrt(6.*ppm->V0/ppm->V1) *
+ 																		 asinh(sqrt(6.*ppm->V0/ppm->V1) *
+ 																					 sqrt(ppm->V0)*ppm->rho_array[pot_index]/
+ 																					 sqrt(1.+pow(sqrt(ppm->V0)*ppm->rho_array[pot_index],2)))) /
+ 																		 sqrt(ppm->V0/ppm->V1));
+ 				
+ 				ppm->d0V_array[pot_index] = (ppm->V3/4.*pow(ppm->rho_array[pot_index],4)
+ 																		 /pow(1.+ppm->V0*pow(ppm->rho_array[pot_index],2),2));
+ 
+ 
+ 				dchidrho = (sqrt(ppm->V1*(1.+ppm->V0*pow(ppm->rho_array[pot_index],2)) +
+ 												 6.*pow(ppm->V0,2)*pow(ppm->rho_array[pot_index],2)) /
+ 										(1.+ppm->V0*pow(ppm->rho_array[pot_index],2)));
+ 				
+ 				ppm->d1V_array[pot_index] = ((ppm->V3*pow(ppm->rho_array[pot_index],3)/dchidrho)
+ 													/pow(1.+ppm->V0*pow(ppm->rho_array[pot_index],2),2)*
+ 													(1.-pow(ppm->rho_array[pot_index],2)*ppm->V0
+ 													 /(1.+ppm->V0*pow(ppm->rho_array[pot_index],2))));
+ 				
+ //				printf("%e, %e\n",ppm->chi_array[pot_index],ppm->d0V_array[pot_index]);
+ 
+ 				if(pot_index>0){
+ 					ppm->d2V_array[pot_index-1] = ((ppm->d1V_array[pot_index]-ppm->d1V_array[pot_index-1])
+ 																				 /(ppm->chi_array[pot_index]-ppm->chi_array[pot_index-1]));
+ 					/* it was suggestive from my MultiModeCode application that there was some issue with setting d3V like this
+ 					 (although I might have fixed that by simply changing indices here.*/
+ 					if(pot_index>1)
+ 						ppm->d3V_array[pot_index-1] = ((ppm->d2V_array[pot_index]-ppm->d2V_array[pot_index-1])
+ 																					 /(ppm->chi_array[pot_index]-ppm->chi_array[pot_index-1]));
+ 				}
+ 			}
+ 			
+ 			if (ppm->primordial_verbose > 0)
+ 				printf(" (creating spline tables for potential)\n");
+ 
+ 			
+ 			class_call(array_spline_table_lines(ppm->chi_array,
+ 																					ppm->max_pot_smash,
+ 																					ppm->d0V_array,
+ 																					1,
+ 																					ppm->ddd0V_array,
+ 																					_SPLINE_EST_DERIV_,
+ 																					ppm->error_message),
+ 								 ppm->error_message,
+ 								 ppm->error_message);
+ 			
+ 			class_call(array_spline_table_lines(ppm->chi_array,
+ 																					ppm->max_pot_smash,
+ 																					ppm->d1V_array,
+ 																					1,
+ 																					ppm->ddd1V_array,
+ 																					_SPLINE_EST_DERIV_,
+ 																					ppm->error_message),
+ 								 ppm->error_message,
+ 								 ppm->error_message);
+ 			
+ 			class_call(array_spline_table_lines(ppm->chi_array,
+ 																					ppm->max_pot_smash,
+ 																					ppm->d2V_array,
+ 																					1,
+ 																					ppm->ddd2V_array,
+ 																					_SPLINE_EST_DERIV_,
+ 																					ppm->error_message),
+ 								 ppm->error_message,
+ 								 ppm->error_message);
+ 			
+ 			
+ 
+ 		}
+ 		
      class_call_except(primordial_inflation_solve_inflation(ppt,ppm,ppr),
                        ppm->error_message,
                        ppm->error_message,
                        primordial_free(ppm));
  
    }
+ 	
+ 	if (ppm->primordial_verbose > 0)
+ 		printf(" (end of inflationary calculations)\n");
+ 
  
    /** - deal with the case of external calculation of \f$ P_k \f$*/
  
***************
*** 393,399 ****
                        ppm->error_message,
                        primordial_free(ppm));
    }
! 
    else {
  
      class_test(0==0,
--- 508,530 ----
                        ppm->error_message,
                        primordial_free(ppm));
    }
!   /* ----------------   SH ---------------- */
! 	
!   else if (ppm->primordial_spec_type == gambit_Pk) {
! 	  
!     class_test(ppt->has_scalars == _FALSE_,
! 				 ppm->error_message,
! 				 "external Pk module cannot work if you do not ask for scalar modes");
! 	  
!     class_test(ppt->has_vectors == _TRUE_,
! 				 ppm->error_message,
! 				 "external Pk module cannot work if you ask for vector modes");
! 		
!    /* ------------------------------------- */
! 	  
! 	  
! 	  
!   }
    else {
  
      class_test(0==0,
***************
*** 405,411 ****
    /** - compute second derivative of each \f$ \ln{P_k} \f$ versus lnk with spline, in view of interpolation */
  
    for (index_md = 0; index_md < ppm->md_size; index_md++) {
! 
      class_call(array_spline_table_lines(ppm->lnk,
                                          ppm->lnk_size,
                                          ppm->lnpk[index_md],
--- 536,542 ----
    /** - compute second derivative of each \f$ \ln{P_k} \f$ versus lnk with spline, in view of interpolation */
  
    for (index_md = 0; index_md < ppm->md_size; index_md++) {
! 		
      class_call(array_spline_table_lines(ppm->lnk,
                                          ppm->lnk_size,
                                          ppm->lnpk[index_md],
***************
*** 439,449 ****
                                            ppt->index_md_scalars,
                                            logarithmic,
                                            log(ppm->k_pivot)+dlnk,
- 
                                            &lnpk_plus),
                   ppm->error_message,
                   ppm->error_message);
! 
        class_call(primordial_spectrum_at_k(ppm,
                                            ppt->index_md_scalars,
                                            logarithmic,
--- 570,579 ----
                                            ppt->index_md_scalars,
                                            logarithmic,
                                            log(ppm->k_pivot)+dlnk,
                                            &lnpk_plus),
                   ppm->error_message,
                   ppm->error_message);
! 		
        class_call(primordial_spectrum_at_k(ppm,
                                            ppt->index_md_scalars,
                                            logarithmic,
***************
*** 451,457 ****
                                            &lnpk_minus),
                   ppm->error_message,
                   ppm->error_message);
! 
        ppm->A_s = exp(lnpk_pivot);
        ppm->n_s = (lnpk_plus-lnpk_minus)/(2.*dlnk)+1.;
        ppm->alpha_s = (lnpk_plus-2.*lnpk_pivot+lnpk_minus)/pow(dlnk,2);
--- 581,587 ----
                                            &lnpk_minus),
                   ppm->error_message,
                   ppm->error_message);
! 		
        ppm->A_s = exp(lnpk_pivot);
        ppm->n_s = (lnpk_plus-lnpk_minus)/(2.*dlnk)+1.;
        ppm->alpha_s = (lnpk_plus-2.*lnpk_pivot+lnpk_minus)/pow(dlnk,2);
***************
*** 493,502 ****
  
        ppm->beta_s = (lnpk_plusplus-2.*lnpk_plus+2.*lnpk_minus-lnpk_minusminus)/pow(dlnk,3);
  
-       if (ppm->primordial_verbose > 0)
-         printf(" -> A_s=%g  n_s=%g  alpha_s=%g\n",ppm->A_s,ppm->n_s,ppm->alpha_s);
- 
      }
  
      if (ppt->has_tensors == _TRUE_) {
  
--- 623,632 ----
  
        ppm->beta_s = (lnpk_plusplus-2.*lnpk_plus+2.*lnpk_minus-lnpk_minusminus)/pow(dlnk,3);
  
      }
+ 	  
+ 	if (ppm->primordial_verbose > 0)
+ 	  printf(" -> A_s=%g  n_s=%g  alpha_s=%g\n",ppm->A_s,ppm->n_s,ppm->alpha_s);
  
      if (ppt->has_tensors == _TRUE_) {
  
***************
*** 969,974 ****
--- 1099,1106 ----
                                     ) {
  
    double e,de,dde,mu,dmu,ddmu,l,dl,ddl,p,dp,ddp;
+ 	
+ 	double xi,beta,lambda;
  
    switch (ppm->potential) {
  
***************
*** 1023,1028 ****
--- 1155,1217 ----
  
      break;
  
+ 			
+ 			/* Higgs-scalar (i.e. smash) inflation*/
+   case smash_inflation:
+ 			
+ 			/*********************************************************************/
+ 			/* Interpolate inflationary potential V at phi := chi.							 */
+ 			/*********************************************************************/
+ 			
+ 			class_call(array_interpolate_spline(ppm->chi_array,
+ 																					ppm->max_pot_smash,
+ 																					ppm->d0V_array,
+ 																					ppm->ddd0V_array,
+ 																					1,
+ 																					phi,
+ 																					&ppm->last_index,
+ 																					V,
+ 																					1,
+ 																					ppm->error_message),
+ 								 ppm->error_message,
+ 								 ppm->error_message);
+ 			
+ 			/*********************************************************************/
+ 			/* Interpolate inflationary potential first derv. dV at phi := chi.	 */
+ 			/*********************************************************************/
+ 			
+ 			class_call(array_interpolate_spline(ppm->chi_array,
+ 																					ppm->max_pot_smash,
+ 																					ppm->d1V_array,
+ 																					ppm->ddd1V_array,
+ 																					1,
+ 																					phi,
+ 																					&ppm->last_index,
+ 																					dV,
+ 																					1,
+ 																					ppm->error_message),
+ 								 ppm->error_message,
+ 								 ppm->error_message);
+ 			
+ 			/*********************************************************************/
+ 			/* Interpolate inflationary potential scnd derv. dV at phi := chi.	 */
+ 			/*********************************************************************/
+ 			
+ 			class_call(array_interpolate_spline(ppm->chi_array,
+ 																					ppm->max_pot_smash,
+ 																					ppm->d2V_array,
+ 																					ppm->ddd2V_array,
+ 																					1,
+ 																					phi,
+ 																					&ppm->last_index,
+ 																					ddV,
+ 																					1,
+ 																					ppm->error_message),
+ 								 ppm->error_message,
+ 								 ppm->error_message);
+ 			
+ 			break;
+ 			
      /* code here other shapes */
  
    default:
***************
*** 1161,1166 ****
--- 1350,1359 ----
                 ppm->error_message);
  
    }
+ 	else if (ppm->primordial_spec_type == inflation_V && ppm->potential == smash_inflation){
+ 		ppm->phi_pivot = -5;
+ 		printf("we have set ppm->phi_pivot to %e\n",ppm->phi_pivot);
+ 	}
    else {
      ppm->phi_pivot = 0.;
    }
***************
*** 2412,2424 ****
  
    class_test(*V <= 0.,
               ppm->error_message,
!              "This potential becomes negative at phi=%g, before the end of observable inflation. It  cannot be treated by this code",
!              phi);
  
    class_test(*dV >= 0.,
               ppm->error_message,
!              "All the code is written for the case dV/dphi<0. Here, in phi=%g, we have dV/dphi=%g. This potential cannot be treated by this code",
!              phi,*dV);
  
    return _SUCCESS_;
  }
--- 2605,2617 ----
  
    class_test(*V <= 0.,
               ppm->error_message,
!              "This potential becomes negative (V=%g) at phi=%g, before the end of observable inflation. It  cannot be treated by this code",
!              *V,phi);
  
    class_test(*dV >= 0.,
               ppm->error_message,
!              "All the code is written for the case dV/dphi<0. Here, in phi=%g, we have dV/dphi=%g. This potential cannot be treated by this code. SCH: Also, V=%g here.",
!              phi,*dV,*V);
  
    return _SUCCESS_;
  }
