*** ../../Backends/installed/class/2.6.3/source/spectra.c	2017-10-24 14:42:41.000000000 +0100
--- ../../Backends/include/gambit/Backends/backend_types/class_types/gambit_update/spectra.c	2018-08-30 12:50:12.000000000 +0100
***************
*** 1242,1248 ****
                   ) {
  
    /** Summary: */
- 
    double TT_II,TT_RI,TT_RR;
    int l1,l2;
  
--- 1242,1247 ----
***************
*** 1420,1426 ****
          /(1.+ppm->f_niv*ppm->f_niv*exp((ppm->n_niv-ppm->n_s)*log(0.1/ppm->k_pivot)));
      }
    }
- 
    return _SUCCESS_;
  }
  
--- 1419,1424 ----
***************
*** 1448,1460 ****
--- 1446,1465 ----
          free(psp->l_max_ct[index_md]);
          free(psp->cl[index_md]);
          free(psp->ddcl[index_md]);
+ 		  
        }
        free(psp->l);
+ 		
        free(psp->l_size);
+ 		
        free(psp->l_max_ct);
+ 		
        free(psp->l_max);
+ 
        free(psp->cl);
+ 		
        free(psp->ddcl);
+ 		
      }
  
      if (psp->ln_k_size > 0) {
***************
*** 1896,1902 ****
    /** - loop over modes (scalar, tensors, etc). For each mode: */
  
    for (index_md = 0; index_md < psp->md_size; index_md++) {
! 
      /** - --> (a) store number of l values for this mode */
  
      psp->l_size[index_md] = ptr->l_size[index_md];
--- 1901,1907 ----
    /** - loop over modes (scalar, tensors, etc). For each mode: */
  
    for (index_md = 0; index_md < psp->md_size; index_md++) {
! 	  
      /** - --> (a) store number of l values for this mode */
  
      psp->l_size[index_md] = ptr->l_size[index_md];
***************
*** 1955,1961 ****
                  This elementary task is assigned to spectra_compute_cl() */
  
              for (index_l=0; index_l < ptr->l_size[index_md]; index_l++) {
! 
  #pragma omp flush(abort)
  
                class_call_parallel(spectra_compute_cl(pba,
--- 1960,1967 ----
                  This elementary task is assigned to spectra_compute_cl() */
  
              for (index_l=0; index_l < ptr->l_size[index_md]; index_l++) {
! 				
! 	
  #pragma omp flush(abort)
  
                class_call_parallel(spectra_compute_cl(pba,
***************
*** 1974,1980 ****
                                                       transfer_ic2),
                                    psp->error_message,
                                    psp->error_message);
! 
              } /* end of loop over l */
  
  #ifdef _OPENMP
--- 1980,1986 ----
                                                       transfer_ic2),
                                    psp->error_message,
                                    psp->error_message);
! 				
              } /* end of loop over l */
  
  #ifdef _OPENMP
***************
*** 1993,1999 ****
  
            } /* end of parallel region */
  
!           if (abort == _TRUE_) return _FAILURE_;
  
          }
          else {
--- 1999,2007 ----
  
            } /* end of parallel region */
  
! 		  if (abort == _TRUE_) {
! 			return _FAILURE_;
! 		  }
  
          }
          else {
***************
*** 2025,2031 ****
                 psp->error_message,
                 psp->error_message);
    }
- 
    return _SUCCESS_;
  
  }
--- 2033,2038 ----
***************
*** 2082,2088 ****
    double * transfer_ic2_nc=NULL;
    double factor;
    int index_q_spline=0;
! 
    index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,psp->ic_size[index_md]);
  
    if (ppt->has_cl_number_count == _TRUE_) {
--- 2089,2095 ----
    double * transfer_ic2_nc=NULL;
    double factor;
    int index_q_spline=0;
! 	
    index_ic1_ic2 = index_symmetric_matrix(index_ic1,index_ic2,psp->ic_size[index_md]);
  
    if (ppt->has_cl_number_count == _TRUE_) {
***************
*** 2092,2106 ****
  
    for (index_q=0; index_q < ptr->q_size; index_q++) {
  
-     //q = ptr->q[index_q];
      k = ptr->k[index_md][index_q];
  
      cl_integrand[index_q*cl_integrand_num_columns+0] = k;
! 
      class_call(primordial_spectrum_at_k(ppm,index_md,linear,k,primordial_pk),
                 ppm->error_message,
                 psp->error_message);
  
      /* above routine checks that k>0: no possible division by zero below */
  
      for (index_tt=0; index_tt < ptr->tt_size[index_md]; index_tt++) {
--- 2099,2116 ----
  
    for (index_q=0; index_q < ptr->q_size; index_q++) {
  
      k = ptr->k[index_md][index_q];
  
      cl_integrand[index_q*cl_integrand_num_columns+0] = k;
! 	  
      class_call(primordial_spectrum_at_k(ppm,index_md,linear,k,primordial_pk),
                 ppm->error_message,
                 psp->error_message);
  
+ //	if(k <= 0.5 && k >= 0.49) {
+ //	  printf("at k = %e -> primordial_pk[0] = %e  and ",k,primordial_pk[0]);
+ //	  printf(" primordial_pk[1] = %e\n",primordial_pk[1]);
+ //	}
      /* above routine checks that k>0: no possible division by zero below */
  
      for (index_tt=0; index_tt < ptr->tt_size[index_md]; index_tt++) {
***************
*** 2195,2201 ****
  
        }
      }
! 
      /* integrand of Cl's */
  
      /* note: we must integrate
--- 2205,2211 ----
  
        }
      }
! 	  
      /* integrand of Cl's */
  
      /* note: we must integrate
