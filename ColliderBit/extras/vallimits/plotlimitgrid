#! /usr/bin/env python

import optparse
op = optparse.OptionParser()
op.add_option("-s", "--save", dest="SAVE", action="store_true", default=False)
opts, args = op.parse_args()
DIR = args[0]
PROC = args[1].lower()

## Set up value arrays
# TODO: automatically compute ranges and steps
import numpy as np
if PROC == "cmssm":
    MX_LABEL = "$M_0$"
    MY_LABEL = "$M_{1/2}$"
    # mx_range = np.arange(300, 1551, 250)
    # my_range = np.arange(300,  871, 30)
    mx_range = np.arange(300, 5801, 250)
    my_range = np.arange(300, 841, 60)
    pt_x_y = (4050, 420)
elif PROC == "crap1000":
    MX_LABEL = "$M_0$"
    MY_LABEL = "$M_{1/2}$"
    mx_range = np.array([1000])
    my_range = np.arange(450, 701, 50)
    pt_x_y = (1000,550)
elif PROC == "crap2000":
    MX_LABEL = "$M_0$"
    MY_LABEL = "$M_{1/2}$"
    mx_range = np.array([2000])
    my_range = np.arange(250, 551, 50)
    pt_x_y = (2000,400)
elif PROC == "crap4000":
    MX_LABEL = "$M_0$"
    MY_LABEL = "$M_{1/2}$"
    mx_range = np.array([4000])
    my_range = np.arange(300, 501, 50)
    pt_x_y = (4000,400)
elif PROC == "ggdcpl":
    MX_LABEL = "$M_{\\tilde{g}}$"
    MY_LABEL = "$M_{\\tilde{\\chi}}$"
    mx_range = np.arange(200, 1601, 50)
    my_range = np.arange(50, 801, 50)
elif PROC == "qqdcpl":
    MX_LABEL = "$M_{\\tilde{q}}$"
    MY_LABEL = "$M_{\\tilde{\\chi}}$"
    mx_range = np.arange(50, 1101, 50)
    my_range = np.arange(50, 551, 50)


xx, yy = np.meshgrid(mx_range, my_range)
# bestdlls = np.full_like(xx, np.nan)
# bestsrs = np.full_like(xx, -1)
obs_sr_llbs, obs_sr_llsbs = {}, {} #< We'll populate these with arrays of LL_{b,s+b} for each SR
exp_sr_llbs, exp_sr_llsbs = {}, {} #< We'll populate this with arrays of LLexp_{b,s+b} for each SR

## Read LLs for each SR and mx-my point from the results files
import os, glob
for i, mx in enumerate(mx_range):
    for j, my in enumerate(my_range):
        fglob = "results*-*_{0:04d}_{1:04d}*.dat".format(mx, my)
        if PROC == "cmssm": #< Martin's naming...
            fglob = "result*-*{0:d}_{1:d}*.dat".format(mx, my)
        #print fglob
        resfiles = glob.glob(os.path.join(DIR, fglob))
        if resfiles:
            with open(resfiles[0], "r") as rf:
                for line in rf:
                    parts = line.strip().split()
                    sr1 = int(parts[1])
                    sr2 = int(parts[2])
                    sr = 10*sr1 + sr2
                    assert len(parts) == 7
                    exp_ll_b = float(parts[3])
                    exp_ll_sb = float(parts[4])
                    obs_ll_b = float(parts[5])
                    obs_ll_sb = float(parts[6])
                    # TODO: create these arrays untransposed, and index backwards?
                    exp_sr_llbs.setdefault(sr, np.full_like(xx.T, np.nan, dtype=np.double))[i,j] = exp_ll_b
                    exp_sr_llsbs.setdefault(sr, np.full_like(xx.T, np.nan, dtype=np.double))[i,j] = exp_ll_sb
                    obs_sr_llbs.setdefault(sr, np.full_like(xx.T, np.nan, dtype=np.double))[i,j] = obs_ll_b
                    obs_sr_llsbs.setdefault(sr, np.full_like(xx.T, np.nan, dtype=np.double))[i,j] = obs_ll_sb
        else:
            print (mx, my), "data file not found"


## Find the expected dLL for each SR
exp_sr_dlls = { sr : exp_sr_llbs[sr] - exp_sr_llsbs[sr] for sr in exp_sr_llbs.keys() }
# for k,v in exp_sr_dll.iteritems(): print(k, "\n", v, "\n\n")
## Find the best such expectation
exp_best_dlls = reduce(np.fmax, exp_sr_dlls.values() + [np.zeros_like(exp_sr_dlls.values()[0])]) #< note cmp to zero

# for sr in (2,5):
#     print exp_sr_dlls[sr]
# print "\nEXP BEST DLLS\n", exp_best_dlls

## Now reverse-engineer which SR gave the best expectation!
exp_best_srs = np.full_like(exp_sr_dlls.values()[0], np.nan)
for i in xrange(exp_best_srs.shape[0]):
    for j in xrange(exp_best_srs.shape[1]):
        for sr, exp_dll in exp_sr_dlls.iteritems():
            if exp_dll[i,j] == exp_best_dlls[i,j]:
                exp_best_srs[i,j] = sr
                break
# print "\nExpected best SRs:\n", exp_best_srs

# print mx_range
# print my_range
# exit(1)


## Define a single point whose LL values are to be printed out in detail
idx_x_y = (mx_range.tolist().index(pt_x_y[0]), my_range.tolist().index(pt_x_y[1]))


print "\nExpected LLs at", pt_x_y
for sr in exp_sr_dlls.keys():
    print sr, ": LL_b_exp =", exp_sr_llbs[sr][idx_x_y], "  LL_s+b_exp =", exp_sr_llsbs[sr][idx_x_y], "  dLL_exp =", exp_sr_dlls[sr][idx_x_y]
print "Best SR, dLL =", int(exp_best_srs[idx_x_y]), exp_best_dlls[idx_x_y]


## Find the scalar LL_b for each SR (should be the same throughout the grid, but some will be NaN)
obs_sr_llb = { sr : np.nanmax(llbs) for (sr, llbs) in obs_sr_llbs.iteritems() }
obs_sr_llbs = { sr : np.full_like(xx.T, obs_llb, dtype=np.double) for (sr, obs_llb) in obs_sr_llb.iteritems() }
# print obs_sr_llb
# print obs_sr_llbs
## Work out the maximum LL for each SR, returned as a full array of maxlls to make dLL computation easy
# sr_maxlls = { sr : np.full_like(xx.T, np.nanmax(lls), dtype=np.double) for (sr, lls) in obs_sr_llsbs.iteritems() }
# print sr_maxlls
## Work out the dLLs for each SR
# sr_dlls = { sr : obs_sr_maxlls[sr] - obs_sr_llsbs[sr] for sr in obs_sr_llsbs.keys() } #< w.r.t. LL_{s+b}^max
obs_sr_dlls = { sr : obs_sr_llbs[sr] - obs_sr_llsbs[sr] for sr in obs_sr_llsbs.keys() } #< w.r.t. LL_b
# print sr_dlls
## Work out the best (most negative) dLL for each point
# TODO: But this loses the info about which SR "won" at each point... can we re-find it?
obs_best_dlls = reduce(np.fmax, obs_sr_dlls.values() + [np.zeros_like(obs_sr_dlls.values()[0])]) #< note cmp to zero
# print bestdlls.T

## Now reverse-engineer which SR gave the best _observed_ limit!
obs_best_srs = np.full_like(obs_sr_dlls.values()[0], np.nan)
for i in xrange(obs_best_srs.shape[0]):
    for j in xrange(obs_best_srs.shape[1]):
        for sr, obs_dll in obs_sr_dlls.iteritems():
            if obs_dll[i,j] == obs_best_dlls[i,j]:
                obs_best_srs[i,j] = sr
                break
# print "\nObserved best SRs:\n", obs_best_srs

print "\nObserved LLs at", pt_x_y
for sr in obs_sr_dlls.keys():
    print sr, ": LL_b_obs =", obs_sr_llbs[sr][idx_x_y], "  LL_s+b_obs =", obs_sr_llsbs[sr][idx_x_y], "  dLL_obs =", obs_sr_dlls[sr][idx_x_y]
print "Best SR, dLL =", int(obs_best_srs[idx_x_y]), obs_best_dlls[idx_x_y]


## We're actually going to plot the observed dLLs in the _expected_ best SR for each point
limit_dlls = np.full_like(xx.T, np.nan, dtype=np.double)
for i in xrange(exp_best_srs.shape[0]):
    for j in xrange(exp_best_srs.shape[1]):
        limit_sr = exp_best_srs[i,j]
        #print limit_sr
        if not np.isnan(limit_sr):
            limit_dlls[i,j] = obs_sr_dlls[limit_sr][i,j]
#print "\ndLL map:\n", limit_dlls

print "\nLimit dLL at", pt_x_y, "=", limit_dlls[idx_x_y]
print "\nLimit dLLs =", limit_dlls


# print
# print "(4050, 420) point exp best SR,DLL =   ", exp_best_srs[idx_4050_420], exp_best_dlls[idx_4050_420]
# print "(4050, 420) point obs DLL in best SR =", obs_sr_dlls[11][idx_4050_420], limit_dlls[idx_4050_420]
# # exit(0)


## Plot dLL filled contours
import matplotlib as mpl
if opts.SAVE:
    mpl.use("PGF")
mpl.rc("font.family = serif")
from matplotlib import pyplot as plt
fig = plt.figure(figsize=[9,6])
ax = fig.add_subplot(1,1,1)
# vals = np.exp(lls.T)
plt.hold(True)
p = ax.contourf(xx, yy, limit_dlls.T)
plt.colorbar(p)

## Highlight the 95% etc. CL contour via dLL = -1/2 chi2(2df, ...)
from scipy import stats
# contour_cls = [2*(stats.norm.cdf(sig) - 0.5) for sig in (1,2)] #< for Gaussian 1, 2 sigma
contour_cls = [0.95] #< for 95% CL
contour_dlls = [stats.chi2.ppf(cl, 2)/2. for cl in contour_cls]
#print contour_dlls
print "95%% contour DLL = %g" % contour_dlls[0]
# print sigdlls
c = plt.contour(xx, yy, limit_dlls.T, contour_dlls, colors="white", linestyles="--") #, linewidths=["2"])
plt.clabel(c, fmt="95%%", fontsize="smaller")

## Write SR values on plot
ax.text(0.95, 0.95, "SR IDs", color="white", ha="right", va="top", transform=ax.transAxes)
for i, mx in enumerate(mx_range):
    for j, my in enumerate(my_range):
        if True: #i % 2 == 0 and j % 2 == 0:
            sr = exp_best_srs[i,j]
            if not np.isnan(sr):
                ax.text(mx, my, str(int(sr)), ha="center", va="center", fontsize="small")

ax.set_title("$\\Delta LL$ contours", x=0, ha="left")
ax.set_xlabel(MX_LABEL, x=1.00, ha="right")
ax.set_ylabel(MY_LABEL, y=0.95, va="top", labelpad=16)

# fig.tight_layout()
if opts.SAVE:
    fig.savefig("atlas0lep-%s-limit.pdf" % PROC)
else:
    plt.show()


def plot_dlls(arr):
    plt.clf()
    plt.hold(True)
    plt.contourf(xx, yy, np.nan_to_num(np.log1p(arr.T)), range(0,9))
    plt.colorbar()
    plt.text(0.95, 0.95, "$\\Delta{LL}$s", color="white", ha="right", va="top", transform=plt.gca().transAxes)
    for i, mx in enumerate(mx_range):
        for j, my in enumerate(my_range):
            dll = arr[i,j]
            if not np.isnan(dll):
                plt.text(mx, my, "%1.0f" % dll, ha="center", va="center", fontsize="x-small")

if opts.SAVE:
    plot_dlls(exp_best_dlls)
    fig.savefig("atlas0lep-%s-expbestdll.pdf" % PROC)

    plot_dlls(obs_best_dlls)
    fig.savefig("atlas0lep-%s-obsbestdll.pdf" % PROC)

    plot_dlls(limit_dlls)
    fig.savefig("atlas0lep-%s-limitdll.pdf" % PROC)
