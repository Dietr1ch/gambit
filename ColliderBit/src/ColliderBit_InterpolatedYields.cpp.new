//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Functions for LHC analyses that use table interpolations
///  rather than direct MC simulation. For now this functionality
///  is specific to the DMEFT model, but it will be turned into
///  a general option in ColliderBit..
///  
///  *********************************************
///
///  Authors (add name and date if you modify):
///
///  \author Martin White
///          (martin.white@adelaide.edu.au)
///
///  \author Andre Scaffidi
///          (andre.scaffidi@adelaide.edu.au)
///  \date 2019 Aug
///
///  \author Tomas Gonzalo
///          (gonzalo@physik.rwth-aachen.de)
///  \date 2021 Apr
///
///  \author Anders Kvellestad
///          (anders.kvellestad@fys.uio.no)
///  \date 2021 May
///
///  Analyses based on: arxiv:1711.03301 and https://journals.aps.org/prd/abstract/10.1103/PhysRevD.97.092005
///  139invfb analysis based on arXiv:2102.10874 
///
///  *********************************************

// Needs GSL 2 
#include <gsl/gsl_math.h>
#include <gsl/gsl_interp2d.h>
#include <gsl/gsl_spline2d.h>
#include <gsl/gsl_sf_gamma.h>

#include "Eigen/Eigenvalues"
#include "Eigen/Eigen"

#include "multimin/multimin.hpp"

#include "gambit/ColliderBit/interp_collection.hpp"
#include "gambit/ColliderBit/analyses/Analysis.hpp"
#include "gambit/Elements/gambit_module_headers.hpp"
#include "gambit/ColliderBit/ColliderBit_rollcall.hpp"
#include "gambit/Utils/ascii_table_reader.hpp"
#include "gambit/Utils/file_lock.hpp"
#include "gambit/ColliderBit/Utils.hpp"


// #define COLLIDERBIT_DEBUG_PROFILING
// #define COLLIDERBIT_DEBUG
// #define DEBUG_PREFIX "DEBUG: OMP thread " << omp_get_thread_num() << ":  "

namespace Gambit
{

  namespace ColliderBit
  {  

    // =========== Useful stuff ===========

    /// A struct with analysis info, currently specific to the DMEFT
    struct DMEFT_analysis_info
    {
      string name;
      double lumi_invfb;

      // int data_INC;
      // int data_INC_d7;
      // int data_SIZE;
      // int data_SIZE_d7;
      // int bin_size;

      size_t n_signal_regions;
      vector<int> OBSNUM;
      vector<double> BKGNUM;
      vector<double> BKGERR;

      vector<double> METMINS;

      // string met_hist_C61_C64;
      // string met_hist_C62_C63;
      // string met_hist_C71;
      // string met_hist_C72;
      // string met_hist_C73;
      // string met_hist_C74;

      map<string,interp1d_collection> interp1d;
      map<string,interp2d_collection> interp2d;
    };
  

    /// A struct to contain parameters for the GSL optimiser target function
    struct _gsl_target_func_params
    {
      float lambda;
      AnalysisDataPointers adata_ptrs_original;
      std::vector<str> skip_analyses;
      bool use_covar;
      bool use_marg;
      bool combine_nocovar_SRs;
    };




    // =========== Forward declarations ===========

    /// Forward declaration of funtion in LHC_likelihoods
    AnalysisLogLikes calc_loglikes_for_analysis(const AnalysisData&, bool, bool, bool, bool);

    /// Forward declarations of functions in this file
    void DMEFT_results_profiled(AnalysisDataPointers&);

    void DMEFT_results_cutoff(AnalysisDataPointers&);

    void DMEFT_results(AnalysisDataPointers&);

    void calc_DMEFT_profiled_LHC_nuisance_params(map_str_dbl&);

    void InterpolatedMCInfo(MCLoopInfo&);


    // double LinearInterpolation(double, double, double, double, double);

    // double BilinearInterpolation(double, double, double, double, 
    //                              double, double, double, double, 
    //                              double, double, double, bool);

    void signal_modifier_function(AnalysisData&, double, double);

    void signal_cutoff_function(AnalysisData&, double);

    // void Acceptance_CS_dim6(vector<double>&, const string, const DMEFT_analysis_info&, double, double, double, double);

    // void Acceptance_CS_dim7(vector<double>&, const string, const DMEFT_analysis_info&, double, double, double);

    // void get_DMEFT_signal_yields(vector<double>&, const DMEFT_analysis_info&, double, double, double, double, double, double, double, double, double, double);
    void get_DMEFT_signal_yields(vector<double>&, const DMEFT_analysis_info&, const Spectrum&);

    void get_DMEFT_signal_yields_dim6(vector<double>&, const string, const DMEFT_analysis_info&, double, double, double, double);

    void get_DMEFT_signal_yields_dim7(vector<double>&, const string, const DMEFT_analysis_info&, double, double, double);

    void _gsl_target_func(const size_t, const double*, void*, double*);



    // =========== Functions ===========

    /// Results from DMEFT analyses after profiling over the 'a' parameter in the smooth cut-off of the MET spectrum
    void DMEFT_results_profiled(AnalysisDataPointers& result)
    {
      using namespace Pipes::DMEFT_results_profiled;

      // Clear previous vectors, etc.
      result.clear();

      // Get the original AnalysisDataPointers that we will adjust
      result = *Dep::AllAnalysisNumbersUnmodified;

      // Get the best-fit nuisance parameter(s)
      map_str_dbl bestfit_nuisance_pars = *Dep::DMEFT_profiled_LHC_nuisance_params;
      float a_bestfit = bestfit_nuisance_pars.at("a");

      // Get Lambda
      const Spectrum& spec = *Dep::DMEFT_spectrum;
      float lambda = spec.get(Par::mass1, "Lambda");

      // Recalculate AnalysisData instances in "result", using the best-fit a-value
      for (AnalysisData* adata_ptr : result)
      {
        signal_modifier_function(*adata_ptr, lambda, a_bestfit);
      }
    }


    /// Results from DMEFT analyses after imposing a hard cut-off of the MET spectrum
    void DMEFT_results_cutoff(AnalysisDataPointers& result)
    {
      using namespace Pipes::DMEFT_results_cutoff;

      // Clear previous vectors, etc.
      result.clear();

      // Get the original AnalysisDataPointers that we will adjust
      result = *Dep::AllAnalysisNumbersUnmodified;

      // Get Lambda
      const Spectrum& spec = *Dep::DMEFT_spectrum;
      float lambda = spec.get(Par::mass1, "Lambda");

      // Apply the function signal_cutoff_function to each of the 
      // AnalysisData instances in "result"
      for (AnalysisData* adata_ptr : result)
      {
        signal_cutoff_function(*adata_ptr, lambda);
      }
    }


    /// Results from DMEFT analyses before any modification of the MET spectrum
    void DMEFT_results(AnalysisDataPointers& result)
    { 
      using namespace Pipes::DMEFT_results;

      static bool first = true;

      // Clear previous vectors, etc.
      result.clear();

      // Create the thread_local AnalysisData instances we need, 
      // and make sure they are properly cleared for each new point
      thread_local AnalysisData analysis_data_CMS("CMS_13TeV_MONOJET_36invfb_interpolated");
      analysis_data_CMS.clear();

      thread_local AnalysisData analysis_data_ATLAS("ATLAS_13TeV_MONOJET_139invfb_interpolated");
      analysis_data_ATLAS.clear();

      // Create the DMEFT_analysis_info instances we need and 
      // initialize them the first time this function is run
      static DMEFT_analysis_info analysis_info_CMS;
      static DMEFT_analysis_info analysis_info_ATLAS;

      if (first)
      {
        vector<string> colnames;

        // 
        // CMS analysis info
        // 

        analysis_info_CMS.name = "CMS_13TeV_MONOJET_36invfb_interpolated";
        analysis_info_CMS.lumi_invfb = 36.1;

        // analysis_info_CMS.data_INC = 15;     // 15 points in both dimensions (mass, theta)
        // analysis_info_CMS.data_SIZE = 225;   // 15 * 15
        // analysis_info_CMS.data_INC_d7 = 19;  // only one dimension (mass)
        // analysis_info_CMS.data_SIZE_d7 = 19; 

        analysis_info_CMS.METMINS = {250., 280., 310., 340., 370., 400., 430., 470., 510., 550., 590.,
                                     640., 690., 740., 790., 840., 900., 960., 1020., 1090., 1160., 1250.}
        analysis_info_CMS.OBSNUM = {136865, 74340, 42540, 25316, 15653, 10092, 8298, 4906, 2987, 2032, 1514,
                                    926, 557, 316, 233, 172, 101, 65, 46, 26, 31, 29};
        analysis_info_CMS.BKGNUM = {134500., 73400., 42320., 25490., 15430., 10160., 8480., 4865., 2970., 1915., 1506.,
                                    844., 526., 325., 223., 169., 107., 88.1, 52.8, 25.0, 25.5, 26.9};
        analysis_info_CMS.BKGERR = {3700., 2000., 810., 490., 310., 170., 140., 95., 49., 33., 32.,
                                    18., 14., 12., 9., 8., 6., 5.3, 3.9, 2.5, 2.6, 2.8};
        assert(analysis_info_CMS.OBSNUM.size() == analysis_info_CMS.METMINS.size());
        assert(analysis_info_CMS.OBSNUM.size() == analysis_info_CMS.BKGERR.size());
        assert(analysis_info_CMS.OBSNUM.size() == analysis_info_CMS.BKGERR.size());
        // analysis_info_CMS.bin_size = analysis_info_CMS.OBSNUM.size(); // = 22
        analysis_info_CMS.n_signal_regions = analysis_info_CMS.OBSNUM.size(); // = 22

        // Create interpolated functions for the CMS analysis
        // - 2d cross-sections
        colnames = {"mass", "theta", "xsec"}
        interp2d["xsec_C61_C64"] = interp2d_collection("mass_theta_xsec_CMS_C61_C64", 
                                                       GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_theta_xsec_CMS_C61_C64.txt", 
                                                       colnames);
        interp2d["xsec_C62_C63"] = interp2d_collection("mass_theta_xsec_CMS_C62_C63", 
                                                       GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_theta_xsec_CMS_C62_C63.txt", 
                                                       colnames);
        // - 1d cross-sections
        colnames = {"mass", "xsec"}
        interp1d["xsec_C71"] = interp1d_collection("mass_xsec_CMS_C71", 
                                                   GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_xsec_CMS_C71.txt", 
                                                   colnames);
        interp1d["xsec_C72"] = interp1d_collection("mass_xsec_CMS_C72", 
                                                   GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_xsec_CMS_C72.txt", 
                                                   colnames);
        interp1d["xsec_C73"] = interp1d_collection("mass_xsec_CMS_C73", 
                                                   GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_xsec_CMS_C73.txt", 
                                                   colnames);
        interp1d["xsec_C74"] = interp1d_collection("mass_xsec_CMS_C74", 
                                                   GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_xsec_CMS_C74.txt", 
                                                   colnames);
        // - 2d signal efficiencies
        colnames = {"mass", "theta", "SR1", "SR2", "SR3", "SR4", "SR5", "SR6", "SR7", "SR8", "SR9", "SR10",
                    "SR11", "SR12", "SR13", "SR14", "SR15", "SR16", "SR17", "SR18", "SR19", "SR20", "SR21", "SR22"};
        interp2d["eff_C61_C64"] = interp2d_collection("mass_theta_eff_CMS_C61_C64", 
                                                       GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_theta_eff_CMS_C61_C64.txt", 
                                                       colnames);
        interp2d["eff_C62_C63"] = interp2d_collection("mass_theta_eff_CMS_C62_C63", 
                                                       GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_theta_eff_CMS_C62_C63.txt", 
                                                       colnames);
        // - 1d signal efficiencies
        colnames = {"mass", "SR1", "SR2", "SR3", "SR4", "SR5", "SR6", "SR7", "SR8", "SR9", "SR10",
                    "SR11", "SR12", "SR13", "SR14", "SR15", "SR16", "SR17", "SR18", "SR19", "SR20", "SR21", "SR22"};
        interp1d["eff_C71"] = interp1d_collection("mass_eff_CMS_C71", 
                                                  GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_eff_CMS_C71.txt", 
                                                  colnames);
        interp1d["eff_C72"] = interp1d_collection("mass_eff_CMS_C72", 
                                                  GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_eff_CMS_C72.txt", 
                                                  colnames);
        interp1d["eff_C73"] = interp1d_collection("mass_eff_CMS_C73", 
                                                  GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_eff_CMS_C73.txt", 
                                                  colnames);
        interp1d["eff_C74"] = interp1d_collection("mass_eff_CMS_C74", 
                                                  GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_eff_CMS_C74.txt", 
                                                  colnames);

        // 
        // ATLAS analysis info
        // 

        analysis_info_ATLAS.name = "ATLAS_13TeV_MONOJET_139invfb_interpolated"; 
        analysis_info_ATLAS.lumi_invfb = 139.0;

        // analysis_info_ATLAS.data_INC = 15;     // 15 points in both dimensions (mass, theta)
        // analysis_info_ATLAS.data_SIZE = 225;   // 15 * 15
        // analysis_info_ATLAS.data_INC_d7 = 19;  // only one dimension (mass)
        // analysis_info_ATLAS.data_SIZE_d7 = 19; 

        analysis_info_ATLAS.METMINS = {200., 250., 300., 350., 400., 500., 600., 700., 800., 900., 1000.};
        analysis_info_ATLAS.OBSNUM = {1791624, 752328, 313912, 141036, 102888, 29458, 10203, 3986, 1663, 738, 413+187+207};
        analysis_info_ATLAS.BKGNUM = {1783000., 753000., 314000., 140100., 101600., 29200., 10000., 3870., 1640., 754., 359.+182.+218.};
        analysis_info_ATLAS.BKGERR = {26000., 9000., 3500., 1600., 1200., 400., 180., 80., 40., 20., sqrt(10*10+6*6+9*9)};
        assert(analysis_info_ATLAS.OBSNUM.size() == analysis_info_ATLAS.METMINS.size());
        assert(analysis_info_ATLAS.OBSNUM.size() == analysis_info_ATLAS.BKGNUM.size());
        assert(analysis_info_ATLAS.OBSNUM.size() == analysis_info_ATLAS.BKGERR.size());
        // analysis_info_ATLAS.bin_size = analysis_info_ATLAS.OBSNUM.size(); 
        analysis_info_ATLAS.n_signal_regions = analysis_info_ATLAS.OBSNUM.size();

        // Create interpolated functions for the ATLAS analysis
        // - 2d cross-sections
        colnames = {"mass", "theta", "xsec"}
        interp2d["xsec_C61_C64"] = interp2d_collection("mass_theta_xsec_ATLAS_C61_C64", 
                                                       GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_theta_xsec_ATLAS_C61_C64.txt", 
                                                       colnames);
        interp2d["xsec_C62_C63"] = interp2d_collection("mass_theta_xsec_ATLAS_C62_C63", 
                                                       GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_theta_xsec_ATLAS_C62_C63.txt", 
                                                       colnames);
        // - 1d cross-sections
        colnames = {"mass", "xsec"}
        interp1d["xsec_C71"] = interp1d_collection("mass_xsec_ATLAS_C71", 
                                                   GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_xsec_ATLAS_C71.txt", 
                                                   colnames);
        interp1d["xsec_C72"] = interp1d_collection("mass_xsec_ATLAS_C72", 
                                                   GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_xsec_ATLAS_C72.txt", 
                                                   colnames);
        interp1d["xsec_C73"] = interp1d_collection("mass_xsec_ATLAS_C73", 
                                                   GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_xsec_ATLAS_C73.txt", 
                                                   colnames);
        interp1d["xsec_C74"] = interp1d_collection("mass_xsec_ATLAS_C74", 
                                                   GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_xsec_ATLAS_C74.txt", 
                                                   colnames);
        // - 2d signal efficiencies
        colnames = {"mass", "theta", "SR1", "SR2", "SR3", "SR4", "SR5", "SR6", "SR7", "SR8", "SR9", "SR10", "SR11"};
        interp2d["eff_C61_C64"] = interp2d_collection("mass_theta_eff_ATLAS_C61_C64", 
                                                       GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_theta_eff_ATLAS_C61_C64.txt", 
                                                       colnames);
        interp2d["eff_C62_C63"] = interp2d_collection("mass_theta_eff_ATLAS_C62_C63", 
                                                       GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_theta_eff_ATLAS_C62_C63.txt", 
                                                       colnames);
        // - 1d signal efficiencies
        colnames = {"mass", "SR1", "SR2", "SR3", "SR4", "SR5", "SR6", "SR7", "SR8", "SR9", "SR10", "SR11"};
        interp1d["eff_C71"] = interp1d_collection("mass_eff_ATLAS_C71", 
                                                  GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_eff_ATLAS_C71.txt", 
                                                  colnames);
        interp1d["eff_C72"] = interp1d_collection("mass_eff_ATLAS_C72", 
                                                  GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_eff_ATLAS_C72.txt", 
                                                  colnames);
        interp1d["eff_C73"] = interp1d_collection("mass_eff_ATLAS_C73", 
                                                  GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_eff_ATLAS_C73.txt", 
                                                  colnames);
        interp1d["eff_C74"] = interp1d_collection("mass_eff_ATLAS_C74", 
                                                  GAMBIT_DIR "/ColliderBit/data/DMEFT/mass_eff_ATLAS_C74.txt", 
                                                  colnames);

        first = false;
      }

      // Get the theory spectrum to extract masses and parameters
      const Spectrum& spec = *Dep::DMEFT_spectrum;


      // Now go through each analysis, fill the corresponding AnalysisData instance 
      // and store the AnalysisData pointer in the result variable

      // 
      // ====== Analysis: CMS_13TeV_MONOJET_36invfb_interpolated ======
      // 

      // Vector to contain signal yield predictions
      vector<double> sr_nums_CMS(analysis_info_CMS.n_signal_regions, 0.);

      // Fill the signal yield vector
      get_DMEFT_signal_yields(sr_nums_CMS, analysis_info_CMS, spec);

      // Create vector of SignalRegionData instances
      std::vector<SignalRegionData> CMS_binned_results;

      for (size_t ibin = 0; ibin < analysis_info_CMS.n_signal_regions; ++ibin) 
      {
        // Generate an 'sr-N' label 
        std::stringstream ss; ss << "sr-" << ibin;

        // Construct a SignalRegionData instance and add it to CMS_binned_results
        SignalRegionData sr;
        sr.sr_label = ss.str();
        sr.n_obs = analysis_info_CMS.OBSNUM.at(ibin);
        sr.n_sig_MC = sr_nums_CMS.at(ibin);
        sr.n_sig_scaled = sr_nums_CMS.at(ibin);  // We have already scaled the signals in sr_nums_CMS to xsec * lumi
        sr.n_sig_MC_sys = 0.;
        sr.n_bkg = analysis_info_CMS.BKGNUM.at(ibin);
        sr.n_bkg_err = analysis_info_CMS.CMS_BKGERR.at(ibin);

        CMS_binned_results.push_back(sr);
      }

      // The covariance matrix
      static const std::vector< std::vector<double> > BKGCOV = {
            {  1.37e+07,  7.18e+06,  2.58e+06,  1.54e+06,  9.29e+05,  4.28e+05,  3.26e+05,  2.04e+05,  8.34e+04,  5.37e+04,  4.62e+04,  2.33e+04,  1.45e+04,  1.20e+04,  6.66e+03,  7.99e+03,  4.00e+03,  1.57e+03,  0.00e+00,  1.30e+03,  3.85e+02, -4.14e+02 },
            {  7.18e+06,  4.00e+06,  1.38e+06,  8.43e+05,  5.02e+05,  2.28e+05,  1.74e+05,  1.05e+05,  4.51e+04,  2.84e+04,  2.30e+04,  1.22e+04,  7.56e+03,  6.48e+03,  3.24e+03,  4.00e+03,  2.28e+03,  1.06e+03,  1.56e+02,  8.00e+02,  3.64e+02, -1.68e+02 },
            {  2.58e+06,  1.38e+06,  6.56e+05,  3.57e+05,  2.18e+05,  1.07e+05,  8.73e+04,  5.31e+04,  2.34e+04,  1.50e+04,  1.35e+04,  7.00e+03,  4.20e+03,  3.30e+03,  2.26e+03,  1.81e+03,  1.12e+03,  6.44e+02,  2.21e+02,  3.04e+02,  1.47e+02,  2.27e+01 },
            {  1.54e+06,  8.43e+05,  3.57e+05,  2.40e+05,  1.32e+05,  6.58e+04,  5.14e+04,  3.17e+04,  1.44e+04,  9.22e+03,  8.15e+03,  4.06e+03,  2.88e+03,  2.00e+03,  1.32e+03,  1.25e+03,  7.06e+02,  3.64e+02,  5.73e+01,  1.59e+02,  7.64e+01, -2.74e+01 },
            {  9.29e+05,  5.02e+05,  2.18e+05,  1.32e+05,  9.61e+04,  4.11e+04,  3.21e+04,  1.88e+04,  8.81e+03,  5.73e+03,  5.46e+03,  2.57e+03,  1.78e+03,  1.34e+03,  6.98e+02,  9.18e+02,  4.28e+02,  1.64e+02,  3.63e+01,  1.32e+02,  1.05e+02, -8.68e+00 },
            {  4.28e+05,  2.28e+05,  1.07e+05,  6.58e+04,  4.11e+04,  2.89e+04,  1.76e+04,  1.07e+04,  5.16e+03,  2.92e+03,  2.83e+03,  1.62e+03,  9.76e+02,  8.77e+02,  3.82e+02,  4.49e+02,  2.04e+02,  1.08e+02,  9.94e+01,  1.02e+02,  3.98e+01,  4.76e+00 },
            {  3.26e+05,  1.74e+05,  8.73e+04,  5.14e+04,  3.21e+04,  1.76e+04,  1.96e+04,  9.18e+03,  4.39e+03,  2.82e+03,  2.46e+03,  1.39e+03,  9.21e+02,  7.39e+02,  5.17e+02,  3.70e+02,  2.35e+02,  9.65e+01,  8.19e+01,  4.20e+01,  1.82e+01,  3.14e+01 },
            {  2.04e+05,  1.04e+05,  5.31e+04,  3.17e+04,  1.88e+04,  1.07e+04,  9.18e+03,  9.02e+03,  2.61e+03,  1.72e+03,  1.70e+03,  8.55e+02,  4.52e+02,  4.67e+02,  2.48e+02,  2.66e+02,  1.54e+02,  5.04e+01,  3.33e+01,  1.19e+01,  3.21e+01,  7.98e+00 },
            {  8.34e+04,  4.51e+04,  2.34e+04,  1.44e+04,  8.81e+03,  5.16e+03,  4.39e+03,  2.61e+03,  2.40e+03,  9.22e+02,  8.94e+02,  4.67e+02,  2.13e+02,  2.41e+02,  1.41e+02,  1.29e+02,  4.70e+01,  4.41e+01,  7.64e+00,  2.08e+01,  2.55e+01,  5.49e+00 },
            {  5.37e+04,  2.84e+04,  1.50e+04,  9.22e+03,  5.73e+03,  2.92e+03,  2.82e+03,  1.72e+03,  9.22e+02,  1.09e+03,  5.17e+02,  3.03e+02,  1.62e+02,  1.47e+02,  8.91e+01,  8.18e+01,  3.17e+01,  2.10e+01,  1.29e+00,  7.42e+00,  7.72e+00,  4.62e+00 },
            {  4.62e+04,  2.30e+04,  1.35e+04,  8.15e+03,  5.46e+03,  2.83e+03,  2.46e+03,  1.70e+03,  8.94e+02,  5.17e+02,  1.02e+03,  2.65e+02,  1.57e+02,  1.61e+02,  9.22e+01,  7.94e+01,  3.84e+01,  3.39e+00, -1.25e+00,  1.44e+01,  3.33e+00, -8.96e-01 },
            {  2.33e+04,  1.22e+04,  7.00e+03,  4.06e+03,  2.57e+03,  1.62e+03,  1.39e+03,  8.55e+02,  4.67e+02,  3.03e+02,  2.65e+02,  3.24e+02,  8.57e+01,  9.07e+01,  5.83e+01,  3.02e+01,  2.70e+01,  2.00e+01,  7.02e+00,  2.25e+00,  5.15e+00,  7.06e+00 },
            {  1.45e+04,  7.56e+03,  4.20e+03,  2.88e+03,  1.78e+03,  9.76e+02,  9.21e+02,  4.52e+02,  2.13e+02,  1.62e+02,  1.57e+02,  8.57e+01,  1.96e+02,  5.21e+01,  3.91e+01,  3.92e+01,  2.69e+01,  8.90e+00,  6.55e+00,  0.00e+00,  1.46e+00,  1.57e+00 },
            {  1.20e+04,  6.48e+03,  3.30e+03,  2.00e+03,  1.34e+03,  8.77e+02,  7.39e+02,  4.67e+02,  2.41e+02,  1.47e+02,  1.61e+02,  9.07e+01,  5.21e+01,  1.44e+02,  3.02e+01,  2.02e+01,  1.44e+01,  3.18e+00,  4.68e-01,  4.50e+00,  2.18e+00,  3.02e+00 },
            {  6.66e+03,  3.24e+03,  2.26e+03,  1.32e+03,  6.98e+02,  3.82e+02,  5.17e+02,  2.48e+02,  1.41e+02,  8.91e+01,  9.22e+01,  5.83e+01,  3.91e+01,  3.02e+01,  8.10e+01,  1.15e+01,  1.19e+01,  7.63e+00,  3.16e+00, -2.25e-01,  1.40e+00,  2.52e+00 },
            {  7.99e+03,  4.00e+03,  1.81e+03,  1.25e+03,  9.18e+02,  4.49e+02,  3.70e+02,  2.66e+02,  1.29e+02,  8.18e+01,  7.94e+01,  3.02e+01,  3.92e+01,  2.02e+01,  1.15e+01,  6.40e+01,  1.92e+00, -1.27e+00, -3.12e-01,  1.40e+00,  2.70e+00, -6.72e-01 },
            {  4.00e+03,  2.28e+03,  1.12e+03,  7.06e+02,  4.28e+02,  2.04e+02,  2.35e+02,  1.54e+02,  4.70e+01,  3.17e+01,  3.84e+01,  2.70e+01,  2.69e+01,  1.44e+01,  1.19e+01,  1.92e+00,  3.60e+01,  5.09e+00,  3.74e+00, -1.65e+00,  1.40e+00,  1.51e+00 },
            {  1.57e+03,  1.06e+03,  6.44e+02,  3.64e+02,  1.64e+02,  1.08e+02,  9.65e+01,  5.04e+01,  4.41e+01,  2.10e+01,  3.39e+00,  2.00e+01,  8.90e+00,  3.18e+00,  7.63e+00, -1.27e+00,  5.09e+00,  2.81e+01,  6.20e-01, -1.19e+00,  5.51e-01, -4.45e-01 },
            {  0.00e+00,  1.56e+02,  2.21e+02,  5.73e+01,  3.63e+01,  9.95e+01,  8.19e+01,  3.33e+01,  7.64e+00,  1.29e+00, -1.25e+00,  7.02e+00,  6.55e+00,  4.68e-01,  3.16e+00, -3.12e-01,  3.74e+00,  6.20e-01,  1.52e+01,  7.80e-01,  3.04e-01,  1.64e+00 },
            {  1.30e+03,  8.00e+02,  3.04e+02,  1.59e+02,  1.32e+02,  1.02e+02,  4.20e+01,  1.19e+01,  2.08e+01,  7.42e+00,  1.44e+01,  2.25e+00,  0.00e+00,  4.50e+00, -2.25e-01,  1.40e+00, -1.65e+00, -1.19e+00,  7.80e-01,  6.25e+00,  1.30e-01,  6.30e-01 },
            {  3.85e+02,  3.64e+02,  1.47e+02,  7.64e+01,  1.05e+02,  3.98e+01,  1.82e+01,  3.21e+01,  2.55e+01,  7.72e+00,  3.33e+00,  5.15e+00,  1.46e+00,  2.18e+00,  1.40e+00,  2.70e+00,  1.40e+00,  5.51e-01,  3.04e-01,  1.30e-01,  6.76e+00,  5.82e-01 },
            { -4.14e+02, -1.68e+02,  2.27e+01, -2.74e+01, -8.68e+00,  4.76e+00,  3.14e+01,  7.98e+00,  5.49e+00,  4.62e+00, -8.96e-01,  7.06e+00,  1.57e+00,  3.02e+00,  2.52e+00, -6.72e-01,  1.51e+00, -4.45e-01,  1.64e+00,  6.30e-01,  5.82e-01,  7.84e+00 }
      };
      assert(BKGCOV.size() == analysis_info_CMS.n_signal_regions);
      assert(BKGCOV[0].size() == analysis_info_CMS.n_signal_regions);

      // Convert to Eigen matrix
      static Eigen::MatrixXd m_BKGCOV(analysis_info_CMS.n_signal_regions, analysis_info_CMS.n_signal_regions);
      static bool first_c = true;
      if (first_c)
      {
        for (int i = 0; i < analysis_info_CMS.n_signal_regions; i++)
        {
          m_BKGCOV.row(i) = Eigen::VectorXd::Map(&BKGCOV[i][0],BKGCOV[i].size()); 
        }
        first_c = false;
      }

      // Save the analysis results + covariance matrix in analysis_data_CMS
      analysis_data_CMS.srdata = CMS_binned_results;
      analysis_data_CMS.srcov = m_BKGCOV;

      // Save a pointer to analysis_data_CMS in the 'result' variable
      result.push_back(&analysis_data_CMS);


      // 
      // ====== Analysis: ATLAS_13TeV_MONOJET_139invfb_interpolated ======
      // 

      // Vector to contain signal yield predictions
      vector<double> sr_nums_ATLAS(analysis_info_ATLAS.n_signal_regions, 0.);

      // Fill the signal yield vector
      get_DMEFT_signal_yields(sr_nums_ATLAS, analysis_info_ATLAS, spec);
      
      // Create vector of SignalRegionData instances
      std::vector<SignalRegionData> ATLAS_binned_results;

      for (size_t ibin = 0; ibin < analysis_info_ATLAS.n_signal_regions; ++ibin) 
      {
        // Generate an 'sr-N' label 
        std::stringstream ss; ss << "sr-" << ibin;

        // Construct a SignalRegionData instance and add it to ATLAS_binned_results
        SignalRegionData sr;
        sr.sr_label = ss.str();
        sr.n_obs = analysis_info_ATLAS.OBSNUM.at(ibin);
        sr.n_sig_MC = sr_nums_ATLAS.at(ibin);
        sr.n_sig_scaled = sr_nums_ATLAS.at(ibin);  // We have already scaled the signals in sr_nums_ATLAS to xsec * lumi
        sr.n_sig_MC_sys = 0.;
        sr.n_bkg = analysis_info_ATLAS.BKGNUM.at(ibin);
        sr.n_bkg_err = analysis_info_ATLAS.ATLAS_BKGERR.at(ibin);

        ATLAS_binned_results.push_back(sr);
      }

      // Save the analysis results in analysis_data_ATLAS
      analysis_data_ATLAS.srdata = ATLAS_binned_results;

      // Save a pointer to analysis_data_ATLAS in the 'result' variable
      result.push_back(&analysis_data_ATLAS);

    };


    /// Fill the input vector with the total DMEFT signal prediction for each SR in the given LHC analysis
    void get_DMEFT_signal_yields(vector<double>& sr_nums, const DMEFT_analysis_info& analysis_info, const Spectrum& spec)
    {

      // Get the parameters we need from the theory spectrum
      double C61 = spec.get(Par::dimensionless, "C61");
      double C62 = spec.get(Par::dimensionless, "C62");
      double C63 = spec.get(Par::dimensionless, "C63");
      double C64 = spec.get(Par::dimensionless, "C64");
      double C71 = spec.get(Par::dimensionless, "C71");
      double C72 = spec.get(Par::dimensionless, "C72");
      double C73 = spec.get(Par::dimensionless, "C73");
      double C74 = spec.get(Par::dimensionless, "C74");
      double lambda = spec.get(Par::mass1, "Lambda");      
      double mchi = spec.get(Par::Pole_Mass, "chi");


      // Get the dim-6 yields

      // C61+C64
      vector<double> A14(analysis_info.n_signal_regions, 0.);
      get_DMEFT_signal_yields_dim6(A14, m, C61, C64, lambda, "C61_C64", analysis_info);

      // C62+C63
      vector<double> A23(analysis_info.n_signal_regions, 0.);
      get_DMEFT_signal_yields_dim6(A23, m, C62, C63, lambda, "C62_C63", analysis_info);


      // Get the dim-7 yields

      // C71
      vector<double> A71(analysis_info.n_signal_regions, 0.);
      get_DMEFT_signal_yields_dim7(A71, m, C71, lambda, "C71", analysis_info);
      
      // C72
      vector<double> A72(analysis_info.n_signal_regions, 0.);
      get_DMEFT_signal_yields_dim7(A72, m, C72, lambda, "C72", analysis_info);

      // C73
      vector<double> A73(analysis_info.n_signal_regions, 0.);
      get_DMEFT_signal_yields_dim7(A73, m, C73, lambda, "C73", analysis_info);

      // C74
      vector<double> A74(analysis_info.n_signal_regions, 0.);
      get_DMEFT_signal_yields_dim7(A74, m, C74, lambda, "C74", analysis_info);


      // Add yields and save in sr_num
      for (size_t i = 0; i < analysis.info.n_signal_regions; ++i)
      {
        sr_nums[i] = A14[i] + A23[i] + A71[i] + A72[i] + A73[i] + A74[i];
      }
    }


    /// Fill the input vector with the DMEFT signal prediction for a given set of dim-6 operators
    void get_DMEFT_signal_yields_dim6(vector<double>& signal_yields, const string operator_key, const DMEFT_analysis_info& analysis_info, double m, double O1, double O2, double lambda);
    {

      // Calculate theta
      double theta;
      if (O2==0)
      {
        theta = 0.5 * pi;
      }
      else
      {
        theta = atan(O1 / O2);
        if ( O1 / O2 < 0)
        {
          theta = theta + pi;
        }
      }

      // Calculate normalisation
      double norm = O1*O1 + O2*O2;
      if (norm < 0.0)
      {
        ColliderBit_error().raise(LOCAL_INFO, "ERROR! norm < 0 in function get_DMEFT_signal_yields_dim6.");
      }

      // Get the interpolator collections for the given operator_key
      const interp2d_collection& xsec_interp = analysis_info.interp2d["xsec_" + operator_key];
      const interp2d_collection& eff_interp = analysis_info.interp2d["eff_" + operator_key];

      // Compute the signal yield for each signal region
      for (size_t sr_i = 0; sr_i < analysis.info.n_signal_regions; ++sr_i)
      {

        // 
        // Get the cross-section at the point (m,theta)
        // 

        double xsec = 0.;
        // Check if (m,theta) point is inside interpolation region
        if (not xsec_interp.is_inside_range(m,theta))
        {
          if (theta < xsec_interp.y_min || theta > xsec_interp.y_max)
          {
            ColliderBit_error().raise(LOCAL_INFO, "ERROR! Theta parameter out of range.");
          }

          if (m < xsec_interp.x_min)
          {
            ColliderBit_error().raise(LOCAL_INFO, "Mass parameter below lowest mass point in the cross-section table.");
          }

          if (m > xsec_interp.x_min)
          {
            // Set cross-section to 0 for masses above the tabulated range
            xsec = 0.;
          }
        }
        else // All is OK, let's evaluate the cross-section
        {
          xsec = xsec_interp.eval(m, theta);
        }

        
        // 
        // Get signal efficiency for signal region sr_i at the point (m,theta)
        // 

        double eff = 0.;
        // Check if (m,theta) point is inside interpolation region
        if (not eff_interp.is_inside_range(m,theta))
        {
          if (theta < eff_interp.y_min || theta > eff_interp.y_max)
          {
            ColliderBit_error().raise(LOCAL_INFO, "ERROR! Theta parameter out of range.");
          }

          if (m < eff_interp.x_min)
          {
            ColliderBit_error().raise(LOCAL_INFO, "Mass parameter below lowest mass point in the signal efficiency table.");
          }

          if (m > eff_interp.x_min)
          {
            // Set efficiency to 0 for masses above the tabulated range
            eff = 0.;
          }
        }
        else // All is OK, let's evaluate the efficiency
        {
          eff = eff_interp.eval(m, theta);
        }

        // 
        // Compute signal prediction and save it in the signal_yields vector
        // 

        signal_yields[sr_i] = analysis_info.lumi_invfb * (xsec * 1000.) * eff * norm; // converting cross-section from pb to fb

      }  // End loop over signal regions

    }


    /// Fill the input vector with the DMEFT signal prediction for a given dim-7 operator
    void get_DMEFT_signal_yields_dim7(vector<double>& signal_yields, const string operator_key, const DMEFT_analysis_info& analysis_info, double m, double O, double lambda);
    {

      // Calculate normalisation
      double norm = O*O;
      if (norm < 0.0)
      {
        ColliderBit_error().raise(LOCAL_INFO, "ERROR! norm < 0 in function get_DMEFT_signal_yields_dim7.");
      }

      // Get the interpolator collections for the given operator_key
      const interp1d_collection& xsec_interp = analysis_info.interp2d["xsec_" + operator_key];
      const interp1d_collection& eff_interp = analysis_info.interp2d["eff_" + operator_key];

      // Compute the signal yield for each signal region
      for (size_t sr_i = 0; sr_i < analysis.info.n_signal_regions; ++sr_i)
      {

        // 
        // Get the cross-section for mass m
        // 

        double xsec = 0.;
        // Check if m is inside interpolation region
        if (not xsec_interp.is_inside_range(m))
        {
          if (m < xsec_interp.x_min)
          {
            ColliderBit_error().raise(LOCAL_INFO, "Mass parameter below lowest mass point in the cross-section table.");
          }

          if (m > xsec_interp.x_min)
          {
            // Set cross-section to 0 for masses above the tabulated range
            xsec = 0.;
          }
        }
        else // All is OK, let's evaluate the cross-section
        {
          xsec = xsec_interp.eval(m);
        }

        
        // 
        // Get signal efficiency for signal region sr_i and mass m
        // 

        double eff = 0.;
        // Check if m point is inside interpolation region
        if (not eff_interp.is_inside_range(m))
        {
          if (m < eff_interp.x_min)
          {
            ColliderBit_error().raise(LOCAL_INFO, "Mass parameter below lowest mass point in the signal efficiency table.");
          }

          if (m > eff_interp.x_min)
          {
            // Set efficiency to 0 for masses above the tabulated range
            eff = 0.;
          }
        }
        else // All is OK, let's evaluate the efficiency
        {
          eff = eff_interp.eval(m);
        }

        // 
        // Compute signal prediction and save it in the signal_yields vector
        // 

        signal_yields[sr_i] = analysis_info.lumi_invfb * (xsec * 1000.) * eff * norm; // converting cross-section from pb to fb

      }  // End loop over signal regions

    }


  } // namespace ColliderBit
    
} // namespace Gambit
