GAMBIT To-do List
=================

(G3 = GAMBIT III = March Collaboration Meeting)


Core
----

Rollcall:
* Implement point-level initialisation functions in backends (**Pat & Chistoph**)
* Allow grouping of backend requirements into blocks, maybe declaration of parameters  (**Pat; discussion with whole collab needed at G3**)
* Tracking of config files -> lists in module/backend rollcall headers (**Pat; after G3**)
  - Add module-level and backend-level HAS_CONFIG_FILE(filename, flag:OVERIDABLE) and DEFINE_CONFIG_FILE_KEY(key, filename) rollcall macros, to allow settings for modules and backends to be stored/specified in configuration files that exist separately to the .ini file
* Make a rollcall header harvester to create module_rollcall.hpp automagically (**Pat, by extending the existing type harvester; after G3**)
* Investigate whether encapsulation of module functions and the things they can access (Dep::s, Params[], etc) could be straightforwardly implemented.
* Demand that all capabilities have a matching description in a 'capability database'

IniFile:
* Allow config file keys to be overridden in the .ini file according to key name, if the config file they belong to has been declared with the OVERIDABLE flag; otherwise, the ini parser should throw an error. (**Christoph; after G3**)
* Add syntactic facility for easily declaring chained dependencies, where all entries in the chain have the same capability-type pair. (**Christoph; after G3**) 
* Support alternative ini format(s)

Dependency Resolver:
* Make dependency resolver errors more informative (**Christoph; major time pressure**)
* Make it possible to resolve dependencies that match a functor's own capability-type pair (**Christoph**)
* Write new entry to auxiliary section of the YAML file if dependency resolution fails, according to user input. (**Christoph**)
* Make copying of functors possible, and therefore also the use of the same module function multiple times in the depedency tree (**Pat & Christoph, during first major code revision following release.**)

Backends:
* Implement The BOSS (backend-on-a-stick script; classloader) (**Anders; before G3**)
* Resolve residual issues with passing strings to fortran backends (**all; at G3**)
* Implement backending of Mathematica codes (**Ben to dabble with; no time pressure**)
* Implement backending of Python codes (**Ben to dabble with; no time pressure**)

Messaging:
* Write printer functions for all common functor types and print streams (**Hopefully happens a bit on its own as the two points above get dealt with**)

General:
* Experiment with automake and cmake for build (**Antje to update automake system to current master; Ben, Pat, Chistoph + others to test; Antje to merge into master before G3. Cmake to be left for after G3.**)
* Add command line gambit diagnostics:
  gambit capabilities [-v/--verbose]
  gambit modules      [-v/--verbose]
  gambit backends     [-v/--verbose]
  gambit scanners     [-v/--verbose]
  gambit models       [-v/--verbose]
* Get the doxygen documentation into the Trac Wiki somehow, and updated automatically (**Antje & Pat; after G3**)
* Create SLHA internal representation, plus hook up file reader/writer. (**Ben; progress before G3, completion maybe not**) 
* General review of legacy code -> cull obsolete stuff (**ALL, but Pat and Ben to pay special attention to legacy SUFit code in ModelParameters**)
* Fix naming conventions (**ALL, whenever we touch a file!!**)
  - filenames (lowercase+underscore)
* Convert comment headers in source/header files to doxygen (///) format; many are still in old-style (//) format (**ALL, whenever we touch a file!!**)
* Convert comments to Doxygen (**ALL, whenever we touch a file!!**)

Recent decisions impacting upcoming development:
* Separate output/log for points with "BadPoint" errors

Done:
* No more GET_DEP -> change all examples to safe pointers (*Dep::observable)
* Separate gambit_example.cpps
* Fix naming convention GAMBIT->Gambit
* Create shorthand for parameter access from within module functions (e.g. Params["M0"])
* Module-specific types in module directories, but common return types in Utils/include/shared_types.hpp
* Make functors thread-safe
* Until the autotools are ready to go, can we please clean up the extra confusing makefile? Many of these make variables are not even being used.
* Implement point-level initialisation functions in modules
* Remove any need for macro calls from within module functions (macros-->safe pointer-like objects)
* Until automake and cmake are done, may want to make more "makefile.common" files for readability
* Allow conditional backend requirements (conditional on model only, not dependency)
* Make rollcall macros throw errors if the required #defines have not been done
* Implement standalone compilation of physics modules
* Convert common block / struct access to by-pointer
* Make dependency resolver more model-aware; now it can choose between two otherwise-valid functor options for filling a dependency, based only on the model being scanned.
* Implement elegant optional array reindexing scheme for Fortran arrays
* Implement proper exception handling system
* Implement proper logging system
* Legacy SUFit logging and exception code culled
* Make name of current model (and related lineage tests) accessible from within module functions
* Sort out specification of what can be given to the Scanner as Likelihoods / what can be given as target observables in iniFile
* Add ability to import key-value pair *settings* from the .ini file for modules, backends and their individual functions.


Models
------

Ongoing:
* Make it possible to declare in module function rollcall macro calls that multiple models are required to be scanned, e.g. ALLOWED_MODELS(GROUP1, blah), ALLOWED_MODELS(GROUP2, blah), s.t. the function requires something from GROUP1 and GROUP2 to be scanned, in order to be used in a given scan. 
* Explicitly disallow multiple parents in all parts of Models (and other) code.
* Remove automatic declaration of "little guys"

Done:
* Reunify model macros with module macros as much as possible (dependency macro in particular)
* Create "little guys" (parameter mini-functors)
* Create boost graph to display model hierarchy
* Sort out 'warning redefined' warnings from BOOST about TUPLE_TO_SEQ.
* Massage function in ModelBit that checks that all the user-requested models are actually used by the dependency resolver.  If not, throw an error to say that they are wasting their CPU time with the unused parameters. 


HE Collider
-----------

* Address some of the other TODOs in the makfiles.

* Py8 shower alpha_s -> 0.118

* Reorganise the Makefile to build more intermediate .o files to speed up compilation

* Do the same-process xsec aggregation on SubprocessGroup rather than in Analysis

* Parameterising strong subprocess cross-sections
* Huge K-factor tails from Prospino?


* Interpolate subprocess NLO cross-sections
* SUSY subprocesses thread split generalization
- Martin and Abram discussed briefly. We came up with a good idea about when to neglect
  a particular subprocess:

  number_of_events = cross_section * Acceptance * Efficiency * Luminosity
  Acceptance * Efficiency <= 1
  ==> number_of_events <= cross_section * Luminosity

  If that number_of_events is less than the known systematic uncertainty for all
  analyses, then we can 'neglect' the subprocess. Thus, we don't bother to simulate it,
  simply set the likelihood for those analyses = 1.
* Collate analyses for different subprocesses, with different k-factor weightings

* Convert HEColliderMain to be able to run with/without Delphes/FastSim
   Put safety checking into the direct P8->Event code, re. P4 mass safety. No
   -ve masses, please! Hopefully not an issue, but maybe Py8 has a way to get
   the 4-vec mass other than via E2-p2.

* Standardise the namespaces used (and using'd)

* Write more analysis codes!
* Verification of ATLAS limits
* Disabling Py8 model elements => properly populate the Event (direct and via Delphes/FastSim)


* Cleanup collider code... Once class loading is ready, all our code should really be hooked up to Gambit.
- in the meantime, make a Gambit module skeleton ready for our code to hook into
- see if hooking up with Gambit is possible without class loading


Scanner
-------

Ongoing:
* Streamlining of Scanner Plugin architecture
* Interface to Antje's MCMC code
* Interface to differential evolution
* Interface to k-walk
* Interface to genetic algorithms
* Organise dedicated scanner section in yaml .ini file structure
* Organise grouping of parameters into fast and slow subsets (useful for some scanners), possibly via the ini file.

Done:
* Interface to MultiNest


DarkBit
-------

Ongoing:
* DarkSUSY relic density solver
  - Problem with Fortran vs. C++ array indexing
* Annihilation yields in DarkSUSY
* Lars' p-/e+ propagation codes
* Neutrinos from sun code in DarkSUSY + IceCube
* Direct search codes (Chris' Fortran routines)
* Relic density solver of MicrOmegas
* SuperISO relic
* PPPC (tables only?)
* CR data (PAMELA, AMS-02 etc)
* Planck, ATC, BESS, WMAP pol, HST... (CosmoBit)
* Astrophysical probes in general (stars, DM self-interaction)
* Implementation of minimal model (singlet DM) for prototypical model and
  cross-section definitions etc.
  - as new Model
  - Calculation of relic density
  - Primitive indirect dwarf limits
  - Direct limits with Chris' module
* Implementation of CMB limits (starting with codes from singlet paper)
* Primitive dwarf/GC likelihood
* Astrophysical DM distributions (substucture & phase space)
* Decaying dark matter
* Asymmetric dark matter
* Make use of print functions, once completed
* Make use error system, once there


More
----
Inline to-dos can be be found here: \todo Do things in the to-do list.
