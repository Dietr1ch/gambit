GAMBIT To-do List
=================

Core
----

Rollcall:
* Make functors thread-safe
* Implement scan-level and point-level initialisation functions, in both backends and modules
* Remove any need for macro calls from within module functions (macros-->safe pointer-like objects)  
* Allow grouping of backend requirements into blocks/groups
* Allow conditional backend requirements (conditional on model only, not dependency)
* Tracking of config files -> lists in module/backend rollcall headers
  - Add module-level and backend-level HAS_CONFIG_FILE(filename, flag:OVERIDABLE) and DEFINE_CONFIG_FILE_KEY(key, filename) rollcall macros, to allow settings for modules and backends to be stored/specified in configuration files that exist separately to the .ini file
* Add chained 'depends on parameter' to functor class (PS: Although I wrote it, I don't remember what this means - can anyone enlighten me??)
* Investigate whether encapsulation of module functions and the things they can access (Dep::s, Params[], etc) could be straightforwardly implemented.

IniFile:
* Add ability to import key-value pair *settings* from the .ini file for modules, backends and their individual functions.
* Allow config file keys to be overridden in the .ini file according to key name, if the config file they belong to has been declared with the OVERIDABLE flag; otherwise, the ini parser should throw an error.
* Support alternative ini format(s)

Dependency Resolver:
* Make dependency resolver more model-aware; at the moment it apparently cannot choose between two otherwise-valid functor options for filling a dependency, based only on the model being scanned.
* Modify model checks in dependency resolver so that all observables are parsed and their dependencies resolved before concluding that some model is not used for anything, and throwing an error (put FlavBit test obervables first in gambit.yaml to see this error)

Backends:
* Implement The BOSS (backend-on-a-stick script; classloader)
* Convert common block / struct access to by-pointer
* Implement elegant optional array reindexing scheme for Fortran arrays
* Resolve residual issues with passing strings to fortran backends
* Implement backending of Mathematica codes
* Implement backending of Python codes

Messaging:
* Implement proper exception handling system
* Implement proper logging system
* Write printer functions for all common functor types and print streams

General:
* Experiment with automake and cmake for build
* Create mini-core for module stand-alone releases
* Implement standalone compilation of physics modules
* Create SLHA internal representation, plus hook up file reader/writer.
* General review of legacy code -> cull obsolete stuff
* Fix naming conventions
  - filenames (lowercase+underscore)
* Convert comments to Doxygen

Recent decisions impacting upcoming development:
* Separate output/log for points with "BadPoint" errors
* No virus-like global "using namespace blah" in headers; scoped use of namespaces only

Done:
* No more GET_DEP -> change all examples to safe pointers (*Dep::observable)
* Separate gambit_example.cpps
* Fix naming conventions
  - GAMBIT->Gambit
* Create shorthand for parameter access from within module functions (e.g. Params["M0"])
* Module-specific types in module directories, but common return types in Utils/include/shared_types.hpp


Models
------

Ongoing:

* **Interpret_as_parent functions to move to .cpp files?**

  Requires users to have to fiddle with the makefile to define new models, not sure if beneficial. Can
  just do with nested headers. Depends how closely we want to follow the
  structure of modules... Ahh - would restore ability of compiler to pick up errors if this is done.
  So probably it is a good idea.

* **Simplify modelbit namespace (remove "models" namespace)?**

    Would allow even closer alignment to structure of modules, increase macro
    reuse. Models would then be almost exactly the same as modules, just with
    special kinds of capabilities and dependencies. Not sure if this is
    worthwhile, quite a few special features currently remain.

* **Create function in ModelBit to check that all the user-request models are actually used by the dependency resolver.**

  If not, throw an error to say that they are wasting their CPU time with the unused parameters.


* **Sort out 'warning redefined' warnings from BOOST about TUPLE_TO_SEQ.**

  Need to check if variadics exists before bothering to redefine the macro,
  or something.


* **Create boost graph to display model hierarchy (and maybe even replace the lineage/ancestry database)**

  Is this already done?

Done:

* Create "little guys" (parameter mini-functors)


HE Collider
-----------

* Py8 shower alpha_s -> 0.118

* Reorganise the Makefile to build more intermediate .o files to speed up compilation

* Do the same-process xsec aggregation on SubprocessGroup rather than in Analysis

* Parameterising strong subprocess cross-sections
* Huge K-factor tails from Prospino?


* Interpolate subprocess NLO cross-sections
* SUSY subprocesses thread split generalization
- Martin and Abram discussed briefly. We came up with a good idea about when to neglect
  a particular subprocess:

  number_of_events = cross_section * Acceptance * Efficiency * Luminosity
  Acceptance * Efficiency <= 1
  ==> number_of_events <= cross_section * Luminosity

  If that number_of_events is less than the known systematic uncertainty for all
  analyses, then we can 'neglect' the subprocess. Thus, we don't bother to simulate it,
  simply set the likelihood for those analyses = 1.
* Collate analyses for different subprocesses, with different k-factor weightings

* Convert HEColliderMain to be able to run with/without Delphes/FastSim
   Put safety checking into the direct P8->Event code, re. P4 mass safety. No
   -ve masses, please! Hopefully not an issue, but maybe Py8 has a way to get
   the 4-vec mass other than via E2-p2.

* Standardise the namespaces used (and using'd)

* Write more analysis codes!
* Verification of ATLAS limits
* Disabling Py8 model elements => properly populate the Event (direct and via Delphes/FastSim)


* Cleanup collider code... Once class loading is ready, all our code should really be hooked up to Gambit.
- in the meantime, make a Gambit module skeleton ready for our code to hook into
- see if hooking up with Gambit is possible without class loading


Scanner
-------

Ongoing:
* Streamlining of Scanner Plugin architecture
* Interface to Antje's MCMC code
* Interface to differential evolution
* Interface to k-walk
* Interface to genetic algorithms
* Organise dedicated scanner section in yaml .ini file structure
* Organise grouping of parameters into fast and slow subsets (useful for some scanners), possibly via the ini file.

Done:
* Interface to MultiNest


DarkBit
-------

Ongoing:

* DarkSUSY relic density solver
  - Problem with Fortran vs. C++ array indexing
* Annihilation yields in DarkSUSY
* Lars' p-/e+ propagation codes
* Neutrinos from sun code in DarkSUSY + IceCube
* Direct search codes (Chris' Fortran routines)
* Relic density solver of MicrOmegas
* SuperISO relic
* PPPC (tables only?)
* CR data (PAMELA, AMS-02 etc)
* Planck, ATC, BESS, WMAP pol, HST... (CosmoBit)
* Astrophysical probes in general (stars, DM self-interaction)
* Implementation of minimal model (singlet DM) for prototypical model and
  cross-section definitions etc.
  - as new Model
  - Calculation of relic density
  - Primitive indirect dwarf limits
  - Direct limits with Chris' module
* Implementation of CMB limits (starting with codes from singlet paper)
* Primitive dwarf/GC likelihood
* Astrophysical DM distributions
* Decaying dark matter
* Asymmetric dark matter
* Make use of print functions, once completed
* Make use error system, once there


More
----
Inline to-dos can be be found here: \todo Do things in the to-do list.
