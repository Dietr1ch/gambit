GAMBIT To-do List
=================


Core / Scanner / Models
----


For first analyses:

Printers:
* MPI initialisation in ScannerBit if needed (Ben, Greg)
* MPI-compatible printer system (Ben)
* Correlation of scanner printer system and GAMBIT printer system (Ben)

Spectrum objects:
* Make spectrum scale limit getter public (Ben)

General:
* Implement isNaN (look at cmath) (Pat)
* Implement NaN check for likelihood in scanner (Pat, Greg)
* Deal safely with errors arising from non-double results with purpose: Likelihood in yaml file (Pat)

DecayBit:
* Add SM Higgs partial decay widths (Pat / Csaba)
* Make decay table type from SLHAea (Pat)
* Add scalar singlet Higgs partial decay widths (SM + invisible; Pat)
* SUSYHIT SLHA replacement interface (Pat)
* SUSYHIT observable getters (Csaba)

EWPOBit:
* SUSY-POPE interface (Peter)
* Testing of FeynHiggs interface (Peter)

BOSS:
* Fix possible copy-constructor memory leak (Anders)
* Fix erroneous header include bug (Anders)
* Wrap global backend functions requiring BOSSed classes (Anders)

ScannerBit:
* Connect Diver (Pat)
* Plugins need the option to link standard GAMBIT/ScannerBit libraries: MPI, GSL, etc (Greg)
* Get rid of 'optional options:' entries in yaml options object. (Greg)

Repo/cmake:
* Split repo into public (code) bit and private extras, Collab doc etc, using git filter-branch (Pat)
* Add check and check-ignore switch for graphviz (Antje)
* Implement proper scanner ditching (Pat)


For first release:

Messaging:
* Separate output/log for points with "BadPoint" errors (Ben)
* Write printer functions for all common functor types and print streams (Ben)

General:
* Add credit/citation system (Pat)
* Fill out capabilities database (all)
* Fill out models database (all)
* Make an alternative release setup that also includes some version of all backends (Antje, Pat)
* Fix naming conventions for filenames (lowercase+underscore) (Pat)
* Convert comment headers in source/header files to doxygen (///) format; many are still in old-style (//) format (all)
* Convert comments to Doxygen (all)
* Tinkering with rollcall macros to improve compile time with -O2 (Pat)
* Bool pipe indicating if conditional deps / bereqs have been activated or not (Pat)

ScannerBit:
* Implement parallel postprocessor as a scanner (Greg)
* Connect Great (Antje)
* Allow partial linking of scanner external libraries, so that multiple versions of the same external scanner can be compiled into GAMBIT at the same time (Greg)
* Test runs for ScannerBit paper

BOSS:
* Wrap member variables of type pointer-to-BOSSed (Anders)
* Deal with function pointers (Anders)
* Propagate constness properly (Anders)
* Bow out more gracefully when encountering templates, etc (Anders)
* Polishing (Anders)

Jenkins:
* multiple test scripts (Andy, Antje, Pat)
* combinatorics: OSes, compilers, boost (Andy, Antje, Pat)

SpecBit:
* Implement SoftSUSY wrapper (Peter)

Release:
* forking of git repo for each major revision
* tarball release for module standalone release, git + tarball release for main gambit release

cmake:
* switching off openmp (Antje, Pat)


After first release:

IniFile:
* Support alternative simplified ini format (Pat / Christoph)

BOSS:
* implement template BOSS (Anders)

Backends:
* Resolve residual issues with passing strings to fortran backends (Lars / Pat)
* Implement backending of Mathematica codes (Ben to dabble with; no time pressure)
* Implement backending of Python codes (Ben to dabble with; no time pressure)

General:
* Get the doxygen documentation into the Trac Wiki somehow, and updated automatically (Antje & Pat)



Core done:
* No more GET_DEP -> change all examples to safe pointers (*Dep::observable)
* Separate gambit_example.cpps
* Fix naming convention GAMBIT->Gambit
* Create shorthand for parameter access from within module functions (e.g. Params["M0"])
* Module-specific types in module directories, but common return types in Utils/include/shared_types.hpp
* Make functors thread-safe
* Until the autotools are ready to go, can we please clean up the extra confusing makefile? Many of these make variables are not even being used.
* Implement point-level initialisation functions in modules
* Remove any need for macro calls from within module functions (macros-->safe pointer-like objects)
* Until automake and cmake are done, may want to make more "makefile.common" files for readability
* Allow conditional backend requirements (conditional on model only, not dependency)
* Make rollcall macros throw errors if the required #defines have not been done
* Implement standalone compilation of physics modules
* Convert common block / struct access to by-pointer
* Make dependency resolver more model-aware; now it can choose between two otherwise-valid functor options for filling a dependency, based only on the model being scanned.
* Implement elegant optional array reindexing scheme for Fortran arrays
* Implement proper exception handling system
* Implement proper logging system
* Legacy SUFit logging and exception code culled
* Make name of current model (and related lineage tests) accessible from within module functions
* Sort out specification of what can be given to the Scanner as Likelihoods / what can be given as target observables in iniFile
* Add ability to import key-value pair *settings* from the .ini file for modules, backends and their individual functions.
* Allow grouping of backend requirements into blocks
* Implement point-level initialisation functions for backends, replacing PointInit functions.
  - This involves the new module BackendInitBit, specifically for backend initialisation, containing only functions that initialise backends.  These functions have capabilities X_init, where X is the backend name.  They are able to have regular dependencies, conditional dependencies and allowed_models.  They have no backend requirements, but can access all functions and variables of the backend-version pair that the specific initialisation function is for.  They have result type void.  They act as point-level initialisation functions, but scan-level is easy to emulate using a static bool first = false that is set true at the end of the first call of the function.  Every module function (from any other module) that resolves a backend requirement using a given backend X is endowed with a dependency on X_init, which is provided only by functions in BackendInitBit.  
* Add command line gambit diagnostics:
  gambit capabilities [-v/--verbose]
  gambit modules      [-v/--verbose]
  gambit backends     [-v/--verbose]
  gambit scanners     [-v/--verbose]
  gambit models       [-v/--verbose]
* Create SLHA internal representation, plus hook up file reader/writer
* Make void to function pointer casting for backend functions happen via a union, in order to suppress the corresponding compiler warning.
* Demand that all capabilities have a matching description in a 'capability database'
* Make a rollcall header harvester to create module_rollcall.hpp automagically
* Cmake for build
* Make loop breakers
* Make ModelInUse flags
* Make general-issue random number generator
* Allow dep resolver to understand typedefs
* Write suggested new entry to stdout for auxiliary section of the YAML file if dependency resolution fails.
* Modify GetObslike to deal with vectors of doubles internally
* Add syntactic facility for easily declaring chained dependencies, where all entries in the chain have the same capability-type pair.
* Make it possible to resolve dependencies that match a functor's own capability-type pair
* Run configure for pythia backend
* Fix error in type equivalencies 
* Split Utils dir into codes needed for ScannerBit standalone and those not needed
* Make dependency resolver errors more informative

Models done:
* Remove automatic declaration of "little guys"
* Reunify model macros with module macros as much as possible (dependency macro in particular)
* Create "little guys" (parameter mini-functors)
* Create boost graph to display model hierarchy
* Sort out 'warning redefined' warnings from BOOST about TUPLE_TO_SEQ.
* Massage function in ModelBit that checks that all the user-requested models are actually used by the dependency resolver.  If not, throw an error to say that they are wasting their CPU time with the unused parameters. 
* Make it possible to declare in module function rollcall macro calls that multiple models are required to be scanned, e.g. ALLOWED_MODELS(GROUP1, blah), ALLOWED_MODELS(GROUP2, blah), s.t. the function requires something from GROUP1 and GROUP2 to be scanned, in order to be used in a given scan. 
* Explicitly disallow multiple parents in all parts of Models (and other) code.


HE Collider
-----------

* Address some of the other TODOs in the makfiles.

* Py8 shower alpha_s -> 0.118

* Reorganise the Makefile to build more intermediate .o files to speed up compilation

* Do the same-process xsec aggregation on SubprocessGroup rather than in Analysis

* Parameterising strong subprocess cross-sections
* Huge K-factor tails from Prospino?


* Interpolate subprocess NLO cross-sections
* SUSY subprocesses thread split generalization
- Martin and Abram discussed briefly. We came up with a good idea about when to neglect
  a particular subprocess:

  number_of_events = cross_section * Acceptance * Efficiency * Luminosity
  Acceptance * Efficiency <= 1
  ==> number_of_events <= cross_section * Luminosity

  If that number_of_events is less than the known systematic uncertainty for all
  analyses, then we can 'neglect' the subprocess. Thus, we don't bother to simulate it,
  simply set the likelihood for those analyses = 1.
* Collate analyses for different subprocesses, with different k-factor weightings

* Convert HEColliderMain to be able to run with/without Delphes/FastSim
   Put safety checking into the direct P8->Event code, re. P4 mass safety. No
   -ve masses, please! Hopefully not an issue, but maybe Py8 has a way to get
   the 4-vec mass other than via E2-p2.

* Standardise the namespaces used (and using'd)

* Write more analysis codes!
* Verification of ATLAS limits
* Disabling Py8 model elements => properly populate the Event (direct and via Delphes/FastSim)


* Cleanup collider code... Once class loading is ready, all our code should really be hooked up to Gambit.
- in the meantime, make a Gambit module skeleton ready for our code to hook into
- see if hooking up with Gambit is possible without class loading


Scanner
-------

Ongoing:
* Interface to GREAT (Antje's MCMC code)
* Interface to differential evolution (Pat)
* Interface to k-walk (Greg)
* Interface to genetic algorithms (Abram)
* Organise grouping of parameters into fast and slow subsets (useful for some scanners), possibly via the ini file.
* add documentation
  - quick start for each plugin
  - internal documentation
* plugin descriptions in plugin files

Done:
* Interface to MultiNest
* Streamlining of Scanner Plugin architecture
* scanner info to core → scanner name, version, library file, library present, YAML options
* switch to using gambit error system
* create plugin registry
* tidy up scanner section in yaml file 
* remove output capture
* update printer system interface 
* tidy up plugin interface
* switch to using Random::draw()
* interface external scanner lib depedencies properly with cmake
* Organise dedicated scanner section in yaml .ini file structure


DarkBit
-------

Ongoing:
* DarkSUSY relic density solver
  - Problem with Fortran vs. C++ array indexing
* Annihilation yields in DarkSUSY
* Lars' p-/e+ propagation codes
* Neutrinos from sun code in DarkSUSY + IceCube
* Direct search codes (Chris' Fortran routines)
* Relic density solver of MicrOmegas
* SuperISO relic
* PPPC (tables only?)
* CR data (PAMELA, AMS-02 etc)
* Planck, ATC, BESS, WMAP pol, HST... (CosmoBit)
* Astrophysical probes in general (stars, DM self-interaction)
* Implementation of minimal model (singlet DM) for prototypical model and
  cross-section definitions etc.
  - as new Model
  - Calculation of relic density
  - Primitive indirect dwarf limits
  - Direct limits with Chris' module
* Implementation of CMB limits (starting with codes from singlet paper)
* Primitive dwarf/GC likelihood
* Astrophysical DM distributions (substucture & phase space)
* Decaying dark matter
* Asymmetric dark matter
* Make use of print functions, once completed
* Make use error system, once there


More
----
Inline to-dos can be be found here: \todo Do things in the to-do list.
