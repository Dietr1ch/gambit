GAMBIT To-do List
=================

(G3 = GAMBIT III = March Collaboration Meeting)


Core
----

Rollcall:
* Implement scan-level and point-level initialisation functions in backends (**Pat & Chistoph; before G3**)
* Allow grouping of backend requirements into blocks  (**Pat; before G3**)
* Tracking of config files -> lists in module/backend rollcall headers (**Pat; before G3**)
  - Add module-level and backend-level HAS_CONFIG_FILE(filename, flag:OVERIDABLE) and DEFINE_CONFIG_FILE_KEY(key, filename) rollcall macros, to allow settings for modules and backends to be stored/specified in configuration files that exist separately to the .ini file
* Investigate whether encapsulation of module functions and the things they can access (Dep::s, Params[], etc) could be straightforwardly implemented.
* Make a rollcall header harvester to create module_rollcall.hpp automagically (**Pat, by extending the existing type harvester; before G3**)
* Make name of current model (and related lineage tests) accessible from within module functions (**Pat; before G3**)

IniFile:
* Add ability to import key-value pair *settings* from the .ini file for modules, backends and their individual functions. (**Christoph & Pat; before G3**)
* Allow config file keys to be overridden in the .ini file according to key name, if the config file they belong to has been declared with the OVERIDABLE flag; otherwise, the ini parser should throw an error. (**Christoph; before G3**)
* Support alternative ini format(s)

Dependency Resolver:
* Make dependency resolver more model-aware; at the moment it apparently cannot choose between two otherwise-valid functor options for filling a dependency, based only on the model being scanned.  (**Christoph; before G3**)
* Modify model checks in dependency resolver so that all observables are parsed and their dependencies resolved before concluding that some model is not used for anything, and throwing an error (put FlavBit test obervables first in gambit.yaml to see this error)  (**Christoph & Ben; before G3**)
* Make dependency resolver errors more informative (**Christoph; no major time pressure**)

Backends:
* Implement The BOSS (backend-on-a-stick script; classloader) (**Anders; before G3**)
* Convert common block / struct access to by-pointer (**Anders; before Xmas**)
* Implement elegant optional array reindexing scheme for Fortran arrays (**Lars & Pat; before G3**)
* Resolve residual issues with passing strings to fortran backends (**Pat, Csaba, Ben & Anders; before G3**)
* Implement backending of Mathematica codes (**Ben to dabble with; no time pressure**)
* Implement backending of Python codes (**Ben to dabble with; no time pressure**)

Messaging:
* Implement proper exception handling system (**Pat, talking to Ben; before G3**)
* Implement proper logging system (**Ben, talking to Pat; before G3**)
* Write printer functions for all common functor types and print streams (**Hopefully happens a bit on its own as the two points above get dealt with**)

General:
* Experiment with automake and cmake for build (**Antje to update automake system to current master; Ben, Pat, Chistoph + others to test; Antje to merge into master before G3. Cmake to be left for after G3.**)
* Get the doxygen documentation into the Trac Wiki somehow, and updated automatically (**Antje & Pat; before G3**)
* Create SLHA internal representation, plus hook up file reader/writer. (**Are, Csaba; progress before G3, completion maybe not**) 
* General review of legacy code -> cull obsolete stuff (**ALL, but Pat and Ben to pay special attention to legacy SUFit code in ModelParameters, exceptions and logging systems**)
* Fix naming conventions (**ALL, whenever we touch a file!!**)
  - filenames (lowercase+underscore)
* Convert comment headers in source/header files to doxygen (///) format; many are still in old-style (//) format (**ALL, whenever we touch a file!!**)
* Convert comments to Doxygen (**ALL, whenever we touch a file!!**)

Recent decisions impacting upcoming development:
* Separate output/log for points with "BadPoint" errors
* No virus-like global "using namespace blah" in headers; scoped use of namespaces only

Done:
* No more GET_DEP -> change all examples to safe pointers (*Dep::observable)
* Separate gambit_example.cpps
* Fix naming conventions
  - GAMBIT->Gambit
* Create shorthand for parameter access from within module functions (e.g. Params["M0"])
* Module-specific types in module directories, but common return types in Utils/include/shared_types.hpp
* Make functors thread-safe
* Until the autotools are ready to go, can we please clean up the extra confusing makefile? Many of these make variables are not even being used.
* Implement point-level initialisation functions in modules
* Remove any need for macro calls from within module functions (macros-->safe pointer-like objects)
* Until automake and cmake are done, may want to make more "makefile.common" files for readability
* Allow conditional backend requirements (conditional on model only, not dependency)  (**Pat; before G3**)
* Make rollcall macros throw errors if the required #defines have not been done
* Implement standalone compilation of physics modules


Models
------

Ongoing:

* Massage function in ModelBit that checks that all the user-requested models are actually used by the dependency resolver. (**Christoph & Ben; before G3**)
  - If not, throw an error to say that they are wasting their CPU time with the unused parameters.  
  - This entry is the same as one on the Core::Dependency Resolver part of the TODO list 

* Sort out 'warning redefined' warnings from BOOST about TUPLE_TO_SEQ. (**Ben; before G3**)
  - Need to check if variadics exists before bothering to redefine the macro, or something.

Done:
* Reunify model macros with module macros as much as possible (dependency macro in particular)
* Create "little guys" (parameter mini-functors)
* Create boost graph to display model hierarchy


HE Collider
-----------

* Address some of the other TODOs in the makfiles.

* Py8 shower alpha_s -> 0.118

* Reorganise the Makefile to build more intermediate .o files to speed up compilation

* Do the same-process xsec aggregation on SubprocessGroup rather than in Analysis

* Parameterising strong subprocess cross-sections
* Huge K-factor tails from Prospino?


* Interpolate subprocess NLO cross-sections
* SUSY subprocesses thread split generalization
- Martin and Abram discussed briefly. We came up with a good idea about when to neglect
  a particular subprocess:

  number_of_events = cross_section * Acceptance * Efficiency * Luminosity
  Acceptance * Efficiency <= 1
  ==> number_of_events <= cross_section * Luminosity

  If that number_of_events is less than the known systematic uncertainty for all
  analyses, then we can 'neglect' the subprocess. Thus, we don't bother to simulate it,
  simply set the likelihood for those analyses = 1.
* Collate analyses for different subprocesses, with different k-factor weightings

* Convert HEColliderMain to be able to run with/without Delphes/FastSim
   Put safety checking into the direct P8->Event code, re. P4 mass safety. No
   -ve masses, please! Hopefully not an issue, but maybe Py8 has a way to get
   the 4-vec mass other than via E2-p2.

* Standardise the namespaces used (and using'd)

* Write more analysis codes!
* Verification of ATLAS limits
* Disabling Py8 model elements => properly populate the Event (direct and via Delphes/FastSim)


* Cleanup collider code... Once class loading is ready, all our code should really be hooked up to Gambit.
- in the meantime, make a Gambit module skeleton ready for our code to hook into
- see if hooking up with Gambit is possible without class loading


Scanner
-------

Ongoing:
* Streamlining of Scanner Plugin architecture
* Interface to Antje's MCMC code
* Interface to differential evolution
* Interface to k-walk
* Interface to genetic algorithms
* Organise dedicated scanner section in yaml .ini file structure
* Organise grouping of parameters into fast and slow subsets (useful for some scanners), possibly via the ini file.

Done:
* Interface to MultiNest


DarkBit
-------

Ongoing:
* DarkSUSY relic density solver
  - Problem with Fortran vs. C++ array indexing
* Annihilation yields in DarkSUSY
* Lars' p-/e+ propagation codes
* Neutrinos from sun code in DarkSUSY + IceCube
* Direct search codes (Chris' Fortran routines)
* Relic density solver of MicrOmegas
* SuperISO relic
* PPPC (tables only?)
* CR data (PAMELA, AMS-02 etc)
* Planck, ATC, BESS, WMAP pol, HST... (CosmoBit)
* Astrophysical probes in general (stars, DM self-interaction)
* Implementation of minimal model (singlet DM) for prototypical model and
  cross-section definitions etc.
  - as new Model
  - Calculation of relic density
  - Primitive indirect dwarf limits
  - Direct limits with Chris' module
* Implementation of CMB limits (starting with codes from singlet paper)
* Primitive dwarf/GC likelihood
* Astrophysical DM distributions (substucture & phase space)
* Decaying dark matter
* Asymmetric dark matter
* Make use of print functions, once completed
* Make use error system, once there


More
----
Inline to-dos can be be found here: \todo Do things in the to-do list.
