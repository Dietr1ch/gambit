//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Ascii printer class member function definitions
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///   
///  \author Ben Farmer
///          (benjamin.farmer@monash.edu.au)
///  \date 2013 Jul, Sep, 2014 Jan
///
///  *********************************************


// Standard libraries
#include <map>
#include <vector>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>

// Gambit
#include "asciiprinter.hpp"
#include "stream_printers.hpp"
#include "model_types.hpp"
#include "all_functor_types.hpp" // Automatically generated by functor_type_harvester.py

// Code!
namespace Gambit
{

  namespace Printers 
  {

    // Printer to ascii file (i.e. table of doubles)

    // Constructor
    asciiPrinter::asciiPrinter(std::ofstream& myfstrm) :
      my_fstream(myfstrm) 
    {
      bufferlength = 10;
      buffer.resize(bufferlength); 
      my_fstream.precision(6); // Precision of output; could easily supply this to the constructor instead.
    }
  
    // default destructor should be fine?
 
    // Initialisation function
    // Run by dependency resolver, which supplies the functors with a vector of VertexIDs whose printme flags are set to true.
    void asciiPrinter::initialise(const std::vector<int>& printmevec)
    {
      // Loop through buffer and initialise all the elements
      for (int i=0; i<bufferlength; i++)
      {
        for (std::vector<int>::const_iterator it = printmevec.begin();
        it != printmevec.end(); it++)
        {
          // Add element to line of buffer (uses default (empty) constructor)
          buffer[i][*it];
        }
      } 
    }
 
    // Clear buffer
    void asciiPrinter::erase_buffer()
    {
      for (int i=0; i<bufferlength; i++)
      {
        for (LineBuf::iterator 
          it = buffer[i].begin(); it != buffer[i].end(); it++)
        {
          // We want to preserve the vertex ID's and just erase the vector part (second) of the map
          (it->second).clear();
        }
      }
    }
  
    // Tell printer to start a new line of the ascii output file
    void asciiPrinter::endline()
    {
      std::cout<<"In acsiiPrinter: starting new printer line!"<<std::endl; 

      // Move buffer location index to the next line
      buf_loc += 1;
      
      // Check if we have filled the buffer
      if (buf_loc >= bufferlength)
      {
        std::map<int,int> newlineindexrecord;
        // Work out how to organise the output file            
        // To do this we need to go through the buffer and find the maximum length of vector associated with each VertexID.
        for (int i=0; i<bufferlength; i++)
        {
          for (LineBuf::iterator 
            it = buffer[i].begin(); it != buffer[i].end(); it++)
          { 
            //(*it)->first  - VertexID
            //(*it)->second - std::vector<double> (result values)
            int oldlen = newlineindexrecord[it->first];
            int newlen = (it->second).size();
            newlineindexrecord[it->first] = std::max(oldlen, newlen);
          }
        }
        // Check if the output format has changed, and raise an error if so
        if (lineindexrecord.size()!=0)
        {
          if (lineindexrecord!=newlineindexrecord)
          {
            //TODO: raise proper gambit error
            std::cout<<"Error! Output format has changed during run! The asciiPrinter cannot handle this!"<<std::endl;
            std::exit(1);
          }
        }
        else
        {
          lineindexrecord = newlineindexrecord;
        }
 
        // Write to file and reset buffer
        dump_buffer();
        erase_buffer();
        buf_loc = 0;
      }
    }
  
    // add results to printer buffer
    void asciiPrinter::addtobuffer(const int& vID, const std::vector<double>& functor_data) 
    {
      //TODO: If a functor gets call twice without the printer advancing the data will currently just be overwritten. Should generate an error or something.
      buffer[buf_loc][vID] = functor_data; 
    }
 
    // write the printer buffer to file       
    void asciiPrinter::dump_buffer()
    {
      for (int i=0; i<bufferlength; i++)
      {
        for (std::map<int,int>::iterator
          it = lineindexrecord.begin(); it != lineindexrecord.end(); it++)
        { 
          int length; // slots reserved in output file for these results
          int reslength;  // actual length of the current results vector
          //(*it)->first  - VertexID
          //(*it)->second - std::pair<int,int> containing startindex and length
          std::vector<double>& results = buffer[i][it->first];
          reslength  = results.size();
          length     = it->second;
 
          // print to the fstream!
          for (int j=0;j<length;j++)
          {
            if(j>=reslength)
            {
              // Allocated space exceeded; fill remaining slots with 'none'
              my_fstream<<std::setw(14)<<"none";
            }
            else
            {
              // print an entry from the results vector
              my_fstream<<std::scientific<<results[j]<<"\t";
            }
          }
          // result printed, do next result                
        } 
        // line printed, print endline character and go to next line
        my_fstream<<std::endl;
      }
      // buffer dump complete! Flush the fstream to ensure write to file happens.
      my_fstream.flush();
    }
 
 
    // PRINT FUNCTIONS
    //----------------------------
    // Need to define one of these for every type we want to print!
    // Could use macros again to generate identical print functions 
    // for all types that have a << operator already defined.
    void asciiPrinter::print(double const& value, const int vertex, const std::string func_name, const std::string func_capability, const std::string origin_name)
    {
      std::vector<double> vdvalue(1,value);
      addtobuffer(vertex,vdvalue);       
    }
 
    void asciiPrinter::print(std::vector<double> const& value, const int vertex, const std::string func_name, const std::string func_capability, const std::string origin_name)
    {
      addtobuffer(vertex,value);
    }
   
    void asciiPrinter::print(ModelParameters const& value, const int vertex, const std::string func_name, const std::string func_capability, const std::string origin_name)
    {
      std::map<std::string, double> parameter_map = value.getValues();
      std::vector<std::string> names;
      std::vector<double> vdvalue;
      names.reserve(parameter_map.size());
      vdvalue.reserve(parameter_map.size());
      int i = 0;
      for (std::map<std::string, double>::iterator 
        it = parameter_map.begin(); it != parameter_map.end(); it++)
      {
        names[i] = it->first;
        vdvalue[i] = it->second;
      }
      addtobuffer(vertex,vdvalue);
    }
     
  } // end namespace printers
} // end namespace Gambit
