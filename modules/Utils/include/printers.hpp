//   GAMBIT: Global and Modular BSM Inference Tool
//   *********************************************
///  \file
///
///  Functor "print" functions header file
///
///  *********************************************
///
///  Authors (add name and date if you modify):
///   
///  \author Ben Farmer
///          (benjamin.farmer@monash.edu.au)
///  \date 2013 Jul, Sep
///
///  *********************************************


#ifndef __printers_hpp__
#define __printers_hpp__

#include <map>
#include <vector>
#include <sstream>
#include <boost/preprocessor/seq/for_each.hpp>
#include <boost/preprocessor/punctuation/comma_if.hpp>
#include "boost_fallbacks.hpp"
#include "all_functor_types.hpp" // Automatically generated by functor_type_harvester.py
#pragma message BOOST_PP_STRINGIZE(PRINTABLE_TYPES) //PRINTABLE_TYPES resides in all_functor_types.hpp 

#define VPRINT(r,data,elem)                       \
  virtual void print(elem& value)                 \
  {                                               \
    std::cout<<"WARNING! No print function override has been defined for this type (for whatever printer class the current printer comes from)"<<std::endl; \
  }                                              

#define ADD_ALL_PRINT_FUNCTIONS \
  BOOST_PP_SEQ_FOR_EACH(VPRINT, _, PRINTABLE_TYPES)

namespace Gambit
{

  namespace printers 
  {

    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //% Printer class declarations                          %
    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     
    // BASE PRINTER CLASS
   
    class BasePrinter  
    {
      public:
        // We need to have a virtual print method for EVERY type we ever want to print (i.e. for every type that can be held in the 'myValue' data member of a module functor). Generate these using a macro.
        // Run the macro; add all the print functions
        ADD_ALL_PRINT_FUNCTIONS
    };
  
    // DERIVED PRINTER CLASSES

    // Printer to ostream
    class ostreamPrinter : public BasePrinter
    {
      public:
        // Default constructor: sets my_ostream to std::cout and verbose to True
        ostreamPrinter() : 
          my_ostream(std::cout), verbose(1) { }
  
        // Constructor
        ostreamPrinter(std::ostream& mystrm, bool vrbs) :
          my_ostream(mystrm), verbose(vrbs) { }
   
        // default destructor should be fine?
 
        // PRINT FUNCTIONS
        //----------------------------
        // Need to define one of these for every type we want to print!
        // Could use macros again to generate identical print functions 
        // for all types that have a << operator already defined.
        void print(double& value)
        {
          if (verbose) {std::cout<<"printing a double using ostreamPrinter!"<<std::endl;}
          my_ostream<<value<<std::endl;       
        }

        void print(std::vector<double>& value)
        {
          if (verbose) {std::cout<<"printing a std::vector<double> using ostreamPrinter!"<<std::endl;}
          my_ostream<<value<<std::endl;       
        }
       
       
        void print(ModelParameters& value)
        {
          std::map<std::string, double> parameter_map = value.getValues();
          typedef std::map<std::string, double>::iterator map_it;
          if (verbose) {std::cout<<"printing a ModelParameters object using ostreamPrinter!"<<std::endl;}
          my_ostream << "[";
          for (map_it it = parameter_map.begin(); it != parameter_map.end(); it++)
          {
            my_ostream << it->first <<":"<< it->second << ", ";
          }
          my_ostream << "\b\b]";
        }
    
      private:
        std::ostream& my_ostream;
        bool verbose;
    };
  
  
    // Simple printer which converts functor results to a vector of doubles.
    class vecdoublePrinter : public BasePrinter
    {
      public:

        // Call this to receive a pointer to the database of stored results
        std::vector<std::vector<double>> get_results()
        {
          return results;
        }

        // Empty the stored results
        void erase_results()
        {
          results.clear();
        }
  
        // PRINT FUNCTIONS
        //----------------------------
        // Need to define one of these for every type we want to print!

        void print(double& value)
        {
          std::vector<double> new_result;
          new_result.push_back(value);
          results.push_back(new_result);
        }

        void print(std::vector<double>& value)
        {
          results.push_back(value);
        }

        void print(ModelParameters& value)
        {
          // In reality we also need some way of tracking which entry is which if this is to be useful...
          std::map<std::string, double> parameter_map = value.getValues();
          std::vector<double> out;
          typedef std::map<std::string, double>::iterator map_it;
          int i = 0;
          out.resize(parameter_map.size());
          for (map_it it = parameter_map.begin(); it != parameter_map.end(); it++)
          {
            out[i] = it->second; // Extracts *value* from the map
            i++;
          }
          results.push_back(out);
        }

      private:
        // Store the last result retrieved from a functor
        std::vector<std::vector<double>> results;
    };
 

     
  } // end namespace printers
} // end namespace Gambit

#endif //ifndef __printers_hpp__
