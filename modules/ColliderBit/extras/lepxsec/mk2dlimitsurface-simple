#! /usr/bin/env python

from p2 import *
import numpy as np
import matplotlib as mpl
from matplotlib import pyplot as plt
from pprint import pprint

import optparse
op = optparse.OptionParser()
opts, args = op.parse_args()


limit_lines = []
for a in args:
    fname, val = a.split(":")
    limit_points = []
    with open(fname) as f:
        for line in f:
            xy = [float(i) for i in line.strip().split()]
            limit_points.append(P2(xy[0], xy[1]))
    limit_lines.append( (limit_points, val) )


## Limits
def minmax(vals):
    return min(vals), max(vals)
xmin = min(p.x for (pts,_) in limit_lines for p in pts)
xmax = max(p.x for (pts,_) in limit_lines for p in pts)
ymin = min(p.y for (pts,_) in limit_lines for p in pts)
ymax = max(p.y for (pts,_) in limit_lines for p in pts)

def mkfig():
    fig = plt.figure()
    ax = fig.add_subplot(1,1,1)
    ax.hold(True)
    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    return fig, ax

## Plot limit lines
fig, ax = mkfig()
for pts, val in limit_lines:
    ax.plot([p.x for p in pts], [p.y for p in pts], "-", label=val)
ax.legend(loc="best")
fig.savefig("lims.pdf")


###############


## Sample the lines between points more densely to build proper contours
contourpts = []
for pts, val in limit_lines:
    xsec = float(val)
    for i in xrange(len(pts)-1):
        v = pts[i+1] - pts[i]
        numpts = (len(v) // 1.0) + 2
        for l in np.linspace(0, 1, numpts)[:-1]:
            l = float(l)
            p = pts[i] + v*l
            p.xs = xsec
            if p.x < 94.01: # < cut out crap mix of points on RHS vertical
                contourpts.append(p)

## Make intermediate contours
newcontourpts = []
# for i, pt in enumerate(contourpts[:-1]):
#     pclosest = sorted(contourpts[i+1:], key=lambda pt2 : len(pt-pt2) if pt.xs != pt2.xs else 1e10)[0]
#     pmid = (pt+pclosest)/2.
#     pmid.xs = (pt.xs+pclosest.xs)/2.
#     newcontourpts.append(pmid)

## Fill x,y,xs lists for plotting, interpolating, etc.
xs, ys, xsecs = [], [], []
for pt in contourpts + newcontourpts:
    xs.append(pt.x)
    ys.append(pt.y)
    xsecs.append(pt.xs)


## Plot interpolation input points
fig, ax = mkfig()
ax.plot(xs, ys, "r.")
for i in xrange(len(xs)): #//2 - 1):
    j = i #2*i + 1
    ax.text(xs[j], ys[j], "{:0.2g}".format(xsecs[j]), fontsize="xx-small", color="gray")
fig.savefig("xsecipolpoints.pdf")


###############


## Transforming functions
def f(x):
    "Flattening function to reduce rapid peaking at kin limit"
    if x < 0.5: return x
    return 0.5 + 0.2*math.log(x+0.5)
F = np.vectorize(f)
def finv(y):
    "Inverse of flattening function"
    if y < 0.5: return y
    return math.exp(5*(y-0.5)) - 0.5
Finv = np.vectorize(finv)


# ## Interpolate into a full 2D grid
from scipy import interpolate
ipol = interpolate.SmoothBivariateSpline(xs, ys, F(xsecs), kx=3, ky=3)
ipolv = np.vectorize(ipol)
xs2 = np.linspace(xmin, xmax, 400)
ys2 = np.linspace(ymin, ymax, 400)
xx, yy = np.meshgrid(xs2, ys2)
vv = Finv(ipolv(xx, yy))
#np.set_printoptions(threshold=np.nan)
#print vv #abs(vv) > 1

## Mask kinematically inaccessible regions
vv_clipped = np.clip(vv, 0, 1e2)
for i, x in enumerate(xs2):
    for j, y in enumerate(ys2):
        if vv_clipped[j,i] <= 0:
            vv_clipped[j,i] = 1e-3
        if x > 94 or y > x:
            #print x, y
            vv_clipped[j,i] = np.nan

## Plot interpolation output points
fig, ax = mkfig()
ax.plot(xx[::32,::32], yy[::32,::32], "r.")
for i, x in enumerate(xs2[::32]):
    for j, y in enumerate(ys2[::32]):
        ax.text(x, y, "{:0.2g}".format(vv[32*j,32*i]), fontsize="xx-small", color="gray")
fig.savefig("xsecgridpoints.pdf")

## Plot interpolated contour
#levels = [0.0, 0.1, 0.2, 0.3, 0.5, 1, 2, 3, 4 , 5]
levels = np.arange(0, 3.1, 0.05)
#
fig, ax = mkfig()
c = ax.contourf(xx, yy, vv_clipped, levels)
cb = fig.colorbar(c) #, cmap="hot") #mpl.cm.hot)
fig.savefig("xseccontour.pdf")
#
fig, ax = mkfig()
c = ax.contourf(xx, yy, np.log10(vv_clipped), levels)
cb = fig.colorbar(c) #, cmap=mpl.cm.hot)
fig.savefig("xseccontourlog.pdf")
