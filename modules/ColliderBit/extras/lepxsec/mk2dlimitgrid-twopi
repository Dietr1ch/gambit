#! /usr/bin/env python

from __future__ import division
import numpy as np
from matplotlib import pyplot as plt

from p2 import P2, LineSegment

import optparse
op = optparse.OptionParser()
opts, args = op.parse_args()

## Limit contours read from file. Plot limits read from extremum of the data.
limitContours = {}

# For the xsection limit plot: x = some mass, y = some other mass, z = xsec limit
xmin = np.inf
xmax = -np.inf
ymin = np.inf
ymax = -np.inf
zmin = np.inf
zmax = -np.inf

for a in args:
    try:
        # NOTE: An input of the lowest xsec limit...
        if float(a) < zmin:
            zmin = float(a)
        continue
    except:
        pass
    fname, xsec = a.split(":")
    limitContours[xsec] = []
    limitPoints = []
    if float(xsec) > zmax:
        zmax = float(xsec)
    with open(fname) as f:
        for line in f:
            xy = [float(i) for i in line.strip().split()]
            if xy[0] > xmax:
                xmax = xy[0]
            if xy[0] < xmin:
                xmin = xy[0]
            if xy[1] > ymax:
                ymax = xy[1]
            if xy[1] < ymin:
                ymin = xy[1]
            limitPoints.append(P2(xy[0], xy[1]))
    for i in xrange(len(limitPoints) - 1):
        limitContours[xsec].append(LineSegment(limitPoints[i], limitPoints[i+1]))
    # NOTE: The data will enforce closed contours, so this is unneccessary
    ###### limitContours[xsec].append(LineSegment(limitPoints[-1], limitPoints[0]))

if xmin < 0.:
    xmin = 0.
if ymin < 0.:
    ymin = 0.

x = np.linspace(xmin, xmax, 100)
y = np.linspace(ymin, ymax, 100)
xx, yy = np.meshgrid(x, y, indexing='ij')
zz = np.zeros_like(xx)

for i in xrange(100):
  for j in xrange(100):
    if yy[i,j] > xx[i,j]:
        zz[i,j] = np.nan
        continue
    point = P2(xx[i,j], yy[i,j])
    rayCollection = []
    for angle in np.arange(0., 2.*np.pi, np.pi/10):
        rayMaker = P2(1000. * np.cos(angle), 1000. * np.sin(angle))
        ray = LineSegment(point, point + rayMaker)
        rmin = np.inf
        xsec_at_rmin = 0.
        sigma_at_rmin = 0.
        for xsec in limitContours.keys():
            for segment in limitContours[xsec]:
                intersection = ray.intersectsAt(segment)
                raydius = abs(LineSegment(point, intersection))
                if raydius < rmin:
                    rmin = raydius
                    xsec_at_rmin = float(xsec)
                    ### TODO: Is this the proper thing to use for the uncertainty of the masses?
                    sigma_at_rmin = abs(P2(0.03 * intersection.x * np.cos(angle),
                                      0.03 * intersection.y * np.sin(angle)))
        if rmin < np.inf:
            rayCollection.append((xsec_at_rmin, rmin, sigma_at_rmin))
    # The maximum xsec of all rayResults is what the sigmoid will "decay" to
    xsecmax = min([rayResult[0] for rayResult in rayCollection])
    for rayResult in rayCollection:
        if rayResult[0] == xsecmax:
            zz[i,j] += xsecmax
        else:
            zz[i,j] += rayResult[0] + (xsecmax - rayResult[0]) * np.e**(
                     -0.5 * rayResult[1]**2 / rayResult[2]**2)
            ## -0.5 * (rayResult[1] + 0.5 * rayResult[2])**2 / rayResult[2]**2)
    zz[i,j] /= len(rayCollection)

fig, axes = plt.subplots(figsize=(11,7), facecolor='#ffffff')
levels = np.array([0.1, 0.15, 0.2, 0.25, 0.3, 0.4, 0.5, 1.25, 2.0])
contours = plt.contourf(xx, yy, zz, levels, cmap=plt.get_cmap('Dark2'))
for xsec in limitContours.keys():
    for segment in limitContours[xsec]:
        x, y = segment.allpoints(1000)
        plt.plot(x, y, linewidth=2, color='black', alpha=0.4, zorder=20)
cb = fig.colorbar(contours, cmap=plt.get_cmap('Dark2'))
fig.savefig("xsecGridWithSigmoid.pdf")
