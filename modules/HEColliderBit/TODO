GAMBIT HE COLLIDER TODO LIST
============================

* Py8 shower alpha_s -> 0.118


* Parameterising strong subprocess cross-sections
* Huge K-factor tails from Prospino?


* Interpolate subprocess NLO cross-sections
* SUSY subprocesses thread split generalization
- Martin and Abram discussed briefly. We came up with a good idea about when to neglect
  a particular subprocess:

  number_of_events = cross_section * Acceptance * Efficiency * Luminosity
  Acceptance * Efficiency <= 1
  ==> number_of_events <= cross_section * Luminosity

  If that number_of_events is less than the known systematic uncertainty for all
  analyses, then we can 'neglect' the subprocess. Thus, we don't bother to simulate it,
  simply set the likelihood for those analyses = 1.
* Collate analyses for different subprocesses, with different k-factor weightings
* Convert HEColliderMain to be able to run with/without Delphes/FastSim


* Write more analysis codes!
* Verification of ATLAS limits
* Disabling Py8 model elements => properly populate the Event (direct and via Delphes/FastSim)


* Cleanup collider code... Once class loading is ready, all our code should really be hooked up to Gambit.
- in the meantime, make a Gambit module skeleton ready for our code to hook into
- see if hooking up with Gambit is possible without class loading


* Py8 feedback
- Speeding up SLHA model initialization: perhaps we could multithread to speed this up?
