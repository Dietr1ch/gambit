Todo list for BOSS:
-------------------

Currently working on: 

Anders: 17, 18
Abram : ?


(2)
Implement a fix for the nameclash between the forward declarations
used in 'abstract_SomeClass.hpp' and the typedef that will be used in
GAMBIT to rename the wrapper classes: 
  typedef SomeClass_GAMBIT SomeClass

-- POSSIBLE FIX:
Extract from 'abstract_SomeClass.hpp' anything that depends on the forward
declarations, and stick this in another header 'abstract_SomeClass_extras.hpp'
that will only be included by the external code, not by GAMBIT.


(5)
Make BOSS generate the 'backend_SomeCode.hpp' file that will go into
'GAMBIT/modules/Backends/include/'. Mostly, this amounts to generating all
the correct BE_FUNCTION(...) lines for both class factory functions and
general global functions.


(6)
Figure out how to deal with friend classes and functions? Do we even have to worry about this?


(8)
At the moment BOSS does not know how to deal with function pointers as return/argument type...


(9)
Generate the correct wrapper functions for template functions.

-- POSSIBLE FIX:
When parsing the original code: When the first specialization is encountered, 
write an empty, general template function:

  template <typename T, typename U>
  void tempFunc_GAMBIT(T t, U u) {}

Then write the wrapper for the given specialization:

  template<>
  void tempFunc_GAMBIT<int, double>(int i, double d) {}

When writing to the source code file, make sure that the empty template function
appears before any of the specializations.


(10)
When creating cfg.std_types_dict, we must check all template arguments before 
accepting a template specialization as a standard type.


(12)
Fix constrFactoryFunction to work properly with template classes


(13)
How do deal with inheritance of accepted, but non-loaded, classes. (E.g. some class inheriting from one of the
std:: classes). We cannot have both class X and class Abstract_X inheriting from the same class, as this will cause
an ambiguity error (even if we use virtual inheritance). 

  Possible solutions:

    Alt 1) Move inheritance from class X and up to class Abstract_X.
           This requires us to find the position of the inheritance statement in the original source and remove it.

    Alt 2) Simply don't add an inheritance statement for class Abstract_X.
           This probably means that none of the inherited member functions can be loaded.

Will implement alt. 2) for now, but we should investigate whether we should aim for alt. 1) in the future.

(15)
Deal with classes-within-classes.

(17)
Do away with STL dictionary by following include statements backwards to determine which
standard/boost/other headers need to be included in the abstract and wrapper classes.

UPDATE: 
There's probably no way around having a dictionary like that. It should be expanded to contain some 
common BOOST (and ROOT?) types as an example. Also, if BOSS encounters a type with no known header file, 
it could output a hint about where it comes from (STD library, BOOST, etc...) Search the header path and 
type namespace to look for hints.


(18)
Set up a first working example of using a 'BOSSed' Pythia as a backend in GAMBIT.

(19)
Does BOSS produce the correct output when run with several .xml files at once?
According to Abram there may be an issue here. (Not covered by the current testing with Pythia.)


Small things to fix:
--------------------





Known issues (not yet on the todo list):
----------------------------------------

(a)
UPDATE:
If we allow the BEptr within a wrapper class to change target, we can no longer
guarantee that the memory of the original class instance (created with the 'new' operator)
will be deleted. (Also, if the user has two pointers to a single wrapper class instance, and
then tries to modify one of them using some wrapped function, the other pointer will also be
affected indirectly, since the pointer manipulation would happen at the level of the common 
BEptr.)

Thus, we should not allow BEptr to change target. This has the consequence that
any original function that may change the destination of a pointer-to-original-class has to be ignored
by the wrapper system that BOSS constructs. (That is, functions that take pointer-to-pointer or 
reference-to-pointer as input.)

One possible way around this is to let the user work directly with the abstract classes in cases like this.
Another option is to generate wrapper code also for functions that take pointer-to-pointer or reference-to-pointer,
but inform the user of the potential risks...


OLD:
Working with double pointers (pointer-to-pointer) to classes seem to require that
we add another variable 'BEptr2' to the wrapper classes:

 Abstract_SomeClass* BEptr;    // Initialized by the Factory_SomeClass function.
 Abstract_SomeClass** BEptr2;  // Initialized to point to BEptr.

This allows us to do (**SomeClass_GAMBIT).BEptr2 to convert from double-pointer-to-wrapper-class 
to double-pointer-to-abstract-class, which can further be cast to double-pointer-to-original-class
inside the BOSSed external code.

However, if the BEptr variable of two wrapper class instances end up pointing to the *same* 
original class instance, we'll get a terrible memory crash when the wrapper class destructor is run 
("double free or corruption"). A dummy example of such a scenario would be if the original code 
contained a function like this:

  void pointToTheSame(SomeClass** scpp1, SomeClass** scpp2)
  {
    *scpp1 = *scpp2;
  }

Can we protect ourselves from this somehow? This might be a fundamental problem with the classloading system,
since it is based on using the 'new' operator to create pointers (on the heap) to instances of the original class.
These pointers must be deleted somewhere in order to avoid a memory leak, and if two point to the same object we get a
crash. Could this perhaps be solved by some clever use of 'smart pointers'?















