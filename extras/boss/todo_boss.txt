Todo list for BOSS:
-------------------

Currently working on: 

Anders: 7, 3
Abram : ?


(1)
Generate the code for the GAMBIT wrapper classes (in a new header file).


(2)
Implement a fix for the nameclash between the forward declarations
used in 'abstract_SomeClass.hpp' and the typedef that will be used in
GAMBIT to rename the wrapper classes: 
  typedef SomeClass_GAMBIT SomeClass

-- POSSIBLE FIX:
Extract from 'abstract_SomeClass.hpp' anything that depends on the forward
declarations, and stick this in another header 'abstract_SomeClass_extras.hpp'
that will only be included by the external code, not by GAMBIT.


(3)
Rewrite/extend bits of funcparse.py and funcutils.py to generate wrapper functions
for all global functions found in the original code. (Check out the file 'after_BOSS/functions.cpp'
in the example that we passed around earlier.)


(4)
Following from (3), we need BOSS to output a header file with GAMBIT wrapper functions 
for the functions generated in (3). (See 'GAMBIT_wrapper_functions.hpp' in the example.)


(5)
Make BOSS generate the 'backend_SomeCode.hpp' file that will go into
'GAMBIT/modules/Backends/include/'. Mostly, this amounts to generating all
the correct BE_FUNCTION(...) lines for both class factory functions and
general global functions.


(6)
Figure out how to deal with friend classes and functions? Do we even have to worry about this?


(7)
For all functions (global and class members), catch any default argument values and propagate them 
to the wrapper functions BOSS produce.


(8)
At the moment BOSS does not know how to deal with function pointers as return/argument type...


(9)
Generate the correct wrapper functions for template functions.

-- POSSIBLE FIX:
When parsing the original code: When the first specialization is encountered, 
write an empty, general template function:

  template <typename T, typename U>
  void tempFunc_GAMBIT(T t, U u) {}

Then write the wrapper for the given specialization:

  template<>
  void tempFunc_GAMBIT<int, double>(int i, double d) {}

When writing to the source code file, make sure that the empty template function
appears before any of the specializations.


(10)
When creating cfg.std_types_dict, we must check all template arguments before 
accepting a template specialization as a standard type.


(11)
BOSS needs to tackle structs as well as classes.


(12)
UPDATE:
Is this not needed as long as we are absolutely sure that all virtual methods are overwritten?
I can't seem to produce the 'unused parameter' or 'unused return' errors with the example code...

OLD:
Pat suggested a fix for getting rid of the pragma statements. Figure out what it was and
implement it.


(13)
Fix constrFactoryFunction to work properly with template classes



(14)
How do deal with inheritance of accepted, but non-loaded, classes. (E.g. some class inheriting from one of the
std:: classes). We cannot have both class X and class Abstract_X inheriting from the same class, as this will cause
an ambiguity error (even if we use virtual inheritance). 

  Possible solutions:

    Alt 1) Move inheritance from class X and up to class Abstract_X.
           This requires us to find the position of the inheritance statement in the original source and remove it.

    Alt 2) Simply don't add an inheritance statement for class Abstract_X.
           This probably means that none of the inherited member functions can be loaded.

Will implement alt. 2) for now, but we should investigate whether we should aim for alt. 1) in the future.



(15)
Handle operator names in a more elegant way. Currently a simple dictionary is used (cfg.operator_names), but this won't
work when a single operator can be interpreted in different ways depending on context. (Example: the '*' operator can 
either be multiplication or pointer dereferencing.) Create a utils function for returning the correct operator name?




Small things to fix:
--------------------





Known issues (not yet on the todo list):
----------------------------------------

(a)
UPDATE:
If we allow the BEptr within a wrapper class to change target, we can no longer
guarantee that the memory of the original class instance (created with the 'new' operator)
will be deleted. (Also, if the user has two pointers to a single wrapper class instance, and
then tries to modify one of them using some wrapped function, the other pointer will also be
affected indirectly, since the pointer manipulation would happen at the level of the common 
BEptr.)

Thus, we should not allow BEptr to change target. This has the consequence that
any original function that may change the destination of a pointer-to-original-class has to be ignored
by the wrapper system that BOSS constructs. (That is, functions that take pointer-to-pointer or 
reference-to-pointer as input.)

One possible way around this is to let the user work directly with the abstract classes in cases like this.
Another option is to generate wrapper code also for functions that take pointer-to-pointer or reference-to-pointer,
but inform the user of the potential risks...


OLD:
Working with double pointers (pointer-to-pointer) to classes seem to require that
we add another variable 'BEptr2' to the wrapper classes:

 Abstract_SomeClass* BEptr;    // Initialized by the Factory_SomeClass function.
 Abstract_SomeClass** BEptr2;  // Initialized to point to BEptr.

This allows us to do (**SomeClass_GAMBIT).BEptr2 to convert from double-pointer-to-wrapper-class 
to double-pointer-to-abstract-class, which can further be cast to double-pointer-to-original-class
inside the BOSSed external code.

However, if the BEptr variable of two wrapper class instances end up pointing to the *same* 
original class instance, we'll get a terrible memory crash when the wrapper class destructor is run 
("double free or corruption"). A dummy example of such a scenario would be if the original code 
contained a function like this:

  void pointToTheSame(SomeClass** scpp1, SomeClass** scpp2)
  {
    *scpp1 = *scpp2;
  }

Can we protect ourselves from this somehow? This might be a fundamental problem with the classloading system,
since it is based on using the 'new' operator to create pointers (on the heap) to instances of the original class.
These pointers must be deleted somewhere in order to avoid a memory leak, and if two point to the same object we get a
crash. Could this perhaps be solved by some clever use of 'smart pointers'?















