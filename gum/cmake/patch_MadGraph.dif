diff -rupN MadGraph_pristine/aloha/aloha_fct.py ../contrib/MadGraph/aloha/aloha_fct.py
--- MadGraph_pristine/aloha/aloha_fct.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_fct.py	2020-10-30 20:49:24.490461031 +1100
@@ -29,7 +29,7 @@ def get_fermion_flow(expression, nb_ferm
     try:
         expr = eval(expression)
     except Exception as error:
-        print error
+        print(error)
         return
     expr = expr.simplify()
     #expr is now a valid AddVariable object if they are a sum or
@@ -40,7 +40,7 @@ def get_fermion_flow(expression, nb_ferm
     for term in expr:
         if term.vartype == 0: # Single object
             if not term.spin_ind in [[1,2], [2,1]]:
-                raise WrongFermionFlow, 'Fermion should be the first particles of any interactions'
+                raise WrongFermionFlow('Fermion should be the first particles of any interactions')
             if isinstance(term, (Gamma, Gamma5, Sigma)):
                 if term.spin_ind == [2,1]:
                     out[1] = 2
@@ -59,11 +59,11 @@ def get_fermion_flow(expression, nb_ferm
                 if ind1 not in link.keys():
                     link[ind1] = ind2
                 else:
-                    raise WrongFermionFlow, 'a spin indices should appear only once on the left indices of an object: %s' % expr
+                    raise WrongFermionFlow('a spin indices should appear only once on the left indices of an object: %s' % expr)
                 if ind2 not in rlink.keys():
                     rlink[ind2] = ind1
                 else: 
-                    raise WrongFermionFlow, 'a spin indices should appear only once on the left indices of an object: %s' % expr             
+                    raise WrongFermionFlow('a spin indices should appear only once on the left indices of an object: %s' % expr)             
              
             for i in range(1, nb_fermion):
                 if i in out.keys() or i in out.values():
@@ -84,9 +84,9 @@ def get_fermion_flow(expression, nb_ferm
                             out[pos] = i
                             break
                         else:
-                            raise WrongFermionFlow,  'incoherent IO state: %s' % expr
+                            raise WrongFermionFlow('incoherent IO state: %s' % expr)
     if not len(out) == nb_fermion //2:
-        raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+        raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
     return out
 
 
@@ -112,10 +112,10 @@ def check_flow_validity(expression, nb_f
     for term in expr:
         if term.vartype == 0: # Single object
             if not term.spin_ind in [[1,2], [2,1]]:
-                raise WrongFermionFlow, 'Fermion should be the first particles of any interactions'
+                raise WrongFermionFlow('Fermion should be the first particles of any interactions')
             if isinstance(term, (Gamma, Gamma5, Sigma)):
                 if not term.spin_ind == [2,1]:
-                    raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+                    raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
         
         elif term.vartype == 2: # product of object
             link, rlink = {}, {}
@@ -127,7 +127,7 @@ def check_flow_validity(expression, nb_f
                 if isinstance(obj, (Gamma, Sigma)):
                     if (ind1 in range(1, nb_fermion+1) and ind1 % 2 == 1) or \
                        (ind2 in range(2, nb_fermion+1) and ind2 % 2 == 0 ):
-                        raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+                        raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
                 if ind1 not in link.keys():
                     link[ind1] = ind2
                 else:
@@ -146,7 +146,7 @@ def check_flow_validity(expression, nb_f
                     elif pos in rlink.keys() and rlink[pos] not in old:
                         pos = rlink[pos]
                     elif pos != i+1:
-                        raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+                        raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
                     elif pos == i+1:
                         break
    
diff -rupN MadGraph_pristine/aloha/aloha_lib.py ../contrib/MadGraph/aloha/aloha_lib.py
--- MadGraph_pristine/aloha/aloha_lib.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_lib.py	2020-10-30 20:49:24.494461018 +1100
@@ -143,13 +143,13 @@ class Computation(dict):
             if isinstance(expression, (MultLorentz, AddVariable, LorentzObject)):
                 try:
                     expr = expression.expand().get_rep([0])
-                except KeyError, error:
+                except KeyError as error:
                     if error.args != ((0,),):
                         raise
                     else:
-                        raise aloha.ALOHAERROR, '''Error in input format. 
+                        raise aloha.ALOHAERROR( '''Error in input format. 
     Argument of function (or denominator) should be scalar.
-    We found %s''' % expression
+    We found %s''' % expression)
                 new = expr.simplify()
                 if not isinstance(new, numbers.Number):
                     new = new.factorize()
@@ -171,10 +171,10 @@ class Computation(dict):
             else:
                 module = 'cmath.'
             try:
-                return str(eval("%s%s(%s)" % (module,fct_tag, ','.join(`x` for x in argument))))
-            except Exception, error:
-                print error
-                print "cmath.%s(%s)" % (fct_tag, ','.join(`x` for x in argument))
+                return str(eval("%s%s(%s)" % (module,fct_tag, ','.join(repr(x) for x in argument))))
+            except Exception as error:
+                print(error)
+                print("cmath.%s(%s)" % (fct_tag, ','.join(repr(x) for x in argument)))
         if str(fct_tag)+str(argument) in self.inverted_fct:
             tag = self.inverted_fct[str(fct_tag)+str(argument)]
             v = tag.split('(')[1][:-1]
@@ -684,7 +684,7 @@ class MultVariable(array):
 #                    self.append(new_id)
 #            return self
         else:
-            raise Exception, 'Cann\'t replace a Variable by %s' % type(expression)
+            raise Exception( 'Cann\'t replace a Variable by %s' % type(expression))
         
     
     def get_all_var_names(self):
diff -rupN MadGraph_pristine/aloha/aloha_parsers.py ../contrib/MadGraph/aloha/aloha_parsers.py
--- MadGraph_pristine/aloha/aloha_parsers.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_parsers.py	2020-10-30 20:49:24.494461018 +1100
@@ -29,17 +29,14 @@ import sys
 root_path = os.path.split(os.path.dirname(os.path.realpath( __file__ )))[0]
 sys.path.append(os.path.join(root_path))
 
-import aloha_lib
-from aloha_object import *
+import aloha.aloha_lib
+from aloha.aloha_object import *
 import vendor.ply.lex as lex
 import vendor.ply.yacc as yacc
 from aloha.aloha_lib import KERNEL
 logger = logging.getLogger('aloha.parsers')
 
-try:
-    import madgraph.various.misc as misc
-except Exception:
-    import aloha.misc as misc
+import madgraph.various.misc as misc
 
 
 # PLY lexer class
@@ -193,7 +190,7 @@ class UFOExpressionParser(object):
 
     def p_error(self, p):
         if p:
-            print p[:]
+            print(p[:])
             raise Exception("Syntax error at '%s' in '%s'" % (p.value, self.f))
         else:
             logger.error("Syntax error at EOF")
diff -rupN MadGraph_pristine/aloha/aloha_writers.py ../contrib/MadGraph/aloha/aloha_writers.py
--- MadGraph_pristine/aloha/aloha_writers.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_writers.py	2020-10-30 20:49:24.494461018 +1100
@@ -1,11 +1,11 @@
-try:
-    import madgraph.iolibs.file_writers as writers 
-    import madgraph.various.q_polynomial as q_polynomial
-    import madgraph.various.misc as misc
-except Exception:
-    import aloha.file_writers as writers
-    import aloha.q_polynomial as q_polynomial
-    import aloha.misc as misc
+#try:
+import madgraph.iolibs.file_writers as writers 
+import madgraph.various.q_polynomial as q_polynomial
+import madgraph.various.misc as misc
+#except Exception:
+#    import aloha.file_writers as writers
+#    import aloha.q_polynomial as q_polynomial
+#    import aloha.misc as misc
 
 import aloha
 import aloha.aloha_lib as aloha_lib
@@ -16,7 +16,12 @@ from numbers import Number
 from collections import defaultdict
 from fractions import Fraction
 # fast way to deal with string
-from cStringIO import StringIO
+
+try:
+    from cStringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 # Look at http://www.skymind.com/~ocrow/python_string/ 
 # For knowing how to deal with long strings efficiently.
 import itertools
@@ -92,12 +97,12 @@ class WriteALOHA:
         elif len(indices) == 2: 
             return  4 * indices[0] + indices[1] + start + self.momentum_size
         else:
-            raise Exception, 'WRONG CONTRACTION OF LORENTZ OBJECT for routine %s: %s' \
-                    % (self.name, ind_name)                                 
+            raise Exception('WRONG CONTRACTION OF LORENTZ OBJECT for routine %s: %s' \
+                    % (self.name, ind_name))                                 
                                  
     def get_header_txt(self,mode=''): 
         """ Prototype for language specific header""" 
-        raise Exception, 'THis function should be overwritten'
+        raise Exception('THis function should be overwritten')
         return ''
     
     def get_declaration_txt(self):
@@ -110,7 +115,7 @@ class WriteALOHA:
 
     def get_momenta_txt(self):
         """ Prototype for the definition of the momenta"""
-        raise Exception, 'THis function should be overwritten'
+        raise Exception('THis function should be overwritten')
 
     def get_momentum_conservation_sign(self):
         """find the sign associated to the momentum conservation"""
@@ -785,7 +790,7 @@ class ALOHAWriterForFortran(WriteALOHA):
                                   {'i': self.outgoing, 'COUP': coup_name})
                 else:
                     if self.routine.denominator:
-                        raise Exception, 'modify denominator are not compatible with complex mass scheme'                
+                        raise Exception('modify denominator are not compatible with complex mass scheme')                
 
                     out.write('    denom = %(COUP)s/(P%(i)s(0)**2-P%(i)s(1)**2-P%(i)s(2)**2-P%(i)s(3)**2 - M%(i)s**2)\n' % \
                       {'i': self.outgoing, 'COUP': coup_name})
@@ -1587,7 +1592,7 @@ class ALOHAWriterForCPP(WriteALOHA):
                       {'i': self.outgoing, 'coup': coup_name})
                 else:
                     if self.routine.denominator:
-                        raise Exception, 'modify denominator are not compatible with complex mass scheme'                
+                        raise Exception('modify denominator are not compatible with complex mass scheme')                
 
                     out.write('    denom = %(coup)s/((P%(i)s[0]*P%(i)s[0])-(P%(i)s[1]*P%(i)s[1])-(P%(i)s[2]*P%(i)s[2])-(P%(i)s[3]*P%(i)s[3]) - (M%(i)s*M%(i)s));\n' % \
                       {'i': self.outgoing, 'coup': coup_name})
@@ -1909,7 +1914,7 @@ class ALOHAWriterForPython(WriteALOHA):
             self.declaration.add(('fct', fct))
             return 'cmath.{0}(%s)'.format(fct)
         else:
-            raise Exception, "Unable to handle function name %s (no special rule defined and not in cmath)" % fct
+            raise Exception("Unable to handle function name %s (no special rule defined and not in cmath)" % fct)
     
     def define_expression(self):
         """Define the functions in a 100% way """
@@ -1970,7 +1975,7 @@ class ALOHAWriterForPython(WriteALOHA):
                           {'i': self.outgoing,'coup':coup_name})
                 else:
                     if self.routine.denominator:
-                        raise Exception, 'modify denominator are not compatible with complex mass scheme'                
+                        raise Exception('modify denominator are not compatible with complex mass scheme')                
                     
                     out.write('    denom = %(coup)s/(P%(i)s[0]**2-P%(i)s[1]**2-P%(i)s[2]**2-P%(i)s[3]**2 - M%(i)s**2)\n' % 
                           {'i': self.outgoing,'coup':coup_name})                    
@@ -2218,7 +2223,7 @@ class WriterFactory(object):
         elif language == 'gpu':
             return ALOHAWriterForGPU(data, outputdir)
         else:
-            raise Exception, 'Unknown output format'
+            raise Exception('Unknown output format')
 
 
     
diff -rupN MadGraph_pristine/aloha/create_aloha.py ../contrib/MadGraph/aloha/create_aloha.py
--- MadGraph_pristine/aloha/create_aloha.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/create_aloha.py	2020-10-30 20:49:24.494461018 +1100
@@ -15,7 +15,12 @@
 from __future__ import division
 import cmath
 import copy
-import cPickle
+
+try:
+    import cPickle ## for Python 2
+except ImportError:
+    import _pickle as cPickle ## for Python 3
+
 import glob
 import logging
 import numbers
@@ -110,7 +115,7 @@ class AbstractRoutine(object):
                 rank = max(sum(coeff), rank)
             return rank -1 # due to the coefficient associate to the wavefunctions
         else:
-            raise ALOHAERROR, '%s is not a valid information that can be computed' % info
+            raise ALOHAERROR( '%s is not a valid information that can be computed' % info)
 
 
 class AbstractRoutineBuilder(object):
@@ -206,7 +211,7 @@ class AbstractRoutineBuilder(object):
             if not data == target:
                 text = """Unable to deal with 4(or more) point interactions
 in presence of majorana particle/flow violation"""
-                raise ALOHAERROR, text
+                raise ALOHAERROR( text)
         
         old_id = 2 * pair - 1
         new_id = _conjugate_gap + old_id
@@ -286,7 +291,7 @@ in presence of majorana particle/flow vi
                 lorentz = eval(lorentz)
             except NameError as error:
                 logger.error('unknow type in Lorentz Evaluation:%s'%str(error))
-                raise ALOHAERROR, 'unknow type in Lorentz Evaluation: %s ' % str(error) 
+                raise ALOHAERROR( 'unknow type in Lorentz Evaluation: %s ' % str(error) )
             else:
                 self.kernel_tag = set(aloha_lib.KERNEL.use_tag)
         elif isinstance(self.routine_kernel,str):
@@ -837,7 +842,7 @@ class AbstractALOHAModel(dict):
                                 realname = conjg_builder.name + ''.join(['C%s' % pair for pair in conjg_builder.conjg])
                                 try:
                                     self[(realname, outgoing)].add_combine(m)
-                                except Exception,error:
+                                except Exception as error:
                                     self[(realname, self.symmetries[lorentz.name][outgoing])].add_combine(m)          
                        
         if save:
@@ -1059,8 +1064,8 @@ class AbstractALOHAModel(dict):
                 break
         else: 
 
-            raise ALOHAERROR, 'No external routine \"%s.%s\" in directories\n %s' % \
-                        (name, ext, '\n'.join(paths))
+            raise ALOHAERROR( 'No external routine \"%s.%s\" in directories\n %s' % \
+                        (name, ext, '\n'.join(paths)))
        
         if output_dir:
             for filepath in ext_files:
diff -rupN MadGraph_pristine/aloha/template_files/wavefunctions.py ../contrib/MadGraph/aloha/template_files/wavefunctions.py
--- MadGraph_pristine/aloha/template_files/wavefunctions.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/template_files/wavefunctions.py	2020-10-30 20:49:24.494461018 +1100
@@ -335,7 +335,7 @@ def txxxxx(p, tmass, nhel, nst):
                 ft[(i,j)] = sqh*( em[i]*e0[j] + e0[i]*em[j] )
 
     else:
-        raise Exception, 'invalid helicity TXXXXXX' 
+        raise Exception('invalid helicity TXXXXXX') 
 
 
 
diff -rupN MadGraph_pristine/input/mg5_configuration.txt ../contrib/MadGraph/input/mg5_configuration.txt
--- MadGraph_pristine/input/mg5_configuration.txt	2020-10-27 21:41:37.769088298 +1100
+++ ../contrib/MadGraph/input/mg5_configuration.txt	2020-10-30 20:49:24.494461018 +1100
@@ -49,7 +49,7 @@
 
 #! Prefered PS viewer
 #!  If None: try to find one available on the system
-# eps_viewer = None
+eps_viewer = true
 
 #! Time allowed to answer question (if no answer takes default value)
 #!  0: No time limit
diff -rupN MadGraph_pristine/madgraph/core/base_objects.py ../contrib/MadGraph/madgraph/core/base_objects.py
--- MadGraph_pristine/madgraph/core/base_objects.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/base_objects.py	2020-10-30 20:49:24.498461004 +1100
@@ -22,7 +22,12 @@ import math
 import numbers
 import os
 import re
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import madgraph.core.color_algebra as color
 from madgraph import MadGraph5Error, MG5DIR, InvalidCmd
 import madgraph.various.misc as misc 
@@ -81,9 +86,9 @@ class PhysicsObject(dict):
                                  "Property name %s is not a string" % repr(name)
 
         if name not in self.keys():
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                         """%s is not a valid property for this object: %s\n
-    Valid property are %s""" % (name,self.__class__.__name__, self.keys())
+    Valid property are %s""" % (name,self.__class__.__name__, self.keys()))
         return True
 
     def get(self, name):
@@ -104,7 +109,7 @@ class PhysicsObject(dict):
                 self.filter(name, value)
                 self[name] = value
                 return True
-            except self.PhysicsObjectError, why:
+            except self.PhysicsObjectError as why:
                 logger.warning("Property " + name + " cannot be changed:" + \
                                 str(why))
                 return False
@@ -272,100 +277,100 @@ class Particle(PhysicsObject):
             # Forbid special character but +-~_
             p=re.compile('''^[\w\-\+~_]+$''')
             if not p.match(value):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid particle name" % value
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid particle name" % value)
 
         if name is 'ghost':
             if not isinstance(value,bool):
-                raise self.PhysicsObjectError, \
-                 "%s is not a valid bool for the 'ghost' attribute" % str(value)
+                raise self.PhysicsObjectError( \
+                 "%s is not a valid bool for the 'ghost' attribute" % str(value))
     
         if name is 'counterterm':
             if not isinstance(value,dict):
-                raise self.PhysicsObjectError, \
-                    "counterterm %s is not a valid dictionary" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "counterterm %s is not a valid dictionary" % repr(value))
             for key, val in value.items():
                 if not isinstance(key,tuple):
-                    raise self.PhysicsObjectError, \
-                        "key %s is not a valid tuple for counterterm key" % repr(key)
+                    raise self.PhysicsObjectError( \
+                        "key %s is not a valid tuple for counterterm key" % repr(key))
                 if not isinstance(key[0],str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % repr(key[0])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % repr(key[0]))
                 if not isinstance(key[1],tuple):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % repr(key[1])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % repr(key[1]))
                 for elem in key[1]:
                     if not isinstance(elem,tuple):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid list" % repr(elem)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid list" % repr(elem))
                     for partPDG in elem:
                         if not isinstance(partPDG,int):
-                            raise self.PhysicsObjectError, \
-                                "%s is not a valid integer for PDG" % repr(partPDG)
+                            raise self.PhysicsObjectError( \
+                                "%s is not a valid integer for PDG" % repr(partPDG))
                         if partPDG<=0:
-                            raise self.PhysicsObjectError, \
-                                "%s is not a valid positive PDG" % repr(partPDG)
+                            raise self.PhysicsObjectError( \
+                                "%s is not a valid positive PDG" % repr(partPDG))
                 if not isinstance(val,dict):
-                    raise self.PhysicsObjectError, \
-                        "value %s is not a valid dictionary for counterterm value" % repr(val)
+                    raise self.PhysicsObjectError( \
+                        "value %s is not a valid dictionary for counterterm value" % repr(val))
                 for vkey, vvalue in val.items():
                     if vkey not in [0,-1,-2]:
-                        raise self.PhysicsObjectError, \
-                            "Key %s is not a valid laurent serie order" % repr(vkey)
+                        raise self.PhysicsObjectError( \
+                            "Key %s is not a valid laurent serie order" % repr(vkey))
                     if not isinstance(vvalue,str):
-                        raise self.PhysicsObjectError, \
-                            "Coupling %s is not a valid string" % repr(vvalue)
+                        raise self.PhysicsObjectError( \
+                            "Coupling %s is not a valid string" % repr(vvalue))
         if name is 'spin':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Spin %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Spin %s is not an integer" % repr(value))
             if (value < 1 or value > 5) and value != 99:
-                raise self.PhysicsObjectError, \
-                   "Spin %i not valid" % value
+                raise self.PhysicsObjectError( \
+                   "Spin %i not valid" % value)
 
         if name is 'color':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Color %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Color %s is not an integer" % repr(value))
             if value not in [1, 3, 6, 8]:
-                raise self.PhysicsObjectError, \
-                   "Color %i is not valid" % value
+                raise self.PhysicsObjectError( \
+                   "Color %i is not valid" % value)
 
         if name in ['mass', 'width']:
             # Must start with a letter, followed by letters, digits or _
             p = re.compile('\A[a-zA-Z]+[\w\_]*\Z')
             if not p.match(value):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid name for mass/width variable" % \
-                        value
+                        value)
 
         if name is 'pdg_code':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "PDG code %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "PDG code %s is not an integer" % repr(value))
 
         if name is 'line':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                    "Line type %s is not a string" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Line type %s is not a string" % repr(value))
             if value not in ['None','dashed', 'straight', 'wavy', 'curly', 'double','swavy','scurly','dotted']:
-                raise self.PhysicsObjectError, \
-                   "Line type %s is unknown" % value
+                raise self.PhysicsObjectError( \
+                   "Line type %s is unknown" % value)
 
         if name is 'charge':
             if not isinstance(value, float):
-                raise self.PhysicsObjectError, \
-                    "Charge %s is not a float" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Charge %s is not a float" % repr(value))
 
         if name is 'propagating':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "Propagating tag %s is not a boolean" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Propagating tag %s is not a boolean" % repr(value))
 
         if name in ['is_part', 'self_antipart']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "%s tag %s is not a boolean" % (name, repr(value))
+                raise self.PhysicsObjectError( \
+                    "%s tag %s is not a boolean" % (name, repr(value)))
 
         return True
 
@@ -486,8 +491,8 @@ class Particle(PhysicsObject):
             # Massive tensor
             res = [-2, -1, 0, 1, 2]
         else:
-            raise self.PhysicsObjectError, \
-              "No helicity state assignment for spin %d particles" % spin
+            raise self.PhysicsObjectError( \
+              "No helicity state assignment for spin %d particles" % spin)
                   
         if allow_reverse and not self.get('is_part'):
             res.reverse()
@@ -689,91 +694,91 @@ class Interaction(PhysicsObject):
         if name == 'id':
             #Should be an integer
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
 
         if name == 'particles':
             #Should be a list of valid particle names
             if not isinstance(value, ParticleList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of particles" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of particles" % str(value))
 
         if name == 'perturbation_type':
             if value!=None and not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)            
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))            
 
         if name == 'type':
             #Should be a string
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
         if name == 'loop_particles':
             if isinstance(value,list):
                 for l in value:
                     if isinstance(l,list):
                         for part in l:
                             if not isinstance(part,int):
-                                raise self.PhysicsObjectError, \
-                                    "%s is not a valid integer" % str(part)
+                                raise self.PhysicsObjectError( \
+                                    "%s is not a valid integer" % str(part))
                             if part<0:
-                                raise self.PhysicsObjectError, \
-                                    "%s is not a valid positive integer" % str(part)
+                                raise self.PhysicsObjectError( \
+                                    "%s is not a valid positive integer" % str(part))
 
         if name == 'orders':
             #Should be a dict with valid order names ask keys and int as values
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dict for coupling orders" % \
-                                                                    str(value)
+                                                                    str(value))
             for order in value.keys():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(order)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(order))
                 if not isinstance(value[order], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value[order])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value[order]))
 
         if name in ['color']:
             #Should be a list of list strings
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of Color Strings" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of Color Strings" % str(value))
             for mycolstring in value:
                 if not isinstance(mycolstring, color.ColorString):
-                    raise self.PhysicsObjectError, \
-                            "%s is not a valid list of Color Strings" % str(value)
+                    raise self.PhysicsObjectError( \
+                            "%s is not a valid list of Color Strings" % str(value))
 
         if name in ['lorentz']:
             #Should be a list of list strings
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of strings" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of strings" % str(value))
             for mystr in value:
                 if not isinstance(mystr, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(mystr))
 
         if name == 'couplings':
             #Should be a dictionary of strings with (i,j) keys
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dictionary for couplings" % \
-                                                                str(value)
+                                                                str(value))
 
             for key in value.keys():
                 if not isinstance(key, tuple):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid tuple" % str(key)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid tuple" % str(key))
                 if len(key) != 2:
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid tuple with 2 elements" % str(key)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid tuple with 2 elements" % str(key))
                 if not isinstance(key[0], int) or not isinstance(key[1], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid tuple of integer" % str(key)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid tuple of integer" % str(key))
                 if not isinstance(value[key], str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % value[key]
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % value[key])
 
         return True
 
@@ -1070,73 +1075,73 @@ class Model(PhysicsObject):
 
         if name in ['name']:
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a string" %type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a string" %type(value))
 
         elif name == 'particles':
             if not isinstance(value, ParticleList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a ParticleList object" % \
-                                                            type(value)
+                                                            type(value))
         elif name == 'interactions':
             if not isinstance(value, InteractionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a InteractionList object" % \
-                                                            type(value)
+                                                            type(value))
         elif name == 'particle_dict':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a dictionary" % \
-                                                        type(value)
+                                                        type(value))
         elif name == 'interaction_dict':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a dictionary" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a dictionary" % type(value))
 
         elif name == 'ref_dict_to0':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a dictionary" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a dictionary" % type(value))
                     
         elif name == 'ref_dict_to1':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a dictionary" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a dictionary" % type(value))
 
         elif name == 'got_majoranas':
             if not (isinstance(value, bool) or value == None):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a boolean" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a boolean" % type(value))
 
         elif name == 'conserved_charge':
             if not (isinstance(value, set)):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a set" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a set" % type(value))
 
         elif name == 'version_tag':
             if not (isinstance(value, str)):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a string" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a string" % type(value))
 
         elif name == 'order_hierarchy':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a dictionary" % \
-                                                            type(value)
+                                                            type(value))
             for key in value.keys():
                 if not isinstance(value[key],int):
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                         "Object of type %s is not an integer" % \
-                                                            type(value[key])
+                                                            type(value[key]))
         elif name == 'gauge':
             if not (isinstance(value, list)):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a list" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a list" % type(value))
 
         elif name == 'case_sensitive':
             if not value in [True ,False]:
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a boolean" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a boolean" % type(value))
             
 
         return True
@@ -1164,7 +1169,7 @@ class Model(PhysicsObject):
                 modeldir = os.path.expanduser(modeldir)
                 return modeldir
             else:
-                raise Exception, "path %s not valid anymore." % modeldir
+                raise Exception( "path %s not valid anymore." % modeldir)
             #modeldir = os.path.join(os.path.dirname(modeldir),
             #                        os.path.basename(modeldir).rsplit("-",1)[0])
             #if os.path.exists(modeldir):
@@ -1174,7 +1179,7 @@ class Model(PhysicsObject):
             modeldir = self.get('version_tag').rsplit('##',1)[0]
             modelname = self['name']            
             if not  os.path.exists(modeldir):
-                raise Exception, "path %s not valid anymore" % modeldir
+                raise Exception( "path %s not valid anymore" % modeldir)
             modeldir = os.path.dirname(modeldir)
             modeldir = pjoin(modeldir, modelname)
             modeldir = os.path.expanduser(modeldir)
@@ -1274,7 +1279,7 @@ class Model(PhysicsObject):
             if isinstance(id, int):
                 try:
                     return self.get("particle_dict")[id]
-                except Exception, error:
+                except Exception as error:
                     return None
             else:
                 if not hasattr(self, 'name2part'):
@@ -1468,8 +1473,8 @@ class Model(PhysicsObject):
                 'to use the particles name defined in the model and not the ' + \
                 'MadGraph5_aMC@NLO convention'
                 
-                raise MadGraph5Error, error_text % \
-                                     (part.get_name(), part.get_pdg_code(), pdg)                
+                raise MadGraph5Error( error_text % \
+                                     (part.get_name(), part.get_pdg_code(), pdg))                
 
         default = self.load_default_name()
 
@@ -1974,32 +1979,32 @@ class Leg(PhysicsObject):
 
         if name in ['id', 'number']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer for leg id" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer for leg id" % str(value))
 
         if name == 'state':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid leg state (True|False)" % \
-                                                                    str(value)
+                                                                    str(value))
 
         if name == 'from_group':
             if not isinstance(value, bool) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid boolean for leg flag from_group" % \
-                                                                    str(value)
+                                                                    str(value))
 
         if name == 'loop_line':
             if not isinstance(value, bool) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "%s is not a valid boolean for leg flag loop_line" % \
-                                                                    str(value)
+                                                                    str(value))
 
         if name == 'onshell':
             if not isinstance(value, bool) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid boolean for leg flag onshell" % \
-                                                                    str(value)
+                                                                    str(value))
         return True
 
     def get_sorted_keys(self):
@@ -2171,18 +2176,18 @@ class MultiLeg(PhysicsObject):
 
         if name == 'ids':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for i in value:
                 if not isinstance(i, int):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of integers" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of integers" % str(value))
 
         if name == 'state':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid leg state (initial|final)" % \
-                                                                    str(value)
+                                                                    str(value))
 
         return True
 
@@ -2250,13 +2255,13 @@ class Vertex(PhysicsObject):
 
         if name == 'id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer for vertex id" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer for vertex id" % str(value))
 
         if name == 'legs':
             if not isinstance(value, LegList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid LegList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid LegList object" % str(value))
 
         return True
 
@@ -2373,20 +2378,20 @@ class ContractedVertex(Vertex):
             if isinstance(value, list):
                 for elem in value:
                     if not isinstance(elem,int):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid integer for leg PDG" % str(elem)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid integer for leg PDG" % str(elem))
             else:
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list for contracted vertex PDGs"%str(value)                
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list for contracted vertex PDGs"%str(value))                
         if name == 'loop_tag':
             if isinstance(value, tuple):
                 for elem in value:
                     if not (isinstance(elem,int) or isinstance(elem,tuple)):
-                        raise self.PhysicsObjectError, \
-                          "%s is not a valid int or tuple for loop tag element"%str(elem)
+                        raise self.PhysicsObjectError( \
+                          "%s is not a valid int or tuple for loop tag element"%str(elem))
             else:
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid tuple for a contracted vertex loop_tag."%str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid tuple for a contracted vertex loop_tag."%str(value))
         if name == 'loop_orders':
             Interaction.filter(Interaction(), 'orders', value)
         else:
@@ -2417,8 +2422,8 @@ class Diagram(PhysicsObject):
 
         if name == 'vertices':
             if not isinstance(value, VertexList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid VertexList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid VertexList object" % str(value))
 
         if name == 'orders':
             Interaction.filter(Interaction(), 'orders', value)
@@ -2457,7 +2462,7 @@ class Diagram(PhysicsObject):
                                      for key in sorted(self['orders'].keys())]))
             
             if not pass_sanity:
-                raise Exception, "invalid diagram: %s. vert_id: %s" % (mystr, responsible) 
+                raise Exception( "invalid diagram: %s. vert_id: %s" % (mystr, responsible)) 
                 
             return mystr
         else:
@@ -2627,7 +2632,7 @@ class Diagram(PhysicsObject):
             security =0
             while not vcurrent.is_external():
                 if security > 1000:
-                    raise Exception, 'wrong diagram'
+                    raise Exception('wrong diagram')
                 next_l = [l for l in vcurrent.lines if l is not l_last and l.is_fermion()][0]
                 next_v = next_l.end
                 if next_v == vcurrent:
@@ -2818,113 +2823,113 @@ class Process(PhysicsObject):
 
         if name in ['legs', 'legs_with_decays'] :
             if not isinstance(value, LegList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid LegList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid LegList object" % str(value))
 
         if name in ['orders', 'overall_orders','squared_orders']:
             Interaction.filter(Interaction(), 'orders', value)
 
         if name == 'constrained_orders':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)            
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))            
 
         if name == 'sqorders_types':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))
             for order in value.keys()+value.values():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid string" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid string" % str(value))
 
         if name == 'split_orders':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for order in value:
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid string" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid string" % str(value))
 
         if name == 'model':
             if not isinstance(value, Model):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Model object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid Model object" % str(value))
         if name in ['id', 'uid']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Process %s %s is not an integer" % (name, repr(value))
+                raise self.PhysicsObjectError( \
+                    "Process %s %s is not an integer" % (name, repr(value)))
 
         if name == 'required_s_channels':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for l in value:
                 if not isinstance(l, list):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of lists" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of lists" % str(value))
                 for i in l:
                     if not isinstance(i, int):
-                        raise self.PhysicsObjectError, \
-                              "%s is not a valid list of integers" % str(l)
+                        raise self.PhysicsObjectError( \
+                              "%s is not a valid list of integers" % str(l))
                     if i == 0:
-                        raise self.PhysicsObjectError, \
-                          "Not valid PDG code %d for s-channel particle" % i
+                        raise self.PhysicsObjectError( \
+                          "Not valid PDG code %d for s-channel particle" % i)
 
         if name in ['forbidden_onsh_s_channels', 'forbidden_s_channels']:
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for i in value:
                 if not isinstance(i, int):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of integers" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of integers" % str(value))
                 if i == 0:
-                    raise self.PhysicsObjectError, \
-                      "Not valid PDG code %d for s-channel particle" % str(value)
+                    raise self.PhysicsObjectError( \
+                      "Not valid PDG code %d for s-channel particle" % str(value))
 
         if name == 'forbidden_particles':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for i in value:
                 if not isinstance(i, int):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of integers" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of integers" % str(value))
                 if i <= 0:
-                    raise self.PhysicsObjectError, \
-                      "Forbidden particles should have a positive PDG code" % str(value)
+                    raise self.PhysicsObjectError( \
+                      "Forbidden particles should have a positive PDG code" % str(value))
 
         if name == 'perturbation_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for order in value:
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid string" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid string" % str(value))
 
         if name == 'is_decay_chain':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
 
         if name == 'has_born':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
 
         if name == 'decay_chains':
             if not isinstance(value, ProcessList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessList" % str(value))
 
         if name == 'NLO_mode':
             import madgraph.interface.madgraph_interface as mg
             if value not in mg.MadGraphCmd._valid_nlo_modes:
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid NLO_mode" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid NLO_mode" % str(value))
         return True
 
     def has_multiparticle_label(self):
@@ -3608,12 +3613,12 @@ class ProcessDefinition(Process):
 
         if name == 'legs':
             if not isinstance(value, MultiLegList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid MultiLegList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid MultiLegList object" % str(value))
         elif name == 'decay_chains':
             if not isinstance(value, ProcessDefinitionList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessDefinitionList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessDefinitionList" % str(value))
 
         else:
             return super(ProcessDefinition, self).filter(name, value)
diff -rupN MadGraph_pristine/madgraph/core/color_algebra.py ../contrib/MadGraph/madgraph/core/color_algebra.py
--- MadGraph_pristine/madgraph/core/color_algebra.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/color_algebra.py	2020-10-30 20:49:24.498461004 +1100
@@ -833,8 +833,8 @@ class ColorString(list):
         are still non trivial color objects."""
 
         if self:
-            raise ValueError, \
-                "String %s cannot be simplified to a number!" % str(self)
+            raise ValueError( \
+                "String %s cannot be simplified to a number!" % str(self))
 
         if self.Nc_power >= 0:
             return (self.coeff * fractions.Fraction(\
diff -rupN MadGraph_pristine/madgraph/core/color_amp.py ../contrib/MadGraph/madgraph/core/color_amp.py
--- MadGraph_pristine/madgraph/core/color_amp.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/color_amp.py	2020-10-30 20:49:24.498461004 +1100
@@ -413,8 +413,8 @@ class ColorBasis(dict):
         # If more than one string at leading N...
         if len(res_cs) > 1 and any([not cs.near_equivalent(res_cs[0]) \
                                     for cs in res_cs]):
-            raise ColorBasis.ColorBasisError, \
-             "More than one color string with leading N coeff: %s" % str(res_cs)
+            raise ColorBasis.ColorBasisError( \
+             "More than one color string with leading N coeff: %s" % str(res_cs))
 
         res_cs = res_cs[0]
 
@@ -423,13 +423,13 @@ class ColorBasis(dict):
         for col_obj in res_cs:
             if not isinstance(col_obj, color_algebra.T) and \
                    not col_obj.__class__.__name__.startswith('Epsilon'):
-                raise ColorBasis.ColorBasisError, \
+                raise ColorBasis.ColorBasisError( \
                   "Color flow decomposition %s contains non T/Epsilon elements" % \
-                                                                    str(res_cs)
+                                                                    str(res_cs))
             if isinstance(col_obj, color_algebra.T) and len(col_obj) != 2:
-                raise ColorBasis.ColorBasisError, \
+                raise ColorBasis.ColorBasisError( \
                   "Color flow decomposition %s contains T's w/o 2 indices" % \
-                                                                    str(res_cs)
+                                                                    str(res_cs))
 
         return res_cs
 
@@ -463,8 +463,8 @@ class ColorBasis(dict):
 
                 # Raise an error if external legs contain non supported repr
                 if abs(leg_repr) not in [1, 3, 6, 8]:
-                    raise ColorBasis.ColorBasisError, \
-        "Particle ID=%i has an unsupported color representation" % leg_repr
+                    raise ColorBasis.ColorBasisError( \
+        "Particle ID=%i has an unsupported color representation" % leg_repr)
 
                 # Build the fake indices replacements for octets
                 if abs(leg_repr) == 8:
diff -rupN MadGraph_pristine/madgraph/core/diagram_generation.py ../contrib/MadGraph/madgraph/core/diagram_generation.py
--- MadGraph_pristine/madgraph/core/diagram_generation.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/diagram_generation.py	2020-10-30 20:49:24.498461004 +1100
@@ -439,16 +439,13 @@ class Amplitude(base_objects.PhysicsObje
 
         if name == 'process':
             if not isinstance(value, base_objects.Process):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Process object" % str(value)
+                raise self.PhysicsObjectError("%s is not a valid Process object" % str(value))
         if name == 'diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList object" % str(value)
+                raise self.PhysicsObjectError("%s is not a valid DiagramList object" % str(value))
         if name == 'has_mirror_process':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid boolean" % str(value)
+                raise self.PhysicsObjectError("%s is not a valid boolean" % str(value))
         return True
 
     def get(self, name):
@@ -568,7 +565,7 @@ class Amplitude(base_objects.PhysicsObje
                         leg.get('id')].is_fermion(), legs)) % 2 == 1:
             if not returndiag:
                 self['diagrams'] = res
-                raise InvalidCmd, 'The number of fermion is odd'
+                raise InvalidCmd('The number of fermion is odd')
             else:
                 return False, res
 
@@ -579,7 +576,7 @@ class Amplitude(base_objects.PhysicsObje
            len(filter(lambda leg: leg.is_outgoing_fermion(model), legs)):
             if not returndiag:
                 self['diagrams'] = res
-                raise InvalidCmd, 'The number of of incoming/outcoming fermions are different'
+                raise InvalidCmd('The number of of incoming/outcoming fermions are different')
             else:
                 return False, res
 
@@ -605,10 +602,10 @@ class Amplitude(base_objects.PhysicsObje
             if abs(total) > 1e-10:
                 if not returndiag:
                     self['diagrams'] = res
-                    raise InvalidCmd, 'No %s conservation for this process ' % charge
+                    raise InvalidCmd('No %s conservation for this process ' % charge)
                     return res
                 else:
-                    raise InvalidCmd, 'No %s conservation for this process ' % charge
+                    raise InvalidCmd( 'No %s conservation for this process ' % charge)
                     return res, res
 
         if not returndiag:
@@ -1362,15 +1359,14 @@ class DecayChainAmplitude(Amplitude):
 
             for process in argument.get('decay_chains'):
                 if process.get('perturbation_couplings'):
-                    raise MadGraph5Error,\
-                          "Decay processes can not be perturbed"
+                    raise MadGraph5Error(\
+                          "Decay processes can not be perturbed")
                 process.set('overall_orders', argument.get('overall_orders'))
                 if not process.get('is_decay_chain'):
                     process.set('is_decay_chain',True)
                 if not process.get_ninitial() == 1:
-                    raise InvalidCmd,\
-                          "Decay chain process must have exactly one" + \
-                          " incoming particle"
+                    raise InvalidCmd("Decay chain process must have exactly one" + \
+                          " incoming particle")
                 self['decay_chains'].append(\
                     DecayChainAmplitude(process, collect_mirror_procs,
                                         ignore_six_quark_processes,
@@ -1443,13 +1439,13 @@ class DecayChainAmplitude(Amplitude):
 
         if name == 'amplitudes':
             if not isinstance(value, AmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid AmplitudeList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid AmplitudeList" % str(value))
         if name == 'decay_chains':
             if not isinstance(value, DecayChainAmplitudeList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid DecayChainAmplitudeList object" % \
-                        str(value)
+                        str(value))
         return True
 
     def get_sorted_keys(self):
@@ -1601,23 +1597,23 @@ class MultiProcess(base_objects.PhysicsO
 
         if name == 'process_definitions':
             if not isinstance(value, base_objects.ProcessDefinitionList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessDefinitionList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessDefinitionList object" % str(value))
 
         if name == 'amplitudes':
             if not isinstance(value, AmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid AmplitudeList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid AmplitudeList object" % str(value))
 
         if name in ['collect_mirror_procs']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid boolean" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid boolean" % str(value))
 
         if name == 'ignore_six_quark_processes':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
 
         return True
 
@@ -1834,9 +1830,9 @@ class MultiProcess(base_objects.PhysicsO
             if len(failed_procs) == 1 and 'error' in locals():
                 raise error
             else:
-                raise NoDiagramException, \
+                raise NoDiagramException( \
             "No amplitudes generated from process %s. Please enter a valid process" % \
-                  process_definition.nice_string()
+                  process_definition.nice_string())
         
 
         # Return the produced amplitudes
@@ -2025,7 +2021,7 @@ class MultiProcess(base_objects.PhysicsO
                     amplitude = Amplitude({'process': process})
                     try:
                         amplitude.generate_diagrams(diagram_filter=diagram_filter)
-                    except InvalidCmd, error:
+                    except InvalidCmd as error:
                         failed_procs.append(tuple(sorted_legs))
                     else:
                         if amplitude.get('diagrams'):
diff -rupN MadGraph_pristine/madgraph/core/drawing.py ../contrib/MadGraph/madgraph/core/drawing.py
--- MadGraph_pristine/madgraph/core/drawing.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/drawing.py	2020-10-30 20:49:24.502460991 +1100
@@ -412,8 +412,8 @@ class FeynmanLine(object):
             self.begin.pos_x
             self.end.pos_y
         except Exception:
-            raise self.FeynmanLineError, 'No vertex in begin-end position ' + \
-                        ' or no position attach at one of those vertex '
+            raise self.FeynmanLineError('No vertex in begin-end position ' + \
+                        ' or no position attach at one of those vertex ')
         return True
 
     def has_ordinate(self, x):
@@ -431,10 +431,10 @@ class FeynmanLine(object):
                 min, max = max, min
 
             if min == max:
-                raise self.FeynmanLineError, 'Vertical line: no unique solution'
+                raise self.FeynmanLineError('Vertical line: no unique solution')
             if(not(min <= x <= max)):
-                raise self.FeynmanLineError, 'point outside interval invalid ' + \
-                    'invalid order {0:3}<={1:3}<={2:3}'.format(min, x, max)
+                raise self.FeynmanLineError('point outside interval invalid ' + \
+                    'invalid order {0:3}<={1:3}<={2:3}'.format(min, x, max))
 
         return self._has_ordinate(x)
 
@@ -548,8 +548,8 @@ class VertexPoint(object):
                 del self.lines[i]
                 return # only one data to remove!
 
-        raise self.VertexPointError, 'trying to remove in a ' + \
-                            'Vertex_Point a non present Feynman_Line'
+        raise self.VertexPointError( 'trying to remove in a ' + \
+                            'Vertex_Point a non present Feynman_Line')
 
 
     def def_level(self, level):
@@ -1060,9 +1060,9 @@ class FeynmanDiagram(object):
             # Associate position to level 2 and following (auto-recursive fct)
             self.find_vertex_position_at_level([init_line.end], 2)
         else:
-            raise self.FeynamDiagramError, \
+            raise self.FeynamDiagramError( \
                                 'only for one or two initial particles not %s' \
-                                % (len(self.initial_vertex))
+                                % (len(self.initial_vertex)))
 
 
     def find_vertex_position_tchannel(self):
@@ -1937,8 +1937,8 @@ class DiagramDrawer(object):
         straight is an example and can be replace by other type of line as 
         dashed, wavy, curly, ..."""
 
-        raise self.DrawDiagramError, 'DrawDiagram.draw_straight should be ' + \
-                'overwritten by Inherited Class'
+        raise self.DrawDiagramError( 'DrawDiagram.draw_straight should be ' + \
+                'overwritten by Inherited Class')
 
     draw_curved_straight = draw_straight
 
diff -rupN MadGraph_pristine/madgraph/core/helas_objects.py ../contrib/MadGraph/madgraph/core/helas_objects.py
--- MadGraph_pristine/madgraph/core/helas_objects.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/helas_objects.py	2020-10-30 20:49:24.502460991 +1100
@@ -300,8 +300,8 @@ class CanonicalConfigTag(diagram_generat
                         right_num = num
             if right_num == -1:
                 # This should never happen
-                raise diagram_generation.DiagramTag.DiagramTagError, \
-                    "Error in CanonicalConfigTag, no link with number 1 or 2."
+                raise diagram_generation.DiagramTag.DiagramTagError( \
+                    "Error in CanonicalConfigTag, no link with number 1 or 2.")
 
             # Now move one step in the direction of right_link
             right_link = self.tag.links[right_num]
@@ -492,8 +492,8 @@ class CanonicalConfigTag(diagram_generat
             return (old_vertex[0], (new_vertex[1][0], min_number), new_vertex[2])
 
         # We should not get here
-        raise diagram_generation.DiagramTag.DiagramTagError, \
-              "Error in CanonicalConfigTag, wrong setup of vertices in link."
+        raise diagram_generation.DiagramTag.DiagramTagError( \
+              "Error in CanonicalConfigTag, wrong setup of vertices in link.")
         
     @staticmethod
     def leg_from_link(link):
@@ -559,7 +559,7 @@ class HelasWavefunction(base_objects.Phy
         try:
             return sizes[abs(spin)]
         except KeyError:
-            raise MadGraph5Error, "L-cut particle has spin %d which is not supported."%spin
+            raise MadGraph5Error("L-cut particle has spin %d which is not supported."%spin)
 
     def default_setup(self):
         """Default values for all properties"""
@@ -695,149 +695,149 @@ class HelasWavefunction(base_objects.Phy
 
         if name in ['particle', 'antiparticle']:
             if not isinstance(value, base_objects.Particle):
-                raise self.PhysicsObjectError, \
-                    "%s tag %s is not a particle" % (name, repr(value))            
+                raise self.PhysicsObjectError( \
+                    "%s tag %s is not a particle" % (name, repr(value)))            
 
         if name == 'is_part':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "%s tag %s is not a boolean" % (name, repr(value))
+                raise self.PhysicsObjectError( \
+                    "%s tag %s is not a boolean" % (name, repr(value)))
 
         if name == 'interaction_id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer " % str(value) + \
-                        " for wavefunction interaction id"
+                        " for wavefunction interaction id")
 
         if name == 'pdg_codes':
             #Should be a list of strings
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of integers" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of integers" % str(value))
             for mystr in value:
                 if not isinstance(mystr, int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(mystr))
 
         if name == 'orders':
             #Should be a dict with valid order names ask keys and int as values
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dict for coupling orders" % \
-                                                                    str(value)
+                                                                    str(value))
             for order in value.keys():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(order)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(order))
                 if not isinstance(value[order], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value[order])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value[order]))
 
 
         if name == 'inter_color':
             # Should be None or a color string
             if value and not isinstance(value, color.ColorString):
-                    raise self.PhysicsObjectError, \
-                            "%s is not a valid Color String" % str(value)
+                    raise self.PhysicsObjectError( \
+                            "%s is not a valid Color String" % str(value))
 
         if name == 'lorentz':
             #Should be a list of string
             if not isinstance(value, list):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
 
         if name == 'coupling':
             #Should be a list of string
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid coupling string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid coupling string" % str(value))
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
             if len(value) == 0:
-                raise self.PhysicsObjectError, \
-                        "%s should have at least one value" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s should have at least one value" % str(value))
 
         if name == 'color_key':
             if value and not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                      "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                      "%s is not a valid integer" % str(value))
 
         if name == 'state':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid string for wavefunction state" % \
-                                                                    str(value)
+                                                                    str(value))
             if value not in ['incoming', 'outgoing',
                              'intermediate', 'initial', 'final']:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid wavefunction " % str(value) + \
-                        "state (incoming|outgoing|intermediate)"
+                        "state (incoming|outgoing|intermediate)")
         if name == 'leg_state':
             if value not in [False, True]:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid wavefunction " % str(value) + \
-                        "state (incoming|outgoing|intermediate)"
+                        "state (incoming|outgoing|intermediate)")
         if name in ['fermionflow']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
             if not value in [-1, 1]:
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid sign (must be -1 or 1)" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid sign (must be -1 or 1)" % str(value))
 
         if name in ['number_external', 'number']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer" % str(value) + \
-                        " for wavefunction number"
+                        " for wavefunction number")
 
         if name == 'mothers':
             if not isinstance(value, HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                       "%s is not a valid list of mothers for wavefunction" % \
-                      str(value)
+                      str(value))
 
         if name in ['decay']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid bool" % str(value) + \
-                        " for decay"
+                        " for decay")
         
         if name in ['onshell']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid bool" % str(value) + \
-                        " for onshell"
+                        " for onshell")
 
         if name in ['is_loop']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid bool" % str(value) + \
-                        " for is_loop"
+                        " for is_loop")
                         
         if name == 'conjugate_indices':
             if not isinstance(value, tuple) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid tuple" % str(value) + \
-                        " for conjugate_indices"
+                        " for conjugate_indices")
 
         if name == 'rank':
             if not isinstance(value, int) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid int" % str(value) + \
-                        " for the rank"
+                        " for the rank")
 
         if name == 'lcut_size':
             if not isinstance(value, int) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid int" % str(value) + \
-                        " for the lcut_size"
+                        " for the lcut_size")
 
         return True
 
@@ -914,8 +914,8 @@ class HelasWavefunction(base_objects.Phy
                     self.set('antiparticle', model.get('particle_dict')[-value])
                 return True
             else:
-                raise self.PhysicsObjectError, \
-                      "%s not allowed name for 3-argument set", name
+                raise self.PhysicsObjectError( \
+                      "%s not allowed name for 3-argument set", name)
         else:
             return super(HelasWavefunction, self).set(name, value)
 
@@ -973,10 +973,10 @@ class HelasWavefunction(base_objects.Phy
         except KeyError:
             # It then need be computed and for this, an alohaModel is necessary
             if alohaModel is None:
-                raise MadGraph5Error,"The analytic information %s has"%info+\
+                raise MadGraph5Error("The analytic information %s has"%info+\
                 " not been computed yet for this wavefunction and an"+\
                 " alohaModel was not specified, so that the information"+\
-                " cannot be retrieved."
+                " cannot be retrieved.")
         result = None
         
         if info=="interaction_rank" and len(self['mothers'])==0:
@@ -1011,8 +1011,8 @@ class HelasWavefunction(base_objects.Phy
                 result = result+self.get_analytic_info('interaction_rank',
                                                                      alohaModel)
             else:
-                raise MadGraph5Error, "A loop wavefunction has more than one loop"+\
-                    " mothers."
+                raise MadGraph5Error("A loop wavefunction has more than one loop"+\
+                    " mothers.")
                     
         # Now cache the resulting analytic info
         self['analytic_info'][info] = result
@@ -1472,8 +1472,8 @@ class HelasWavefunction(base_objects.Phy
         helas call """
         
         if self['mothers']:
-            raise MadGraph5Error, "This function should be called only for"+\
-                                                    " external wavefunctions."
+            raise MadGraph5Error("This function should be called only for"+\
+                                                    " external wavefunctions.")
         return_dict = {}
         if self.get('is_loop'):
             return_dict['conjugate'] = ('C' if self.needs_hermitian_conjugate() \
@@ -1795,7 +1795,7 @@ class HelasWavefunction(base_objects.Phy
             if self.get('spin') == 3:
                 return 'V'
             else:
-                raise MadGraph5Error,'L-cut particle type not supported'
+                raise MadGraph5Error('L-cut particle type not supported')
         else:
             return ''
 
@@ -1967,8 +1967,8 @@ class HelasWavefunction(base_objects.Phy
             loop_wf_index=\
                        [wf['is_loop'] for wf in self.get('mothers')].index(True)
         except ValueError:
-            raise MadGraph5Error, "The loop wavefunctions should have exactly"+\
-                                                " one loop wavefunction mother."
+            raise MadGraph5Error("The loop wavefunctions should have exactly"+\
+                                                " one loop wavefunction mother.")
 
         if self.find_outgoing_number()-1<=loop_wf_index:
             # If the incoming loop leg is placed after the outgoing one we
@@ -2009,8 +2009,8 @@ class HelasWavefunction(base_objects.Phy
             if len(loop_wfs)==1:
                 return loop_wfs[0]
             else:
-                raise MadGraph5Error, "The loop wavefunction must have either"+\
-                  " no mothers, or exactly one mother with type 'loop'."
+                raise MadGraph5Error("The loop wavefunction must have either"+\
+                  " no mothers, or exactly one mother with type 'loop'.")
         else:
             return None
         
@@ -2389,11 +2389,11 @@ class HelasWavefunctionList(base_objects
             return True
     
         def RaiseError():
-            raise self.PhysicsObjectListError, \
+            raise self.PhysicsObjectListError( \
       "This wavefunction list does not have a consistent wavefunction ordering."+\
       "\n  Wf numbers: %s"%str([wf['number'] for wf in diag_wfs])+\
       "\n  Wf mothers: %s"%str([[mother['number'] for mother in wf['mothers']] \
-                                                  for wf in diag_wfs])
+                                                  for wf in diag_wfs]))
     
         # We want to work on a local copy of the wavefunction list attribute
         diag_wfs = copy.copy(self)
@@ -2508,106 +2508,106 @@ class HelasAmplitude(base_objects.Physic
 
         if name == 'interaction_id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer for interaction id" % \
-                        str(value)
+                        str(value))
 
         if name == 'pdg_codes':
             #Should be a list of integers
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of integers" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of integers" % str(value))
             for mystr in value:
                 if not isinstance(mystr, int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(mystr))
 
         if name == 'orders':
             #Should be a dict with valid order names ask keys and int as values
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dict for coupling orders" % \
-                                                                    str(value)
+                                                                    str(value))
             for order in value.keys():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(order)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(order))
                 if not isinstance(value[order], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value[order])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value[order]))
 
         if name == 'inter_color':
             # Should be None or a color string
             if value and not isinstance(value, color.ColorString):
-                    raise self.PhysicsObjectError, \
-                            "%s is not a valid Color String" % str(value)
+                    raise self.PhysicsObjectError( \
+                            "%s is not a valid Color String" % str(value))
 
         if name == 'lorentz':
             #Should be a list of string
             if not isinstance(value, list):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid list of string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid list of string" % str(value))
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
                         
         if name == 'coupling':
             #Should be a list of string
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                      "%s is not a valid coupling (list of string)" % str(value)
+                raise self.PhysicsObjectError( \
+                      "%s is not a valid coupling (list of string)" % str(value))
             
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
             if not len(value):
-                raise self.PhysicsObjectError, \
-                                      'coupling should have at least one value'
+                raise self.PhysicsObjectError( \
+                                      'coupling should have at least one value')
 
         if name == 'color_key':
             if value and not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                      "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                      "%s is not a valid integer" % str(value))
 
         if name == 'number':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer for amplitude number" % \
-                        str(value)
+                        str(value))
 
         if name == 'fermionfactor':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer for fermionfactor" % \
-                        str(value)
+                        str(value))
             if not value in [-1, 0, 1]:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid fermion factor (-1, 0 or 1)" % \
-                        str(value)
+                        str(value))
 
         if name == 'color_indices':
             #Should be a list of integers
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of integers" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of integers" % str(value))
             for mystr in value:
                 if not isinstance(mystr, int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(mystr))
 
         if name == 'mothers':
             if not isinstance(value, HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                       "%s is not a valid list of mothers for amplitude" % \
-                      str(value)
+                      str(value))
 
         if name == 'conjugate_indices':
             if not isinstance(value, tuple) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid tuple" % str(value) + \
-                        " for conjugate_indices"
+                        " for conjugate_indices")
 
         return True
 
@@ -2719,8 +2719,8 @@ class HelasAmplitude(base_objects.Physic
                         self.set('coupling', [inter.get('couplings').values()[0]])
                 return True
             else:
-                raise self.PhysicsObjectError, \
-                      "%s not allowed name for 3-argument set", name
+                raise self.PhysicsObjectError( \
+                      "%s not allowed name for 3-argument set", name)
         else:
             return super(HelasAmplitude, self).set(name, value)
 
@@ -3208,15 +3208,15 @@ class HelasDiagram(base_objects.PhysicsO
 
         if name == 'wavefunctions' or name == 'loop_wavefunctions':
             if not isinstance(value, HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid HelasWavefunctionList object" % \
-                        str(value)
+                        str(value))
       
         if name == 'amplitudes':
             if not isinstance(value, HelasAmplitudeList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid HelasAmplitudeList object" % \
-                        str(value)
+                        str(value))
 
         return True
                 
@@ -3316,33 +3316,33 @@ class HelasMatrixElement(base_objects.Ph
 
         if name == 'processes':
             if not isinstance(value, base_objects.ProcessList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessList object" % str(value))
         if name == 'diagrams':
             if not isinstance(value, HelasDiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid HelasDiagramList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid HelasDiagramList object" % str(value))
         if name == 'identical_particle_factor':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid int object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid int object" % str(value))
         if name == 'color_basis':
             if not isinstance(value, color_amp.ColorBasis):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ColorBasis object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ColorBasis object" % str(value))
         if name == 'color_matrix':
             if not isinstance(value, color_amp.ColorMatrix):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ColorMatrix object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ColorMatrix object" % str(value))
         if name == 'base_amplitude':
             if value != None and not \
                    isinstance(value, diagram_generation.Amplitude):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Amplitude object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid Amplitude object" % str(value))
         if name == 'has_mirror_process':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid boolean" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid boolean" % str(value))
         return True
 
     def get_sorted_keys(self):
@@ -3578,7 +3578,7 @@ class HelasMatrixElement(base_objects.Ph
                         try:
                             wf = diagram_wavefunctions[\
                                     diagram_wavefunctions.index(wf)]
-                        except ValueError, error:
+                        except ValueError as error:
                             # Update wf number
                             wf_number = wf_number + 1
                             wf.set('number', wf_number)
@@ -4079,8 +4079,8 @@ class HelasMatrixElement(base_objects.Ph
 
                 # Ignore possibility for unoptimizated generation for now
                 if len(my_diagrams) > 1:
-                    raise self.PhysicsObjectError, \
-                          "Decay chains not yet prepared for GPU"
+                    raise self.PhysicsObjectError( \
+                          "Decay chains not yet prepared for GPU")
 
                 for diagram in my_diagrams:
 
@@ -4391,8 +4391,8 @@ class HelasMatrixElement(base_objects.Ph
                                  diagrams)
 
             if len(wf_diagrams) > 1:
-                raise self.PhysicsObjectError, \
-                      "Decay chains not yet prepared for GPU"
+                raise self.PhysicsObjectError( \
+                      "Decay chains not yet prepared for GPU")
 
             for diagram in wf_diagrams:
 
@@ -4749,12 +4749,12 @@ class HelasMatrixElement(base_objects.Ph
                           tuple(amp.get('color_indices')) == diag_tuple[1],
                           diagrams[diag_tuple[0]].get('amplitudes'))
                 if not res_amps:
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                           """No amplitude found for color structure
                             %s and color index chain (%s) (diagram %i)""" % \
                             (col_basis_elem,
                              str(diag_tuple[1]),
-                             diag_tuple[0])
+                             diag_tuple[0]))
 
                 for res_amp in res_amps:
                     col_amp.append(((res_amp.get('fermionfactor'),
@@ -5150,15 +5150,15 @@ class HelasDecayChainProcess(base_object
 
         if name == 'core_processes':
             if not isinstance(value, HelasMatrixElementList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid HelasMatrixElementList object" % \
-                        str(value)
+                        str(value))
 
         if name == 'decay_chains':
             if not isinstance(value, HelasDecayChainProcessList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                      "%s is not a valid HelasDecayChainProcessList object" % \
-                     str(value)
+                     str(value))
 
         return True
 
@@ -5441,8 +5441,8 @@ class HelasMultiProcess(base_objects.Phy
 
         if name == 'matrix_elements':
             if not isinstance(value, HelasMatrixElementList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid HelasMatrixElementList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid HelasMatrixElementList object" % str(value))
         return True
 
     def get_sorted_keys(self):
@@ -5522,8 +5522,8 @@ class HelasMultiProcess(base_objects.Phy
         tree-level Nc and present for structural reasons only."""
         
         if compute_loop_nc:
-            raise MadGraph5Error, "The tree-level function 'process_color' "+\
-             " of class HelasMultiProcess cannot be called with a value for compute_loop_nc"
+            raise MadGraph5Error( "The tree-level function 'process_color' "+\
+             " of class HelasMultiProcess cannot be called with a value for compute_loop_nc")
         
         # Define the objects stored in the contained color_information
         for key in color_information:
@@ -5741,8 +5741,8 @@ class HelasMultiProcess(base_objects.Phy
                                                 compute_loop_nc=compute_loop_nc)                    
 
         if not matrix_elements:
-            raise InvalidCmd, \
-                  "No matrix elements generated, check overall coupling orders"
+            raise InvalidCmd( \
+                  "No matrix elements generated, check overall coupling orders")
 
         return matrix_elements
 
diff -rupN MadGraph_pristine/madgraph/fks/fks_base.py ../contrib/MadGraph/madgraph/fks/fks_base.py
--- MadGraph_pristine/madgraph/fks/fks_base.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/fks/fks_base.py	2020-10-30 20:49:24.502460991 +1100
@@ -63,28 +63,28 @@ class FKSMultiProcess(diagram_generation
 
         if name == 'born_processes':
             if not isinstance(value, FKSProcessList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list for born_processes " % str(value)                             
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list for born_processes " % str(value))                             
 
         if name == 'real_amplitudes':
             if not isinstance(value, diagram_generation.AmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list for real_amplitudes " % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list for real_amplitudes " % str(value))
                                                   
         if name == 'real_pdgs':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list for real_amplitudes " % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list for real_amplitudes " % str(value))
         
         if name == 'OLP':
             if not isinstance(value,str):
-                raise self.PhysicsObjectError, \
-                    "%s is not a valid string for OLP " % str(value)
+                raise self.PhysicsObjectError( \
+                    "%s is not a valid string for OLP " % str(value))
 
         if name == 'ncores_for_proc_gen':
             if not isinstance(value,int):
-                raise self.PhysicsObjectError, \
-                    "%s is not a valid value for ncores_for_proc_gen " % str(value)
+                raise self.PhysicsObjectError( \
+                    "%s is not a valid value for ncores_for_proc_gen " % str(value))
                                                      
         return super(FKSMultiProcess,self).filter(name, value)
     
@@ -123,12 +123,12 @@ class FKSMultiProcess(diagram_generation
 
         except diagram_generation.NoDiagramException as error:
             # If no born, then this process most likely does not have any.
-            raise NoBornException, "Born diagrams could not be generated for the "+\
+            raise NoBornException("Born diagrams could not be generated for the "+\
                self['process_definitions'][0].nice_string().replace('Process',\
                'process')+". Notice that aMC@NLO does not handle loop-induced"+\
                " processes yet, but you can still use MadLoop if you want to "+\
                "only generate them."+\
-               " For this, use the 'virt=' mode, without multiparticle labels."
+               " For this, use the 'virt=' mode, without multiparticle labels.")
 
         self['OLP'] = olp
         self['ncores_for_proc_gen'] = ncores_for_proc_gen
@@ -621,13 +621,13 @@ class FKSProcess(object):
                         and \
                         real_m.get_leg_j()['id'] == real_n.get_leg_i()['id']):
                         if i_m > i_n:
-                            print real_m.get_leg_i()['id'], real_m.get_leg_j()['id']
+                            print(real_m.get_leg_i()['id'], real_m.get_leg_j()['id'])
                             if real_m.get_leg_i()['id'] == -real_m.get_leg_j()['id']:
                                 self.real_amps[m].is_to_integrate = False
                             else:
                                 self.real_amps[n].is_to_integrate = False
                         elif i_m == i_n and j_m > j_n:
-                            print real_m.get_leg_i()['id'], real_m.get_leg_j()['id']
+                            print(real_m.get_leg_i()['id'], real_m.get_leg_j()['id'])
                             if real_m.get_leg_i()['id'] == -real_m.get_leg_j()['id']:
                                 self.real_amps[m].is_to_integrate = False
                             else:
diff -rupN MadGraph_pristine/madgraph/fks/fks_common.py ../contrib/MadGraph/madgraph/fks/fks_common.py
--- MadGraph_pristine/madgraph/fks/fks_common.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/fks/fks_common.py	2020-10-30 20:49:24.502460991 +1100
@@ -191,7 +191,7 @@ def link_rb_configs(born_amp, real_amp,
 
     # and compare them
     if len(born_tags) != len(real_tags):
-        print '\n'.join([str(r) for r in real_tags]) + '\n'
+        print('\n'.join([str(r) for r in real_tags]) + '\n')
         raise FKSProcessError('Cannot map born/real configurations between \
                 %s and %s (i,j=%d,%d): not same number of configurations: %d %d' % \
                 (born_amp.get('process').nice_string().replace('Process:',''), 
@@ -209,8 +209,8 @@ def link_rb_configs(born_amp, real_amp,
             real_tags.remove(btag)
             good_diags.pop(ir)
         except ValueError:
-            print real_tags, i, j, ij
-            print '\n'.join( d['diagram'].nice_string() for d in good_diags)
+            print(real_tags, i, j, ij)
+            print('\n'.join( d['diagram'].nice_string() for d in good_diags))
             raise FKSProcessError('Linking %s to %s: could not link born diagram %s' % \
                  (born_amp.get('process').nice_string().replace('Process:',''), 
                   real_amp.get('process').nice_string().replace('Process:',''),
@@ -329,7 +329,7 @@ def insert_legs(leglist_orig, leg, split
     elif pert == 'QED':
         color = 'charge'
     else:
-        raise FKSProcessError, "Only QCD or QED is allowed not  %s" % pert
+        raise FKSProcessError("Only QCD or QED is allowed not  %s" % pert)
     # the deepcopy statement is crucial
     leglist = FKSLegList(copy.deepcopy(leglist_orig))         
     #find the position of the first final state leg
@@ -555,7 +555,7 @@ def find_color_links(leglist, symm = Fal
         color = 'charge'
         zero = 0.
     else:
-        raise FKSProcessError,"Only QCD or QED is allowed not %s" % pert
+        raise FKSProcessError("Only QCD or QED is allowed not %s" % pert)
     color_links = []
     for leg1 in leglist:
         for leg2 in leglist:
@@ -637,7 +637,7 @@ def legs_to_color_link_string(leg1, leg2
             string.coeff = string.coeff * fractions.Fraction(leg['charge']*3.)*\
             fractions.Fraction(1,3)            
     else:
-        raise FKSProcessError,"Only QCD or QED is allowed not %s"% pert
+        raise FKSProcessError("Only QCD or QED is allowed not %s"% pert)
     
     dict['replacements'] = replacements
     dict['string'] = string  
@@ -734,7 +734,7 @@ class FKSLegList(MG.LegList):
             color = 'charge'
             zero = 0.
         else:
-            raise FKSProcessError,"Only QCD and QED is allowed not %s"% pert
+            raise FKSProcessError("Only QCD and QED is allowed not %s"% pert)
         colors = sorted(set([abs(l[color]) for l in final_legs]))
         # first put massless particles, without any rearrangment
         if zero in colors:
@@ -824,25 +824,25 @@ class FKSLeg(MG.Leg):
 
         if name == 'fks':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid string for leg fks flag" \
-                                                        % str(value)
+                                                        % str(value))
         if name in ['color', 'spin']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid leg %s flag" % \
-                                                 str(value),name
+                                                 str(value),name)
                                                  
         if name in ['massless','self_antipart','is_part']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid boolean for leg flag %s" % \
-                                                                    str(value),name
+                                                                    str(value),name)
         if name is 'charge':
             if not isinstance(value, float):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "%s is not a valid float for leg flag charge" \
-                    % str(value)                                                           
+                    % str(value))                                                           
         return super(FKSLeg,self).filter(name, value)
     
      
diff -rupN MadGraph_pristine/madgraph/fks/fks_helas_objects.py ../contrib/MadGraph/madgraph/fks/fks_helas_objects.py
--- MadGraph_pristine/madgraph/fks/fks_helas_objects.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/fks/fks_helas_objects.py	2020-10-30 20:49:24.502460991 +1100
@@ -32,7 +32,10 @@ import array
 import multiprocessing
 import signal
 import tempfile
-import cPickle
+try:
+    import cPickle
+except:
+    import _pickle as cPickle
 import itertools
 import os
 
@@ -211,8 +214,8 @@ class FKSHelasMultiProcess(helas_objects
 
         if name == 'real_matrix_elements':
             if not isinstance(value, helas_objects.HelasMultiProcess):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list for real_matrix_element " % str(value)                             
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list for real_matrix_element " % str(value))                             
     
     def __init__(self, fksmulti, loop_optimized = False, gen_color =True, decay_ids =[]):
         """Initialization from a FKSMultiProcess"""
diff -rupN MadGraph_pristine/madgraph/__init__.py ../contrib/MadGraph/madgraph/__init__.py
--- MadGraph_pristine/madgraph/__init__.py	2020-10-27 21:41:37.889090214 +1100
+++ ../contrib/MadGraph/madgraph/__init__.py	2020-10-30 20:49:24.502460991 +1100
@@ -46,5 +46,5 @@ if ReadWrite:
             os.remove(tmp_path)
             shutil.copy(pjoin(MG5DIR, 'Template','LO','Source','.make_opts'),
                     pjoin(MG5DIR, 'Template','LO','Source','make_opts'))
-    except Exception,error:
+    except Exception as error:
         pass
diff -rupN MadGraph_pristine/madgraph/interface/amcatnlo_interface.py ../contrib/MadGraph/madgraph/interface/amcatnlo_interface.py
--- MadGraph_pristine/madgraph/interface/amcatnlo_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/amcatnlo_interface.py	2020-10-30 20:49:24.502460991 +1100
@@ -29,7 +29,10 @@ import signal
 import tempfile
 import itertools
 import os
-import cPickle
+try:
+    import cPickle
+except:
+    import _pickle as cPickle
 
 
 import madgraph
@@ -172,16 +175,16 @@ class CheckFKS(mg_interface.CheckValidFo
                 return
             else:
                 self.help_launch()
-                raise self.InvalidCmd, \
-                       'No default location available, please specify location.'
+                raise self.InvalidCmd( \
+                       'No default location available, please specify location.')
         
         if len(args) > 2:
             self.help_launch()
-            return self.InvalidCmd, 'Invalid Syntax: Too many argument'
+            return self.InvalidCmd('Invalid Syntax: Too many argument')
 
         elif len(args) == 2:
             if not args[1] in ['LO', 'NLO', 'aMC@NLO', 'aMC@LO', 'auto']:
-                raise self.InvalidCmd, '%s is not a valid mode, please use "LO", "NLO", "aMC@NLO" or "aMC@LO"' % args[1]
+                raise self.InvalidCmd('%s is not a valid mode, please use "LO", "NLO", "aMC@NLO" or "aMC@LO"' % args[1])
         else:
             #check if args[0] is path or mode
             if args[0] in ['LO', 'NLO', 'aMC@NLO', 'aMC@LO', 'auto'] and self._done_export:
@@ -191,7 +194,7 @@ class CheckFKS(mg_interface.CheckValidFo
                 args.append('auto')
             else:
                 self.help_launch()
-                raise self.InvalidCmd, '%s is not a valid process directory nor run mode' % args[0]
+                raise self.InvalidCmd('%s is not a valid process directory nor run mode' % args[0])
 
         mode = args[1]
         
@@ -203,7 +206,7 @@ class CheckFKS(mg_interface.CheckValidFo
         elif  MG4DIR and os.path.isdir(pjoin(MG4DIR,args[0])):
             path = pjoin(MG4DIR,args[0])
         else:    
-            raise self.InvalidCmd, '%s is not a valid directory' % args[0]
+            raise self.InvalidCmd('%s is not a valid directory' % args[0])
         args[0] = path
                 
         # inform where we are for future command
@@ -211,10 +214,10 @@ class CheckFKS(mg_interface.CheckValidFo
 
         # check for incompatible options/modes
         if options['multicore'] and options['cluster']:
-            raise self.InvalidCmd, 'options -m (--multicore) and -c (--cluster)' + \
-                    ' are not compatible. Please choose one.'
+            raise self.InvalidCmd('options -m (--multicore) and -c (--cluster)' + \
+                    ' are not compatible. Please choose one.')
         if mode == 'NLO' and options['reweightonly']:
-            raise self.InvalidCmd, 'option -r (--reweightonly) needs mode "aMC@NLO" or "aMC@LO"'
+            raise self.InvalidCmd('option -r (--reweightonly) needs mode "aMC@NLO" or "aMC@LO"')
 
 
 class CheckFKSWeb(mg_interface.CheckValidForCmdWeb, CheckFKS):
@@ -249,8 +252,8 @@ class CompleteFKS(mg_interface.CompleteF
             if len(args) > 1 and args[1] == 'aloha':
                 try:
                     return self.aloha_complete_output(text, line, begidx, endidx)
-                except Exception, error:
-                    print error
+                except Exception as error:
+                    print(error)
             # Directory continuation
             if args[-1].endswith(os.path.sep):
                 return [name for name in self.path_completion(text,
@@ -415,14 +418,14 @@ class aMCatNLOInterface(CheckFKS, Comple
                     #check that if one requests the virt diagrams, there are virt_amplitudes
                     if args[1] in ['virt', 'loop'] and len(self._curr_amps) == 0:
                         raise self.InvalidCmd('No virtuals have been generated')
-                    print '\n'.join(amp.nice_string_processes() for amp in self._curr_amps)
+                    print('\n'.join(amp.nice_string_processes() for amp in self._curr_amps))
                 else:
-                    print 'Born processes:'
-                    print '\n'.join(amp.nice_string_processes() for amp in get_amps_dict['born']())
-                    print 'Real processes:'
-                    print '\n'.join(amp.nice_string_processes() for amp in get_amps_dict['real']())
-                    print 'Loop processes:'
-                    print '\n'.join(amp.nice_string_processes() for amp in get_amps_dict['loop']())
+                    print('Born processes:')
+                    print('\n'.join(amp.nice_string_processes() for amp in get_amps_dict['born']()))
+                    print('Real processes:')
+                    print('\n'.join(amp.nice_string_processes() for amp in get_amps_dict['real']()))
+                    print('Loop processes:')
+                    print('\n'.join(amp.nice_string_processes() for amp in get_amps_dict['loop']()))
                 # set _curr_amps back to empty
                 self._curr_amps = diagram_generation.AmplitudeList()
 
@@ -587,8 +590,8 @@ class aMCatNLOInterface(CheckFKS, Comple
             ndiags = 0
             if not self._curr_matrix_elements.get_matrix_elements():
                 if group:
-                    raise MadGraph5Error, "Cannot group subprocesses when "+\
-                                                              "exporting to NLO"
+                    raise MadGraph5Error("Cannot group subprocesses when "+\
+                                                              "exporting to NLO")
                 else:
                     self._curr_matrix_elements = \
                              fks_helas.FKSHelasMultiProcess(\
@@ -716,7 +719,7 @@ class aMCatNLOInterface(CheckFKS, Comple
                 proc_charac['nexternal'] = max([diroutput[4] for diroutput in diroutputmap])
                 ninitial_set = set([diroutput[3] for diroutput in diroutputmap])
                 if len(ninitial_set) != 1:
-                    raise MadGraph5Error, ("Invalid ninitial values: %s" % ' ,'.join(list(ninitial_set)))    
+                    raise MadGraph5Error("Invalid ninitial values: %s" % ' ,'.join(list(ninitial_set)))    
                 proc_charac['ninitial'] = list(ninitial_set)[0]
 
                 self.born_processes = []
diff -rupN MadGraph_pristine/madgraph/interface/amcatnlo_run_interface.py ../contrib/MadGraph/madgraph/interface/amcatnlo_run_interface.py
--- MadGraph_pristine/madgraph/interface/amcatnlo_run_interface.py	2020-10-27 21:41:37.889090214 +1100
+++ ../contrib/MadGraph/madgraph/interface/amcatnlo_run_interface.py	2020-10-30 20:49:24.506460977 +1100
@@ -37,7 +37,12 @@ import copy
 import datetime
 import tarfile
 import traceback
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 try:
     import cpickle as pickle
 except:
@@ -108,7 +113,7 @@ def compile_dir(*arguments):
     elif len(arguments)==7:
         (me_dir, p_dir, mode, options, tests, exe, run_mode) = arguments
     else:
-        raise aMCatNLOError, 'not correct number of argument'
+        raise aMCatNLOError('not correct number of argument')
     logger.info(' Compiling %s...' % p_dir)
 
     this_dir = pjoin(me_dir, 'SubProcesses', p_dir) 
@@ -148,7 +153,7 @@ def compile_dir(*arguments):
 
         logger.info('    %s done.' % p_dir) 
         return 0
-    except MadGraph5Error, msg:
+    except MadGraph5Error as msg:
         return msg
 
 
@@ -418,10 +423,10 @@ class CheckValidForCmd(object):
         
         if len(args) == 0:
             self.help_shower()
-            raise self.InvalidCmd, 'Invalid syntax, please specify the run name'
+            raise self.InvalidCmd('Invalid syntax, please specify the run name')
         if not os.path.isdir(pjoin(self.me_dir, 'Events', args[0])):
-            raise self.InvalidCmd, 'Directory %s does not exists' % \
-                            pjoin(os.getcwd(), 'Events',  args[0])
+            raise self.InvalidCmd('Directory %s does not exists' % \
+                            pjoin(os.getcwd(), 'Events',  args[0]))
 
         self.set_run_name(args[0], level= 'shower')
         args[0] = pjoin(self.me_dir, 'Events', args[0])
@@ -607,17 +612,17 @@ class CheckValidForCmd(object):
         
         if len(args) > 1:
             self.help_calculate_xsect()
-            raise self.InvalidCmd, 'Invalid Syntax: Too many argument'
+            raise self.InvalidCmd('Invalid Syntax: Too many argument')
 
         elif len(args) == 1:
             if not args[0] in ['NLO', 'LO']:
-                raise self.InvalidCmd, '%s is not a valid mode, please use "LO" or "NLO"' % args[1]
+                raise self.InvalidCmd('%s is not a valid mode, please use "LO" or "NLO"' % args[1])
         mode = args[0]
         
         # check for incompatible options/modes
         if options['multicore'] and options['cluster']:
-            raise self.InvalidCmd, 'options -m (--multicore) and -c (--cluster)' + \
-                    ' are not compatible. Please choose one.'
+            raise self.InvalidCmd('options -m (--multicore) and -c (--cluster)' + \
+                    ' are not compatible. Please choose one.')
 
 
     def check_generate_events(self, args, options):
@@ -632,17 +637,17 @@ class CheckValidForCmd(object):
         
         if len(args) > 1:
             self.help_generate_events()
-            raise self.InvalidCmd, 'Invalid Syntax: Too many argument'
+            raise self.InvalidCmd('Invalid Syntax: Too many argument')
 
         elif len(args) == 1:
             if not args[0] in ['NLO', 'LO']:
-                raise self.InvalidCmd, '%s is not a valid mode, please use "LO" or "NLO"' % args[1]
+                raise self.InvalidCmd('%s is not a valid mode, please use "LO" or "NLO"' % args[1])
         mode = args[0]
         
         # check for incompatible options/modes
         if options['multicore'] and options['cluster']:
-            raise self.InvalidCmd, 'options -m (--multicore) and -c (--cluster)' + \
-                    ' are not compatible. Please choose one.'
+            raise self.InvalidCmd('options -m (--multicore) and -c (--cluster)' + \
+                    ' are not compatible. Please choose one.')
 
     def check_banner_run(self, args):
         """check the validity of line"""
@@ -719,19 +724,19 @@ class CheckValidForCmd(object):
         
         if len(args) > 1:
             self.help_launch()
-            raise self.InvalidCmd, 'Invalid Syntax: Too many argument'
+            raise self.InvalidCmd('Invalid Syntax: Too many argument')
 
         elif len(args) == 1:
             if not args[0] in ['LO', 'NLO', 'aMC@NLO', 'aMC@LO','auto']:
-                raise self.InvalidCmd, '%s is not a valid mode, please use "LO", "NLO", "aMC@NLO" or "aMC@LO"' % args[0]
+                raise self.InvalidCmd('%s is not a valid mode, please use "LO", "NLO", "aMC@NLO" or "aMC@LO"' % args[0])
         mode = args[0]
         
         # check for incompatible options/modes
         if options['multicore'] and options['cluster']:
-            raise self.InvalidCmd, 'options -m (--multicore) and -c (--cluster)' + \
-                    ' are not compatible. Please choose one.'
+            raise self.InvalidCmd('options -m (--multicore) and -c (--cluster)' + \
+                    ' are not compatible. Please choose one.')
         if mode == 'NLO' and options['reweightonly']:
-            raise self.InvalidCmd, 'option -r (--reweightonly) needs mode "aMC@NLO" or "aMC@LO"'
+            raise self.InvalidCmd('option -r (--reweightonly) needs mode "aMC@NLO" or "aMC@LO"')
 
 
     def check_compile(self, args, options):
@@ -749,11 +754,11 @@ class CheckValidForCmd(object):
         
         if len(args) > 1:
             self.help_compile()
-            raise self.InvalidCmd, 'Invalid Syntax: Too many argument'
+            raise self.InvalidCmd('Invalid Syntax: Too many argument')
 
         elif len(args) == 1:
             if not args[0] in ['MC', 'FO']:
-                raise self.InvalidCmd, '%s is not a valid mode, please use "FO" or "MC"' % args[0]
+                raise self.InvalidCmd('%s is not a valid mode, please use "FO" or "MC"' % args[0])
         mode = args[0]
         
         # check for incompatible options/modes
@@ -821,8 +826,8 @@ class CompleteForCmd(CheckValidForCmd):
         return self.deal_multiple_categories(possibilites, formatting)
     
         
-       except Exception, error:
-           print error
+       except Exception as error:
+           print(error)
 
  
     def complete_compile(self, text, line, begidx, endidx):
@@ -2806,7 +2811,7 @@ RESTART = %(mint_mode)s
         while p.poll() is None:
             line = p.stdout.readline()
             if any(t in line for t in ['INFO:','WARNING:','CRITICAL:','ERROR:','KEEP:']):
-                print line[:-1]
+                print(line[:-1])
             elif __debug__ and line:
                 logger.debug(line[:-1])
 
@@ -3137,7 +3142,7 @@ RESTART = %(mint_mode)s
             all_log_files = misc.glob(pjoin('P*','born_G*','log_MINT*.txt'), 
                                       pjoin(self.me_dir, 'SubProcesses')) 
         else:
-            raise aMCatNLOError, 'Running mode %s not supported.'%mode
+            raise aMCatNLOError('Running mode %s not supported.'%mode)
 
         try:
             message, debug_msg = \
@@ -3548,7 +3553,7 @@ RESTART = %(mint_mode)s
             try:
                 TimeList = [((100.0*time/stats['timings']['Total'][chan]), 
                      chan) for chan, time in stats['timings'][name].items()]
-            except KeyError, ZeroDivisionError:
+            except (KeyError, ZeroDivisionError):
                 debug_msg += '\n\n  Timing profile for %s unavailable.'%name
                 continue
             TimeList.sort()
@@ -3557,7 +3562,7 @@ RESTART = %(mint_mode)s
                 debug_msg += '\n    Overall fraction of time         %.3f %%'%\
                        safe_float((100.0*(sum(stats['timings'][name].values())/
                                       sum(stats['timings']['Total'].values()))))
-            except KeyError, ZeroDivisionError:
+            except (KeyError, ZeroDivisionError):
                 debug_msg += '\n    Overall fraction of time unavailable.'
             debug_msg += '\n    Largest fraction of time         %.3f %% (%s)'%\
                                              (TimeList[-1][0],TimeList[-1][1])
@@ -3794,7 +3799,7 @@ RESTART = %(mint_mode)s
         exe = 'MCATNLO_%s_EXE' % shower
         if not os.path.exists(pjoin(self.me_dir, 'MCatNLO', exe)) and \
             not os.path.exists(pjoin(self.me_dir, 'MCatNLO', 'Pythia8.exe')):
-            print open(mcatnlo_log).read()
+            print(open(mcatnlo_log).read())
             raise aMCatNLOError('Compilation failed, check %s for details' % mcatnlo_log)
         logger.info('                     ... done')
 
@@ -3932,7 +3937,7 @@ RESTART = %(mint_mode)s
                      ' showering the (split) parton-level event file %s.gz with %s') % \
                      ('\n  '.join(hep_list), hep_format, evt_file, shower)
 
-            except OSError, IOError:
+            except (OSError, IOError):
                 raise aMCatNLOError('No file has been generated, an error occurred.'+\
              ' More information in %s' % pjoin(os.getcwd(), 'amcatnlo_run.log'))
 
@@ -3940,7 +3945,7 @@ RESTART = %(mint_mode)s
             if hep_format == 'StdHEP':
                 try:
                     self.do_plot('%s -f' % self.run_name)
-                except Exception, error:
+                except Exception as error:
                     logger.info("Fail to make the plot. Continue...")
                     pass
 
@@ -4848,8 +4853,8 @@ RESTART = %(mint_mode)s
                 elif os.path.exists(pjoin(self.me_dir, 'Events', self.run_name, 'events.lhe')):
                     input_files.append(pjoin(self.me_dir, 'Events', self.run_name, 'events.lhe'))
                 else:
-                    raise aMCatNLOError, 'Event file not present in %s' % \
-                            pjoin(self.me_dir, 'Events', self.run_name)
+                    raise aMCatNLOError('Event file not present in %s' % \
+                            pjoin(self.me_dir, 'Events', self.run_name))
             else: 
                 input_files.append(pjoin(cwd, 'events_%s.lhe' % args[3]))
             # the output files
@@ -4873,7 +4878,7 @@ RESTART = %(mint_mode)s
                     fname = 'histfile_%s' % args[3]
                 output_files.append(fname + '.tar')
             else:
-                raise aMCatNLOError, 'Not a valid output argument for shower job :  %d' % args[1]
+                raise aMCatNLOError('Not a valid output argument for shower job :  %d' % args[1])
             #submitting
             self.cluster.submit2(exe, args, cwd=cwd, 
                     input_files=input_files, output_files=output_files)
@@ -4960,7 +4965,7 @@ RESTART = %(mint_mode)s
                 output_files.append('%s/results.dat' % current)
 
         else:
-            raise aMCatNLOError, 'not valid arguments: %s' %(', '.join(args))
+            raise aMCatNLOError('not valid arguments: %s' %(', '.join(args)))
 
         #Find the correct PDF input file
         pdfinput = self.get_pdf_input_filename()
@@ -5216,7 +5221,7 @@ RESTART = %(mint_mode)s
                     tests, exe, self.options['run_mode']])
         try:
             compile_cluster.wait(self.me_dir, update_status)
-        except Exception, error:
+        except Exception as error:
             logger.warning("Fail to compile the Subprocesses")
             if __debug__:
                 raise
@@ -5612,7 +5617,7 @@ if '__main__' == __name__:
         try:
             (options, args) = parser.parse_args(sys.argv[1:len(sys.argv)-i])
             done = True
-        except MyOptParser.InvalidOption, error:
+        except MyOptParser.InvalidOption as error:
             pass
         else:
             args += sys.argv[len(sys.argv)-i:]
@@ -5620,8 +5625,8 @@ if '__main__' == __name__:
         # raise correct error:                                                                                                                                                                                  
         try:
             (options, args) = parser.parse_args()
-        except MyOptParser.InvalidOption, error:
-            print error
+        except MyOptParser.InvalidOption as error:
+            print(error)
             sys.exit(2)
 
     if len(args) == 0:
@@ -5640,7 +5645,7 @@ if '__main__' == __name__:
             level = int(options.logging)
         else:
             level = eval('logging.' + options.logging)
-        print os.path.join(root_path, 'internal', 'me5_logging.conf')
+        print(os.path.join(root_path, 'internal', 'me5_logging.conf'))
         logging.config.fileConfig(os.path.join(root_path, 'internal', 'me5_logging.conf'))
         logging.root.setLevel(level)
         logging.getLogger('madgraph').setLevel(level)
@@ -5661,16 +5666,16 @@ if '__main__' == __name__:
 
             if not hasattr(cmd_line, 'do_%s' % args[0]):
                 if parser_error:
-                    print parser_error
-                    print 'and %s  can not be interpreted as a valid command.' % args[0]
+                    print(parser_error)
+                    print('and %s  can not be interpreted as a valid command.' % args[0])
                 else:
-                    print 'ERROR: %s  not a valid command. Please retry' % args[0]
+                    print('ERROR: %s  not a valid command. Please retry' % args[0])
             else:
                 cmd_line.use_rawinput = False
                 cmd_line.run_cmd(' '.join(args))
                 cmd_line.run_cmd('quit')
 
     except KeyboardInterrupt:
-        print 'quit on KeyboardInterrupt'
+        print('quit on KeyboardInterrupt')
         pass
 
diff -rupN MadGraph_pristine/madgraph/interface/common_run_interface.py ../contrib/MadGraph/madgraph/interface/common_run_interface.py
--- MadGraph_pristine/madgraph/interface/common_run_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/common_run_interface.py	2020-10-30 20:49:24.510460964 +1100
@@ -33,7 +33,11 @@ import time
 import traceback
 import urllib
 import glob
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
 
 try:
     import readline
@@ -211,16 +215,16 @@ class CheckValidForCmd(object):
         
         # Check that MG5 directory is present .
         if MADEVENT and not self.options['mg5_path']:
-            raise self.InvalidCmd, '''The automatic computations of widths requires that MG5 is installed on the system.
-            You can install it and set his path in ./Cards/me5_configuration.txt'''
+            raise self.InvalidCmd('''The automatic computations of widths requires that MG5 is installed on the system.
+            You can install it and set his path in ./Cards/me5_configuration.txt''')
         elif MADEVENT:
             sys.path.append(self.options['mg5_path'])
         try:
             import models.model_reader as model_reader
             import models.import_ufo as import_ufo
         except ImportError:
-            raise self.ConfigurationError, '''Can\'t load MG5.
-            The variable mg5_path should not be correctly configure.'''
+            raise self.ConfigurationError('''Can\'t load MG5.
+            The variable mg5_path should not be correctly configure.''')
         
 
         ufo_path = pjoin(self.me_dir,'bin','internal', 'ufomodel')
@@ -258,7 +262,7 @@ class CheckValidForCmd(object):
             if arg.startswith('--output='):
                 output_path = arg.split('=',1)[1]
                 if not os.path.exists(output_path):
-                    raise self.InvalidCmd, 'Invalid Path for the output. Please retry.'
+                    raise self.InvalidCmd('Invalid Path for the output. Please retry.')
                 if not os.path.isfile(output_path):
                     output_path = pjoin(output_path, 'param_card.dat')
                 output['output'] = output_path       
@@ -267,13 +271,13 @@ class CheckValidForCmd(object):
             elif os.path.isfile(arg):
                 ftype = self.detect_card_type(arg)
                 if ftype != 'param_card.dat':
-                    raise self.InvalidCmd , '%s is not a valid param_card.' % arg
+                    raise self.InvalidCmd('%s is not a valid param_card.' % arg)
                 output['path'] = arg
             elif arg.startswith('--path='):
                 arg = arg.split('=',1)[1]
                 ftype = self.detect_card_type(arg)
                 if ftype != 'param_card.dat':
-                    raise self.InvalidCmd , '%s is not a valid param_card.' % arg
+                    raise self.InvalidCmd('%s is not a valid param_card.' % arg)
                 output['path'] = arg
             elif arg.startswith('--'):
                 if "=" in arg:
@@ -281,7 +285,7 @@ class CheckValidForCmd(object):
                     try:
                         value = float(value)
                     except Exception:
-                        raise self.InvalidCmd, '--%s requires integer or a float' % name
+                        raise self.InvalidCmd('--%s requires integer or a float' % name)
                     output[name[2:]] = float(value)
                 elif arg == "--nlo":
                     output["nlo"] = True
@@ -294,13 +298,13 @@ class CheckValidForCmd(object):
                 output['particles'] = set(['all'])
             else:
                 self.help_compute_widths()
-                raise self.InvalidCmd, '%s is not a valid argument for compute_widths' % arg
+                raise self.InvalidCmd('%s is not a valid argument for compute_widths' % arg)
         if self.force:
             output['force'] = True
 
         if not output['particles']:
-            raise self.InvalidCmd, '''This routines requires at least one particle in order to compute
-            the related width'''
+            raise self.InvalidCmd('''This routines requires at least one particle in order to compute
+            the related width''')
             
         if output['output'] is None:
             output['output'] = output['path']
@@ -654,7 +658,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 closed. If no instance is running, you can delete the file
                 %s and try again.''' % pjoin(me_dir,'RunWeb')
                 self.stop_for_runweb = True
-                raise AlreadyRunning, message
+                raise AlreadyRunning(message)
             else:
                 self.write_RunWeb(me_dir)
 
@@ -689,7 +693,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
     def writeRunWeb(me_dir):
         pid = os.getpid()
         fsock = open(pjoin(me_dir,'RunWeb'),'w')
-        fsock.write(`pid`)
+        fsock.write(repr(pid))
         fsock.close()        
         
     class RunWebHandling(object):
@@ -719,7 +723,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 (for this exact same directory). Please wait that this is instance is 
                 closed. If no instance is running, you can delete the file
                 %s and try again.''' % (pid, pjoin(me_dir, 'RunWeb'))
-                                raise AlreadyRunning, message
+                                raise AlreadyRunning(message)
                         elif warnifpresent:
                             if isinstance( warnifpresent, bool):
                                 logger.warning("%s/RunWeb is present. Please check that only one run is running in that directory.")
@@ -811,7 +815,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             else:
                 try:                                
                     self.results.resetall(self.me_dir)
-                except Exception, error:
+                except Exception as error:
                     logger.debug(error)
                     # Maybe the format was updated -> try fresh
                     model = self.find_model_name()
@@ -845,7 +849,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
         else:   
             try:
                 self.cluster.modify_interface(self)
-            except Exception, error:
+            except Exception as error:
                 misc.sprint(str(error))
                 
         keepwidth = False
@@ -991,7 +995,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             elif path == 'MadLoopParams.dat':
                 return 'MadLoopParams'
             else:
-                raise Exception, 'Unknow cards name %s' % path
+                raise Exception('Unknow cards name %s' % path)
 
         # Ask the user if he wants to edit any of the files
         #First create the asking text
@@ -1447,7 +1451,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 if not self.options['pythia-pgs_path']:
                     return
             else:
-                raise self.InvalidCmd, 'Invalid mode %s' % mode
+                raise self.InvalidCmd('Invalid mode %s' % mode)
         elif mode == 'reweight' and not output:
                 output = pjoin(self.me_dir, 'HTML',self.run_name,
                               'plots_%s.html' % tag)
@@ -1456,7 +1460,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             if os.path.exists(event_path+'.gz'):
                 misc.gunzip('%s.gz' % event_path)
             else:
-                raise self.InvalidCmd, 'Events file %s does not exist' % event_path
+                raise self.InvalidCmd('Events file %s does not exist' % event_path)
         elif event_path.endswith(".gz"):
              misc.gunzip(event_path)
              event_path = event_path[:-3]
@@ -1503,7 +1507,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
 
             logger.info("Plots for %s level generated, see %s" % \
                          (mode, output))
-        except OSError, error:
+        except OSError as error:
             logger.error('fail to create plot: %s. Please check that MadAnalysis is correctly installed.' % error)
 
         self.update_status('End Plots for %s level' % mode, level = mode.lower(),
@@ -1515,7 +1519,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
         """Run hep2lhe on the file Events/pythia_events.hep"""
 
         if not self.options['pythia-pgs_path']:
-            raise self.InvalidCmd, 'No pythia-pgs path defined'
+            raise self.InvalidCmd('No pythia-pgs path defined')
 
         pydir = pjoin(self.options['pythia-pgs_path'], 'src')
         eradir = self.options['exrootanalysis_path']
@@ -1548,7 +1552,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                              'pythia_events.lhe',
                              pjoin(self.run_name, '%s_pythia_lhe_events.root' % self.run_tag)],
                             cwd=pjoin(self.me_dir,'Events'))
-                except Exception, error:
+                except Exception as error:
                     misc.sprint('ExRootLHEFConverter fails', str(error),
                                                                      log=logger)
                     pass
@@ -1675,14 +1679,14 @@ class CommonRunCmd(HelpToCmd, CheckValid
                                  '--remove_wgts=', '--keep_wgts','--start_id=', '--weight_format=',
                                  '--weight_info='))
                 for o in opts):
-            raise self.InvalidCmd, "command systematics called with invalid option syntax. Please retry."
+            raise self.InvalidCmd("command systematics called with invalid option syntax. Please retry.")
         
         # check that we have define the input
         if len(args) == 0:
             if self.run_name:
                 args[0] = self.run_name
             else:
-                raise self.InvalidCmd, 'no default run. Please specify the run_name'
+                raise self.InvalidCmd('no default run. Please specify the run_name')
         
         if args[0] != self.run_name:
             self.set_run_name(args[0])
@@ -1707,7 +1711,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                     args[0] = p
                     break
             else:
-                raise self.InvalidCmd, 'Invalid run name. Please retry'
+                raise self.InvalidCmd('Invalid run name. Please retry')
         elif self.options['nb_core'] != 1:
             lhe = lhe_parser.EventFile(args[0])
             nb_event = len(lhe)
@@ -1721,20 +1725,20 @@ class CommonRunCmd(HelpToCmd, CheckValid
     
         lhaid = [self.run_card.get_lhapdf_id()]
         if 'store_rwgt_info' in self.run_card and not self.run_card['store_rwgt_info']:
-            raise self.InvalidCmd,  "The events was not generated with store_rwgt_info=True. Can not evaluate systematics error on this event file."
+            raise self.InvalidCmd("The events was not generated with store_rwgt_info=True. Can not evaluate systematics error on this event file.")
         elif 'use_syst'  in self.run_card:
             if not self.run_card['use_syst']:
-                raise self.InvalidCmd,  "The events was not generated with use_syst=True. Can not evaluate systematics error on this event file."
+                raise self.InvalidCmd("The events was not generated with use_syst=True. Can not evaluate systematics error on this event file.")
             elif self.proc_characteristics['ninitial'] ==1:
                 if '--from_card' in opts:
                     logger.warning('systematics not available for decay processes. Bypass it')
                     return
                 else:
-                    raise self.InvalidCmd, 'systematics not available for decay processes.'
+                    raise self.InvalidCmd('systematics not available for decay processes.')
                 
         try:
             pdfsets_dir = self.get_lhapdf_pdfsetsdir()
-        except Exception, error:
+        except Exception as error:
             logger.debug(str(error))
             logger.warning('Systematic computation requires lhapdf to run. Bypass Systematics')
             return
@@ -1769,7 +1773,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
         # Copy all the relevant PDF sets
         try:
             [self.copy_lhapdf_set([onelha], pdfsets_dir, require_local=False) for onelha in lhaid]
-        except Exception, error:
+        except Exception as error:
             logger.debug(str(error))
             logger.warning('impossible to download all the pdfsets. Bypass systematics')
             return
@@ -1958,15 +1962,15 @@ class CommonRunCmd(HelpToCmd, CheckValid
             
         # Check that MG5 directory is present .
         if MADEVENT and not self.options['mg5_path']:
-            raise self.InvalidCmd, '''The module reweight requires that MG5 is installed on the system.
-            You can install it and set its path in ./Cards/me5_configuration.txt'''
+            raise self.InvalidCmd('''The module reweight requires that MG5 is installed on the system.
+            You can install it and set its path in ./Cards/me5_configuration.txt''')
         elif MADEVENT:
             sys.path.append(self.options['mg5_path'])
         try:
             import madgraph.interface.reweight_interface as reweight_interface
         except ImportError:
-            raise self.ConfigurationError, '''Can\'t load Reweight module.
-            The variable mg5_path might not be correctly configured.'''
+            raise self.ConfigurationError('''Can\'t load Reweight module.
+            The variable mg5_path might not be correctly configured.''')
         
 
                         
@@ -2012,7 +2016,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                     line = p.stdout.readline()
                     if any(t in line for t in ['INFO:', 'WARNING:', 'CRITICAL:', 'ERROR:', 'root:','KEEP:']) and \
                        not '***********' in line:
-                            print line[:-1].replace('INFO', 'REWEIGHT').replace('KEEP:','')
+                            print(line[:-1].replace('INFO', 'REWEIGHT').replace('KEEP:',''))
                     elif __debug__ and line:
                         logger.debug(line[:-1])
                 if p.returncode !=0:
@@ -2048,7 +2052,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 self.check_decay_events(new_args) 
                 try:
                     os.remove(pjoin(self.me_dir,'rw_me','rwgt.pkl'))
-                except Exception, error:
+                except Exception as error:
                     pass
                 # prepare multi-core  job:
                 import madgraph.various.lhe_parser as lhe_parser
@@ -2105,7 +2109,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 if any(os.path.exists('%s_%s_debug.log' % (f, self.run_tag)) for f in all_lhe):
                     for f in all_lhe:
                         if os.path.exists('%s_%s_debug.log' % (f, self.run_tag)):
-                            raise Exception, "Some of the run failed: Please read %s_%s_debug.log" % (f, self.run_tag) 
+                            raise Exception("Some of the run failed: Please read %s_%s_debug.log" % (f, self.run_tag) )
                 
                 
                 if 'event_norm' in self.run_card and self.run_card['event_norm'] in ['average','bias']:
@@ -2839,8 +2843,8 @@ class CommonRunCmd(HelpToCmd, CheckValid
                     reco_event_file = misc.glob('*.lhe.gz',pjoin(reco_output,'Output','_reco_events','lheEvents0_%d'%MA5_run_number))+\
                                        misc.glob('*.root',pjoin(reco_output,'Output','_reco_events', 'RecoEvents0_%d'%MA5_run_number))
                     if len(reco_event_file)==0:
-                        raise MadGraph5Error, "MadAnalysis5 failed to produce the "+\
-                  "reconstructed event file for reconstruction '%s'."%MA5_runtag[6:]
+                        raise MadGraph5Error("MadAnalysis5 failed to produce the "+\
+                  "reconstructed event file for reconstruction '%s'."%MA5_runtag[6:])
                     reco_event_file = reco_event_file[0]
                     # move the reconstruction output to the HTML directory
                     shutil.move(reco_output,pjoin(self.me_dir,'HTML',
@@ -2951,7 +2955,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             delphes3 = False
             prog = '../bin/internal/run_delphes'
             if filepath and '.hepmc' in filepath[:-10]:
-                raise self.InvalidCmd, 'delphes2 do not support hepmc'
+                raise self.InvalidCmd('delphes2 do not support hepmc')
         else:
             delphes3 = True
             prog =  '../bin/internal/run_delphes3'
@@ -3131,7 +3135,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 misc.mod_compilator(self.me_dir, args[1], current, 'cpp')
         elif args[0] == "run_mode":
             if not args[1] in [0,1,2,'0','1','2']:
-                raise self.InvalidCmd, 'run_mode should be 0, 1 or 2.'
+                raise self.InvalidCmd('run_mode should be 0, 1 or 2.')
             self.cluster_mode = int(args[1])
             self.options['run_mode'] =  self.cluster_mode
         elif args[0] in  ['cluster_type', 'cluster_queue', 'cluster_temp_path']:
@@ -3239,20 +3243,20 @@ class CommonRunCmd(HelpToCmd, CheckValid
             cluster_name = opt['cluster_type']
             if cluster_name in cluster.from_name:
                 self.cluster = cluster.from_name[cluster_name](**opt)
-                print "using cluster:", cluster_name
+                print("using cluster:", cluster_name)
             else:
-                print "cluster_class", cluster_name
-                print self.plugin_path
+                print("cluster_class", cluster_name)
+                print(self.plugin_path)
                 # Check if a plugin define this type of cluster
                 # check for PLUGIN format
                 cluster_class = misc.from_plugin_import(self.plugin_path, 
                                             'new_cluster', cluster_name,
                                             info = 'cluster handling will be done with PLUGIN: %(plug)s' )
-                print type(cluster_class)
+                print(type(cluster_class))
                 if cluster_class:
                     self.cluster = cluster_class(**self.options)
                 else:
-                    raise self.InvalidCmd, "%s is not recognized as a supported cluster format." % cluster_name              
+                    raise self.InvalidCmd("%s is not recognized as a supported cluster format." % cluster_name)              
     def check_param_card(self, path, run=True, dependent=False):
         """
         1) Check that no scan parameter are present
@@ -3287,7 +3291,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
         if pattern_scan.search(text):
             if not isinstance(interface, cmd.CmdShell):
                 # we are in web mode => forbid scan due to security risk
-                raise Exception, "Scan are not allowed in web mode"
+                raise Exception("Scan are not allowed in web mode")
             # at least one scan parameter found. create an iterator to go trough the cards
             main_card = iterator_class(text)
             interface.param_card_iterator = main_card
@@ -3382,7 +3386,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             
             
             
-        raise Exception, 'fail to find a way to handle Auto width'
+        raise Exception('fail to find a way to handle Auto width')
         
         
     def store_scan_result(self):
@@ -3437,7 +3441,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
 
         try:
             self.update_status('', level=None)
-        except Exception, error:
+        except Exception as error:
             pass
 
         self.gen_card_html()
@@ -3662,8 +3666,8 @@ class CommonRunCmd(HelpToCmd, CheckValid
         # First need to load MadSpin
         # Check that MG5 directory is present .
         if MADEVENT and not self.options['mg5_path']:
-            raise self.InvalidCmd, '''The module decay_events requires that MG5 is installed on the system.
-            You can install it and set its path in ./Cards/me5_configuration.txt'''
+            raise self.InvalidCmd('''The module decay_events requires that MG5 is installed on the system.
+            You can install it and set its path in ./Cards/me5_configuration.txt''')
         elif MADEVENT:
             sys.path.append(self.options['mg5_path'])
         try:
@@ -3673,8 +3677,8 @@ class CommonRunCmd(HelpToCmd, CheckValid
             if __debug__:
                 raise
             else:
-                raise self.ConfigurationError, '''Can\'t load MadSpin
-            The variable mg5_path might not be correctly configured.'''
+                raise self.ConfigurationError('''Can\'t load MadSpin
+            The variable mg5_path might not be correctly configured.''')
 
         self.update_status('Running MadSpin', level='madspin')
         if not '-from_cards' in line and '-f' not in line:
@@ -3838,15 +3842,15 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 
         # Check that MG5 directory is present .
         if MADEVENT and not self.options['mg5_path']:
-            raise self.InvalidCmd, '''The module reweight requires that MG5 is installed on the system.
-            You can install it and set its path in ./Cards/me5_configuration.txt'''
+            raise self.InvalidCmd('''The module reweight requires that MG5 is installed on the system.
+            You can install it and set its path in ./Cards/me5_configuration.txt''')
         elif MADEVENT:
             sys.path.append(self.options['mg5_path'])
         try:
             import madgraph.interface.reweight_interface as reweight_interface
         except ImportError:
-            raise self.ConfigurationError, '''Can\'t load Reweight module.
-            The variable mg5_path might not be correctly configured.'''
+            raise self.ConfigurationError('''Can\'t load Reweight module.
+            The variable mg5_path might not be correctly configured.''')
               
 
         # load the name of the event file
@@ -4065,7 +4069,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                             shutil.rmtree(pjoin(self.me_dir, 'lib', 'PDFsets', name))
                         else:
                             os.remove(pjoin(self.me_dir, 'lib', 'PDFsets', name))
-                    except Exception, error:
+                    except Exception as error:
                         logger.debug('%s', error)
         
         if self.options["cluster_local_path"]:
@@ -4093,7 +4097,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                             shutil.rmtree(pjoin(pdfsets_dir, name))
                         else:
                             os.remove(pjoin(pdfsets_dir, name))
-                    except Exception, error:
+                    except Exception as error:
                         logger.debug('%s', error)
             if not require_local and (os.path.exists(pjoin(pdfsets_dir, pdfset)) or \
                                     os.path.isdir(pjoin(pdfsets_dir, pdfset))):
@@ -4218,9 +4222,9 @@ class CommonRunCmd(HelpToCmd, CheckValid
                                                               filename, 
                                         lhapdf_version, alternate_path)
                     else:
-                        raise MadGraph5Error, \
+                        raise MadGraph5Error( \
                 'Could not download %s into %s. Please try to install it manually.' \
-                    % (filename, pdfsets_dir) 
+                    % (filename, pdfsets_dir) )
                 else:
                     return CommonRunCmd.install_lhapdf_pdfset_static(lhapdf_config, None, 
                                                               filename, 
@@ -4237,22 +4241,22 @@ class CommonRunCmd(HelpToCmd, CheckValid
                                                               filename, 
                                         lhapdf_version, alternate_path)
                     else:
-                        raise MadGraph5Error, \
+                        raise MadGraph5Error( \
                 'Could not download %s into %s. Please try to install it manually.' \
-                    % (filename, pdfsets_dir) 
+                    % (filename, pdfsets_dir) )
                 else:
                     return CommonRunCmd.install_lhapdf_pdfset_static(lhapdf_config, None, 
                                                               filename, 
                                         lhapdf_version, alternate_path)
             else:  
-                raise MadGraph5Error, \
+                raise MadGraph5Error( \
                 'Could not download %s into %s. Please try to install it manually.' \
-                    % (filename, pdfsets_dir)                          
+                    % (filename, pdfsets_dir))                          
             
         else:                    
-            raise MadGraph5Error, \
+            raise MadGraph5Error( \
                 'Could not download %s into %s. Please try to install it manually.' \
-                    % (filename, pdfsets_dir)
+                    % (filename, pdfsets_dir))
 
 
 
@@ -4270,7 +4274,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             if os.path.exists('%s.index' % pdfsets_dir):
                 indexfile = '%s.index' % pdfsets_dir
             else:
-                raise MadGraph5Error, 'index of lhapdf file not found'
+                raise MadGraph5Error('index of lhapdf file not found')
             pdfsets_lines = \
                     [l for l in open(indexfile).read().split('\n') if l.strip() and \
                         not '90cl' in l]
@@ -4308,9 +4312,9 @@ class CommonRunCmd(HelpToCmd, CheckValid
             lhapdf_version = \
                     subprocess.Popen([lhapdf_config, '--version'], 
                         stdout = subprocess.PIPE).stdout.read().strip()
-        except OSError, error:
+        except OSError as error:
             if error.errno == 2:
-                raise Exception, 'lhapdf executable (%s) is not found on your system. Please install it and/or indicate the path to the correct executable in input/mg5_configuration.txt' % self.options['lhapdf']
+                raise Exception('lhapdf executable (%s) is not found on your system. Please install it and/or indicate the path to the correct executable in input/mg5_configuration.txt' % self.options['lhapdf'])
             else:
                 raise
                 
@@ -4825,15 +4829,15 @@ class AskforEditCard(cmd.OneLinePathComp
         if len(args)==0 or (len(args) == 1 and hasattr(self, 'do_%s' % args[0])):
             out = cmd.BasicCmd.do_help(self, line)
             if len(args)==0:
-                print 'Allowed Argument'
-                print '================'
-                print '\t'.join(self.allow_arg)
-                print 
-                print 'Special shortcut: (type help <name>)'
-                print '===================================='
-                print '    syntax: set <name> <value>' 
-                print '\t'.join(self.special_shortcut)
-                print
+                print( 'Allowed Argument')
+                print( '================')
+                print( '\t'.join(self.allow_arg))
+                print( )
+                print( 'Special shortcut: (type help <name>)')
+                print( '====================================')
+                print( '    syntax: set <name> <value>' )
+                print( '\t'.join(self.special_shortcut))
+                print()
             if banner:
                 logger.info('*** END HELP ***', '$MG:BOLD')  
             return out      
@@ -4841,7 +4845,7 @@ class AskforEditCard(cmd.OneLinePathComp
         # special shortcut:
         if args[0] in self.special_shortcut:    
             if args[0] in self.special_shortcut_help:
-                print self.special_shortcut_help[args[0]]
+                print( self.special_shortcut_help[args[0]])
             if banner:
                 logger.info('*** END HELP ***', '$MG:BOLD')  
             return       
@@ -4862,23 +4866,23 @@ class AskforEditCard(cmd.OneLinePathComp
                     args[0] = 'PY8Card'              
                 if args[0] == 'param_card':
                     logger.info("Param_card information: ", '$MG:color:BLUE')
-                    print "File to define the various model parameter"
+                    print( "File to define the various model parameter")
                     logger.info("List of the Block defined:",'$MG:color:BLUE')
-                    print "\t".join(self.param_card.keys())
+                    print( "\t".join(self.param_card.keys()))
                 elif args[0].startswith('madanalysis5'):
-                    print 'This card allow to make plot with the madanalysis5 package'
-                    print 'An example card is provided. For more information about the '
-                    print 'syntax please refer to: https://madanalysis.irmp.ucl.ac.be/'
-                    print 'or to the user manual [arXiv:1206.1599]'
+                    print( 'This card allow to make plot with the madanalysis5 package')
+                    print( 'An example card is provided. For more information about the ')
+                    print( 'syntax please refer to: https://madanalysis.irmp.ucl.ac.be/')
+                    print( 'or to the user manual [arXiv:1206.1599]')
                     if args[0].startswith('madanalysis5_hadron'):
-                        print 
-                        print 'This card also allow to make recasting analysis'
-                        print 'For more detail, see: arXiv:1407.3278'                   
+                        print() 
+                        print( 'This card also allow to make recasting analysis')
+                        print( 'For more detail, see: arXiv:1407.3278')                   
                 elif hasattr(self, args[0]):
                     logger.info("%s information: " % args[0], '$MG:color:BLUE')
                     print(eval('self.%s' % args[0]).__doc__)
                     logger.info("List of parameter associated", '$MG:color:BLUE')
-                    print "\t".join(eval('self.%s' % args[0]).keys())
+                    print( "\t".join(eval('self.%s' % args[0]).keys()))
                 if banner:
                     logger.info('*** END HELP ***', '$MG:BOLD')  
                 return card
@@ -4967,11 +4971,11 @@ class AskforEditCard(cmd.OneLinePathComp
 
             self.PY8Card.do_help(args[start])
         elif card.startswith('madanalysis5'):
-            print 'MA5'
+            print( 'MA5')
             
             
         elif banner:
-            print "no help available" 
+            print( "no help available" )
           
         if banner:                      
             logger.info('*** END HELP ***', '$MG:BOLD')    
@@ -5301,7 +5305,7 @@ class AskforEditCard(cmd.OneLinePathComp
                     val = [values[str(i)] for i in range(len(values))]
                     try:
                         arg(self)(*val)
-                    except Exception, e:
+                    except Exception as e:
                         logger.warning(str(e))
             return
 
@@ -5441,7 +5445,7 @@ class AskforEditCard(cmd.OneLinePathComp
 
             if args[start] not in self.run_set:
                 if card in self.from_banner or 'run' in self.from_banner:
-                    raise Exception, "change not allowed for this card: event already generated!"
+                    raise Exception("change not allowed for this card: event already generated!")
                 args[start] = [l for l in self.run_set if l.lower() == args[start]][0]
 
             if args[start] in self.conflict and card == '':
@@ -5735,7 +5739,7 @@ class AskforEditCard(cmd.OneLinePathComp
         
         try:
             self.MLcard.set(name, value, user=True)
-        except Exception, error:
+        except Exception as error:
             logger.warning("Fail to change parameter. Please Retry. Reason: %s." % error)
             return
         logger.info('modify parameter %s of the MadLoopParam.dat to %s' % (name, value),'$MG:BOLD')
@@ -5745,7 +5749,7 @@ class AskforEditCard(cmd.OneLinePathComp
     def setPY8(self, name, value, default=False):
         try:
             self.PY8Card.userSet(name, value)
-        except Exception, error:
+        except Exception as error:
             logger.warning("Fail to change parameter. Please Retry. Reason: %s." % error)
             return
         logger.info('modify parameter %s of the pythia8_card.dat to %s' % (name, value), '$MG:BOLD')
@@ -5804,7 +5808,7 @@ class AskforEditCard(cmd.OneLinePathComp
                   (self.run_card['nb_proton1'] != self.run_card['nb_proton2'] or
                  self.run_card['nb_neutron1'] != self.run_card['nb_neutron2'] or
                  self.run_card['mass_ion1'] != self.run_card['mass_ion2']):
-                raise Exception, "Heavy ion profile for both beam are different but the symmetry used forbids it. \n Please generate your process with \"set group_subprocesses False\"."
+                raise Exception("Heavy ion profile for both beam are different but the symmetry used forbids it. \n Please generate your process with \"set group_subprocesses False\".")
             
             # check the status of small width status from LO
             for param in self.param_card['decay']:
@@ -5841,13 +5845,13 @@ class AskforEditCard(cmd.OneLinePathComp
                 
             if 'MLM' in proc_charac['limitations']:
                 if self.run_card['dynamical_scale_choice'] == -1:
-                    raise InvalidCmd, "Your model is identified as not fully supported within MG5aMC.\n" +\
+                    raise InvalidCmd("Your model is identified as not fully supported within MG5aMC.\n" +\
                         "As your process seems to be impacted by the issue,\n"+\
-                      "You can NOT run with CKKW dynamical scale for this model. Please choose another one." 
+                      "You can NOT run with CKKW dynamical scale for this model. Please choose another one." )
                 if self.run_card['ickkw']:
-                    raise InvalidCmd, "Your model is identified as not fully supported within MG5aMC.\n" +\
+                    raise InvalidCmd("Your model is identified as not fully supported within MG5aMC.\n" +\
                         "As your process seems to be impacted by the issue,\n" +\
-                      "You can NOT run with MLM matching/merging. Please check if merging outside MG5aMC are suitable or refrain to use merging with this model" 
+                      "You can NOT run with MLM matching/merging. Please check if merging outside MG5aMC are suitable or refrain to use merging with this model" )
                 
 
         ########################################################################
@@ -5863,17 +5867,17 @@ class AskforEditCard(cmd.OneLinePathComp
 
             if proc_charac and 'MLM' in proc_charac['limitations']:
                 if self.run_card['ickkw']:
-                    raise Exception, "Your model is identified as not fully supported within MG5aMC.\n" +\
-                      "You can NOT run with FxFx/UnLOPS matching/merging. Please check if merging outside MG5aMC are suitable or refrain to use merging with this model" 
+                    raise Exception("Your model is identified as not fully supported within MG5aMC.\n" +\
+                      "You can NOT run with FxFx/UnLOPS matching/merging. Please check if merging outside MG5aMC are suitable or refrain to use merging with this model" )
                             
             
             for pdg in set(self.run_card['pt_min_pdg'].keys()+self.run_card['pt_max_pdg'].keys()+
                            self.run_card['mxx_min_pdg'].keys()): 
             
                 if int(pdg)<0:
-                    raise Exception, "For PDG specific cuts, always use positive PDG codes: the cuts are applied to both particles and anti-particles"
+                    raise Exception("For PDG specific cuts, always use positive PDG codes: the cuts are applied to both particles and anti-particles")
                 if self.param_card.get_value('mass', int(pdg), default=0) ==0:
-                    raise Exception, "For NLO runs, you can use PDG specific cuts only for massive particles: (failed for %s)" % pdg
+                    raise Exception("For NLO runs, you can use PDG specific cuts only for massive particles: (failed for %s)" % pdg)
         
             # if NLO reweighting is ON: ensure that we keep the rwgt information
             if 'reweight' in self.allow_arg and 'run' in self.allow_arg and \
@@ -5912,10 +5916,10 @@ class AskforEditCard(cmd.OneLinePathComp
             if self.run_card['parton_shower'] == 'PYTHIA8':
                 # First check sanity of PY8
                 if not self.mother_interface.options['pythia8_path']:
-                    raise self.mother_interface.InvalidCmd, 'Pythia8 is not correctly specified  to MadGraph5_aMC@NLO'
+                    raise self.mother_interface.InvalidCmd('Pythia8 is not correctly specified  to MadGraph5_aMC@NLO')
                 executable = pjoin(self.mother_interface.options['pythia8_path'], 'bin', 'pythia8-config')
                 if not os.path.exists(executable):
-                    raise self.mother.InvalidCmd, 'Pythia8 is not correctly specified to MadGraph5_aMC@NLO'                
+                    raise self.mother.InvalidCmd('Pythia8 is not correctly specified to MadGraph5_aMC@NLO')                
                 
                 # 2. take the compilation flag of PY8 from pythia8-config
                 libs , paths = [], []
@@ -5986,7 +5990,7 @@ class AskforEditCard(cmd.OneLinePathComp
             if self.param_consistency:
                 try:
                     self.do_update('dependent', timer=20)
-                except MadGraph5Error, error:
+                except MadGraph5Error as error:
                     if 'Missing block:' in str(error):
                         self.fail_due_to_format +=1
                         if self.fail_due_to_format == 10:
@@ -6046,14 +6050,14 @@ class AskforEditCard(cmd.OneLinePathComp
             try:
                 param_card_mod.convert_to_mg5card(self.paths['param'])
                 logger.info('card updated')
-            except Exception, error:
+            except Exception as error:
                 logger.warning('failed to update to slha2 due to %s' % error)
             self.param_card = param_card_mod.ParamCard(self.paths['param'])
         elif args[0] == 'to_slha1':
             try:
                 param_card_mod.convert_to_slha1(self.paths['param'])
                 logger.info('card updated')
-            except Exception, error:
+            except Exception as error:
                 logger.warning('failed to update to slha1 due to %s' % error)
             self.param_card = param_card_mod.ParamCard(self.paths['param'])            
         elif args[0] == 'to_full':
@@ -6083,7 +6087,7 @@ class AskforEditCard(cmd.OneLinePathComp
             if name in self.modified_card:
                 self.modified_card.remove(name)
         else:
-            raise Exception, "Need to add the associate writter proxy for %s" % name
+            raise Exception("Need to add the associate writter proxy for %s" % name)
         
     def write_card_run(self):
         """ write the run_card """
@@ -6124,7 +6128,7 @@ class AskforEditCard(cmd.OneLinePathComp
                            'This might create trouble for external program (like MadSpin/shower/...)\n'+\
                            'The update can be forced without timer by typing \'update dependent\' at the time of the card edition')
             modify =False
-        except Exception,error:
+        except Exception as error:
             logger.debug(str(error))
             logger.warning('Failed to update dependent parameter. This might create trouble for external program (like MadSpin/shower/...)')
             signal.alarm(0)
@@ -6159,9 +6163,9 @@ class AskforEditCard(cmd.OneLinePathComp
                 if key not in input_in_block:
                     param = block.get(key)
                     if blockname != 'decay':
-                        text.append('\t%s\t%s # %s\n' % (' \t'.join([`i` for i in param.lhacode]), param.value, param.comment))
+                        text.append('\t%s\t%s # %s\n' % (' \t'.join([repr(i) for i in param.lhacode]), param.value, param.comment))
                     else: 
-                        text.append('DECAY \t%s\t%s # %s\n' % (' \t'.join([`i` for i in param.lhacode]), param.value, param.comment))
+                        text.append('DECAY \t%s\t%s # %s\n' % (' \t'.join([repr(i) for i in param.lhacode]), param.value, param.comment))
                     add_entry += 1
             if add_entry:
                 text.append('\n')
@@ -6402,7 +6406,7 @@ class AskforEditCard(cmd.OneLinePathComp
 
         try:
             out = self.mother_interface.do_compute_widths(line)
-        except InvalidCmd, error:
+        except InvalidCmd as error:
             logger.error("Invalid command: %s " % error)
         else:
             if hasattr(self, 'run_card'):
@@ -6433,11 +6437,11 @@ class AskforEditCard(cmd.OneLinePathComp
         """help for command decay which modifies MadSpin_card"""
         
         signal.alarm(0) # avoid timer if any
-        print '--syntax: decay PROC [--add]'
-        print ' '
-        print '  modify the madspin_card to modify the decay of the associate particle.'
-        print '  and define it to PROC.'
-        print '  if --add is present, just add a new decay for the associate particle.'
+        print( '--syntax: decay PROC [--add]')
+        print( ' ')
+        print( '  modify the madspin_card to modify the decay of the associate particle.')
+        print( '  and define it to PROC.')
+        print( '  if --add is present, just add a new decay for the associate particle.')
         
     def complete_compute_widths(self, text, line, begidx, endidx, **opts):
         prev_timer = signal.alarm(0) # avoid timer if any
@@ -6545,7 +6549,7 @@ class AskforEditCard(cmd.OneLinePathComp
             elif os.path.exists(pjoin(self.me_dir,'Cards',card)):
                 path = pjoin(self.me_dir,'Cards',card)
             else:
-                raise Exception, 'unknow path'
+                raise Exception('unknow path')
             
             # handling the various option on where to write the line            
             if args[1] == '--clean':
@@ -6605,7 +6609,7 @@ class AskforEditCard(cmd.OneLinePathComp
                     new_line = re.split(search_pattern,line)[-1].strip()
                     if new_line.startswith(('--before_line=','--after_line')):
                         return self.do_add('%s %s' % (args[0], new_line))   
-                    raise Exception, 'invalid regular expression: not found in file'
+                    raise Exception('invalid regular expression: not found in file')
                 # found the line position "posline"
                 # need to check if the a fail savety is present
                 new_line = re.split(search_pattern,line)[-1].strip()
@@ -6632,7 +6636,7 @@ class AskforEditCard(cmd.OneLinePathComp
                     if re.search(pattern, l):
                         break
                 else:
-                    raise Exception, 'invalid regular expression: not found in file'
+                    raise Exception('invalid regular expression: not found in file')
                 split.insert(posline, re.split(search_pattern,line)[-1])
                 ff = open(path,'w')
                 ff.write('\n'.join(split))
@@ -6673,11 +6677,11 @@ class AskforEditCard(cmd.OneLinePathComp
         """Help associated to the asperge command"""
         signal.alarm(0)
 
-        print '-- syntax: asperge [options]'
-        print '   Call ASperGe to diagonalize all mass matrices in the model.'
-        print '   This works only if the ASperGE module is part of the UFO model (a subdirectory).'
-        print '   If you specify some names after the command (i.e. asperge m1 m2) then ASperGe will only'
-        print '   diagonalize the associate mass matrices (here m1 and m2).'
+        print( '-- syntax: asperge [options]')
+        print( '   Call ASperGe to diagonalize all mass matrices in the model.')
+        print( '   This works only if the ASperGE module is part of the UFO model (a subdirectory).')
+        print( '   If you specify some names after the command (i.e. asperge m1 m2) then ASperGe will only')
+        print( '   diagonalize the associate mass matrices (here m1 and m2).')
 
     def complete_asperge(self, text, line, begidx, endidx, formatting=True):
         prev_timer = signal.alarm(0) # avoid timer if any
@@ -6715,7 +6719,7 @@ class AskforEditCard(cmd.OneLinePathComp
             logger.info('ASperGe has been detected but is not compiled. Running the compilation now.')
             try:
                 misc.compile(cwd=path,shell=True)
-            except MadGraph5Error, error:
+            except MadGraph5Error as error:
                 logger.error('''ASperGe failed to compile. Note that gsl is needed
      for this compilation to go trough. More information on how to install this package on
      http://www.gnu.org/software/gsl/
@@ -6822,7 +6826,7 @@ class AskforEditCard(cmd.OneLinePathComp
 
         try:
             self.mother_interface.exec_cmd('open %s' % path)
-        except InvalidCmd, error:
+        except InvalidCmd as error:
             if str(error) != 'No default path for this file':
                 raise
             if answer == 'transfer_card.dat':
@@ -6983,7 +6987,7 @@ def scanparamcardhandling(input_path=lam
                         set_run_name(obj)(next_name)
                         try:
                             original_fct(obj, *args, **opts)
-                        except ignoreerror, error:
+                        except ignoreerror as error:
                             param_card_iterator.store_entry(next_name, {'exception': error})
                         else:
                             param_card_iterator.store_entry(next_name, store_for_scan(obj)(), param_card_path=card_path)
diff -rupN MadGraph_pristine/madgraph/interface/extended_cmd.py ../contrib/MadGraph/madgraph/interface/extended_cmd.py
--- MadGraph_pristine/madgraph/interface/extended_cmd.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/extended_cmd.py	2020-10-30 20:49:24.510460964 +1100
@@ -15,6 +15,7 @@
 """  A file containing different extension of the cmd basic python library"""
 
 
+from io import FileIO
 import logging
 import math
 import os
@@ -41,7 +42,7 @@ try:
     import madgraph.various.misc as misc
     from madgraph import MG5DIR, MadGraph5Error
     MADEVENT = False
-except ImportError, error:
+except ImportError as error:
     try:
         import internal.misc as misc
     except:
@@ -65,7 +66,7 @@ def debug(debug_only=True):
         def deco_f(*args, **opt):
             try:
                 return f(*args, **opt)
-            except Exception, error:
+            except Exception as error:
                 logger.error(error)
                 logger.error(traceback.print_exc(file=sys.stdout))
                 return
@@ -391,7 +392,7 @@ class OriginalCmd(object):
         nonstrings = [i for i in range(len(list))
                         if not isinstance(list[i], str)]
         if nonstrings:
-            raise TypeError, ("list[i] not a string for i in %s" %
+            raise TypeError("list[i] not a string for i in %s" %
                               ", ".join(map(str, nonstrings)))
         size = len(list)
         if size == 1:
@@ -541,7 +542,7 @@ class BasicCmd(OriginalCmd):
     
             self.stdout.write(self.prompt+readline.get_line_buffer())
             self.stdout.flush()
-        except Exception, error:
+        except Exception as error:
             if __debug__:
                 logger.error(error)
             
@@ -596,9 +597,9 @@ class BasicCmd(OriginalCmd):
                 else:
                     try:
                         compfunc = getattr(self, 'complete_' + cmd)
-                    except AttributeError, error:
+                    except AttributeError as error:
                         compfunc = self.completedefault
-                    except Exception, error:
+                    except Exception as error:
                         misc.sprint(error)
             else:
                 compfunc = self.completenames
@@ -623,8 +624,8 @@ class BasicCmd(OriginalCmd):
                 data = compfunc(Ntext, line, Nbegidx, endidx)
                 self.completion_matches = [p[to_rm:] for p in data 
                                               if len(p)>to_rm]
-             except Exception, error:
-                 print error                
+             except Exception as error:
+                 print(error)                
             else:
                 self.completion_prefix = ''
                 self.completion_matches = compfunc(text, line, begidx, endidx)
@@ -635,7 +636,7 @@ class BasicCmd(OriginalCmd):
         
         try:
             return self.completion_matches[state]
-        except IndexError, error:
+        except IndexError as error:
             # if __debug__:
             #    logger.error('\n Completion ERROR:')
             #    logger.error( error)
@@ -754,13 +755,13 @@ class CheckCmd(object):
         
         if len(args) > 2:
             self.help_save()
-            raise self.InvalidCmd, 'too many arguments for save command.'
+            raise self.InvalidCmd('too many arguments for save command.')
         
         if len(args) == 2:
             if args[0] != 'options':
                 self.help_save()
-                raise self.InvalidCmd, '\'%s\' is not recognized as first argument.' % \
-                                                args[0]
+                raise self.InvalidCmd('\'%s\' is not recognized as first argument.' % \
+                                                args[0])
             else:
                 args.pop(0)           
 
@@ -921,7 +922,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         if intro is not None:
             self.intro = intro
         if self.intro:
-            print self.intro
+            print(self.intro)
         stop = None
         while not stop:
             if self.cmdqueue:
@@ -944,7 +945,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
             try:
                 line = self.precmd(line)
                 stop = self.onecmd(line)
-            except BaseException, error:
+            except BaseException as error:
                 self.error_handling(error, line)
                 if isinstance(error, KeyboardInterrupt):
                     stop = True
@@ -1285,7 +1286,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
             os.remove(self.debug_output)
         try:
             super(Cmd,self).onecmd('history %s' % self.debug_output.replace(' ', '\ '))
-        except Exception, error:
+        except Exception as error:
             logger.error(error)
 
         debug_file = open(self.debug_output, 'a')
@@ -1309,7 +1310,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         # Add options status to the debug file
         try:
             self.do_display('options', debug_file)
-        except Exception, error:
+        except Exception as error:
             debug_file.write('Fail to write options with error %s' % error)
         
         #add the cards:
@@ -1403,7 +1404,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         # Add options status to the debug file
         try:
             self.do_display('options', debug_file)
-        except Exception, error:
+        except Exception as error:
             debug_file.write('Fail to write options with error %s' % error)
             
         if hasattr(self, 'options') and 'crash_on_error' in self.options:
@@ -1512,7 +1513,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
            
         try:
             return self.onecmd_orig(line, **opt)
-        except BaseException, error: 
+        except BaseException as error: 
             return self.error_handling(error, line)
             
     
@@ -1865,7 +1866,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         
         if len(args) == 0:
             self.help_display()
-            raise self.InvalidCmd, 'display require at least one argument'
+            raise self.InvalidCmd('display require at least one argument')
         
         if args[0] == "options":
             outstr = "Value of current Options:\n" 
@@ -1898,7 +1899,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
                 except ImportError:
                     try:
                         var = eval(args[1])
-                    except Exception, error:
+                    except Exception as error:
                         outstr += 'EXTERNAL:\nVariable %s is not a external variable\n' % args[1]
                         break
                     else:
@@ -2085,7 +2086,7 @@ class SmartQuestion(BasicCmd):
         for key,value in opts:
             setattr(self, key, value)
         if reprint_opt:
-            print question
+            print(question)
             logger_tuto.info("Need help here? type 'help'", '$MG:BOLD')
             logger_plugin.info("Need help here? type 'help'" , '$MG:BOLD')
         return self.cmdloop()
@@ -2104,8 +2105,8 @@ class SmartQuestion(BasicCmd):
             out[' Recognized command'] = super(SmartQuestion, self).completenames(text,line, *ignored)
             
             return self.deal_multiple_categories(out)
-        except Exception, error:
-            print error
+        except Exception as error:
+            print(error)
     
     completedefault = completenames
 
@@ -2158,7 +2159,7 @@ class SmartQuestion(BasicCmd):
         if reprint_opt:
             if not prev_timer:
                 self.question = pat.sub('',self.question)
-            print self.question.encode('utf8')
+            print(self.question.encode('utf8'))
 
         if self.mother_interface:
             answer = self.mother_interface.check_answer_in_input_file(self, 'EOF', 
@@ -2244,7 +2245,7 @@ class SmartQuestion(BasicCmd):
                 
             else: 
                 raise Exception
-        except Exception,error:
+        except Exception as error:
             if self.wrong_answer < 100:
                 self.wrong_answer += 1
                 logger.warning("""%s not valid argument. Valid argument are in (%s).""" \
@@ -2261,7 +2262,7 @@ class SmartQuestion(BasicCmd):
     
 # a function helper
 def smart_input(input_text, allow_arg=[], default=None):
-    print input_text
+    print(input_text)
     obj = SmartQuestion(allow_arg=allow_arg, default=default)
     return obj.cmdloop()
 
@@ -2289,8 +2290,8 @@ class OneLinePathCompletion(SmartQuestio
             out[' Recognized command'] = BasicCmd.completenames(self, text, line, begidx, endidx)
             
             return self.deal_multiple_categories(out, formatting)
-        except Exception, error:
-            print error
+        except Exception as error:
+            print(error)
             
     def precmd(self, *args):
         """ """
@@ -2307,8 +2308,8 @@ class OneLinePathCompletion(SmartQuestio
             self.stdout.flush()
         try:
             args = Cmd.split_arg(line[0:begidx])
-        except Exception, error:
-            print error
+        except Exception as error:
+            print(error)
 
         # Directory continuation                 
         if args[-1].endswith(os.path.sep):
@@ -2336,10 +2337,10 @@ class OneLinePathCompletion(SmartQuestio
                 reprint_opt = True         
             else:
                 raise Exception
-        except Exception, error:  
-            print """not valid argument. Valid argument are file path or value in (%s).""" \
-                          % ','.join(self.allow_arg)
-            print 'please retry'
+        except Exception as error:  
+            print("""not valid argument. Valid argument are file path or value in (%s).""" \
+                          % ','.join(self.allow_arg))
+            print('please retry')
             reprint_opt = False 
 
         if line != 'EOF':
@@ -2348,7 +2349,7 @@ class OneLinePathCompletion(SmartQuestio
             
 # a function helper
 def raw_path_input(input_text, allow_arg=[], default=None):
-    print input_text
+    print(input_text)
     obj = OneLinePathCompletion(allow_arg=allow_arg, default=default )
     return obj.cmdloop()
 
@@ -2416,7 +2417,7 @@ class ControlSwitch(SmartQuestion):
         question = self.create_question()
         
         #check all default for auto-completion
-        allowed_args = [ `i`+';' for i in range(1, 1+len(self.to_control))] 
+        allowed_args = [ repr(i)+';' for i in range(1, 1+len(self.to_control))] 
         for key in self.switch:
             allowed_args += ['%s=%s;' % (key,s) for s in self.get_allowed(key)]
         # adding special mode
@@ -2552,7 +2553,7 @@ class ControlSwitch(SmartQuestion):
             base, value = line.split(' ', 1)
         elif hasattr(self, 'ans_%s' % line.lower()):
             base, value = line.lower(), None
-        elif line.isdigit() and line in [`i` for i in range(1, len(self.to_control)+1)]:
+        elif line.isdigit() and line in [repr(i) for i in range(1, len(self.to_control)+1)]:
             # go from one valid option to the next in the get_allowed for that option
             base = self.to_control[int(line)-1][0].lower()
             return self.default(base) # just recall this function with the associate name
@@ -2865,7 +2866,7 @@ class ControlSwitch(SmartQuestion):
         #re-order the options in order to have those in cycling order    
         try:
             ind =  self.get_allowed(key).index(self.switch[key])
-        except Exception, err:
+        except Exception as err:
             options = self.get_allowed(key)
         else:
             options = self.get_allowed(key)[ind:]+ self.get_allowed(key)[:ind] 
@@ -3101,7 +3102,7 @@ class ControlSwitch(SmartQuestion):
         try:
             nb_rows, nb_col = os.popen('stty size', 'r').read().split()
             nb_rows, nb_col = int(nb_rows), int(nb_col)
-        except Exception,error:
+        except Exception as error:
             nb_rows, nb_col = 20, 80
         
         #compute information on the length of element to display
@@ -3210,13 +3211,13 @@ class ControlSwitch(SmartQuestion):
 #===============================================================================
 # 
 #===============================================================================
-class CmdFile(file):
+class CmdFile(FileIO):
     """ a class for command input file -in order to debug cmd \n problem"""
     
     def __init__(self, name, opt='rU'):
         
-        file.__init__(self, name, opt)
-        self.text = file.read(self)
+        FileIO.__init__(self, name, opt)
+        self.text = FileIO.read(self)
         self.close()
         self.lines = self.text.split('\n')
     
diff -rupN MadGraph_pristine/madgraph/interface/launch_ext_program.py ../contrib/MadGraph/madgraph/interface/launch_ext_program.py
--- MadGraph_pristine/madgraph/interface/launch_ext_program.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/launch_ext_program.py	2020-10-30 20:49:24.510460964 +1100
@@ -118,7 +118,7 @@ class ExtLauncher(object):
             "particles."
                                          
         if not self.force:
-            if msg:  print msg
+            if msg:  print(msg)
             question = 'Do you want to edit file: %(card)s?' % {'card':filename}
             choices = ['y', 'n']
             path_info = 'path of the new %(card)s' % {'card':os.path.basename(filename)}
@@ -153,7 +153,7 @@ class MadLoopLauncher(ExtLauncher):
 
         if filename == 'PS.input':
             if not self.force:
-                if msg!='':  print msg
+                if msg!='':  print(msg)
                 question = 'Do you want to specify the Phase-Space point: %(card)s?' % {'card':filename}
                 choices = ['y', 'n']
                 path_info = 'path of the PS.input file'
@@ -204,8 +204,8 @@ class MadLoopLauncher(ExtLauncher):
                                 curr_path, sub_path, infos,
                                 req_files = ['HelFilter.dat','LoopFilter.dat'])
                 if nps == None:
-                    raise MadGraph5Error,"MadLoop could not initialize the process %s"\
-                      %shell_name
+                    raise MadGraph5Error("MadLoop could not initialize the process %s"\
+                      %shell_name)
                 logger.debug(("MadLoop initialization performed for %s"+\
                         " using %d PS points (%s)")\
                         %(shell_name,abs(nps),\
@@ -222,13 +222,13 @@ class MadLoopLauncher(ExtLauncher):
                 # check
                 t1, t2, ram_usage = me_cmd.MadLoopInitializer.make_and_run(curr_path)
                 if t1==None or t2==None:
-                    raise MadGraph5Error,"Error while running process %s."\
-                                                                     %shell_name
+                    raise MadGraph5Error("Error while running process %s."\
+                                                                     %shell_name)
                 try:
                     rFile=open(os.path.join(curr_path,'result.dat'), 'r')
                 except IOError:
-                    raise MadGraph5Error,"Could not find result file %s."%\
-                                       str(os.path.join(curr_path,'result.dat'))
+                    raise MadGraph5Error("Could not find result file %s."%\
+                                       str(os.path.join(curr_path,'result.dat')))
                 # The result are returned as a dictionary.
                 result = evaluator.parse_check_output(rFile,format='dict')
                 for line in self.format_res_string(result, shell_name):
@@ -543,7 +543,7 @@ class aMCatNLOLauncher(ExtLauncher):
                 continue
             try:
                 usecmd.exec_cmd(line)
-            except Exception, error:
+            except Exception as error:
                 misc.sprint('Command %s fails with msg: %s'%(str(line), \
                                                                     str(error)))
                 pass
@@ -726,7 +726,7 @@ class Pythia8Launcher(ExtLauncher):
             date_file_list.append((lastmod_date, os.path.split(file)[-1]))
 
         if not date_file_list:
-            raise MadGraph5Error, 'No Pythia output found'
+            raise MadGraph5Error('No Pythia output found')
         # Sort files according to date with newest first
         date_file_list.sort()
         date_file_list.reverse()
@@ -749,7 +749,7 @@ class Pythia8Launcher(ExtLauncher):
                     break
         
         if self.name == '':
-            raise MadGraph5Error, 'too many runs in this directory'
+            raise MadGraph5Error('too many runs in this directory')
 
         # Find all exported models
         models = misc.glob("Processes_*", pjoin(self.running_dir,os.path.pardir))
@@ -774,16 +774,16 @@ class Pythia8Launcher(ExtLauncher):
         """launch the main program"""
 
         # Make pythia8
-        print "Running make for pythia8 directory"
+        print("Running make for pythia8 directory")
         if self.model_dir:
-            print "Running make in %s" % self.model_dir
+            print("Running make in %s" % self.model_dir)
             misc.compile(cwd=self.model_dir, mode='cpp')
         # Finally run make for executable
         makefile = self.executable.replace("main_","Makefile_")
-        print "Running make with %s" % makefile
+        print("Running make with %s" % makefile)
         misc.compile(arg=['-f', makefile], cwd=self.running_dir, mode='cpp')
         
-        print "Running " + self.executable
+        print("Running " + self.executable)
         
         output = open(os.path.join(self.running_dir, self.name), 'w')
         if not self.executable.startswith('./'):
@@ -795,8 +795,8 @@ class Pythia8Launcher(ExtLauncher):
         path = os.path.join(self.running_dir, self.name) 
         pydoc.pager(open(path).read())
 
-        print "Output of the run is found at " + \
-              os.path.realpath(os.path.join(self.running_dir, self.name))
+        print("Output of the run is found at " + \
+              os.path.realpath(os.path.join(self.running_dir, self.name)))
 
 # old compatibility shortcut
 open_file = misc.open_file
diff -rupN MadGraph_pristine/madgraph/interface/loop_interface.py ../contrib/MadGraph/madgraph/interface/loop_interface.py
--- MadGraph_pristine/madgraph/interface/loop_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/loop_interface.py	2020-10-30 20:49:24.514460951 +1100
@@ -95,7 +95,7 @@ class CheckLoop(mg_interface.CheckValidF
         mg_interface.MadGraphCmd.check_output(self,args, default=default)
 
         if self._export_format not in self.supported_ML_format:
-            raise self.InvalidCmd, "not supported format %s" % self._export_format
+            raise self.InvalidCmd("not supported format %s" % self._export_format)
 
         
     def check_launch(self, args, options):
@@ -291,7 +291,7 @@ class CommonLoopInterface(mg_interface.M
 
         if coupling_type!= ['QCD'] and loop_type not in ['virtual','noborn']:
             c = ' '.join(coupling_type)
-            raise self.InvalidCmd, 'MG5aMC can only handle QCD at NLO accuracy.\n We can however compute loop with [virt=%s].\n We can also compute cross-section for loop-induced processes with [noborn=%s]' % (c,c)
+            raise self.InvalidCmd('MG5aMC can only handle QCD at NLO accuracy.\n We can however compute loop with [virt=%s].\n We can also compute cross-section for loop-induced processes with [noborn=%s]' % (c,c))
         
 
         if not isinstance(self._curr_model,loop_base_objects.LoopModel) or \
@@ -824,7 +824,7 @@ own and set the path to its library in t
                 if arg.startswith('--loop_filter='):
                     loop_filter = arg[14:]
                 if not isinstance(self, extended_cmd.CmdShell):
-                    raise self.InvalidCmd, "loop_filter is not allowed in web mode"
+                    raise self.InvalidCmd("loop_filter is not allowed in web mode")
             args = [a for a in args if not a.startswith('--loop_filter=')]
 
             # Rejoin line
diff -rupN MadGraph_pristine/madgraph/interface/madevent_interface.py ../contrib/MadGraph/madgraph/interface/madevent_interface.py
--- MadGraph_pristine/madgraph/interface/madevent_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/madevent_interface.py	2020-10-30 20:49:24.514460951 +1100
@@ -31,7 +31,12 @@ import subprocess
 import sys
 import time
 import tarfile
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import shutil
 import copy
 
@@ -54,7 +59,7 @@ logger_stderr = logging.getLogger('madev
  
 try:
     import madgraph
-except ImportError,error: 
+except ImportError as error: 
     # import from madevent directory
     MADEVENT = True
     import internal.extended_cmd as cmd
@@ -1732,8 +1737,8 @@ class CompleteForCmd(CheckValidForCmd):
         return self.deal_multiple_categories(possibilites, formatting)
     
         
-       except Exception, error:
-           print error
+       except Exception as error:
+           print(error)
 
 
     def complete_history(self, text, line, begidx, endidx):
@@ -2299,13 +2304,13 @@ class MadEventCmd(CompleteForCmd, CmdExt
                         out[name].append(tag)
                     else:
                         out[name] = [tag]
-                print 'the runs available are:'
+                print('the runs available are:')
                 for run_name, tags in out.items():
-                    print '  run: %s' % run_name
-                    print '       tags: ', 
-                    print ', '.join(tags)
+                    print('  run: %s' % run_name)
+                    print('       tags: ',) 
+                    print(', '.join(tags))
             else:
-                print 'No run detected.'
+                print('No run detected.')
                 
         elif  args[0] == 'options':
             outstr = "                              Run Options    \n"
@@ -2591,7 +2596,7 @@ Beware that MG5aMC now changes your runt
         
         if self.run_card['boost_event'].startswith('lambda'):
             if not isinstance(self, cmd.CmdShell):
-                raise Exception, "boost not allowed online"
+                raise Exception("boost not allowed online")
             filter = eval(self.run_card['boost_event'])
         else:
             raise Exception
@@ -2606,7 +2611,7 @@ Beware that MG5aMC now changes your runt
                 event_path = p
                 break
         else:
-            raise Exception, "fail to find event file for the boost"
+            raise Exception("fail to find event file for the boost")
             
             
         lhe = lhe_parser.EventFile(event_path)
@@ -3359,8 +3364,8 @@ Beware that this can be dangerous for lo
         if P_zero_result:
             if len(P_zero_result) == len(subproc):
                 Pdir = pjoin(self.me_dir, 'SubProcesses',subproc[0].strip())
-                raise ZeroResult, '%s' % \
-                    open(pjoin(Pdir,'ajob.no_ps.log')).read()
+                raise ZeroResult( '%s' % \
+                    open(pjoin(Pdir,'ajob.no_ps.log')).read())
             else:
                 logger.warning(''' %s SubProcesses doesn\'t have available phase-space.
             Please check mass spectrum.''' % ','.join(P_zero_result))
@@ -4349,9 +4354,9 @@ You can follow PY8 run with the followin
                 else:
                     n_events = PY8_Card['Main:numberOfEvents']
                     if n_events > n_available_events:
-                        raise self.InvalidCmd, 'You specified more events (%d) in the PY8 parameter'%n_events+\
+                        raise self.InvalidCmd( 'You specified more events (%d) in the PY8 parameter'%n_events+\
                             "'Main:numberOfEvents' than the total number of events available (%d)"%n_available_events+\
-                            ' in the event file:\n %s'%pjoin(self.me_dir,'Events',self.run_name,PY8_Card.subruns[0]['Beams:LHEF'])
+                            ' in the event file:\n %s'%pjoin(self.me_dir,'Events',self.run_name,PY8_Card.subruns[0]['Beams:LHEF']))
 
                 # Implement a security to insure a minimum numbe of events per job
                 if self.options['run_mode']==2:
@@ -4377,9 +4382,9 @@ You can follow PY8 run with the followin
                                       cwd=pjoin(self.me_dir,'Events',self.run_name))
                     stdout.close()
                 if ret_code != 0:
-                    raise self.InvalidCmd, 'Pythia8 shower interrupted with return'+\
+                    raise self.InvalidCmd( 'Pythia8 shower interrupted with return'+\
                         ' code %d.\n'%ret_code+\
-                        'You can find more information in this log file:\n%s'%pythia_log
+                        'You can find more information in this log file:\n%s'%pythia_log)
             else:
                 if self.run_card['event_norm']=='sum':
                     logger.error("")
@@ -4648,7 +4653,7 @@ tar -czf split_$1.tar.gz split_$1
                                 break
                         tail.close()
                         if n_tail>1:
-                            raise MadGraph5Error,'HEPMC files should only have one trailing command.'
+                            raise MadGraph5Error('HEPMC files should only have one trailing command.')
                         ###################################################################### 
                         # This is the most efficient way of putting together HEPMC's, *BUT*  #
                         #    WARNING: NEED TO RENDER THE CODE BELOW SAFE TOWARDS INJECTION   #
@@ -4820,14 +4825,14 @@ tar -czf split_$1.tar.gz split_$1
                     if Ntry is None:
                         Ntry = int(info.group('tried'))
                     if Nacc==0:
-                        raise self.InvalidCmd, 'Pythia8 shower failed since it'+\
-                          ' did not accept any event from the MG5aMC event file.'
+                        raise self.InvalidCmd( 'Pythia8 shower failed since it'+\
+                          ' did not accept any event from the MG5aMC event file.')
                     return sigma_m, Nacc, Ntry
                 except ValueError:
                     return None,None,None
 
-        raise self.InvalidCmd, "Could not find cross-section and event number information "+\
-                         "in Pythia8 log\n  '%s'."%log_file_path
+        raise self.InvalidCmd( "Could not find cross-section and event number information "+\
+                         "in Pythia8 log\n  '%s'."%log_file_path)
     
     def extract_cross_sections_from_DJR(self,djr_output):
         """Extract cross-sections from a djr XML output."""
@@ -4995,7 +5000,7 @@ tar -czf split_$1.tar.gz split_$1
             # Calculate syscalc info based on syst.dat
             try:
                 self.run_syscalc('Pythia')
-            except SysCalcError, error:
+            except SysCalcError as error:
                 logger.error(str(error))
             else:
                 if os.path.exists(pjoin(self.me_dir,'Events', 'syst.dat')):
@@ -5045,7 +5050,7 @@ tar -czf split_$1.tar.gz split_$1
                         args.append('-f')
                     try:
                         self.exec_cmd('remove %s %s' % (run, ' '.join(args[1:]) ) )
-                    except self.InvalidCmd, error:
+                    except self.InvalidCmd as error:
                         logger.info(error)
                         pass # run already clear
                 return
@@ -5073,7 +5078,7 @@ tar -czf split_$1.tar.gz split_$1
             if 'parton' in mode or 'all' in mode:
                 try:
                     if self.results[run][0]['tag'] != tag:
-                        raise Exception, 'dummy'
+                        raise Exception( 'dummy')
                 except Exception:
                     pass
                 else:
@@ -5125,7 +5130,7 @@ tar -czf split_$1.tar.gz split_$1
         if 'all' in mode or 'channel' in mode:
             try:
                 if tag and self.results[run][0]['tag'] != tag:
-                    raise Exception, 'dummy'
+                    raise Exception('dummy')
             except Exception:
                 pass
             else:
@@ -5158,10 +5163,10 @@ tar -czf split_$1.tar.gz split_$1
                     return
             elif any(['banner' not in os.path.basename(p) for p in to_delete]):
                 if to_delete:
-                    raise MadGraph5Error, '''Some output still exists for this run. 
+                    raise MadGraph5Error('''Some output still exists for this run. 
                 Please remove those output first. Do for example: 
                 remove %s all banner
-                ''' % run
+                ''' % run)
             else:
                 shutil.rmtree(pjoin(self.me_dir, 'Events',run))
                 if run in self.results:
@@ -5283,7 +5288,7 @@ tar -czf split_$1.tar.gz split_$1
                 shutil.move(filename, pjoin(self.me_dir, 'Events','syst.dat'))
                 try:
                     self.run_syscalc('Pythia')
-                except SysCalcError, error:
+                except SysCalcError as error:
                     logger.warning(str(error))
                     return
                 misc.gzip(pjoin(self.me_dir, 'Events','syst.dat'), "%s.gz" % filename)
@@ -5365,7 +5370,7 @@ tar -czf split_$1.tar.gz split_$1
             status = misc.call([exe] + argument, cwd=cwd, stdout=stdout, **opt)
             logger.info('%s run in %f s' % (exe, time.time() -start))
             if status:
-                raise MadGraph5Error, '%s didn\'t stop properly. Stop all computation' % exe
+                raise MadGraph5Error('%s didn\'t stop properly. Stop all computation' % exe)
 
 
         elif mode in [1,2]:
@@ -5532,7 +5537,7 @@ tar -czf split_$1.tar.gz split_$1
                 update_first = None
             try:   
                 self.cluster.wait(self.me_dir, update_status, update_first=update_first)            
-            except Exception, error:
+            except Exception as error:
                 logger.info(error)
                 if not self.force:
                     ans = self.ask('Cluster Error detected. Do you want to clean the queue? ("c"=continue the run anyway)',
@@ -5544,7 +5549,7 @@ tar -czf split_$1.tar.gz split_$1
                 elif ans == 'c':
                     return self.monitor(run_type=run_type, mode=mode, html=html)
                 raise
-            except KeyboardInterrupt, error:
+            except KeyboardInterrupt as error:
                 self.cluster.remove()
                 raise                            
         
@@ -5867,8 +5872,8 @@ tar -czf split_$1.tar.gz split_$1
         
         self.random += 3
         if self.random > 30081*30081: # can't use too big random number
-            raise MadGraph5Error,\
-                  'Random seed too large ' + str(self.random) + ' > 30081*30081'
+            raise MadGraph5Error(\
+                  'Random seed too large ' + str(self.random) + ' > 30081*30081')
         if self.run_card['python_seed'] == -2: 
             import random
             random.seed(self.random)
@@ -6000,7 +6005,7 @@ tar -czf split_$1.tar.gz split_$1
             lhaid += [l for l in self.run_card['sys_pdf'].split() if not l.isdigit() or int(l) > 500]
         try:
             pdfsets_dir = self.get_lhapdf_pdfsetsdir()
-        except Exception, error:
+        except Exception as error:
             logger.debug(str(error))
             logger.warning('Systematic computation requires lhapdf to run. Bypass SysCalc')
             return
@@ -6069,21 +6074,21 @@ tar -czf split_$1.tar.gz split_$1
                         xqcut = abs(self.run_card['xqcut'])
                         for value in self.run_card['sys_matchscale'].split():
                             if float(value) < qcut:
-                                raise SysCalcError, 'qcut value for sys_matchscale lower than qcut in pythia_card. Bypass syscalc'
+                                raise SysCalcError('qcut value for sys_matchscale lower than qcut in pythia_card. Bypass syscalc')
                             if float(value) < xqcut:
-                                raise SysCalcError, 'qcut value for sys_matchscale lower than xqcut in run_card. Bypass syscalc'
+                                raise SysCalcError('qcut value for sys_matchscale lower than xqcut in run_card. Bypass syscalc')
                         
                         
                 event_path = pjoin(event_dir,'syst.dat')
                 output = pjoin(event_dir, 'syscalc.dat')
             else:
-                raise self.InvalidCmd, 'Invalid mode %s' % mode
+                raise self.InvalidCmd('Invalid mode %s' % mode)
             
         if not os.path.exists(event_path):
             if os.path.exists(event_path+'.gz'):
                 misc.gunzip(event_path+'.gz')
             else:
-                raise SysCalcError, 'Events file %s does not exits' % event_path
+                raise SysCalcError('Events file %s does not exits' % event_path)
         
         self.update_status('Calculating systematics for %s level' % mode, level = mode.lower())
         try:
@@ -6094,7 +6099,7 @@ tar -czf split_$1.tar.gz split_$1
                             cwd=event_dir)
             # Wait 5 s to make sure file is finished writing
             time.sleep(5)            
-        except OSError, error:
+        except OSError as error:
             logger.error('fail to run syscalc: %s. Please check that SysCalc is correctly installed.' % error)
         else:
             if not os.path.exists(output):
@@ -6366,9 +6371,9 @@ class GridPackCmd(MadEventCmd):
         if me_dir and nb_event and seed:
             self.launch(nb_event, seed)
         else:
-            raise MadGraph5Error,\
+            raise MadGraph5Error(\
                   'Gridpack run failed: ' + str(me_dir) + str(nb_event) + \
-                  str(seed)
+                  str(seed))
 
 
     def update_status(self, *args, **opts):
@@ -6400,7 +6405,7 @@ class GridPackCmd(MadEventCmd):
         """write the grid_card.dat file at appropriate location"""
         
         # first try to write grid_card within the gridpack.
-        print "WRITE GRIDCARD", self.me_dir
+        print("WRITE GRIDCARD", self.me_dir)
         if self.readonly:
             if not os.path.exists('Cards'):
                 os.mkdir('Cards')
@@ -6553,9 +6558,9 @@ class GridPackCmd(MadEventCmd):
                              (self.nb_refine, subdir, nb_proc+1, len(subproc)))
                     if os.path.exists(pjoin(self.me_dir,'error')):
                         self.monitor(html=True)
-                        raise MadEventError, \
+                        raise MadEventError( \
                             'Error detected in dir %s: %s' % \
-                            (Pdir, open(pjoin(self.me_dir,'error')).read())
+                            (Pdir, open(pjoin(self.me_dir,'error')).read()))
         self.monitor(run_type='All job submitted for refine number %s' % 
                                                                  self.nb_refine)
         
@@ -6797,8 +6802,8 @@ class MadLoopInitializer(object):
             infos={}
         
         if SubProc_dir is None and run_dir is None:
-            raise MadGraph5Error, 'At least one of [SubProc_dir,run_dir] must'+\
-                                           ' be provided in run_initialization.'
+            raise MadGraph5Error('At least one of [SubProc_dir,run_dir] must'+\
+                                           ' be provided in run_initialization.')
         
         # If the user does not specify where is check_sa.f, then it is assumed
         # to be one levels above run_dir
@@ -6811,8 +6816,8 @@ class MadLoopInitializer(object):
             if directories:
                 run_dir = directories[0]
             else:
-                raise MadGraph5Error, 'Could not find a valid running directory'+\
-                                                      ' in %s.'%str(SubProc_dir)
+                raise MadGraph5Error('Could not find a valid running directory'+\
+                                                      ' in %s.'%str(SubProc_dir))
 
         # Use the presence of the file born_matrix.f to decide if it is a 
         # loop-induced process or not. It's not crucial, but just that because
@@ -6830,8 +6835,8 @@ class MadLoopInitializer(object):
 
         MLCardPath = pjoin(SubProc_dir,'MadLoopParams.dat')
         if not os.path.isfile(MLCardPath):
-            raise MadGraph5Error, 'Could not find MadLoopParams.dat at %s.'\
-                                                                     %MLCardPath
+            raise MadGraph5Error('Could not find MadLoopParams.dat at %s.'\
+                                                                     %MLCardPath)
         else:
             MLCard      = banner_mod.MadLoopParam(MLCardPath) 
             MLCard_orig = banner_mod.MadLoopParam(MLCard)
@@ -6923,8 +6928,8 @@ class MadLoopInitializer(object):
 
         MLCardPath = pjoin(proc_dir,'SubProcesses','MadLoopParams.dat')
         if not os.path.isfile(MLCardPath):
-            raise MadGraph5Error, 'Could not find MadLoopParams.dat at %s.'\
-                                                                     %MLCardPath        
+            raise MadGraph5Error('Could not find MadLoopParams.dat at %s.'\
+                                                                     %MLCardPath)        
         MLCard      = banner_mod.MadLoopParam(MLCardPath) 
 
         req_files = ['HelFilter.dat','LoopFilter.dat']
@@ -7035,11 +7040,11 @@ class MadLoopInitializer(object):
         for v_folder in VirtualFolders:
             init = init_info[v_folder]
             if init['nPS'] is None:
-                raise MadGraph5Error, 'Failed the initialization of'+\
+                raise MadGraph5Error('Failed the initialization of'+\
                   " loop-induced matrix element '%s'%s."%\
                   (os.path.basename(v_folder),' (using default n_PS points)' if\
                     n_PS is None else ' (trying with a maximum of %d PS points)'\
-                                                               %(max_mult*n_PS))
+                                                               %(max_mult*n_PS)))
             if init['nPS']==0:
                 logger.debug("Nothing to be done in '%s', all filters already "%\
                              os.path.basename(v_folder)+\
@@ -7090,7 +7095,7 @@ if '__main__' == __name__:
         try:
             (options, args) = parser.parse_args(sys.argv[1:len(sys.argv)-i])
             done = True
-        except MyOptParser.InvalidOption, error:
+        except MyOptParser.InvalidOption as error:
             pass
         else:
             args += sys.argv[len(sys.argv)-i:]
@@ -7098,8 +7103,8 @@ if '__main__' == __name__:
         # raise correct error:                                                                                                                                                                                  
         try:
             (options, args) = parser.parse_args()
-        except MyOptParser.InvalidOption, error:
-            print error
+        except MyOptParser.InvalidOption as error:
+            print(error)
             sys.exit(2)
 
     if len(args) == 0:
@@ -7137,17 +7142,17 @@ if '__main__' == __name__:
                 cmd_line = MadEventCmdShell(os.path.dirname(root_path),force_run=True)
             if not hasattr(cmd_line, 'do_%s' % args[0]):
                 if parser_error:
-                    print parser_error
-                    print 'and %s  can not be interpreted as a valid command.' % args[0]
+                    print(parser_error)
+                    print('and %s  can not be interpreted as a valid command.' % args[0])
                 else:
-                    print 'ERROR: %s  not a valid command. Please retry' % args[0]
+                    print('ERROR: %s  not a valid command. Please retry' % args[0])
             else:
                 cmd_line.use_rawinput = False
                 cmd_line.run_cmd(' '.join(args))
                 cmd_line.run_cmd('quit')
 
     except KeyboardInterrupt:
-        print 'quit on KeyboardInterrupt'
+        print('quit on KeyboardInterrupt')
         pass
 
 
diff -rupN MadGraph_pristine/madgraph/interface/madgraph_interface.py ../contrib/MadGraph/madgraph/interface/madgraph_interface.py
--- MadGraph_pristine/madgraph/interface/madgraph_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/madgraph_interface.py	2020-10-30 20:50:36.586234836 +1100
@@ -24,6 +24,7 @@ import glob
 import logging
 import optparse
 import os
+import stat
 import pydoc
 import random
 import re
@@ -32,7 +33,12 @@ import subprocess
 import copy
 import sys
 import shutil
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import traceback
 import time
 import inspect
@@ -185,7 +191,7 @@ class CmdExtended(cmd.Cmd):
         info = misc.get_pkg_info()
         info_line = ""
 
-        if info.has_key('version') and  info.has_key('date'):
+        if 'version' in info and 'date' in info:
             len_version = len(info['version'])
             len_date = len(info['date'])
             if len_version + len_date < 30:
@@ -844,10 +850,10 @@ class CheckValidForCmd(cmd.CheckCmd):
 
         if len(args) < 1:
             self.help_display()
-            raise self.InvalidCmd, 'display requires an argument specifying what to display'
+            raise self.InvalidCmd('display requires an argument specifying what to display')
         if args[0] not in self._display_opts + ['model_list']:
             self.help_display()
-            raise self.InvalidCmd, 'Invalid arguments for display command: %s' % args[0]
+            raise self.InvalidCmd('Invalid arguments for display command: %s' % args[0])
 
         if not self._curr_model:
             raise self.InvalidCmd("No model currently active, please import a model!")
@@ -981,7 +987,7 @@ class CheckValidForCmd(cmd.CheckCmd):
                 parsed = arg.split('=')
                 key, value = parsed[0],'='.join(parsed[1:])
                 if key not in user_options:
-                    raise self.InvalidCmd, "unknown option %s" % key
+                    raise self.InvalidCmd("unknown option %s" % key)
                 user_options[key] = value
                 args.remove(arg)
 
@@ -1221,8 +1227,8 @@ This will take effect only in a NEW term
                     args.append(self._done_export[1])
                     args.append(self._done_export[0])
                 else:
-                    raise self.InvalidCmd, \
-                          '%s not valid directory for launch' % self._done_export[0]
+                    raise self.InvalidCmd( \
+                          '%s not valid directory for launch' % self._done_export[0])
                 return
             else:
                 logger.warning('output command missing, run it automatically (with default argument)')
@@ -1242,7 +1248,7 @@ This will take effect only in a NEW term
         elif  MG4DIR and os.path.isdir(pjoin(MG4DIR,args[0])):
             path = pjoin(MG4DIR,args[0])
         else:
-            raise self.InvalidCmd, '%s is not a valid directory' % args[0]
+            raise self.InvalidCmd('%s is not a valid directory' % args[0])
 
         mode = self.find_output_type(path)
 
@@ -1303,7 +1309,7 @@ This will take effect only in a NEW term
             os.path.isfile(pjoin(include_path, 'Pythia8', 'Pythia.h')):
             return 'pythia8'
         elif not os.path.isdir(os.path.join(path, 'SubProcesses')):
-            raise self.InvalidCmd, '%s : Not a valid directory' % path
+            raise self.InvalidCmd('%s : Not a valid directory' % path)
 
         if os.path.isdir(src_path):
             return 'standalone_cpp'
@@ -1316,7 +1322,7 @@ This will take effect only in a NEW term
         elif os.path.isdir(card_path):
             return 'standalone'
 
-        raise self.InvalidCmd, '%s : Not a valid directory' % path
+        raise self.InvalidCmd('%s : Not a valid directory' % path)
 
     def check_load(self, args):
         """ check the validity of the line"""
@@ -1373,7 +1379,7 @@ This will take effect only in a NEW term
                 elif arg.startswith('--'):
                     raise self.InvalidCmd('unknow command for \'save options\'')
                 elif arg == 'global':
-                    if os.environ.has_key('HOME'):
+                    if 'HOME' in os.environ:
                         args.remove('global')
                         args.insert(1,pjoin(os.environ['HOME'],'.mg5','mg5_configuration.txt'))
                         has_path = True
@@ -1579,7 +1585,7 @@ This will take effect only in a NEW term
             elif path != 'auto':
                 if path in ['HELAS', 'tests', 'MadSpin', 'madgraph', 'mg5decay', 'vendor']:
                     if os.getcwd() == MG5DIR:
-                        raise self.InvalidCmd, "This name correspond to a buildin MG5 directory. Please choose another name"
+                        raise self.InvalidCmd("This name correspond to a buildin MG5 directory. Please choose another name")
                 self._export_dir = path
             elif path == 'auto':
                 if self.options['pythia8_path']:
@@ -1709,7 +1715,7 @@ This will take effect only in a NEW term
             elif self.stdin != sys.stdin:
                 #Check for position defined by the input files
                 input_path = os.path.realpath(self.stdin.name).split(os.path.sep)
-                print "Not standard stdin, use input path"
+                print("Not standard stdin, use input path")
                 if input_path[-2] == 'Cards':
                     self._export_dir = os.path.sep.join(input_path[:-2])
                     if 'TemplateVersion.txt' in self._export_dir:
@@ -1815,7 +1821,7 @@ class CheckValidForCmdWeb(CheckValidForC
         No Path authorize for the Web"""
 
         if not args:
-            raise self.WebRestriction, 'import requires at least one option'
+            raise self.WebRestriction('import requires at least one option')
 
         if args[0] not in self._import_formats:
             args[:] = ['command', './proc_card_mg5.dat']
@@ -1866,7 +1872,7 @@ class CheckValidForCmdWeb(CheckValidForC
         self._export_dir = os.path.realpath(os.getcwd())
         # Check that we output madevent
         if 'madevent' != self._export_format:
-                raise self.WebRestriction, 'only available output format is madevent (at current stage)'
+                raise self.WebRestriction('only available output format is madevent (at current stage)')
 
 #===============================================================================
 # CompleteForCmd
@@ -2043,7 +2049,7 @@ class CompleteForCmd(cmd.CompleteCmd):
         try:
             return self.model_completion(text, ' '.join(args[1:]),line, formatting)
         except Exception as error:
-            print error
+            print(error)
 
         #if len(args) > 1 and args[-1] != '>':
         #    couplings = ['>']
@@ -2398,8 +2404,8 @@ class CompleteForCmd(cmd.CompleteCmd):
             if len(args) > 1 and args[1] == 'aloha':
                 try:
                     return self.aloha_complete_output(text, line, begidx, endidx)
-                except Exception, error:
-                    print error
+                except Exception as error:
+                    print(error)
             # Directory continuation
             if args[-1].endswith(os.path.sep):
                 return [name for name in self.path_completion(text,
@@ -2567,7 +2573,7 @@ class CompleteForCmd(cmd.CompleteCmd):
                 try:
                     cur_path = pjoin(*[a for a in args \
                                                    if a.endswith(os.path.sep)])
-                except Exception, error:
+                except Exception as error:
                     pass
                 else:
                     all_dir = self.path_completion(text, cur_path, only_dirs = True)
@@ -3117,8 +3123,8 @@ This implies that with decay chains:
                 if amp not in self._curr_amps:
                     self._curr_amps.append(amp)
                 elif warning_duplicate:
-                    raise self.InvalidCmd, "Duplicate process %s found. Please check your processes." % \
-                                                amp.nice_string_processes()
+                    raise self.InvalidCmd("Duplicate process %s found. Please check your processes." % \
+                                                amp.nice_string_processes())
 
             # Reset _done_export, since we have new process
             self._done_export = False
@@ -3170,7 +3176,7 @@ This implies that with decay chains:
                 try:
                     self.exec_cmd('import model %s' % new_model_name, errorhandling=False, 
                               printcmd=False, precmd=True, postcmd=True)
-                except Exception, error:
+                except Exception as error:
                     logger.debug('fail to load model %s with error:\n %s' % (output_dir, error))
                     logger.warning('Fail to load the model. Restore previous model')
                     self.exec_cmd('import model %s' % oldmodel, errorhandling=False, 
@@ -3262,21 +3268,21 @@ This implies that with decay chains:
                 else:
                     nb_unpropagating += 1
 
-            print "Current model contains %i particles:" % \
-                    len(propagating_particle)
+            print("Current model contains %i particles:" % \
+                    len(propagating_particle))
             part_antipart = [part for part in propagating_particle \
                              if not part['self_antipart']]
             part_self = [part for part in propagating_particle \
                              if part['self_antipart']]
             for part in part_antipart:
-                print part['name'] + '/' + part['antiname'],
-            print ''
+                print(part['name'] + '/' + part['antiname'],)
+            print('')
             for part in part_self:
-                print part['name'],
-            print ''
+                print(part['name'],)
+            print('')
             if nb_unpropagating:
-                print 'In addition of %s un-physical particle mediating new interactions.' \
-                                     % nb_unpropagating
+                print('In addition of %s un-physical particle mediating new interactions.' \
+                                     % nb_unpropagating)
 
         elif args[0] == 'particles':
             for arg in args[1:]:
@@ -3285,10 +3291,10 @@ This implies that with decay chains:
                 else:
                     particle = self._curr_model['particles'].find_name(arg)
                 if not particle:
-                    raise self.InvalidCmd, 'no particle %s in current model' % arg
+                    raise self.InvalidCmd('no particle %s in current model' % arg)
 
-                print "Particle %s has the following properties:" % particle.get_name()
-                print str(particle)
+                print("Particle %s has the following properties:" % particle.get_name())
+                print(str(particle))
 
         elif args[0] == 'interactions' and len(args) == 1:
             text = "Current model contains %i interactions\n" % \
@@ -3309,12 +3315,12 @@ This implies that with decay chains:
         elif args[0] == 'interactions' and len(args)==2 and args[1].isdigit():
             for arg in args[1:]:
                 if int(arg) > len(self._curr_model['interactions']):
-                    raise self.InvalidCmd, 'no interaction %s in current model' % arg
+                    raise self.InvalidCmd('no interaction %s in current model' % arg)
                 if int(arg) == 0:
-                    print 'Special interactions which identify two particles'
+                    print('Special interactions which identify two particles')
                 else:
-                    print "Interactions %s has the following property:" % arg
-                    print self._curr_model['interactions'][int(arg)-1]
+                    print("Interactions %s has the following property:" % arg)
+                    print( self._curr_model['interactions'][int(arg)-1])
 
         elif args[0] == 'interactions':
             request_part = args[1:]
@@ -3346,7 +3352,7 @@ This implies that with decay chains:
                 text += str(self._curr_model['interactions'][i])
 
                 text += '\n'
-                print name
+                print(name)
             if text =='':
                 text += 'No matching for any interactions'
             pydoc.pager(text)
@@ -3385,16 +3391,16 @@ This implies that with decay chains:
 
         elif args[0] == 'processes':
             for amp in self._curr_amps:
-                print amp.nice_string_processes()
+                print( amp.nice_string_processes())
 
         elif args[0] == 'diagrams_text':
             text = "\n".join([amp.nice_string() for amp in self._curr_amps])
             pydoc.pager(text)
 
         elif args[0] == 'multiparticles':
-            print 'Multiparticle labels:'
+            print( 'Multiparticle labels:')
             for key in self._multiparticles:
-                print self.multiparticle_string(key)
+                print( self.multiparticle_string(key))
 
         elif args[0] == 'coupling_order':
             hierarchy = self._curr_model['order_hierarchy'].items()
@@ -3406,11 +3412,11 @@ This implies that with decay chains:
                     return 1
             hierarchy.sort(order)
             for order in hierarchy:
-                print ' %s : weight = %s' % order
+                print( ' %s : weight = %s' % order)
 
         elif args[0] == 'couplings' and len(args) == 1:
             if self._model_v4_path:
-                print 'No couplings information available in V4 model'
+                print( 'No couplings information available in V4 model')
                 return
             text = ''
             text = "Current model contains %i couplings\n" % \
@@ -3440,34 +3446,34 @@ This implies that with decay chains:
 
         elif args[0] == 'couplings':
             if self._model_v4_path:
-                print 'No couplings information available in V4 model'
+                print('No couplings information available in V4 model')
                 return
 
             try:
                 ufomodel = ufomodels.load_model(self._curr_model.get('name'))
-                print 'Note that this is the UFO informations.'
-                print ' "display couplings" present the actual definition'
-                print 'prints the current states of mode'
-                print eval('ufomodel.couplings.%s.nice_string()'%args[1])
+                print('Note that this is the UFO informations.')
+                print(' "display couplings" present the actual definition')
+                print('prints the current states of mode')
+                print(eval('ufomodel.couplings.%s.nice_string()'%args[1]))
             except Exception:
-                raise self.InvalidCmd, 'no couplings %s in current model' % args[1]
+                raise self.InvalidCmd('no couplings %s in current model' % args[1])
 
         elif args[0] == 'lorentz':
-            print 'in lorentz'
+            print('in lorentz')
             if self._model_v4_path:
-                print 'No lorentz information available in V4 model'
+                print('No lorentz information available in V4 model')
                 return
             elif len(args) == 1:
                 ufomodel = ufomodels.load_model(self._curr_model.get('name'))
-                print dir(ufomodel.lorentz)
+                print(dir(ufomodel.lorentz))
                 return
             try:
                 ufomodel = ufomodels.load_model(self._curr_model.get('name'))
-                print getattr(ufomodel.lorentz, args[1]).nice_string()
-            except Exception, error:
+                print(getattr(ufomodel.lorentz, args[1]).nice_string())
+            except Exception as error:
                 raise
                 logger.info(str(error))
-                raise self.InvalidCmd, 'no lorentz %s in current model' % args[1]
+                raise self.InvalidCmd('no lorentz %s in current model' % args[1])
 
         elif args[0] == 'checks':
             outstr = ''
@@ -4319,8 +4325,8 @@ This implies that with decay chains:
                 if key not in options:
                     options[key] = value
                 else:
-                    raise MadGraph5Error,"Option '%s' is both in the option"%key+\
-                                                   " and CMS_option dictionary." 
+                    raise MadGraph5Error("Option '%s' is both in the option"%key+\
+                                                   " and CMS_option dictionary." )
             
             if options['analyze']=='None':
                 cms_results = []
@@ -4544,8 +4550,8 @@ This implies that with decay chains:
                     elif option=='noborn':
                         HasBorn=False
                 else:
-                    raise self.InvalidCmd, "NLO mode %s is not valid. "%option+\
-                       "Valid modes are %s. "%str(self._valid_nlo_modes)
+                    raise self.InvalidCmd("NLO mode %s is not valid. "%option+\
+                       "Valid modes are %s. "%str(self._valid_nlo_modes))
             else:
                 LoopOption='all'
 
@@ -4569,8 +4575,8 @@ This implies that with decay chains:
             type = order_re.group('type')
             if order_re.group('name').endswith('^2'):
                 if type not in self._valid_sqso_types:
-                    raise self.InvalidCmd, "Type of squared order "+\
-                                 "constraint '%s'"% type+" is not supported."
+                    raise self.InvalidCmd("Type of squared order "+\
+                                 "constraint '%s'"% type+" is not supported.")
                 if type == '=':
                     name =  order_re.group('name')
                     value = order_re.group('value')
@@ -4581,9 +4587,9 @@ This implies that with decay chains:
                                          (int(order_re.group('value')),type)
             else:
                 if type not in self._valid_amp_so_types:
-                    raise self.InvalidCmd, \
+                    raise self.InvalidCmd( \
                       "Amplitude order constraints can only be of type %s"%\
-                    (', '.join(self._valid_amp_so_types))+", not '%s'."%type
+                    (', '.join(self._valid_amp_so_types))+", not '%s'."%type)
                 name = order_re.group('name')
                 value = int(order_re.group('value'))
                 if type in ['=', '<=']:
@@ -4620,9 +4626,9 @@ This implies that with decay chains:
         
         #only allow amplitue restrctions >/ == for LO/tree level
         if constrained_orders and LoopOption != 'tree':
-            raise self.InvalidCmd, \
+            raise self.InvalidCmd( \
                           "Amplitude order constraints (for not LO processes) can only be of type %s"%\
-                        (', '.join(['<=']))+", not '%s'."%type
+                        (', '.join(['<=']))+", not '%s'."%type)
 
         # If the squared orders are defined but not the orders, assume 
         # orders=sq_orders. In case the squared order has a negative value or is
@@ -4686,23 +4692,23 @@ This implies that with decay chains:
         for part_name in args:
             if part_name == '>':
                 if not myleglist:
-                    raise self.InvalidCmd, "No final state particles"
+                    raise self.InvalidCmd("No final state particles")
                 state = True
                 continue
 
             mylegids = []
             if part_name in self._multiparticles:
                 if isinstance(self._multiparticles[part_name][0], list):
-                    raise self.InvalidCmd,\
+                    raise self.InvalidCmd(\
                           "Multiparticle %s is or-multiparticle" % part_name + \
-                          " which can be used only for required s-channels"
+                          " which can be used only for required s-channels")
                 mylegids.extend(self._multiparticles[part_name])
             elif part_name.isdigit() or part_name.startswith('-') and part_name[1:].isdigit():
                 if int(part_name) in self._curr_model.get('particle_dict'):
                     mylegids.append(int(part_name))
                 else:
-                    raise self.InvalidCmd, \
-                      "No pdg_code %s in model" % part_name
+                    raise self.InvalidCmd( \
+                      "No pdg_code %s in model" % part_name)
             else:
                 mypart = self._curr_model['particles'].get_copy(part_name)
                 if mypart:
@@ -4712,7 +4718,7 @@ This implies that with decay chains:
                 myleglist.append(base_objects.MultiLeg({'ids':mylegids,
                                                         'state':state}))
             else:
-                raise self.InvalidCmd, "No particle %s in model" % part_name
+                raise self.InvalidCmd("No particle %s in model" % part_name)
 
         # Apply the keyword 'all' for perturbed coupling orders.
         if perturbation_couplings.lower() in ['all', 'loonly']:
@@ -4735,10 +4741,10 @@ This implies that with decay chains:
                                        self._curr_model.get('order_hierarchy')
                                        [elem if not elem.endswith('.sqrt') else elem[:-5]])
             except KeyError:
-                raise self.InvalidCmd, "The loaded model does not defined a "+\
+                raise self.InvalidCmd("The loaded model does not defined a "+\
                     " coupling order hierarchy for these couplings: %s"%\
                       str([so for so in split_orders if so!='WEIGHTED' and so not 
-                                 in self._curr_model['order_hierarchy'].keys()])
+                                 in self._curr_model['order_hierarchy'].keys()]))
 
             # If the loopOption is 'tree' then the user used the syntax 
             # [tree= Orders] for the sole purpose of setting split_orders. We
@@ -4777,14 +4783,14 @@ This implies that with decay chains:
                               self.extract_particle_ids(forbidden_schannels)
             if forbidden_onsh_schannel_ids and \
                isinstance(forbidden_onsh_schannel_ids[0], list):
-                raise self.InvalidCmd,\
+                raise self.InvalidCmd(\
                       "Multiparticle %s is or-multiparticle" % part_name + \
-                      " which can be used only for required s-channels"
+                      " which can be used only for required s-channels")
             if forbidden_schannel_ids and \
                isinstance(forbidden_schannel_ids[0], list):
-                raise self.InvalidCmd,\
+                raise self.InvalidCmd(\
                       "Multiparticle %s is or-multiparticle" % part_name + \
-                      " which can be used only for required s-channels"
+                      " which can be used only for required s-channels")
             required_schannel_ids = \
                                self.extract_particle_ids(required_schannels)
             if required_schannel_ids and not \
@@ -4908,8 +4914,8 @@ This implies that with decay chains:
                 if amp['has_born']:
                     raise Exception
             elif warning_duplicate:
-                raise self.InvalidCmd, "Duplicate process %s found. Please check your processes." % \
-                                            amp.nice_string_processes()
+                raise self.InvalidCmd("Duplicate process %s found. Please check your processes." % \
+                                            amp.nice_string_processes())
 
         # Reset _done_export, since we have new process
         self._done_export = False
@@ -5027,7 +5033,7 @@ This implies that with decay chains:
                 elif first in self._multiparticles:
                     pid = set(self._multiparticles[first])
                 else:
-                    raise Exception, 'invalid particle name: %s. ' % first
+                    raise Exception('invalid particle name: %s. ' % first)
                 core_final.difference_update(pid)
                 core_final.update(self.get_final_part(one_decay))
 
@@ -5179,8 +5185,8 @@ This implies that with decay chains:
 
             if level_down:
                 if index_par == -1:
-                    raise self.InvalidCmd, \
-                      "Missing ending parenthesis for decay process"
+                    raise self.InvalidCmd(\
+                      "Missing ending parenthesis for decay process")
 
                 if index_par < index_comma:
                     line = line[index_par + 1:]
@@ -5190,8 +5196,8 @@ This implies that with decay chains:
         if level_down:
             index_par = line.find(')')
             if index_par == -1:
-                raise self.InvalidCmd, \
-                      "Missing ending parenthesis for decay process"
+                raise self.InvalidCmd( \
+                      "Missing ending parenthesis for decay process")
             line = line[index_par + 1:]
 
         # Return the core process (ends recursion when there are no
@@ -5289,7 +5295,7 @@ This implies that with decay chains:
         elif args[0] == 'banner':
             type = madevent_interface.MadEventCmd.detect_card_type(args[1])
             if type != 'banner':
-                raise self.InvalidCmd, 'The File should be a valid banner'
+                raise self.InvalidCmd('The File should be a valid banner')
             ban = banner_module.Banner(args[1])
             # Check that this is MG5 banner
             if 'mg5proccard' in ban:
@@ -5298,7 +5304,7 @@ This implies that with decay chains:
                         continue
                     self.exec_cmd(line)
             else:
-                raise self.InvalidCmd, 'Only MG5 banner are supported'
+                raise self.InvalidCmd('Only MG5 banner are supported')
 
             if not self._done_export:
                 self.exec_cmd('output . -f')
@@ -5385,8 +5391,8 @@ This implies that with decay chains:
                  [p.get('antiname') for p in self._curr_model.get('particles') \
                                                     if p.get('propagating')]
 
-        self._couplings = list(set(sum([i.get('orders').keys() for i in \
-                                        self._curr_model.get('interactions')], [])))
+        self._couplings = list(set(sum(list([i.get('orders').keys() for i in \
+                                        self._curr_model.get('interactions')]), [])))
 
         self.add_default_multiparticles()
 
@@ -5451,7 +5457,7 @@ This implies that with decay chains:
                 if multipart_name not in self._multiparticles:
                     #self.do_define(line)
                     self.exec_cmd('define %s' % line, printcmd=False, precmd=True)
-            except self.InvalidCmd, why:
+            except self.InvalidCmd as why:
                 logger_stderr.warning('impossible to set default multiparticles %s because %s' %
                                         (line.split()[0],why))
                 if self.history[-1] == 'define %s' % line.strip():
@@ -5484,7 +5490,7 @@ This implies that with decay chains:
                 if container in defined_multiparticles:
                     defined_multiparticles.remove(container)
             self.history.append("define p = %s # pass to %s flavors" % \
-                                (' ' .join([`i` for i in self._multiparticles['p']]), 
+                                (' ' .join([repr(i) for i in self._multiparticles['p']]), 
                                  scheme) 
                                )
             self.history.append("define j = p")
@@ -5524,9 +5530,9 @@ This implies that with decay chains:
         # Always refresh the installer if already present
         if not os.path.isdir(pjoin(MG5DIR,'HEPTools','HEPToolsInstallers')):
             if HepToolsInstaller_web_address is None:
-                raise MadGraph5Error, "The option 'HepToolsInstaller_web_address'"+\
+                raise MadGraph5Error("The option 'HepToolsInstaller_web_address'"+\
                              " must be specified in function advanced_install"+\
-                                " if the installers are not already downloaded."
+                                " if the installers are not already downloaded.")
             if not os.path.isdir(pjoin(MG5DIR,'HEPTools')):
                 os.mkdir(pjoin(MG5DIR,'HEPTools'))
         elif not HepToolsInstaller_web_address is None:
@@ -5930,7 +5936,7 @@ MG5aMC that supports quadruple precision
                 cluster_path = data_path[index]
                 try:
                     data = urllib.urlopen(cluster_path)
-                except Exception, error:
+                except Exception as error:
                     misc.sprint(str(error), cluster_path)
                     continue
                 if data.getcode() != 200:
@@ -5939,8 +5945,8 @@ MG5aMC that supports quadruple precision
                 break
                 
             else:
-                raise MadGraph5Error, '''Impossible to connect any of us servers.
-                Please check your internet connection or retry later'''
+                raise MadGraph5Error('''Impossible to connect any of us servers.
+                Please check your internet connection or retry later''')
             for wwwline in data:
                 split = wwwline.split()
                 if len(split)!=2:
@@ -6018,7 +6024,7 @@ MG5aMC that supports quadruple precision
                 if 'xxx' in advertisements[name][0]:
                     logger.warning("Program not yet released. Please try later")
                 else:
-                    raise Exception, "Online server are corrupted. No tarball available for %s" % name
+                    raise Exception("Online server are corrupted. No tarball available for %s" % name)
                 return
             
         # Load that path
@@ -6030,7 +6036,7 @@ MG5aMC that supports quadruple precision
                                      stdout=open(os.devnull, 'w'))
 
         if returncode:
-            raise MadGraph5Error, 'Fail to download correctly the File. Stop'
+            raise MadGraph5Error('Fail to download correctly the File. Stop')
 
 
         # Check that the directory has the correct name
@@ -6038,7 +6044,7 @@ MG5aMC that supports quadruple precision
             created_name = [n for n in os.listdir(MG5DIR) if n.lower().startswith(
                                          name.lower()) and not n.endswith('gz')]
             if not created_name:
-                raise MadGraph5Error, 'The file was not loaded correctly. Stop'
+                raise MadGraph5Error('The file was not loaded correctly. Stop')
             else:
                 created_name = created_name[0]
             files.mv(pjoin(MG5DIR, created_name), pjoin(MG5DIR, name))
@@ -6158,10 +6164,10 @@ MG5aMC that supports quadruple precision
                 latest_validated_version = plugin.latest_validated_version
                 minimal_mg5amcnlo_version = plugin.minimal_mg5amcnlo_version
                 maximal_mg5amcnlo_version = plugin.maximal_mg5amcnlo_version
-            except Exception, error:
-                raise Exception, 'Plugin %s fail to be loaded. Please contact the author of the PLUGIN\n Error %s' % (name, error)
+            except Exception as error:
+                raise Exception('Plugin %s fail to be loaded. Please contact the author of the PLUGIN\n Error %s' % (name, error))
                 
-            logger.info('Plugin %s correctly interfaced. Latest official validition for MG5aMC version %s.' % (name, '.'.join(`i` for i in latest_validated_version)))
+            logger.info('Plugin %s correctly interfaced. Latest official validition for MG5aMC version %s.' % (name, '.'.join(repr(i) for i in latest_validated_version)))
             if new_interface:
                 ff = open(pjoin(MG5DIR, 'bin', '%s.py' % name) , 'w') 
                 if __debug__:
@@ -6245,8 +6251,8 @@ os.system('%s  -O -W ignore::Deprecation
             try:
                 os.system('rm -rf td')
                 os.mkdir(pjoin(MG5DIR, 'td'))
-            except Exception, error:
-                print error
+            except Exception as error:
+                print(error)
                 pass
 
             if sys.platform == "darwin":
@@ -6267,7 +6273,7 @@ os.system('%s  -O -W ignore::Deprecation
                     logger.info('Downloading TD for Linux 32 bit')
                     target = 'http://madgraph.phys.ucl.ac.be/Downloads/td'
                 misc.wget(target, 'td', cwd=pjoin(MG5DIR,'td'))
-            os.chmod(pjoin(MG5DIR,'td','td'), 0775)
+            os.chmod(pjoin(MG5DIR,'td','td'), stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IXOTH)
             self.options['td_path'] = pjoin(MG5DIR,'td')
 
             if not misc.which('gs'):
@@ -6345,7 +6351,7 @@ os.system('%s  -O -W ignore::Deprecation
             pattern = re.compile(r'''=== renamed file \'(?P<orig>[^\']*)\' => \'(?P<new>[^\']*)\'''')
             #=== renamed file 'Template/SubProcesses/addmothers.f' => 'madgraph/iolibs/template_files/addmothers.f'
             for orig, new in pattern.findall(text):
-                print 'move %s to %s' % (orig, new)
+                print('move %s to %s' % (orig, new))
                 try:
                     files.cp(pjoin(MG5DIR, orig), pjoin(MG5DIR, new), error=True)
                 except IOError:
@@ -6361,7 +6367,7 @@ os.system('%s  -O -W ignore::Deprecation
             #pattern = re.compile(r'''=== removed file \'(?P<new>[^\']*)\'''')
             #all_rm = pattern.findall(text)
             pattern=re.compile(r'''=== removed file \'(?P<new>[^\']*)\'(?=.*=== added file \'(?P=new)\')''',re.S)
-            print 'this step can take a few minuts. please be patient'
+            print('this step can take a few minuts. please be patient')
             all_rm_add = pattern.findall(text)
             #=== added file 'tests/input_files/full_sm/interactions.dat'
             for new in all_add:
@@ -6400,7 +6406,7 @@ os.system('%s  -O -W ignore::Deprecation
                         for i in range(1,len(split)):
                             path = '/'.join(split[:i])
                             if not os.path.exists(path):
-                                print 'mkdir', path
+                                print( 'mkdir', path)
                                 os.mkdir(path)
                     files.cp(old,new)
             #=== renamed file 'Template/bin/internal/run_delphes' => 'Template/Common/bin/internal/run_delphes'
@@ -6446,10 +6452,10 @@ os.system('%s  -O -W ignore::Deprecation
                     for i in range(1,len(split)+1):
                         path = '/'.join(split[:i])
                         if path and not os.path.exists(path):
-                            print 'mkdir', path
+                            print( 'mkdir', path)
                             os.mkdir(path)
                 if match[0] == 'file':
-                    print 'touch ', pjoin(MG5DIR, match[1])
+                    print( 'touch ', pjoin(MG5DIR, match[1]))
                     misc.call(['touch', pjoin(MG5DIR, match[1])])
             # add new symlink
             pattern=re.compile('''^=== link file \'(?P<new>[^\']*)\' \'(?P<old>[^\']*)\'''', re.M)
@@ -6566,7 +6572,7 @@ os.system('%s  -O -W ignore::Deprecation
             web_version = int(filetext.read().strip())
         except (TimeOutError, ValueError, IOError):
             signal.alarm(0)
-            print 'failed to connect server'
+            print( 'failed to connect server')
             if mode == 'mg5_end':
                 # wait 24h before next check
                 fsock = open(os.path.join(MG5DIR,'input','.autoupdate'),'w')
@@ -6606,7 +6612,7 @@ os.system('%s  -O -W ignore::Deprecation
                 try:
                     filetext = urllib.urlopen('http://madgraph.phys.ucl.ac.be/patch/build%s.patch' %(i+1))
                 except Exception:
-                    print 'fail to load patch to build #%s' % (i+1)
+                    print( 'fail to load patch to build #%s' % (i+1))
                     fail = i
                     break
                 need_binary = apply_patch(filetext)
@@ -6630,7 +6636,7 @@ os.system('%s  -O -W ignore::Deprecation
             logger.info('Checking current version. (type ctrl-c to bypass the check)')
             subprocess.call([os.path.join('tests','test_manager.py')],
                                                                   cwd=MG5DIR)            
-            print 'new version installed, please relaunch mg5'
+            print( 'new version installed, please relaunch mg5')
             try:
                 os.remove(pjoin(MG5DIR, 'Template','LO','Source','make_opts'))
                 shutil.copy(pjoin(MG5DIR, 'Template','LO','Source','.make_opts'),
@@ -6669,7 +6675,7 @@ os.system('%s  -O -W ignore::Deprecation
             self.options.update(self.options_madevent)
 
         if not config_path:
-            if os.environ.has_key('MADGRAPH_BASE'):
+            if 'MADGRAPH_BASE' in os.environ:
                 config_path = pjoin(os.environ['MADGRAPH_BASE'],'mg5_configuration.txt')
                 self.set_configuration(config_path, final=False)
             if 'HOME' in os.environ:
@@ -6811,8 +6817,8 @@ in the MG5aMC option 'samurai' (instead
                 # Default: try to set parameter
                 try:
                     self.do_set("%s %s --no_save" % (key, self.options[key]), log=False)
-                except MadGraph5Error, error:
-                    print error
+                except MadGraph5Error as error:
+                    print(error)
                     logger.warning("Option %s from config file not understood" \
                                    % key)
                 else:
@@ -6937,7 +6943,7 @@ in the MG5aMC option 'samurai' (instead
                                                  options=self.options,**options)            
         else:
             os.chdir(start_cwd) #ensure to go to the initial path
-            raise self.InvalidCmd , '%s cannot be run from MG5 interface' % args[0]
+            raise self.InvalidCmd('%s cannot be run from MG5 interface' % args[0])
 
 
         ext_program.run()
@@ -7367,7 +7373,7 @@ in the MG5aMC option 'samurai' (instead
                  'variable to the full (absolute) /PATH/TO/fastjet-config (including fastjet-config).' +
                         '\n MG5_aMC> set fastjet /PATH/TO/fastjet-config\n')
                 self.options[args[0]] = None
-                self.history.pop()
+                #self.history.pop()
             elif int(output.split('.')[0]) < 3:
                 logger.warning('%s is not ' % args[1] + \
                         'v3 or greater. Please install FastJet v3+.')
@@ -7601,7 +7607,7 @@ in the MG5aMC option 'samurai' (instead
                 self._export_dir = pjoin(self._export_dir, 'Pythia8_proc_%i' %i)
                 logger.info('Create output in %s' % self._export_dir)
             elif not args[0] in ['.', '-f']:
-                raise self.InvalidCmd, 'Wrong path directory to create in local directory use \'.\''
+                raise self.InvalidCmd('Wrong path directory to create in local directory use \'.\'')
         elif not noclean and os.path.isdir(self._export_dir) and options['check']:
             if not force:
                 # Don't ask if user already specified force or noclean
@@ -8137,8 +8143,8 @@ in the MG5aMC option 'samurai' (instead
                                        (particle.get('name'), ' '.join([p.get('name') for p in mode]), value))
                         value = 0
                     elif value < 0:
-                        raise Exception, 'Partial width for %s > %s negative: %s' % \
-                                       (particle.get('name'), ' '.join([p.get('name') for p in mode]), value)
+                        raise Exception('Partial width for %s > %s negative: %s' % \
+                                       (particle.get('name'), ' '.join([p.get('name') for p in mode]), value))
                     elif 0 < value < 0.1 and particle['color'] !=1:
                         logger.warning("partial width of particle %s lower than QCD scale:%s. Set it to zero. (%s)" \
                                    % (particle.get('name'), value, decay_to))
@@ -8158,7 +8164,7 @@ in the MG5aMC option 'samurai' (instead
         # add info from decay module
         #
         
-        self.do_decay_diagram('%s %s' % (' '.join([`id` for id in particles]),
+        self.do_decay_diagram('%s %s' % (' '.join([repr(id) for id in particles]),
                                          ' '.join('--%s=%s' % (key,value)
                                                   for key,value in opts.items()
                                                   if key not in ['precision_channel'])
@@ -8287,7 +8293,7 @@ in the MG5aMC option 'samurai' (instead
             currmodel = model
 
         if not os.path.exists(pjoin(model_path, 'SMWidth')):
-            raise self.InvalidCmd, "Model %s is not valid for computing NLO width with SMWidth"%model_name
+            raise self.InvalidCmd("Model %s is not valid for computing NLO width with SMWidth"%model_name)
 
         # determine the EW scheme
         externparam = [(param.lhablock.lower(),param.name.lower()) for param \
@@ -8300,7 +8306,7 @@ in the MG5aMC option 'samurai' (instead
             # Gmu scheme
             arg2 = "2"
         else:
-            raise Exception, "Do not know the EW scheme in the model %s"%model_name
+            raise Exception("Do not know the EW scheme in the model %s"%model_name)
 
         #compile the code
         if not os.path.exists(pjoin(model_path, 'SMWidth','smwidth')):
@@ -8635,27 +8641,27 @@ class AskforCustomize(cmd.SmartQuestion)
     def do_help(self, line):
         '''help message'''
 
-        print 'This allows you to optimize your model to your needs.'
-        print 'Enter the number associate to the possible restriction/add-on'
-        print ' to change the status of this restriction/add-on.'
-        print ''
-        print 'In order to allow scripting of this function you can use the '
-        print 'function \'set\'. This function takes two argument:'
-        print 'set NAME VALUE'
-        print '   NAME is the description of the option where you remove all spaces'
-        print '   VALUE is either True or False'
-        print ' Example: For the question'
-        print '''     sm customization:
+        print('This allows you to optimize your model to your needs.')
+        print('Enter the number associate to the possible restriction/add-on')
+        print(' to change the status of this restriction/add-on.')
+        print('')
+        print('In order to allow scripting of this function you can use the ')
+        print('function \'set\'. This function takes two argument:')
+        print('set NAME VALUE')
+        print('   NAME is the description of the option where you remove all spaces')
+        print('   VALUE is either True or False')
+        print(' Example: For the question')
+        print('''     sm customization:
         1: diagonal ckm [True]
         2: c mass = 0 [True]
         3: b mass = 0 [False]
         4: tau mass = 0 [False]
         5: muon mass = 0 [True]
         6: electron mass = 0 [True]
-    Enter a number to change it's status or press enter to validate.'''
-        print ''' you can answer by'''
-        print '   set diagonalckm False'
-        print '   set taumass=0 True'
+    Enter a number to change it's status or press enter to validate.''')
+        print(''' you can answer by''')
+        print('   set diagonalckm False')
+        print('   set taumass=0 True')
 
     def cmdloop(self, intro=None):
         cmd.SmartQuestion.cmdloop(self, intro)
Binary files MadGraph_pristine/madgraph/interface/.madgraph_interface.py.swp and ../contrib/MadGraph/madgraph/interface/.madgraph_interface.py.swp differ
diff -rupN MadGraph_pristine/madgraph/interface/master_interface.py ../contrib/MadGraph/madgraph/interface/master_interface.py
--- MadGraph_pristine/madgraph/interface/master_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/master_interface.py	2020-10-30 20:49:24.518460937 +1100
@@ -153,7 +153,7 @@ class Switcher(object):
                     correct = False                    
                     
         if not correct:
-            raise Exception, 'The Cmd interface has dangerous features. Please see previous warnings and correct those.' 
+            raise Exception('The Cmd interface has dangerous features. Please see previous warnings and correct those.' )
 
     
 
@@ -593,7 +593,7 @@ class MasterCmd(Switcher, LoopCmd.LoopIn
             self.cmd= self.interface_names[main][1]
             self.current_interface=main
         else:
-            raise MadGraph5Error, 'Type of interface not valid: %s' % main  
+            raise MadGraph5Error('Type of interface not valid: %s' % main  )
         self.cmd.__init__(self, *args, **opt)     
         self.current_interface = main  
     
@@ -619,14 +619,14 @@ class MasterCmd(Switcher, LoopCmd.LoopIn
         if old_cmd == name:
             return
         elif not allow_switch:
-            raise InvalidCmd, "Command not compatible with previous command: Can not combine LO/NLO feature."
+            raise InvalidCmd("Command not compatible with previous command: Can not combine LO/NLO feature.")
             
         if name in self.interface_names.keys():
             self.prompt= self.interface_names[name][0]+'>'
             self.cmd= self.interface_names[name][1]
             self.current_interface=name
         else:
-            raise MadGraph5Error, 'Type of interface not valid: %s' % name  
+            raise MadGraph5Error('Type of interface not valid: %s' % name  )
         
         if self.interface_names[old_cmd][0]!=self.interface_names[name][0]:
             logger.info("Switching from interface %s to %s"\
@@ -662,7 +662,7 @@ class MasterCmdWeb(MGcmd.MadGraphCmdWeb,
         elif name == 'Loop':
             self.cmd = LoopCmd.LoopInterfaceWeb
         else:
-            raise MadGraph5Error, 'Type of interface not valid'  
+            raise MadGraph5Error('Type of interface not valid'  )
         
         if __debug__:
             self.debug_link_to_command() 
diff -rupN MadGraph_pristine/madgraph/interface/reweight_interface.py ../contrib/MadGraph/madgraph/interface/reweight_interface.py
--- MadGraph_pristine/madgraph/interface/reweight_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/reweight_interface.py	2020-10-30 20:49:24.518460937 +1100
@@ -203,7 +203,7 @@ class ReweightInterface(extended_cmd.Cmd
 
         if not process:
             msg = 'Invalid proc_card information in the file (no generate line):\n %s' % self.banner['mg5proccard']
-            raise Exception, msg
+            raise Exception(msg)
         process, option = mg_interface.MadGraphCmd.split_process_line(process)
         self.proc_option = option
         self.is_decay = len(process.split('>',1)[0].split()) == 1 
@@ -294,8 +294,8 @@ class ReweightInterface(extended_cmd.Cmd
 
             try:
                 event.check() #check 4 momenta/...
-            except Exception, error:
-                print event
+            except Exception as error:
+                print(event)
                 raise error
             sum_of_weight += event.wgt
             sum_of_abs_weight += abs(event.wgt)
@@ -335,11 +335,11 @@ class ReweightInterface(extended_cmd.Cmd
     def help_change(self):
         """help for change command"""
     
-        print "change model X :use model X for the reweighting"
-        print "change process p p > e+ e-: use a new process for the reweighting"
-        print "change process p p > mu+ mu- --add : add one new process to existing ones"
-        print "change output [default|2.0|unweight]:"
-        print "               default: add weight(s) to the current file"    
+        print("change model X :use model X for the reweighting")
+        print("change process p p > e+ e-: use a new process for the reweighting")
+        print("change process p p > mu+ mu- --add : add one new process to existing ones")
+        print("change output [default|2.0|unweight]:")
+        print("               default: add weight(s) to the current file"    )
     
     def do_change(self, line):
         """allow to define a second model/processes"""
@@ -402,7 +402,7 @@ class ReweightInterface(extended_cmd.Cmd
             if len(args) == 2:
                 try:
                     self.systematics = banner.ConfigFile.format_variable(args[1], bool)
-                except Exception, error:
+                except Exception as error:
                     self.systematics = args[1:]
             else:
                 self.systematics = args[1:]
@@ -484,8 +484,8 @@ class ReweightInterface(extended_cmd.Cmd
                 while not os.path.exists(pjoin(self.me_dir,'rw_me','rwgt.pkl')):
                     time.sleep(10+i)
                     i+=5
-                    print 'wait for pickle'                  
-                print "loading from pickle"
+                    print('wait for pickle')                  
+                print("loading from pickle")
                 if not self.rwgt_dir:
                     self.rwgt_dir = self.me_dir
                 self.load_from_pickle(keep_name=True)
@@ -732,7 +732,7 @@ class ReweightInterface(extended_cmd.Cmd
                 Shell_internal = None
             import madgraph.interface.extended_cmd as extended_cmd
             if not isinstance(self.mother, (extended_cmd.CmdShell, Shell_internal)): 
-                raise Exception, "scan are not allowed on the Web"
+                raise Exception( "scan are not allowed on the Web")
             # at least one scan parameter found. create an iterator to go trough the cards
             main_card = check_param_card.ParamCardIterator(new_card)
             if self.options['rwgt_name']:
@@ -814,7 +814,7 @@ class ReweightInterface(extended_cmd.Cmd
             try:
                 if old_param['sminputs'].get(3)- new_param['sminputs'].get(3) > 1e-3 * new_param['sminputs'].get(3):
                     logger.warning("We found different value of alpha_s. Note that the value of alpha_s used is the one associate with the event and not the one from the cards.")
-            except Exception, error:
+            except Exception as error:
                 logger.debug("error in check of alphas: %s" % str(error))
                 pass #this is a security                
             if not self.second_process:
@@ -993,7 +993,7 @@ class ReweightInterface(extended_cmd.Cmd
             else:
                 nhel = 0
             misc.sprint(nhel, Pdir, hel_dict)                        
-            raise Exception, "Invalid matrix element for original computation (weight=0)"
+            raise Exception("Invalid matrix element for original computation (weight=0)")
 
         return {'orig': orig_wgt, '': w_new/w_orig*orig_wgt*jac}
      
@@ -1327,7 +1327,7 @@ class ReweightInterface(extended_cmd.Cmd
             logger.info("RETRY with %s", commandline)
             mgcmd.exec_cmd(commandline, precmd=True)
             has_nlo = False
-        except Exception, error:
+        except Exception as error:
             raise
         
         commandline = 'output standalone_rw %s --prefix=int' % pjoin(path_me,data['paths'][0])
@@ -1364,7 +1364,7 @@ class ReweightInterface(extended_cmd.Cmd
                     if tag in data['id2path']:
                         if not Pdir == data['id2path'][tag][1]:
                             misc.sprint(tag, Pdir, data['id2path'][tag][1])
-                            raise self.InvalidCmd, '2 different process have the same final states. This module can not handle such situation'
+                            raise self.InvalidCmd('2 different process have the same final states. This module can not handle such situation')
                         else:
                             continue
                     # build the helicity dictionary
@@ -1399,7 +1399,7 @@ class ReweightInterface(extended_cmd.Cmd
         
         if os.path.exists(pjoin(path_me, data['paths'][1], 'Cards', 'MadLoopParams.dat')):
             if self.multicore == 'create':
-                print "compile OLP", data['paths'][1]
+                print("compile OLP", data['paths'][1])
                 # It is potentially unsafe to use several cores, We limit ourself to one for now
                 # n_cores = self.mother.options['nb_core']
                 n_cores = 1
@@ -1450,7 +1450,7 @@ class ReweightInterface(extended_cmd.Cmd
             m_opts['lhapdfversion'] = 5 # 6 always fail on my computer since 5 is compatible but slower always use 5
             m_opts['llhapdf'] = self.mother.get_lhapdf_libdir()                       
         else:
-            raise Exception, "NLO reweighting requires LHAPDF to work correctly"
+            raise Exception("NLO reweighting requires LHAPDF to work correctly")
 
         path = pjoin(path_me,data['paths'][1], 'Source', 'make_opts')             
         common_run_interface.CommonRunCmd.update_make_opts_full(path, m_opts)      
@@ -1484,7 +1484,7 @@ class ReweightInterface(extended_cmd.Cmd
                     if (tag,'V') in data['id2path']:
                         if not Pdir == data['id2path'][(tag,'V')][1]:
                             misc.sprint(tag, Pdir, self.id_to_path[(tag,'V')][1])
-                            raise self.InvalidCmd, '2 different process have the same final states. This module can not handle such situation'
+                            raise self.InvalidCmd('2 different process have the same final states. This module can not handle such situation')
                         else:
                             continue
                     # build the helicity dictionary
@@ -1628,7 +1628,7 @@ class ReweightInterface(extended_cmd.Cmd
                     self.combine_wgt = mymod.get_wgt
 
             if self.multicore == 'create':
-                print "compile OLP", data['paths'][1]
+                print("compile OLP", data['paths'][1])
                 try:
                     misc.compile(['OLP_static'], cwd=pjoin(path_me, data['paths'][1],'SubProcesses'),
                              nb_core=self.mother.options['nb_core'])
@@ -1663,7 +1663,7 @@ class ReweightInterface(extended_cmd.Cmd
                 m_opts['lhapdfversion'] = 5 # 6 always fail on my computer since 5 is compatible but slower always use 5
                 m_opts['llhapdf'] = self.mother.get_lhapdf_libdir()                        
             else:
-                raise Exception, "NLO_tree reweighting requires LHAPDF to work correctly"
+                raise Exception("NLO_tree reweighting requires LHAPDF to work correctly")
  
             path = pjoin(path_me,data['paths'][1], 'Source', 'make_opts')             
             common_run_interface.CommonRunCmd.update_make_opts_full(path, m_opts)      
diff -rupN MadGraph_pristine/madgraph/iolibs/export_cpp.py ../contrib/MadGraph/madgraph/iolibs/export_cpp.py
--- MadGraph_pristine/madgraph/iolibs/export_cpp.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/export_cpp.py	2020-10-30 20:49:24.518460937 +1100
@@ -92,8 +92,8 @@ class OneProcessExporterCPP(object):
         elif isinstance(matrix_elements, helas_objects.HelasMatrixElementList):
             self.matrix_elements = matrix_elements
         else:
-            raise base_objects.PhysicsObject.PhysicsObjectError,\
-                  "Wrong object type for matrix_elements: %s" % type(matrix_elements)
+            raise base_objects.PhysicsObject.PhysicsObjectError(\
+                  "Wrong object type for matrix_elements: %s" % type(matrix_elements))
 
         if not self.matrix_elements:
             raise MadGraph5Error("No matrix elements to export")
@@ -127,8 +127,8 @@ class OneProcessExporterCPP(object):
         self.helas_call_writer = cpp_helas_call_writer
 
         if not isinstance(self.helas_call_writer, helas_call_writers.CPPUFOHelasCallWriter):
-            raise self.ProcessExporterCPPError, \
-                "helas_call_writer not CPPUFOHelasCallWriter"
+            raise self.ProcessExporterCPPError( \
+                "helas_call_writer not CPPUFOHelasCallWriter")
 
         self.nexternal, self.ninitial = \
                         self.matrix_elements[0].get_nexternal_ninitial()
@@ -944,7 +944,7 @@ class OneProcessExporterMatchbox(OneProc
             for match in all_matches:
                 ctype, arg = match[0], [m.strip() for m in match[1].split(',')]
                 if ctype not in ['T', 'Tr']:
-                    raise self.ProcessExporterCPPError, 'Color Structure not handle by Matchbox'
+                    raise self.ProcessExporterCPPError( 'Color Structure not handle by Matchbox')
                 tmp_color.append(arg)
             #compute the maximal size of the vector
             nb_index = sum(len(o) for o in tmp_color)
@@ -994,9 +994,9 @@ class OneProcessExporterPythia8(OneProce
         for me in self.matrix_elements:
             if me.get_nexternal_ninitial() not in [(3,2),(4,2),(5,2)]:
                 nex,nin = me.get_nexternal_ninitial()
-                raise InvalidCmd,\
+                raise InvalidCmd(\
                       "Pythia 8 can only handle 2->1,2,3 processes, not %d->%d" % \
-                      (nin,nex-nin)
+                      (nin,nex-nin))
             
         self.process_class = self.process_name
         
@@ -1371,8 +1371,8 @@ class OneProcessExporterPythia8(OneProce
 
             if final_id_list and final_mirror_id_list or \
                not final_id_list and not final_mirror_id_list:
-                raise self.ProcessExporterCPPError,\
-                      "Missing processes, or both process and mirror process"
+                raise self.ProcessExporterCPPError(\
+                      "Missing processes, or both process and mirror process")
 
 
             ncombs = len(final_id_list)+len(final_mirror_id_list)
@@ -1391,9 +1391,9 @@ class OneProcessExporterPythia8(OneProce
                                            (i, l) in items if l > 0]).\
                                  replace('*1', ''))
                 if any([l>1 for (i, l) in items]):
-                    raise self.ProcessExporterCPPError,\
+                    raise self.ProcessExporterCPPError(\
                           "More than one process with identical " + \
-                          "external particles is not supported"
+                          "external particles is not supported")
 
             for final_ids in final_mirror_id_list:
                 items = [(i, len([ p for p in me.get_mirror_processes() \
@@ -1405,9 +1405,9 @@ class OneProcessExporterPythia8(OneProce
                                            (i, l) in items if l > 0]).\
                                  replace('*1', ''))
                 if any([l>1 for (i, l) in items]):
-                    raise self.ProcessExporterCPPError,\
+                    raise self.ProcessExporterCPPError(\
                           "More than one process with identical " + \
-                          "external particles is not supported"
+                          "external particles is not supported")
 
             if final_id_list:
                 res_lines.append("int flavors[%d][%d] = {%s};" % \
diff -rupN MadGraph_pristine/madgraph/iolibs/export_fks.py ../contrib/MadGraph/madgraph/iolibs/export_fks.py
--- MadGraph_pristine/madgraph/iolibs/export_fks.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/export_fks.py	2020-10-30 20:49:24.518460937 +1100
@@ -92,8 +92,8 @@ class ProcessExporterFortranFKS(loop_exp
         #First copy the full template tree if dir_path doesn't exit
         if not os.path.isdir(dir_path):
             if not mgme_dir:
-                raise MadGraph5Error, \
-                      "No valid MG_ME path given for MG4 run directory creation."
+                raise MadGraph5Error( \
+                      "No valid MG_ME path given for MG4 run directory creation.")
             logger.info('initialize a new directory: %s' % \
                         os.path.basename(dir_path))
             shutil.copytree(os.path.join(mgme_dir, 'Template', 'NLO'), dir_path, True)
@@ -110,8 +110,8 @@ class ProcessExporterFortranFKS(loop_exp
             
         elif not os.path.isfile(os.path.join(dir_path, 'TemplateVersion.txt')):
             if not mgme_dir:
-                raise MadGraph5Error, \
-                      "No valid MG_ME path given for MG4 run directory creation."
+                raise MadGraph5Error( \
+                      "No valid MG_ME path given for MG4 run directory creation.")
         try:
             shutil.copy(os.path.join(mgme_dir, 'MGMEVersion.txt'), dir_path)
         except IOError:
@@ -129,7 +129,7 @@ class ProcessExporterFortranFKS(loop_exp
                 try:
                     subprocess.call([os.path.join('bin', 'internal', 'clean_template')], \
                                                                        cwd=dir_path)
-                except Exception, why:
+                except Exception as why:
                     raise MadGraph5Error('Failed to clean correctly %s: \n %s' \
                                                 % (os.path.basename(dir_path),why))
             #Write version info
@@ -432,8 +432,8 @@ class ProcessExporterFortranFKS(loop_exp
     def write_coef_specs_file(self, virt_me_list):
         """writes the coef_specs.inc in the DHELAS folder. Should not be called in the 
         non-optimized mode"""
-        raise fks_common.FKSProcessError(), \
-                "write_coef_specs should be called only in the loop-optimized mode"
+        raise fks_common.FKSProcessError()( \
+                "write_coef_specs should be called only in the loop-optimized mode")
         
         
     #===============================================================================
@@ -451,12 +451,12 @@ class ProcessExporterFortranFKS(loop_exp
         cwd = os.getcwd()
         try:
             os.chdir(path)
-        except OSError, error:
+        except OSError as error:
             error_msg = "The directory %s should exist in order to be able " % path + \
                         "to \"export\" in it. If you see this error message by " + \
                         "typing the command \"export\" please consider to use " + \
                         "instead the command \"output\". "
-            raise MadGraph5Error, error_msg 
+            raise MadGraph5Error(error_msg)
         
         calls = 0
         
@@ -908,8 +908,8 @@ class ProcessExporterFortranFKS(loop_exp
                     " libstdhep.a and libFmcfio.a in you environment paths.")
             
         else:
-            raise MadGraph5Error, 'output_dependencies option %s not recognized'\
-                                                            %output_dependencies
+            raise MadGraph5Error('output_dependencies option %s not recognized'\
+                                                            %output_dependencies)
            
         # Create the default MadAnalysis5 cards
         if 'madanalysis5_path' in self.opt and not \
@@ -951,8 +951,8 @@ This typically happens when using the 'l
             max_links=max(max_links,len(links))
             for i,diags in enumerate(links):
                 if not i == diags['born_conf']:
-                    print links
-                    raise MadGraph5Error, "born_conf should be canonically ordered"
+                    print(links)
+                    raise MadGraph5Error("born_conf should be canonically ordered")
             real_configs=', '.join(['%d' % int(diags['real_conf']+1) for diags in links])
             lines.append("data (real_from_born_conf(irfbc,%d),irfbc=1,%d) /%s/" \
                              % (iFKS,len(links),real_configs))
@@ -2536,8 +2536,8 @@ C     charge is set 0. with QCD correcti
         nexternal, ninitial = matrix_element.get_nexternal_ninitial()
     
         if ninitial < 1 or ninitial > 2:
-            raise writers.FortranWriter.FortranWriterError, \
-                  """Need ninitial = 1 or 2 to write auto_dsig file"""
+            raise writers.FortranWriter.FortranWriterError( \
+                  """Need ninitial = 1 or 2 to write auto_dsig file""")
     
         replace_dict = {}
 
@@ -3391,8 +3391,8 @@ class ProcessOptimizedExporterFortranFKS
         #First copy the full template tree if dir_path doesn't exit
         if not os.path.isdir(dir_path):
             if not mgme_dir:
-                raise MadGraph5Error, \
-                      "No valid MG_ME path given for MG4 run directory creation."
+                raise MadGraph5Error( \
+                      "No valid MG_ME path given for MG4 run directory creation.")
             logger.info('initialize a new directory: %s' % \
                         os.path.basename(dir_path))
             shutil.copytree(os.path.join(mgme_dir, 'Template', 'NLO'), dir_path, True)
@@ -3410,8 +3410,8 @@ class ProcessOptimizedExporterFortranFKS
 
         elif not os.path.isfile(os.path.join(dir_path, 'TemplateVersion.txt')):
             if not mgme_dir:
-                raise MadGraph5Error, \
-                      "No valid MG_ME path given for MG4 run directory creation."
+                raise MadGraph5Error( \
+                      "No valid MG_ME path given for MG4 run directory creation.")
         try:
             shutil.copy(os.path.join(mgme_dir, 'MGMEVersion.txt'), dir_path)
         except IOError:
@@ -3429,7 +3429,7 @@ class ProcessOptimizedExporterFortranFKS
                 try:
                     subprocess.call([os.path.join('bin', 'internal', 'clean_template')], \
                                                                        cwd=dir_path)
-                except Exception, why:
+                except Exception as why:
                     raise MadGraph5Error('Failed to clean correctly %s: \n %s' \
                                                 % (os.path.basename(dir_path),why))
             #Write version info
diff -rupN MadGraph_pristine/madgraph/iolibs/export_python.py ../contrib/MadGraph/madgraph/iolibs/export_python.py
--- MadGraph_pristine/madgraph/iolibs/export_python.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/export_python.py	2020-10-30 20:49:24.518460937 +1100
@@ -81,8 +81,8 @@ class ProcessExporterPython(object):
         self.helas_call_writer = python_helas_call_writer
 
         if not isinstance(self.helas_call_writer, helas_call_writers.PythonUFOHelasCallWriter):
-            raise Exception, \
-                "helas_call_writer not PythonUFOHelasCallWriter"
+            raise Exception( \
+                "helas_call_writer not PythonUFOHelasCallWriter")
 
         self.matrix_methods = {}
 
diff -rupN MadGraph_pristine/madgraph/iolibs/export_v4.py ../contrib/MadGraph/madgraph/iolibs/export_v4.py
--- MadGraph_pristine/madgraph/iolibs/export_v4.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/export_v4.py	2020-10-30 20:49:24.518460937 +1100
@@ -16,7 +16,12 @@ from madgraph.iolibs.helas_call_writers
 """Methods and classes to export matrix elements to v4 format."""
 
 import copy
-from cStringIO import StringIO
+
+try:
+    from cStringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 from distutils import dir_util
 import itertools
 import fractions
@@ -141,11 +146,11 @@ class VirtualExporter(object):
         return False, matrix_element
            
     def export_model_files(self, model_v4_path):
-        raise Exception, "V4 model not supported by this type of exporter. Please use UFO model"
+        raise Exception("V4 model not supported by this type of exporter. Please use UFO model")
         return
     
     def export_helas(self, HELAS_PATH):
-        raise Exception, "V4 model not supported by this type of exporter. Please use UFO model"
+        raise Exception("V4 model not supported by this type of exporter. Please use UFO model")
         return
 
 #===============================================================================
@@ -305,7 +310,7 @@ class ProcessExporterFortran(VirtualExpo
                 try:
                     misc.call([pjoin('bin', 'internal', 'clean_template')], \
                                                                        cwd=self.dir_path)
-                except Exception, why:
+                except Exception as why:
                     raise MadGraph5Error('Failed to clean correctly %s: \n %s' \
                                                 % (os.path.basename(self.dir_path),why))
 
@@ -1218,7 +1223,7 @@ param_card.inc: ../Cards/param_card.dat\
         
         if(not isinstance(color_amplitudes,list) or 
            not (color_amplitudes and isinstance(color_amplitudes[0],list))):
-                raise MadGraph5Error, "Incorrect col_amps argument passed to get_JAMP_coefs"
+                raise MadGraph5Error("Incorrect col_amps argument passed to get_JAMP_coefs")
 
         res_list = []
         my_cs = color.ColorString()
@@ -1274,36 +1279,36 @@ param_card.inc: ../Cards/param_card.dat\
             if(col_amps and isinstance(col_amps[0],list)):
                 color_amplitudes=col_amps
             else:
-                raise MadGraph5Error, error_msg%'col_amps'
+                raise MadGraph5Error(error_msg%'col_amps')
         else:
-            raise MadGraph5Error, error_msg%'col_amps'
+            raise MadGraph5Error(error_msg%'col_amps')
         
         # Verify the sanity of the split_order_amps and split_order_names args
         if isinstance(split_order_amps,list):
             for elem in split_order_amps:
                 if len(elem)!=2:
-                    raise MadGraph5Error, error_msg%'split_order_amps'
+                    raise MadGraph5Error(error_msg%'split_order_amps')
                 # Check the first element of the two lists to make sure they are
                 # integers, although in principle they should all be integers.
                 if not isinstance(elem[0],tuple) or \
                    not isinstance(elem[1],tuple) or \
                    not isinstance(elem[0][0],int) or \
                    not isinstance(elem[1][0],int):
-                    raise MadGraph5Error, error_msg%'split_order_amps'
+                    raise MadGraph5Error(error_msg%'split_order_amps')
         else:
-            raise MadGraph5Error, error_msg%'split_order_amps'
+            raise MadGraph5Error(error_msg%'split_order_amps')
         
         if not split_order_names is None:
             if isinstance(split_order_names,list):
                 # Should specify the same number of names as there are elements
                 # in the key of the split_order_amps.
                 if len(split_order_names)!=len(split_order_amps[0][0]):
-                    raise MadGraph5Error, error_msg%'split_order_names'
+                    raise MadGraph5Error(error_msg%'split_order_names')
                 # Check the first element of the list to be a string
                 if not isinstance(split_order_names[0],str):
-                    raise MadGraph5Error, error_msg%'split_order_names'                    
+                    raise MadGraph5Error(error_msg%'split_order_names')                    
             else:
-                raise MadGraph5Error, error_msg%'split_order_names'                
+                raise MadGraph5Error(error_msg%'split_order_names')                
         
         # Now scan all contributing orders to be individually computed and 
         # construct the list of color_amplitudes for JAMP to be constructed
@@ -1346,9 +1351,9 @@ param_card.inc: ../Cards/param_card.dat\
             if(col_amps and isinstance(col_amps[0],list)):
                 color_amplitudes=col_amps
             else:
-                raise MadGraph5Error, "Incorrect col_amps argument passed to get_JAMP_lines"
+                raise MadGraph5Error("Incorrect col_amps argument passed to get_JAMP_lines")
         else:
-            raise MadGraph5Error, "Incorrect col_amps argument passed to get_JAMP_lines"
+            raise MadGraph5Error("Incorrect col_amps argument passed to get_JAMP_lines")
 
 
         res_list = []
@@ -1748,7 +1753,7 @@ param_card.inc: ../Cards/param_card.dat\
             logger.warning('No Fortran Compiler detected! Please install one')
             f77_compiler = default_compiler['fortran'] # maybe misc fail so try with it
         else:
-            raise MadGraph5Error, 'No Fortran Compiler detected! Please install one'
+            raise MadGraph5Error('No Fortran Compiler detected! Please install one')
         logger.info('Use Fortran compiler ' + f77_compiler)
         
         
@@ -1810,7 +1815,7 @@ param_card.inc: ../Cards/param_card.dat\
             logger.warning('No c++ Compiler detected! Please install one')
             compiler = default_compiler # maybe misc fail so try with it
         else:
-            raise MadGraph5Error, 'No c++ Compiler detected! Please install one'
+            raise MadGraph5Error('No c++ Compiler detected! Please install one')
         logger.info('Use c++ compiler ' + compiler)
         self.replace_make_opt_c_compiler(compiler)
         # Replace also for Template but not for cluster
@@ -2254,7 +2259,7 @@ CF2PY CHARACTER*20, intent(out) :: PREFI
             elif self.cmd_options['prefix'] == 'proc':
                 proc_prefix = matrix_element.get('processes')[0].shell_string().split('_',1)[1]
             else:
-                raise Exception, '--prefix options supports only \'int\' and \'proc\''
+                raise Exception('--prefix options supports only \'int\' and \'proc\'')
             for proc in matrix_element.get('processes'):
                 ids = [l.get('id') for l in proc.get('legs_with_decays')]
                 self.prefix_info[tuple(ids)] = [proc_prefix, proc.get_tag()] 
@@ -2597,7 +2602,7 @@ class ProcessExporterFortranMatchBox(Pro
                 if ctype in ['ColorOne' ]:
                     continue
                 if ctype not in ['T', 'Tr' ]:
-                    raise MadGraph5Error, 'Color Structure not handled by Matchbox: %s'  % ctype
+                    raise MadGraph5Error('Color Structure not handled by Matchbox: %s'  % ctype)
                 tmparg += ['0']
                 arg +=tmparg
             for j, v in enumerate(arg):
@@ -2640,9 +2645,9 @@ class ProcessExporterFortranMatchBox(Pro
             if(col_amps and isinstance(col_amps[0],list)):
                 col_amps=col_amps
             else:
-                raise MadGraph5Error, error_msg % 'col_amps'
+                raise MadGraph5Error(error_msg % 'col_amps')
         else:
-            raise MadGraph5Error, error_msg % 'col_amps'
+            raise MadGraph5Error(error_msg % 'col_amps')
 
         text = super(ProcessExporterFortranMatchBox, self).get_JAMP_lines(col_amps,
                                             JAMP_format=JAMP_format,
@@ -3211,8 +3216,8 @@ c     channel position
         nexternal, ninitial = matrix_element.get_nexternal_ninitial()
 
         if ninitial < 1 or ninitial > 2:
-            raise writers.FortranWriter.FortranWriterError, \
-                  """Need ninitial = 1 or 2 to write auto_dsig file"""
+            raise writers.FortranWriter.FortranWriterError( \
+                  """Need ninitial = 1 or 2 to write auto_dsig file""")
 
         replace_dict = {}
 
@@ -3901,7 +3906,7 @@ class ProcessExporterFortranME(ProcessEx
         if makejpg:
             try:
                 os.remove(pjoin(self.dir_path,'HTML','card.jpg'))
-            except Exception, error:
+            except Exception as error:
                 pass
             
             if misc.which('gs'):
@@ -4187,8 +4192,8 @@ class ProcessExporterFortranME(ProcessEx
                                                            p.get('color')>1])))
 
         if ninitial < 1 or ninitial > 2:
-            raise writers.FortranWriter.FortranWriterError, \
-                  """Need ninitial = 1 or 2 to write auto_dsig file"""
+            raise writers.FortranWriter.FortranWriterError( \
+                  """Need ninitial = 1 or 2 to write auto_dsig file""")
 
         replace_dict = {}
 
@@ -4995,8 +5000,8 @@ class ProcessExporterFortranMEGroup(Proc
         ncomb = matrix_elements[0].get_helicity_combinations()
         for me in matrix_elements[1:]:
             if ncomb!=me.get_helicity_combinations():
-                raise MadGraph5Error, "All grouped processes must share the "+\
-                                       "same number of helicity configurations."                
+                raise MadGraph5Error("All grouped processes must share the "+\
+                                       "same number of helicity configurations.")                
 
         filename = 'driver.f'
         self.write_driver(writers.FortranWriter(filename),ncomb,
@@ -5148,7 +5153,7 @@ class ProcessExporterFortranMEGroup(Proc
                 continue
             if nqcd_list[i] != nqcd_list[abs(sym_fact)-1]:
                 misc.sprint(i, sym_fact, nqcd_list[i], nqcd_list[abs(sym_fact)])
-                raise Exception, "identical diagram with different QCD powwer" 
+                raise Exception("identical diagram with different QCD powwer") 
                                       
         
 
@@ -5519,7 +5524,7 @@ class UFO_model_to_mg4(object):
                     continue
                 try:
                     lower_dict[lower_name].append(param)
-                except KeyError,error:
+                except KeyError as error:
                     lower_dict[lower_name] = [param]
                 else:
                     duplicate.add(lower_name)
@@ -6953,7 +6958,7 @@ def ExportV4Factory(cmd, noclean, output
                     ExporterClass=loop_exporters.LoopProcessExporterFortranMatchBox
                     MadLoop_SA_options['export_format'] = 'madloop_matchbox'
                 else:
-                    raise Exception, "output_type not recognize %s" % output_type
+                    raise Exception("output_type not recognize %s" % output_type)
             return ExporterClass(cmd._export_dir, MadLoop_SA_options)
         else:
             raise MadGraph5Error('MG5_aMC cannot find the \'loop_material\' directory'+\
@@ -7046,9 +7051,9 @@ def ExportV4Factory(cmd, noclean, output
                 return cmd._export_plugin(cmd._export_dir, opt)
 
         else:
-            raise Exception, 'Wrong export_v4 format'
+            raise Exception('Wrong export_v4 format')
     else:
-        raise MadGraph5Error, 'Output type %s not reckognized in ExportV4Factory.'
+        raise MadGraph5Error('Output type %s not reckognized in ExportV4Factory.')
     
             
 
@@ -7073,8 +7078,8 @@ class ProcessExporterFortranMWGroup(Proc
         other helper files."""
 
         if not isinstance(subproc_group, group_subprocs.SubProcessGroup):
-            raise base_objects.PhysicsObject.PhysicsObjectError,\
-                  "subproc_group object not SubProcessGroup"
+            raise base_objects.PhysicsObject.PhysicsObjectError(\
+                  "subproc_group object not SubProcessGroup")
 
         if not self.model:
             self.model = subproc_group.get('matrix_elements')[0].\
diff -rupN MadGraph_pristine/madgraph/iolibs/files.py ../contrib/MadGraph/madgraph/iolibs/files.py
--- MadGraph_pristine/madgraph/iolibs/files.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/files.py	2020-10-30 20:49:24.522460924 +1100
@@ -31,16 +31,16 @@ def read_from_file(filename, myfunct, *a
     returns None if something goes wrong. 
     """
     try:
-        sock = open(filename, 'r')
+        sock = open(filename, 'rb')
         try:
             ret_value = myfunct(sock, *args)
         finally:
             sock.close()
-    except IOError, (errno, strerror):
+    except IOError as e:
         if opt.has_key('print_error'):
             if not opt['print_error']:
                 return None
-        logger.error("I/O error on file %s (%s): %s" % (filename,errno, strerror))
+        logger.error("I/O error on file %s (%s): %s" % (filename,e.errno, e.strerror))
         return None
 
     return ret_value
@@ -55,14 +55,14 @@ def write_to_file(filename, myfunct, *ar
     """
 
     try:
-        sock = open(filename, 'w')
+        sock = open(filename, 'wb')
         try:
             ret_value = myfunct(sock, *args)
         finally:
             sock.close()
-    except IOError, (errno, strerror):
+    except IOError as e:
         if 'log' not in opts or opts['log']:
-            logger.error("I/O error (%s): %s" % (errno, strerror))
+            logger.error("I/O error (%s): %s" % (e.errno, e.strerror))
         return None
 
     return ret_value
@@ -82,8 +82,8 @@ def append_to_file(filename, myfunct, *a
             ret_value = myfunct(sock, *args)
         finally:
             sock.close()
-    except IOError, (errno, strerror):
-        logger.error("I/O error (%s): %s" % (errno, strerror))
+    except IOError as e:
+        logger.error("I/O error (%s): %s" % (e.errno, e.strerror))
         return None
 
     return ret_value
@@ -136,13 +136,13 @@ def cp(path1, path2, log=True, error=Fal
     path2 = format_path(path2)
     try:
         shutil.copy(path1, path2)
-    except IOError, why:
+    except IOError as why:
         import madgraph.various.misc as misc
         try: 
             if os.path.exists(path2):
                 path2 = os.path.join(path2, os.path.split(path1)[1])
             shutil.copytree(path1, path2)
-        except IOError, why:
+        except IOError as why:
             if error:
                 raise
             if log:
@@ -228,7 +228,7 @@ def ln(file_pos, starting_dir='.', name=
 
     try:
         os.symlink(target, os.path.join(starting_dir, name))
-    except Exception, error:
+    except Exception as error:
         if log:
             logger.debug(error)
             logger.warning('Could not link %s at position: %s' % (file_pos, \
diff -rupN MadGraph_pristine/madgraph/iolibs/file_writers.py ../contrib/MadGraph/madgraph/iolibs/file_writers.py
--- MadGraph_pristine/madgraph/iolibs/file_writers.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/file_writers.py	2020-10-30 20:49:24.522460924 +1100
@@ -19,6 +19,8 @@ Fortran, C++, etc."""
 
 import re
 import collections
+from io import FileIO
+
 try:
     import madgraph
 except ImportError:
@@ -26,7 +28,7 @@ except ImportError:
 else:
     import madgraph.various.misc as misc
 
-class FileWriter(file):
+class FileWriter(FileIO):
     """Generic Writer class. All writers should inherit from this class."""
 
     supported_preprocessor_commands = ['if']
@@ -50,7 +52,7 @@ class FileWriter(file):
     def __init__(self, name, opt = 'w'):
         """Initialize file to write to"""
 
-        return file.__init__(self, name, opt)
+        return FileIO.__init__(self, name, opt)
 
     def write_line(self, line):
         """Write a line with proper indent and splitting of long lines
@@ -100,6 +102,8 @@
                 splitlines.extend(line.split('\n'))
         elif isinstance(lines, str):
             splitlines.extend(lines.split('\n'))
+        elif isinstance(lines, unicode):
+            splitlines.extend((lines.encode('ascii')).split('\n'))
         else:
             raise self.FileWriterError("%s not string" % repr(lines))
 
@@ -148,8 +152,8 @@ class FileWriter(file):
             if preproc_command is None:
                 preproc_endif = self.preprocessor_endif_re.match(line[2:])
                 if len(if_stack)==0 or preproc_endif is None:
-                    raise self.FilePreProcessingError, 'Incorrect '+\
-                             'preprocessing command %s at line %d.'%(line,i)
+                    raise self.FilePreProcessingError('Incorrect '+\
+                             'preprocessing command %s at line %d.'%(line,i))
                 if preproc_endif.group('new_block') is None:
                     if_stack.pop()
                 elif preproc_endif.group('endif')=='else':
@@ -158,15 +162,15 @@ class FileWriter(file):
             elif preproc_command.group('command')=='if':
                 try:
                     if_stack.append(eval(preproc_command.group('body'))==True)
-                except Exception, e:
-                    raise self.FilePreProcessingError, 'Could not evaluate'+\
+                except Exception as e:
+                    raise self.FilePreProcessingError('Could not evaluate'+\
                       "python expression '%s' given the context %s provided."%\
                             (preproc_command.group('body'),str(context))+\
-                                           "\nLine %d of file %s."%(i,self.name)
+                                           "\nLine %d of file %s."%(i,self.name))
         
         if len(if_stack)>0:
-            raise self.FilePreProcessingError, 'Some conditional statements are'+\
-                                                     ' not properly terminated.'
+            raise self.FilePreProcessingError('Some conditional statements are'+\
+                                                     ' not properly terminated.')
         return res
 
 #===============================================================================
@@ -441,7 +445,7 @@ class FortranWriter(FileWriter):
                 else:
                     if not line.endswith('\n'):
                         line = '%s\n' % line
-                    file.writelines(self, line)
+                    FileIO.writelines(self, line)
             else:
                 removed.append(line)
                 
@@ -967,13 +971,13 @@ class PythonWriter(FileWriter):
     
     def write_comments(self, text):
         text = '#%s\n' % text.replace('\n','\n#')
-        file.write(self, text)
+        FileIO.write(self, text)
         
 class MakefileWriter(FileWriter):
     
     def write_comments(self, text):
         text = '#%s\n' % text.replace('\n','\n#')
-        file.write(self, text)
+        FileIO.write(self, text)
         
     def writelines(self, lines):
         """Extends the regular file.writeline() function to write out

diff -rupN MadGraph_pristine/madgraph/iolibs/group_subprocs.py ../contrib/MadGraph/madgraph/iolibs/group_subprocs.py
--- MadGraph_pristine/madgraph/iolibs/group_subprocs.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/group_subprocs.py	2020-10-30 20:49:24.522460924 +1100
@@ -93,8 +93,8 @@ class IdentifyConfigTag(diagram_generati
             # We go from next-to-last link to last link - remove propagator info
             return (old_vertex[0],)
         # We should not get here
-        raise diagram_generation.DiagramTag.DiagramTagError, \
-              "Error in IdentifyConfigTag, wrong setup of vertices in link."
+        raise diagram_generation.DiagramTag.DiagramTagError( \
+              "Error in IdentifyConfigTag, wrong setup of vertices in link.")
         
 #===============================================================================
 # SubProcessGroup
@@ -122,38 +122,38 @@ class SubProcessGroup(base_objects.Physi
 
         if name == 'number':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid int object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid int object" % str(value))
         if name == 'name':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid str object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid str object" % str(value))
         if name == 'amplitudes':
             if not isinstance(value, diagram_generation.AmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid amplitudelist" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid amplitudelist" % str(value))
         if name in ['mapping_diagrams', 'diagrams_for_configs']:
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
         if name == 'diagram_maps':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dict" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dict" % str(value))
         if name == 'matrix_elements':
             if not isinstance(value, helas_objects.HelasMatrixElementList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid HelasMatrixElementList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid HelasMatrixElementList" % str(value))
 
         if name == 'amplitude_map':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dict object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dict object" % str(value))
 
         if name == 'matrix_element_opts':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary object" % str(value))
 
         return True
 
@@ -197,8 +197,8 @@ class SubProcessGroup(base_objects.Physi
         in self"""
 
         if not self.get('amplitudes'):
-            raise self.PhysicsObjectError, \
-                  "Need amplitudes to generate matrix_elements"
+            raise self.PhysicsObjectError( \
+                  "Need amplitudes to generate matrix_elements")
 
         amplitudes = copy.copy(self.get('amplitudes'))
 
@@ -549,16 +549,16 @@ class DecayChainSubProcessGroup(SubProce
 
         if name == 'core_groups':
             if not isinstance(value, SubProcessGroupList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid core_groups" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid core_groups" % str(value))
         if name == 'decay_groups':
             if not isinstance(value, DecayChainSubProcessGroupList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid decay_groups" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid decay_groups" % str(value))
         if name == 'decay_chain_amplitudes':
             if not isinstance(value, diagram_generation.DecayChainAmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DecayChainAmplitudeList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DecayChainAmplitudeList" % str(value))
         return True
 
     def get_sorted_keys(self):
diff -rupN MadGraph_pristine/madgraph/iolibs/helas_call_writers.py ../contrib/MadGraph/madgraph/iolibs/helas_call_writers.py
--- MadGraph_pristine/madgraph/iolibs/helas_call_writers.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/helas_call_writers.py	2020-10-30 20:49:24.522460924 +1100
@@ -68,16 +68,16 @@ class HelasCallWriter(base_objects.Physi
 
         if name == 'model':
             if not isinstance(value, base_objects.Model):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a model" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a model" % type(value))
 
         if name == 'wavefunctions':
             # Should be a dictionary of functions returning strings, 
             # with keys (spins, flow state)
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dictionary for wavefunction" % \
-                                                                str(value)
+                                                                str(value))
 
             for key in value.keys():
                 self.add_wavefunction(key, value[key])
@@ -86,9 +86,9 @@ class HelasCallWriter(base_objects.Physi
             # Should be a dictionary of functions returning strings, 
             # with keys (spins, flow state)
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dictionary for amplitude" % \
-                                                                str(value)
+                                                                str(value))
 
             for key in value.keys():
                 self.add_amplitude(key, value[key])
@@ -286,7 +286,7 @@ class HelasCallWriter(base_objects.Physi
 
         try:
             call = self["amplitudes"][amplitude.get_call_key()]
-        except KeyError, error:
+        except KeyError as error:
             return ""
         else:
             return call(amplitude)
@@ -594,9 +594,9 @@ class FortranHelasCallWriter(HelasCallWr
         # If function not already existing, try to generate it.
 
         if len(wavefunction.get('mothers')) > 3:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                   """Automatic generation of Fortran wavefunctions not
-                  implemented for > 3 mothers"""
+                  implemented for > 3 mothers""")
 
         self.generate_helas_call(wavefunction)
         return super(FortranHelasCallWriter, self).get_wavefunction_call(\
@@ -615,9 +615,9 @@ class FortranHelasCallWriter(HelasCallWr
         # If function not already existing, try to generate it.
 
         if len(amplitude.get('mothers')) > 4:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                   """Automatic generation of Fortran amplitudes not
-                  implemented for > 4 mothers"""
+                  implemented for > 4 mothers""")
 
         self.generate_helas_call(amplitude)
         return super(FortranHelasCallWriter, self).get_amplitude_call(amplitude)
@@ -645,8 +645,8 @@ class FortranHelasCallWriter(HelasCallWr
         
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "get_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "get_helas_call must be called with wavefunction or amplitude")
 
         call = "CALL "
 
@@ -1085,8 +1085,8 @@ class FortranUFOHelasCallWriter(UFOHelas
 
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "generate_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "generate_helas_call must be called with wavefunction or amplitude")
         
         call = "CALL "
 
@@ -1255,8 +1255,8 @@ class FortranUFOHelasCallWriter(UFOHelas
                 elif lcutpart.get('spin')==2 or lcutpart.get('spin')==3:
                     res.append("DO I=1,4")
                 else:
-                    raise self.PhysicsObjectError, \
-                  "The L-cut particle type is not supported"
+                    raise self.PhysicsObjectError( \
+                  "The L-cut particle type is not supported")
                 # Temporarily relabel the 'me_id' attribute of the external wfs
                 # in this wavefunction's mothers so to have them matching the
                 # convention in the loop helas calls.
@@ -1495,8 +1495,8 @@ class FortranUFOHelasCallWriterOptimized
             
         if isinstance(argument, helas_objects.HelasAmplitude) and \
                                                   argument.get('type')=='loop':
-           raise MadGraph5Error, 'There should not be any helas call '+\
-                                'associated with helas amplitudes of type loop.'
+           raise MadGraph5Error( 'There should not be any helas call '+\
+                                'associated with helas amplitudes of type loop.')
 
         # Check if we need to append a charge conjugation flag
         l = [str(l) for l in argument.get('lorentz')]
@@ -1612,8 +1612,8 @@ class CPPUFOHelasCallWriter(UFOHelasCall
 
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "get_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "get_helas_call must be called with wavefunction or amplitude")
         
         call = ""
 
@@ -1742,8 +1742,8 @@ class PythonUFOHelasCallWriter(UFOHelasC
                                    and wf.get('spin') == 3 \
                                    and wf.get('mass').lower() == 'zero']
                 if not gauge_check_wfs:
-                    raise HelasWriterError, \
-                          'no massless spin one particle for gauge check'
+                    raise HelasWriterError( \
+                          'no massless spin one particle for gauge check')
                 gauge_check_wf = wfs.pop(wfs.index(gauge_check_wfs[0]))
                 res.append(self.generate_helas_call(gauge_check_wf, True)(\
                                                     gauge_check_wf))
@@ -1764,8 +1764,8 @@ class PythonUFOHelasCallWriter(UFOHelasC
 
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "get_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "get_helas_call must be called with wavefunction or amplitude")
         
         call_function = None
 
diff -rupN MadGraph_pristine/madgraph/iolibs/import_v4.py ../contrib/MadGraph/madgraph/iolibs/import_v4.py
--- MadGraph_pristine/madgraph/iolibs/import_v4.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/import_v4.py	2020-10-30 20:49:24.522460924 +1100
@@ -43,7 +43,7 @@ def import_model(model_path, mgme_dir =
     model_path_old = model_path
     try:
         model_path = find_model_path(model_path, mgme_dir, absolute)
-    except Exception, error:
+    except Exception as error:
         if not web:
             raise
         import models.import_ufo as import_ufo
@@ -64,8 +64,8 @@ def import_model(model_path, mgme_dir =
     for filepath in files_list:
         if not os.path.isfile(filepath):
             if not absolute:
-                raise InvalidCmd,  "%s directory is not a valid v4 model" % \
-                                                                    (model_path)
+                raise InvalidCmd("%s directory is not a valid v4 model" % \
+                                                                    (model_path))
             else:
                 return import_model(model_path_old, mgme_dir, False)
                                                                 
@@ -166,8 +166,8 @@ def read_particles_v4(fsock):
             values = line.split()
             if len(values) != 9:
                 # Not the right number tags on the line
-                raise ValueError, \
-                    "Unvalid initialization string:" + line
+                raise ValueError( \
+                    "Unvalid initialization string:" + line)
             else:
                 try:
                     mypart.set('name', values[0].lower())
@@ -180,15 +180,15 @@ def read_particles_v4(fsock):
                         mypart.set('spin',
                                    spin_equiv[values[2].lower()])
                     else:
-                        raise ValueError, "Invalid spin %s" % \
-                                values[2]
+                        raise ValueError( "Invalid spin %s" % \
+                                values[2])
 
                     if values[3].lower() in line_equiv.keys():
                         mypart.set('line',
                                    line_equiv[values[3].lower()])
                     else:
-                        raise ValueError, \
-                                "Invalid line type %s" % values[3]
+                        raise ValueError( \
+                                "Invalid line type %s" % values[3])
 
                     mypart.set("mass", values[4])
                     mypart.set("width", values[5])
@@ -197,8 +197,8 @@ def read_particles_v4(fsock):
                         mypart.set('color',
                                    color_equiv[values[6].lower()])
                     else:
-                        raise ValueError, \
-                            "Invalid color rep %s" % values[6]
+                        raise ValueError( \
+                            "Invalid color rep %s" % values[6])
 
                     #mypart.set("texname", values[7])
                     mypart.set("pdg_code", int(values[8]))
@@ -206,7 +206,7 @@ def read_particles_v4(fsock):
                     mypart.set('charge', 0.)
                     #mypart.set('antitexname', mypart.get('texname'))
 
-                except (Particle.PhysicsObjectError, ValueError), why:
+                except (Particle.PhysicsObjectError, ValueError) as why:
                     logger.warning("Warning: %s, particle ignored" % why)
                 else:
                     mypartlist.append(mypart)
@@ -225,8 +225,8 @@ def read_interactions_v4(fsock, ref_part
     myinterlist = InteractionList()
 
     if not isinstance(ref_part_list, ParticleList):
-        raise ValueError, \
-            "Object %s is not a valid ParticleList" % repr(ref_part_list)
+        raise ValueError( \
+            "Object %s is not a valid ParticleList" % repr(ref_part_list))
 
     for line in fsock:
         myinter = Interaction()
@@ -253,8 +253,8 @@ def read_interactions_v4(fsock, ref_part
                     else: break
 
                 if len(part_list) < 3:
-                    raise Interaction.PhysicsObjectError, \
-                        "Vertex with less than 3 known particles found."
+                    raise Interaction.PhysicsObjectError( \
+                        "Vertex with less than 3 known particles found.")
 
                 # Flip part/antipart of first part for FFV, FFS, FFT vertices
                 # according to v4 convention
@@ -432,7 +432,7 @@ def read_interactions_v4(fsock, ref_part
 
                 myinterlist.append(myinter)
 
-            except Interaction.PhysicsObjectError, why:
+            except Interaction.PhysicsObjectError as why:
                 logger.error("Interaction ignored: %s" % why)
 
     return myinterlist
diff -rupN MadGraph_pristine/madgraph/iolibs/save_load_object.py ../contrib/MadGraph/madgraph/iolibs/save_load_object.py
--- MadGraph_pristine/madgraph/iolibs/save_load_object.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/save_load_object.py	2020-10-30 20:49:24.522460924 +1100
@@ -16,7 +16,10 @@
 """Function to save any Python object to file."""
 
 import pickle
-import cPickle
+try:
+    import cPickle
+except:
+    import _pickle as cPickle
 
 from . import files as files
 
@@ -28,8 +31,8 @@ class SaveObjectError(Exception):
 def save_to_file(filename, object, log=True):
     """Save any Python object to file filename"""
 
-    if not isinstance(filename, basestring):
-        raise SaveObjectError, "filename must be a string"
+    if not isinstance(filename, str):
+        raise SaveObjectError("filename must be a string")
 
     files.write_to_file(filename, pickle_object, object, log=log)
 
@@ -39,7 +42,7 @@ def load_from_file(filename):
     """Save any Python object to file filename"""
 
     if not isinstance(filename, str):
-        raise SaveObjectError, "filename must be a string"
+        raise SaveObjectError("filename must be a string")
     return files.read_from_file(filename, unpickle_object)
     
 def pickle_object(fsock, object):
diff -rupN MadGraph_pristine/madgraph/iolibs/save_model.py ../contrib/MadGraph/madgraph/iolibs/save_model.py
--- MadGraph_pristine/madgraph/iolibs/save_model.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/save_model.py	2020-10-30 20:49:24.522460924 +1100
@@ -27,8 +27,8 @@ def save_particles(fsock, part_list):
     """Save particle objects contained in part_list in the stream fsock"""
 
     if not isinstance(part_list, base_objects.ParticleList):
-        raise ValueError, \
-            "Object %s is not a valid ParticleList" % repr(part_list)
+        raise ValueError( \
+            "Object %s is not a valid ParticleList" % repr(part_list))
 
     fsock.write("particles = [\n")
 
@@ -44,8 +44,8 @@ def save_interactions(fsock, inter_list)
     """Save interaction objects contained in inter_list in the stream fsock"""
 
     if not isinstance(inter_list, base_objects.InteractionList):
-        raise ValueError, \
-            "Object %s is not a valid InteractionList" % repr(inter_list)
+        raise ValueError( \
+            "Object %s is not a valid InteractionList" % repr(inter_list))
 
     fsock.write("interactions = [\n")
 
@@ -61,31 +61,31 @@ def save_model(path, model):
     """Save a full model in directory path (try to create if necessary)."""
 
     if not isinstance(model, base_objects.Model):
-        raise ValueError, \
-            "Object %s is not a valid Model" % repr(model)
+        raise ValueError( \
+            "Object %s is not a valid Model" % repr(model))
 
     if not isinstance(path, str):
-        raise ValueError, \
-            "Object %s is not a path string" % repr(path)
+        raise ValueError( \
+            "Object %s is not a path string" % repr(path))
 
     if not os.path.isdir(path):
         logger.warning("Path %s does not exist, try to make it..." % str(path))
         try:
             os.mkdir(path)
-        except IOError, (errno, strerror):
-            logger.error("I/O error (%s): %s" % (errno, strerror))
+        except IOError as e :
+            logger.error("I/O error (%s): %s" % (e.errno, e.strerror))
             return None
 
-    print "Saving particles...",
+    print("Saving particles...",
     files.write_to_file(os.path.join(path, 'particles.py'),
                         save_particles,
-                        model['particles'])
-    print "%i particles saved to %s" % (len(model['particles']),
-                                      os.path.join(path, 'particles.py'))
+                        model['particles']))
+    print("%i particles saved to %s" % (len(model['particles']),
+                                      os.path.join(path, 'particles.py')))
 
-    print "Saving interactions...",
+    print("Saving interactions...",
     files.write_to_file(os.path.join(path, 'interactions.py'),
                         save_interactions,
-                        model['interactions'])
-    print "%i interactions saved to %s" % (len(model['interactions']),
-                                      os.path.join(path, 'interactions.py'))
+                        model['interactions']))
+    print("%i interactions saved to %s" % (len(model['interactions']),
+                                      os.path.join(path, 'interactions.py')))
diff -rupN MadGraph_pristine/madgraph/iolibs/template_files/__init__.py ../contrib/MadGraph/madgraph/iolibs/template_files/__init__.py
--- MadGraph_pristine/madgraph/iolibs/template_files/__init__.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/template_files/__init__.py	2020-10-30 20:49:24.522460924 +1100
@@ -1,2 +1,2 @@
-import mg4_proc_card
+from .mg4_proc_card import *
 
diff -rupN MadGraph_pristine/madgraph/iolibs/ufo_expression_parsers.py ../contrib/MadGraph/madgraph/iolibs/ufo_expression_parsers.py
--- MadGraph_pristine/madgraph/iolibs/ufo_expression_parsers.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/ufo_expression_parsers.py	2020-10-30 20:49:24.522460924 +1100
@@ -924,17 +924,17 @@ class UFOExpressionParserPythonIF(UFOExp
                 try:
                     self.defined_variables = eval(args[0])
                 except:
-                    raise ModelError, 'The expression "%s"'%str(args[0])+\
+                    raise ModelError('The expression "%s"'%str(args[0])+\
                       " given as defined variables for the UFOExpressionParserPythonIF"+\
-                      " does not have a correct syntax."
+                      " does not have a correct syntax.")
                 if not isinstance(self.defined_variables, dict):
-                    raise ModelError, 'The argument "%s"'%str(args[0])+\
+                    raise ModelError('The argument "%s"'%str(args[0])+\
                       " given as defined variables for the UFOExpressionParserPythonIF"+\
-                      " is not a dictionary."
+                      " is not a dictionary.")
             else:
-                raise ModelError, "The argument %s"%str(args[0])+\
+                raise ModelError("The argument %s"%str(args[0])+\
                       " given as defined variables for the UFOExpressionParserPythonIF"+\
-                      " must be either a dictionary or a string."
+                      " must be either a dictionary or a string.")
             args = args[1:]
             for key, value in self.defined_variables.items():
                 if not isinstance(key,str) or \
@@ -1052,7 +1052,7 @@ class UFOExpressionParserPythonIF(UFOExp
 if __name__ == '__main__':
     
     if len(sys.argv) == 1:
-        print "Please specify a parser: fortran, mpfortran or c++"
+        print("Please specify a parser: fortran, mpfortran or c++")
         exit()
     if sys.argv[1] == "fortran":
         calc = UFOExpressionParserFortran()
@@ -1068,10 +1068,10 @@ if __name__ == '__main__':
         else:
             calc = UFOExpressionParserPythonIF()
     else:
-        print "Please specify a parser: fortran, mpfortran, c++ or pythonif"
-        print "You gave", sys.argv[1]
+        print("Please specify a parser: fortran, mpfortran, c++ or pythonif")
+        print("You gave", sys.argv[1])
         if len(sys.argv) > 2:
-            print "with the second argument",sys.argv[2]
+            print("with the second argument",sys.argv[2])
         exit()
 
     while 1:
@@ -1080,5 +1080,5 @@ if __name__ == '__main__':
         except EOFError:
             break
         if not s: continue
-        print calc.parse(s)
+        print(calc.parse(s))
     
diff -rupN MadGraph_pristine/madgraph/loop/loop_base_objects.py ../contrib/MadGraph/madgraph/loop/loop_base_objects.py
--- MadGraph_pristine/madgraph/loop/loop_base_objects.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_base_objects.py	2020-10-30 20:49:24.522460924 +1100
@@ -88,48 +88,48 @@ class LoopDiagram(base_objects.Diagram):
 
         if name == 'tag':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid tag" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid tag" % str(value))
             else:
                 for item in value:
                     if (len(item)!=3 or \
                       not isinstance(item[0],base_objects.Leg) or \
                       not isinstance(item[1],list)) or \
                       not isinstance(item[2],base_objects.Vertex):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid tag" % str(value)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid tag" % str(value))
 
         if name == 'canonical_tag':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid tag" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid tag" % str(value))
             else:
                 for item in value:
                     if (len(item)!=3 or not isinstance(item[0],int) or \
                       not isinstance(item[1],list)) or \
                       not isinstance(item[2],int):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid canonical_tag" % str(value)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid canonical_tag" % str(value))
 
         if name == 'CT_vertices':
             if not isinstance(value, base_objects.VertexList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid VertexList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid VertexList object" % str(value))
 
         if name == 'type':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
 
         if name == 'multiplier':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
 
         if name == 'contracted_diagram':
             if not isinstance(value, base_objects.Diagram):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Diagram." % str(value)                            
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid Diagram." % str(value))                            
 
         else:
             super(LoopDiagram, self).filter(name, value)
@@ -206,9 +206,9 @@ class LoopDiagram(base_objects.Diagram):
         # Without the tagging information we will have to reconstruct the
         # contracted diagrams with the unordered vertices
         if len(self.get('vertices'))==0:
-            raise MadGraph5Error, "Function get_contracted_loop_diagram()"+\
+            raise MadGraph5Error("Function get_contracted_loop_diagram()"+\
                 "called for the first time without specifying struct_rep "+\
-                                            "for a diagram already tagged."
+                                            "for a diagram already tagged.")
                                 
         # The leg below will be the outgoing one 
         contracted_vertex_last_loop_leg = None
@@ -635,8 +635,8 @@ class LoopDiagram(base_objects.Diagram):
             start=start_in.get('number')
             end=end_in.get('number')
         else:
-            raise MadGraph5Error, "In the diagram tag function, 'start' and "+\
-                " 'end' must be either integers or Leg objects." 
+            raise MadGraph5Error("In the diagram tag function, 'start' and "+\
+                " 'end' must be either integers or Leg objects." )
         
         if self.process_next_loop_leg(struct_rep,-1,-1,start,end,\
                                           loopVertexList, model, external_legs):
@@ -657,8 +657,8 @@ class LoopDiagram(base_objects.Diagram):
                 canonical_tag=self.choose_optimal_lcut(self['tag'],struct_rep, 
                                                            model, external_legs)
             else:
-                raise MadGraph5Error, 'The cutting method %s is not implemented.'\
-                                                            %self.cutting_method
+                raise MadGraph5Error('The cutting method %s is not implemented.'\
+                                                            %self.cutting_method)
             # The tag of the diagram is now updated with the canonical tag
             self['tag']=canonical_tag
             # We assign here the loopVertexList to the list of vertices 
@@ -674,8 +674,8 @@ class LoopDiagram(base_objects.Diagram):
             self['canonical_tag']=[[t[0]['id'],t[1],t[2]] for t in canonical_tag]
             return True
         else:
-            raise self.PhysicsObjectError, \
-                  "Loop diagram tagging failed."
+            raise self.PhysicsObjectError( \
+                  "Loop diagram tagging failed.")
             return False
 
 
@@ -717,9 +717,9 @@ class LoopDiagram(base_objects.Diagram):
                     # Now we can add the corresponding vertex
                     return base_objects.Vertex({'legs':myleglist,'id':vertID})
         else:
-            raise cls.PhysicsObjectError, \
+            raise cls.PhysicsObjectError( \
             "An interaction from the original L-cut diagram could"+\
-            " not be found when reconstructing the loop vertices."
+            " not be found when reconstructing the loop vertices.")
 
     def process_next_loop_leg(self, structRep, fromVert, fromPos, currLeg, \
                                   endLeg, loopVertexList, model, external_legs):
@@ -748,8 +748,8 @@ class LoopDiagram(base_objects.Diagram):
                                self['vertices'][i].get('legs')[k],FDStruct)
 
             if not canonical:
-                raise self.PhysicsObjectError, \
-                      "Failed to reconstruct a FDStructure."
+                raise self.PhysicsObjectError( \
+                      "Failed to reconstruct a FDStructure.")
             
             # The branch was directly an external leg, so it the canonical
             # repr of this struct is simply ((legID),0).
@@ -758,8 +758,8 @@ class LoopDiagram(base_objects.Diagram):
             elif isinstance(canonical,tuple):
                 FDStruct.set('canonical',canonical)
             else:                                      
-                raise self.PhysicsObjectError, \
-                "Non-proper behavior of the construct_FDStructure function"
+                raise self.PhysicsObjectError( \
+                "Non-proper behavior of the construct_FDStructure function")
             
             # First check if this structure exists in the dictionary of the
             # structures already obtained in the diagrams for this process
@@ -858,8 +858,8 @@ class LoopDiagram(base_objects.Diagram):
                                 nextLoopLeg=self['vertices'][i].get('legs')[k]
                                 legPos=pos
                             else:
-                                raise self.PhysicsObjectError, \
-                                  " An interaction has more than two loop legs."
+                                raise self.PhysicsObjectError( \
+                                  " An interaction has more than two loop legs.")
                         else:
                             process_loop_interaction(i,j,k,pos)
                     # Now that we have found loop leg curr_leg, we can get out 
@@ -1135,8 +1135,8 @@ class LoopDiagram(base_objects.Diagram):
                 branch=self.construct_FDStructure(i, legPos, \
                               self['vertices'][vertID].get('legs')[k], FDStruct)
                 if not branch:
-                    raise self.PhysicsObjectError, \
-                          "Failed to reconstruct a FDStructure."
+                    raise self.PhysicsObjectError( \
+                          "Failed to reconstruct a FDStructure.")
                 # That means that this branch was an external leg. 
                 if isinstance(branch,int):
                     parentBuffer[0].append(branch)
@@ -1146,8 +1146,8 @@ class LoopDiagram(base_objects.Diagram):
                     parentBuffer[0]+=list(branch[0][0])
                     vertBuffer.append(branch)
                 else:
-                    raise self.PhysicsObjectError, \
-                    "Non-proper behavior of the construct_FDStructure function"
+                    raise self.PhysicsObjectError( \
+                    "Non-proper behavior of the construct_FDStructure function")
             return legPos
 
         # == Beginning of the code ==
@@ -1193,8 +1193,8 @@ class LoopDiagram(base_objects.Diagram):
                 FDStruct.get('external_legs').append(copy.copy(currLeg))
                 return currLeg.get('number')
             else:
-                raise self.PhysicsObjectError, \
-                                  " A structure is malformed."
+                raise self.PhysicsObjectError( \
+                                  " A structure is malformed.")
         else:
             # In this case a vertex with currLeg has been found and we must
             # return the list of tuple described above. First let's sort the 
@@ -1360,23 +1360,23 @@ class LoopUVCTDiagram(base_objects.Diagr
 
         if name == 'UVCT_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             else:
                 for elem in value:
                     if not isinstance(elem, str) and not isinstance(elem, int):
-                        raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                        raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
         
         if name == 'UVCT_orders':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))
 
         if name == 'type':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
         
         else:
             super(LoopUVCTDiagram, self).filter(name, value)
@@ -1474,14 +1474,14 @@ class LoopModel(base_objects.Model):
 
         if name == 'perturbation_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a list" % \
-                                                            type(value)
+                                                            type(value))
             for order in value:
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                         "Object of type %s is not a string" % \
-                                                            type(order)
+                                                            type(order))
         else:
             super(LoopModel,self).filter(name,value)
         
@@ -1534,9 +1534,9 @@ class DGLoopLeg(base_objects.Leg):
 
         if name == 'depth':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a int" % \
-                                                            type(value)
+                                                            type(value))
         else:
             super(DGLoopLeg,self).filter(name,value)
         
@@ -1587,33 +1587,33 @@ class FDStructure(base_objects.PhysicsOb
 
         if name == 'vertices':
             if not isinstance(value, base_objects.VertexList):
-                raise self.PhysicsObjectError, \
-        "%s is not a valid VertexList object" % str(value)
+                raise self.PhysicsObjectError( \
+        "%s is not a valid VertexList object" % str(value))
 
         if name == 'id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-        "id %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+        "id %s is not an integer" % repr(value))
 
         if name == 'weight':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-        "weight %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+        "weight %s is not an integer" % repr(value))
 
         if name == 'external_legs':
             if not isinstance(value, base_objects.LegList):
-                raise self.PhysicsObjectError, \
-        "external_legs %s is not a valid Leg List" % str(value)
+                raise self.PhysicsObjectError( \
+        "external_legs %s is not a valid Leg List" % str(value))
 
         if name == 'binding_leg':
             if not isinstance(value, base_objects.Leg):
-                raise self.PhysicsObjectError, \
-        "binding_leg %s is not a valid Leg" % str(value)
+                raise self.PhysicsObjectError( \
+        "binding_leg %s is not a valid Leg" % str(value))
 
         if name == 'canonical':
             if not isinstance(value, tuple):
-                raise self.PhysicsObjectError, \
-        "canonical %s is not a valid tuple" % str(value)
+                raise self.PhysicsObjectError( \
+        "canonical %s is not a valid tuple" % str(value))
 
         return True
     
@@ -1693,9 +1693,9 @@ class FDStructure(base_objects.PhysicsOb
         ref_dict_to1 = model.get('ref_dict_to1')
 
         if not tag:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
         "The canonical tag of the FD structure is not set yet, so that the "+\
-        "reconstruction of the vertices cannot be performed."
+        "reconstruction of the vertices cannot be performed.")
 
         # Create a local copy of the external legs
         leglist = copy.deepcopy(external_legs)
@@ -1783,9 +1783,9 @@ class FDStructure(base_objects.PhysicsOb
                 tag.pop(0)
 
             else:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
         "The canonical tag of the FD structure is corrupted because one "+\
-        "interaction does not exist."
+        "interaction does not exist.")
 
 #===============================================================================
 # FDStructureList
@@ -1814,9 +1814,9 @@ class FDStructureList(base_objects.Physi
                     return FDStruct
             return None
         else:
-            raise self.PhysicsObjectListError, \
+            raise self.PhysicsObjectListError( \
               "The ID %s specified for get_struct is not an integer or tuple"%\
-                                                                    repr(object)
+                                                                    repr(object))
 
     def nice_string(self):
         """Returns a nicely formatted string"""
diff -rupN MadGraph_pristine/madgraph/loop/loop_color_amp.py ../contrib/MadGraph/madgraph/loop/loop_color_amp.py
--- MadGraph_pristine/madgraph/loop/loop_color_amp.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_color_amp.py	2020-10-30 20:49:24.522460924 +1100
@@ -67,8 +67,8 @@ class LoopColorBasis(color_amp.ColorBasi
               [color_algebra.Tr(lcut_numbers[1],lcut_numbers[0])],
               fractions.Fraction(2, 1))
         else:
-            raise color_amp.ColorBasis.ColorBasisError, \
-        "L-cut particle has an unsupported color representation %s" % lcut_charge
+            raise color_amp.ColorBasis.ColorBasisError( \
+        "L-cut particle has an unsupported color representation %s" % lcut_charge)
 
         # Append it to all color strings for this diagram.
         for CS in colorize_dict.values():
@@ -110,8 +110,8 @@ class LoopColorBasis(color_amp.ColorBasi
         list_color_dict = []
         
         if not isinstance(amplitude,loop_diagram_generation.LoopAmplitude):
-            raise color_amp.ColorBasis.ColorBasisError, \
-              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude'
+            raise color_amp.ColorBasis.ColorBasisError( \
+              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude')
         for diagram in amplitude.get('loop_diagrams'):
 
             colorize_dict = self.colorize(diagram,
@@ -147,8 +147,8 @@ class LoopColorBasis(color_amp.ColorBasi
         list_color_dict = []
 
         if not isinstance(amplitude,loop_diagram_generation.LoopAmplitude):
-            raise color_amp.ColorBasis.ColorBasisError, \
-              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude'
+            raise color_amp.ColorBasis.ColorBasisError( \
+              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude')
 
         for diagram in amplitude.get('born_diagrams'):
             colorize_dict = self.colorize(diagram,
diff -rupN MadGraph_pristine/madgraph/loop/loop_diagram_generation.py ../contrib/MadGraph/madgraph/loop/loop_diagram_generation.py
--- MadGraph_pristine/madgraph/loop/loop_diagram_generation.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_diagram_generation.py	2020-10-30 20:49:24.522460924 +1100
@@ -104,37 +104,37 @@ class LoopAmplitude(diagram_generation.A
 
         if name == 'diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DiagramList" % str(value))
             for diag in value:
                 if not isinstance(diag,loop_base_objects.LoopDiagram) and \
                    not isinstance(diag,loop_base_objects.LoopUVCTDiagram):
-                    raise self.PhysicsObjectError, \
-                        "%s contains a diagram which is not an NLODiagrams." % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s contains a diagram which is not an NLODiagrams." % str(value))
         if name == 'born_diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DiagramList" % str(value))
             for diag in value:
                 if not isinstance(diag,loop_base_objects.LoopDiagram):
-                    raise self.PhysicsObjectError, \
-                        "%s contains a diagram which is not an NLODiagrams." % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s contains a diagram which is not an NLODiagrams." % str(value))
         if name == 'loop_diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DiagramList" % str(value))
             for diag in value:
                 if not isinstance(diag,loop_base_objects.LoopDiagram):
-                    raise self.PhysicsObjectError, \
-                        "%s contains a diagram which is not an NLODiagrams." % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s contains a diagram which is not an NLODiagrams." % str(value))
         if name == 'has_born':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
         if name == 'structure_repository':
             if not isinstance(value, loop_base_objects.FDStructureList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
 
         else:
             super(LoopAmplitude, self).filter(name, value)
@@ -329,8 +329,8 @@ class LoopAmplitude(diagram_generation.A
         n_discarded = 0
         for diag in self['loop_diagrams']:
             if diag.get('tag')==[]:
-                raise MadGraph5Error, "The loop diagrams should have been tagged"+\
-                  " before going through the Furry filter."
+                raise MadGraph5Error("The loop diagrams should have been tagged"+\
+                  " before going through the Furry filter.")
             
             loop_line_pdgs = diag.get_loop_lines_pdgs()
             attached_pdgs   = diag.get_pdgs_attached_to_loop(structs)
@@ -402,8 +402,8 @@ class LoopAmplitude(diagram_generation.A
         i=0
         for diag in self['loop_diagrams']:
             if diag.get('tag')==[]:
-                raise MadGraph5Error, "Before using the user_filter, please "+\
-                       "make sure that the loop diagrams have been tagged first."
+                raise MadGraph5Error("Before using the user_filter, please "+\
+                       "make sure that the loop diagrams have been tagged first.")
             valid_diag = True
             i=i+1
     
diff -rupN MadGraph_pristine/madgraph/loop/loop_exporters.py ../contrib/MadGraph/madgraph/loop/loop_exporters.py
--- MadGraph_pristine/madgraph/loop/loop_exporters.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_exporters.py	2020-10-30 20:49:24.522460924 +1100
@@ -167,7 +167,7 @@ class LoopExporterFortran(object):
                 
                 if not os.path.exists(os.path.join(self.cuttools_dir,
                                                       'includects','libcts.a')):            
-                    raise MadGraph5Error,"CutTools could not be correctly compiled."
+                    raise MadGraph5Error("CutTools could not be correctly compiled.")
     
             # Create the links to the lib folder
             linkfiles = ['libcts.a', 'mpmodule.mod']
@@ -665,9 +665,9 @@ CF2PY CHARACTER*20, intent(out) :: PREFI
             if(col_amps and isinstance(col_amps[0],list)):
                 color_amplitudes=col_amps
             else:
-                raise MadGraph5Error, "Incorrect col_amps argument passed to get_amp_to_jamp_map"
+                raise MadGraph5Error( "Incorrect col_amps argument passed to get_amp_to_jamp_map")
         else:
-            raise MadGraph5Error, "Incorrect col_amps argument passed to get_amp_to_jamp_map"
+            raise MadGraph5Error("Incorrect col_amps argument passed to get_amp_to_jamp_map")
         
         # To store the result
         res_list = [[] for i in range(n_amps)]
@@ -874,8 +874,8 @@ CF2PY CHARACTER*20, intent(out) :: PREFI
         logger.info('Creating files in directory %s' % dirpath)
 
         if unique_id is None:
-            raise MadGraph5Error, 'A unique id must be provided to the function'+\
-                     'generate_loop_subprocess of LoopProcessExporterFortranSA.'
+            raise MadGraph5Error('A unique id must be provided to the function'+\
+                     'generate_loop_subprocess of LoopProcessExporterFortranSA.')
         # Create an include with the unique consecutive ID assigned
         open('unique_id.inc','w').write(
 """      integer UNIQUE_ID
@@ -1080,13 +1080,13 @@ CF2PY CHARACTER*20, intent(out) :: PREFI
         # Create the necessary files for the loop matrix element subroutine
         
         if config_map:
-            raise MadGraph5Error, 'The default loop output cannot be used with'+\
-              'MadEvent and cannot compute the AMP2 for multi-channeling.'
+            raise MadGraph5Error('The default loop output cannot be used with'+\
+              'MadEvent and cannot compute the AMP2 for multi-channeling.')
 
         if not isinstance(fortran_model,\
           helas_call_writers.FortranUFOHelasCallWriter):
-            raise MadGraph5Error, 'The loop fortran output can only'+\
-              ' work with a UFO Fortran model'
+            raise MadGraph5Error('The loop fortran output can only'+\
+              ' work with a UFO Fortran model')
         
         LoopFortranModel = helas_call_writers.FortranUFOHelasCallWriter(
                      argument=fortran_model.get('model'),
@@ -1123,7 +1123,7 @@ CF2PY CHARACTER*20, intent(out) :: PREFI
                    '\n'.join(['DO I=1,NBORNAMPS','DPAMP(I,H)=AMP(I,H)','ENDDO'])
         
         if writer:
-            raise MadGraph5Error, 'Matrix output mode no longer supported.'
+            raise MadGraph5Error('Matrix output mode no longer supported.')
         
         filename = 'loop_matrix.f'
         calls = self.write_loopmatrix(writers.FortranWriter(filename),
@@ -1818,7 +1818,7 @@ class LoopProcessOptimizedExporterFortra
             context['%s_available'%tir]=self.tir_available_dict[tir]
             # safety check
             if tir not in ['golem','pjfry','iregi','samurai','ninja','collier']:
-                raise MadGraph5Error,"%s was not a TIR currently interfaced."%tir_name
+                raise MadGraph5Error("%s was not a TIR currently interfaced."%tir_name)
 
         return context
 
@@ -2075,12 +2075,12 @@ class LoopProcessOptimizedExporterFortra
         # Warn the user that the 'matrix' output where all relevant code is
         # put together in a single file is not supported in this loop output.
         if writer:
-            raise MadGraph5Error, 'Matrix output mode no longer supported.'
+            raise MadGraph5Error('Matrix output mode no longer supported.')
         
         if not isinstance(fortran_model,\
           helas_call_writers.FortranUFOHelasCallWriter):
-            raise MadGraph5Error, 'The optimized loop fortran output can only'+\
-              ' work with a UFO Fortran model'
+            raise MadGraph5Error('The optimized loop fortran output can only'+\
+              ' work with a UFO Fortran model')
         OptimizedFortranModel=\
           helas_call_writers.FortranUFOHelasCallWriterOptimized(\
           fortran_model.get('model'),False)
@@ -3209,8 +3209,8 @@ class LoopInducedExporterME(LoopProcessO
     def get_amp2_lines(self, *args, **opts):
         """Make sure the function is implemented in the daughters"""
 
-        raise NotImplemented, 'The function get_amp2_lines must be called in '+\
-                                       ' the daugthers of LoopInducedExporterME'
+        raise NotImplemented('The function get_amp2_lines must be called in '+\
+                                       ' the daugthers of LoopInducedExporterME')
 
 #===============================================================================
 # LoopInducedExporterMEGroup
@@ -3290,8 +3290,8 @@ class LoopInducedExporterMEGroup(LoopInd
         """
 
         if not config_map:
-            raise MadGraph5Error, 'A multi-channeling configuration map is '+\
-              ' necessary for the MadEvent Loop-induced output with grouping.'
+            raise MadGraph5Error('A multi-channeling configuration map is '+\
+              ' necessary for the MadEvent Loop-induced output with grouping.')
 
         nexternal, ninitial = matrix_element.get_nexternal_ninitial()
 
@@ -3450,8 +3450,8 @@ class LoopInducedExporterMENoGroup(LoopI
         """Return the amp2(i) = sum(amp for diag(i))^2 lines"""
 
         if config_map:
-            raise MadGraph5Error, 'A configuration map should not be specified'+\
-                              ' for the Loop induced exporter without grouping.'
+            raise MadGraph5Error('A configuration map should not be specified'+\
+                              ' for the Loop induced exporter without grouping.')
 
         nexternal, ninitial = matrix_element.get_nexternal_ninitial()
         # Get minimum legs in a vertex
diff -rupN MadGraph_pristine/madgraph/loop/loop_helas_objects.py ../contrib/MadGraph/madgraph/loop/loop_helas_objects.py
--- MadGraph_pristine/madgraph/loop/loop_helas_objects.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_helas_objects.py	2020-10-30 20:49:24.526460910 +1100
@@ -79,22 +79,22 @@ class LoopHelasUVCTAmplitude(helas_objec
 
         if name=='UVCT_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list for UVCT_couplings" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list for UVCT_couplings" % str(value))
             for id in value:
                 if not isinstance(id, str) and not isinstance(id, int):
-                    raise self.PhysicsObjectError, \
-                      "%s is not a valid string or integer for UVCT_couplings" % str(value)
+                    raise self.PhysicsObjectError( \
+                      "%s is not a valid string or integer for UVCT_couplings" % str(value))
                       
         if name == 'UVCT_orders':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))
 
         if name == 'type':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
 
         else:
             return super(LoopHelasUVCTAmplitude,self).filter(name, value)
@@ -279,22 +279,22 @@ class LoopHelasAmplitude(helas_objects.H
 
         if name=='wavefunctions':
             if not isinstance(value, helas_objects.HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list of HelasWaveFunctions" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list of HelasWaveFunctions" % str(value))
             for wf in value:
                 if not wf['is_loop']:
-                    raise self.PhysicsObjectError, \
-                      "Wavefunctions from a LoopHelasAmplitude must be from a loop."
+                    raise self.PhysicsObjectError( \
+                      "Wavefunctions from a LoopHelasAmplitude must be from a loop.")
         
         elif name=='amplitudes':
             if not isinstance(value, helas_objects.HelasAmplitudeList):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list of HelasAmplitudes" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list of HelasAmplitudes" % str(value))
 
         elif name in ['type','loop_group_id','multiplier','loopsymmetryfactor']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid integer for the attribute '%s'" %(str(value),name)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid integer for the attribute '%s'" %(str(value),name))
 
         else:
             return super(LoopHelasAmplitude,self).filter(name, value)
@@ -332,9 +332,9 @@ class LoopHelasAmplitude(helas_objects.H
         final_lwf=[lwf for lwf in self.get('amplitudes')[0].get('mothers') if \
                    lwf.get('mothers')]
         if len(final_lwf)!=1:
-            raise MadGraph5Error, 'The helas amplitude building the helas loop'+\
+            raise MadGraph5Error( 'The helas amplitude building the helas loop'+\
                 ' amplitude should be made of exactly one loop wavefunctions'+\
-                ' with mothers.'
+                ' with mothers.')
         return final_lwf[0]
 
     def get_base_diagram(self, wf_dict, vx_list = [], optimization = 1):
@@ -628,19 +628,19 @@ class LoopHelasMatrixElement(helas_objec
         
         if name=='born_color_basis' or name=='loop_color_basis':
             if not isinstance(value,color_amp.ColorBasis):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid color basis" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid color basis" % str(value))
         elif name=='loop_groups':
             if not isinstance(value,list):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list"%str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list"%str(value))
             for (dkey, dvalue) in value:
                 if not isinstance(dvalue,helas_objects.HelasAmplitudeList):
-                    raise self.PhysicsObjectError, \
-                      "%s is not a valid HelasAmplitudeList."%str(dvalue)
+                    raise self.PhysicsObjectError( \
+                      "%s is not a valid HelasAmplitudeList."%str(dvalue))
                 if not isinstance(dkey,tuple):
-                    raise self.PhysicsObjectError, \
-                      "%s is not a valid tuple."%str(dkey)
+                    raise self.PhysicsObjectError( \
+                      "%s is not a valid tuple."%str(dkey))
         else:
             return super(LoopHelasMatrixElement,self).filter(name, value)
 
@@ -1465,9 +1465,9 @@ class LoopHelasMatrixElement(helas_objec
                 for last_loop_wf, color_list in zip(last_loop_wfs,color_lists):
                     # Now generate HelasAmplitudes from the last vertex.
                     if lastvx.get('id')!=-1:
-                        raise self.PhysicsObjectError, \
+                        raise self.PhysicsObjectError( \
                           "The amplitude vertex of a loop diagram must be a "+\
-                          "two point vertex with id=-1" 
+                          "two point vertex with id=-1") 
                     # skip the boson and Dirac fermions
                     # adjust the fermion flow of external majorana loop wfs
                     if other_external_loop_wf.is_majorana():
@@ -1543,21 +1543,21 @@ class LoopHelasMatrixElement(helas_objec
                 if lcut_wf1.is_boson():
                     if lcut_wf1.get('state')!='final' or\
                             lcut_wf2.get('state')!='final':
-                        raise MadGraph5Error,\
-                            "Inconsistent flow in L-cut bosons."
+                        raise MadGraph5Error(\
+                            "Inconsistent flow in L-cut bosons.")
                 elif not lcut_wf1.is_majorana():
                     for lcut_wf in [lcut_wf1,lcut_wf2]:
                         if not ((lcut_wf.get('is_part') and \
                                      lcut_wf.get('state')=='outgoing') or\
                                     (not lcut_wf.get('is_part') and\
                                          lcut_wf.get('state')=='incoming')):
-                            raise MadGraph5Error,\
-                                "Inconsistent flow in L-cut Dirac fermions."
+                            raise MadGraph5Error(\
+                                "Inconsistent flow in L-cut Dirac fermions.")
                 elif lcut_wf1.is_majorana():
                     if (lcut_wf1.get('state'), lcut_wf2.get('state')) not in \
                             [('incoming','outgoing'),('outgoing','incoming')]:
-                        raise MadGraph5Error,\
-                            "Inconsistent flow in L-cut Majorana fermions."
+                        raise MadGraph5Error(\
+                            "Inconsistent flow in L-cut Majorana fermions.")
                             
             def fix_lcut_majorana_fermion_flow(last_loop_wf,\
                                                other_external_loop_wf):
@@ -2388,8 +2388,8 @@ class LoopHelasMatrixElement(helas_objec
         """ Just to forbid the usage of this generic function in a
         LoopHelasMatrixElement"""
 
-        raise self.PhysicsObjectError, \
-            "Usage of get_color_amplitudes is not allowed in a LoopHelasMatrixElement"
+        raise self.PhysicsObjectError( \
+            "Usage of get_color_amplitudes is not allowed in a LoopHelasMatrixElement")
 
     def get_born_color_amplitudes(self):
         """Return a list of (coefficient, amplitude number) lists,
@@ -2456,12 +2456,12 @@ class LoopHelasMatrixElement(helas_objec
                           tuple(amp.get('color_indices')) == diag_tuple[1],
                           LoopDiagramsHelasAmplitudeList[diag_tuple[0]])
                 if not res_amps:
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                           """No amplitude found for color structure
                             %s and color index chain (%s) (diagram %i)""" % \
                             (col_basis_elem,
                              str(diag_tuple[1]),
-                             diag_tuple[0])
+                             diag_tuple[0]))
 
                 for res_amp in res_amps:
                     col_amp.append(((res_amp.get('fermionfactor'),
diff -rupN MadGraph_pristine/madgraph/madevent/combine_grid.py ../contrib/MadGraph/madgraph/madevent/combine_grid.py
--- MadGraph_pristine/madgraph/madevent/combine_grid.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/madevent/combine_grid.py	2020-10-30 20:49:24.526460910 +1100
@@ -60,7 +60,7 @@ class grid_information(object):
         elif isinstance(path, file):
             finput=path
         else:
-            raise Exception, "path should be a path or a file descriptor"
+            raise Exception("path should be a path or a file descriptor")
         
         line = finput.readline()
         if self.nonzero == 0:
@@ -79,7 +79,7 @@ class grid_information(object):
                 self.oneFail = True
                 return
             elif len(info) !=3:
-                raise Exception, "wrong formatting of %s"% finput.name
+                raise Exception("wrong formatting of %s"% finput.name)
             
             nonzero, ng, maxinvar = info
             self.nonzero+=nonzero
@@ -153,7 +153,7 @@ class grid_information(object):
             finput=path
             fname = finput.name
         else:
-            raise Exception, "path should be a path or a file descriptor"
+            raise Exception("path should be a path or a file descriptor")
          
         
         return self.results.add_results(fname,finput)
diff -rupN MadGraph_pristine/madgraph/madevent/combine_runs.py ../contrib/MadGraph/madgraph/madevent/combine_runs.py
--- MadGraph_pristine/madgraph/madevent/combine_runs.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/madevent/combine_runs.py	2020-10-30 20:49:24.526460910 +1100
@@ -150,7 +150,7 @@ class CombineRuns(object):
                 nb_evt+=1
                 data = line.split()
                 if not len(data) == 6:
-                    raise MadGraph5Error, "Line after <event> should have 6 entries"
+                    raise MadGraph5Error("Line after <event> should have 6 entries")
                 if float(data[2]) > 0:
                     sign = ''
                 else:
diff -rupN MadGraph_pristine/madgraph/madevent/gen_crossxhtml.py ../contrib/MadGraph/madgraph/madevent/gen_crossxhtml.py
--- MadGraph_pristine/madgraph/madevent/gen_crossxhtml.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/madevent/gen_crossxhtml.py	2020-10-30 20:49:24.526460910 +1100
@@ -600,7 +600,7 @@ class RunResults(list):
             # return last entry
             return self[-1]
         
-        raise Exception, '%s is not a valid tag' % name
+        raise Exception('%s is not a valid tag' % name)
     
     def recreate(self, banner):
         """Fully recreate the information due to a hard removal of the db
diff -rupN MadGraph_pristine/madgraph/madevent/gen_ximprove.py ../contrib/MadGraph/madgraph/madevent/gen_ximprove.py
--- MadGraph_pristine/madgraph/madevent/gen_ximprove.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/madevent/gen_ximprove.py	2020-10-30 20:49:24.526460910 +1100
@@ -147,7 +147,7 @@ class gensym(object):
             #compile gensym
             self.cmd.compile(['gensym'], cwd=Pdir)
             if not os.path.exists(pjoin(Pdir, 'gensym')):
-                raise Exception, 'Error make gensym not successful'  
+                raise Exception('Error make gensym not successful')  
             
             # Launch gensym
             p = misc.Popen(['./gensym'], stdout=subprocess.PIPE, 
@@ -177,11 +177,11 @@ class gensym(object):
                         continue
                     else:
                         if done:
-                            raise Exception, 'Parsing error in gensym: %s' % stdout 
+                            raise Exception('Parsing error in gensym: %s' % stdout) 
                         job_list[Pdir] = l.split()        
                         done = True
                 if not done:
-                    raise Exception, 'Parsing error in gensym: %s' % stdout
+                    raise Exception('Parsing error in gensym: %s' % stdout)
                      
             self.cmd.compile(['madevent'], cwd=Pdir)
             if to_submit:
@@ -218,7 +218,7 @@ class gensym(object):
                 for G in to_resub:
                     try:
                         shutil.rmtree(pjoin(P, 'G%s' % G))
-                    except Exception, error:
+                    except Exception as error:
                         misc.sprint(error)
                         pass
             misc.sprint(to_resub) 
@@ -411,7 +411,7 @@ class gensym(object):
             need_submit = False
         elif self.cmd.opts['accuracy'] < 0:
             #check for luminosity
-            raise Exception, "Not Implemented"
+            raise Exception("Not Implemented")
         elif self.abscross[(Pdir,G)] == 0:
             need_submit = False 
         else:   
@@ -617,7 +617,7 @@ For offline investigation, the problemat
             path = pjoin(Pdir, "G%s_%s" % (G, i+1))
             try: 
                 os.remove(pjoin(path, 'grid_information'))
-            except OSError, oneerror:
+            except OSError as oneerror:
                 if oneerror.errno != 2:
                     raise
         return grid_calculator, cross, error
@@ -639,7 +639,7 @@ For offline investigation, the problemat
              logger.warning(msg%(G,EPS_fraction))
         elif EPS_fraction > 0.01:
              logger.critical((msg%(G,EPS_fraction)).replace('might', 'can'))
-             raise Exception, (msg%(G,EPS_fraction)).replace('might', 'can')
+             raise Exception((msg%(G,EPS_fraction)).replace('might', 'can'))
     
     def get_current_axsec(self):
         
@@ -874,7 +874,7 @@ class gen_ximprove(object):
                 targettype = type(getattr(self, key))
                 setattr(self, key, self.format_variable(value, targettype, key))
             else:
-                raise Exception, '%s not define' % key
+                raise Exception('%s not define' % key)
                         
             
         # special treatment always do outside the loop to avoid side effect
@@ -1601,7 +1601,7 @@ class gen_ximprove_gridpack(gen_ximprove
     max_request_event = 1e12         # split jobs if a channel if it needs more than that 
     max_event_in_iter = 4000
     min_event_in_iter = 500
-    combining_job = sys.maxint
+    combining_job = sys.maxsize
     gen_events_security = 1.00
 
     def __new__(cls, *args, **opts):
diff -rupN MadGraph_pristine/madgraph/madevent/sum_html.py ../contrib/MadGraph/madgraph/madevent/sum_html.py
--- MadGraph_pristine/madgraph/madevent/sum_html.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/madevent/sum_html.py	2020-10-30 20:49:24.526460910 +1100
@@ -79,9 +79,9 @@ class RunStatistics(dict):
             new_stats = [new_stats, ]
         elif isinstance(new_stats,list):
             if any(not isinstance(_,RunStatistics) for _ in new_stats):
-                raise MadGraph5Error, "The 'new_stats' argument of the function "+\
+                raise MadGraph5Error("The 'new_stats' argument of the function "+\
                         "'updtate_statistics' must be a (possibly list of) "+\
-                                                       "RunStatistics instance."
+                                                       "RunStatistics instance.")
  
         keys = set([])
         for stat in [self,]+new_stats:
@@ -280,7 +280,7 @@ class OneResult(object):
         elif isinstance(filepath, file):
             finput = filepath
         else:
-            raise Exception, "filepath should be a path or a file descriptor"
+            raise Exception("filepath should be a path or a file descriptor")
         
         i=0
         found_xsec_line = False
@@ -311,12 +311,12 @@ class OneResult(object):
                         if 'end code not correct' in line:
                             error_code = data[4]
                             log = pjoin(os.path.dirname(filepath), 'log.txt')
-                            raise Exception, "Reported error: End code %s \n Full associated log: \n%s"\
-                                  % (error_code, open(log).read())
+                            raise Exception("Reported error: End code %s \n Full associated log: \n%s"\
+                                  % (error_code, open(log).read()))
                         else:
                             log = pjoin(os.path.dirname(filepath), 'log.txt')
-                            raise Exception, "Wrong formatting in results.dat: %s \n Full associated log: \n%s"\
-                                %  (line, open(log).read())                        
+                            raise Exception("Wrong formatting in results.dat: %s \n Full associated log: \n%s"\
+                                %  (line, open(log).read()))                        
                 if len(data) > 10:
                     self.maxwgt = data[10]
                 if len(data) >12:
@@ -364,7 +364,7 @@ class OneResult(object):
         if statistics_node:
             try:
                 self.run_statistics.load_statistics(statistics_node[0])
-            except ValueError, IndexError:
+            except (ValueError, IndexError):
                 logger.warning('Fail to read run statistics from results.dat')
 
     def set_mfactor(self, value):
diff -rupN MadGraph_pristine/madgraph/various/banner.py ../contrib/MadGraph/madgraph/various/banner.py
--- MadGraph_pristine/madgraph/various/banner.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/banner.py	2020-10-30 20:49:24.526460910 +1100
@@ -22,7 +22,11 @@ import os
 import sys
 import re
 import math
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
 
 pjoin = os.path.join
 
@@ -181,7 +185,7 @@ class Banner(dict):
         if version < 3:
             version = 1
         elif version > 3:
-            raise Exception, "Not Supported version"
+            raise Exception("Not Supported version")
         self.lhe_version = version
     
     def get_cross(self, witherror=False):
@@ -306,27 +310,27 @@ class Banner(dict):
         """get the lha_strategy: how the weight have to be handle by the shower"""
         
         if not self["init"]:
-            raise Exception, "No init block define"
+            raise Exception("No init block define")
         
         data = self["init"].split('\n')[0].split()
         if len(data) != 10:
             misc.sprint(len(data), self['init'])
-            raise Exception, "init block has a wrong format"
+            raise Exception("init block has a wrong format")
         return int(float(data[-2]))
         
     def set_lha_strategy(self, value):
         """set the lha_strategy: how the weight have to be handle by the shower"""
         
         if not (-4 <= int(value) <= 4):
-            raise Exception, "wrong value for lha_strategy", value
+            raise Exception("wrong value for lha_strategy", value)
         if not self["init"]:
-            raise Exception, "No init block define"
+            raise Exception("No init block define")
         
         all_lines = self["init"].split('\n')
         data = all_lines[0].split()
         if len(data) != 10:
             misc.sprint(len(data), self['init'])
-            raise Exception, "init block has a wrong format"
+            raise Exception("init block has a wrong format")
         data[-2] = '%s' % value
         all_lines[0] = ' '.join(data)
         self['init'] = '\n'.join(all_lines)
@@ -459,7 +463,7 @@ class Banner(dict):
             elif 'madanalysis5_hadron_card' in card_name:
                 tag='MA5Card_hadron'
             else:
-                raise Exception, 'Impossible to know the type of the card'
+                raise Exception('Impossible to know the type of the card')
 
             self.add_text(tag.lower(), open(path).read())
 
@@ -566,7 +570,7 @@ class Banner(dict):
             if tag == 'mg5proccard':
                 try:
                     return card.get(arg[0])
-                except KeyError, error:
+                except KeyError as error:
                     if 'default' in opt:
                         return opt['default']
                     else:
@@ -589,7 +593,7 @@ class Banner(dict):
         elif len(arg) == 0:
             return card
         else:
-            raise Exception, "Unknow command"
+            raise Exception("Unknow command")
     
     #convenient alias
     get = get_detail
@@ -685,7 +689,7 @@ def recover_banner(results_object, level
     if not tag:
         try:    
             _tag = results_object[run].tags[-1] 
-        except Exception,error:
+        except Exception as error:
             if os.path.exists( pjoin(results_object.path,'Events','%s_banner.txt' % (run))):
                 tag = None
             else:
@@ -790,7 +794,7 @@ class ProcCard(list):
                 self.append(tmp.strip())
                 store_line = ""
         if store_line:
-            raise Exception, "WRONG CARD FORMAT"
+            raise Exception("WRONG CARD FORMAT")
         
         
     def move_to_last(self, cmd):
@@ -1185,7 +1189,7 @@ class ConfigFile(dict):
                 else:
                     dict.__getitem__(self, lower_name).update(value)
             else:
-                raise Exception, '%s should be of dict type'% lower_name
+                raise Exception('%s should be of dict type'% lower_name)
             if change_userdefine:
                 self.user_set.add(lower_name)
             return self.post_set(lower_name, None, change_userdefine, raiseerror)
@@ -1254,12 +1258,12 @@ class ConfigFile(dict):
                 targettype=typelist
                 assert typelist
             if any([targettype != type(v) for v in value]):
-                raise Exception, "All entry should have the same type"
+                raise Exception("All entry should have the same type")
             self.list_parameter[lower_name] = targettype
         elif isinstance(value, dict):
             allvalues = value.values()
             if any([type(allvalues[0]) != type(v) for v in allvalues]):
-                raise Exception, "All entry should have the same type"   
+                raise Exception("All entry should have the same type")   
             self.dict_parameter[lower_name] = type(allvalues[0])  
             if '__type__' in value:
                 del value['__type__']
@@ -1318,11 +1322,11 @@ class ConfigFile(dict):
                 if new_value == value:
                     value = new_value
                 else:
-                    raise InvalidCmd, "Wrong input type for %s found %s and expecting %s for value %s" %\
-                        (name, type(value), targettype, value)
+                    raise InvalidCmd("Wrong input type for %s found %s and expecting %s for value %s" %\
+                        (name, type(value), targettype, value))
             else:
-                raise InvalidCmd, "Wrong input type for %s found %s and expecting %s for value %s" %\
-                        (name, type(value), targettype, value)                
+                raise InvalidCmd("Wrong input type for %s found %s and expecting %s for value %s" %\
+                        (name, type(value), targettype, value))                
         else:
             # We have a string we have to format the attribute from the string
             if targettype == UnknownType:
@@ -1335,7 +1339,7 @@ class ConfigFile(dict):
                 elif value.lower() in ['1', '.true.', 't', 'true', 'on']:
                     value = True
                 else:
-                    raise InvalidCmd, "%s can not be mapped to True/False for %s" % (repr(value),name)
+                    raise InvalidCmd("%s can not be mapped to True/False for %s" % (repr(value),name))
             elif targettype == str:
                 value = value.strip()
                 if value.startswith('\'') and value.endswith('\''):
@@ -1361,25 +1365,25 @@ class ConfigFile(dict):
                                 v /=  float(split[2*i+2])
                     except:
                         v=0
-                        raise InvalidCmd, "%s can not be mapped to an integer" % value
+                        raise InvalidCmd("%s can not be mapped to an integer" % value)
                     finally:
                         value = int(v)
                         if value != v:
-                            raise InvalidCmd, "%s can not be mapped to an integer" % v
+                            raise InvalidCmd("%s can not be mapped to an integer" % v)
                 else:
                     try:
                         value = float(value.replace('d','e'))
                     except ValueError:
-                        raise InvalidCmd, "%s can not be mapped to an integer" % value                    
+                        raise InvalidCmd("%s can not be mapped to an integer" % value)                   
                     try:
                         new_value = int(value)
                     except ValueError:
-                        raise InvalidCmd, "%s can not be mapped to an integer" % value
+                        raise InvalidCmd("%s can not be mapped to an integer" % value)
                     else:
                         if value == new_value:
                             value = new_value
                         else:
-                            raise InvalidCmd, "incorect input: %s need an integer for %s" % (value,name)
+                            raise InvalidCmd("incorect input: %s need an integer for %s" % (value,name))
                      
             elif targettype == float:
                 if value.endswith(('k', 'M')) and value[:-1].isdigit():
@@ -1400,11 +1404,11 @@ class ConfigFile(dict):
                                     v /=  float(split[2*i+2])
                         except:
                             v=0
-                            raise InvalidCmd, "%s can not be mapped to a float" % value
+                            raise InvalidCmd("%s can not be mapped to a float" % value)
                         finally:
                             value = v
             else:
-                raise InvalidCmd, "type %s is not handle by the card" % targettype
+                raise InvalidCmd("type %s is not handle by the card" % targettype)
             
         return value
             
@@ -1416,8 +1420,8 @@ class ConfigFile(dict):
         if __debug__:
             if lower_name not in self:
                 if lower_name in [key.lower() for key in self] :
-                    raise Exception, "Some key are not lower case %s. Invalid use of the class!"\
-                                     % [key for key in self if key.lower() != key]
+                    raise Exception("Some key are not lower case %s. Invalid use of the class!"\
+                                     % [key for key in self if key.lower() != key])
         
         if lower_name in self.auto_set:
             return 'auto'
@@ -1475,7 +1479,7 @@ class ProcCharacteristic(ConfigFile):
             elif os.path.isfile(finput):
                 finput = open(finput)
             else:
-                raise Exception, "No such file %s" % finput
+                raise Exception("No such file %s" % finput)
             
         for line in finput:
             if '#' in line:
@@ -1525,7 +1529,7 @@ class GridpackCard(ConfigFile):
             elif os.path.isfile(finput):
                 finput = open(finput)
             else:
-                raise Exception, "No such file %s" % finput
+                raise Exception("No such file %s" % finput)
         
         for line in finput:
             line = line.split('#')[0]
@@ -1749,12 +1753,12 @@ class PY8Card(ConfigFile):
         """Add a subrun to this PY8 Card."""
         assert(isinstance(py8_subrun,PY8SubRun))
         if py8_subrun['Main:subrun']==-1:
-            raise MadGraph5Error, "Make sure to correctly set the subrun ID"+\
-                            " 'Main:subrun' *before* adding it to the PY8 Card."
+            raise MadGraph5Error("Make sure to correctly set the subrun ID"+\
+                            " 'Main:subrun' *before* adding it to the PY8 Card.")
         if py8_subrun['Main:subrun'] in self.subruns:
-            raise MadGraph5Error, "A subrun with ID '%s'"%py8_subrun['Main:subrun']+\
+            raise MadGraph5Error("A subrun with ID '%s'"%py8_subrun['Main:subrun']+\
                 " is already present in this PY8 card. Remove it first, or "+\
-                                                          " access it directly."
+                                                          " access it directly.")
         self.subruns[py8_subrun['Main:subrun']] = py8_subrun
         if not 'LHEFInputs:nSubruns' in self.user_set:
             self['LHEFInputs:nSubruns'] = max(self.subruns.keys())
@@ -1921,7 +1925,7 @@ class PY8Card(ConfigFile):
             elif '\n' in template:
                 tmpl = StringIO.StringIO(template)
             else:
-                raise Exception, "File input '%s' not found." % file_input     
+                raise Exception("File input '%s' not found." % file_input)     
         elif template is None:
             # Then use a dummy empty StringIO, hence skipping the reading
             tmpl = StringIO.StringIO()
@@ -1952,8 +1956,8 @@ class PY8Card(ConfigFile):
                 value = value_entry.strip()
             except ValueError:
                 line = line.replace('\n','')
-                raise MadGraph5Error, "Could not read line '%s' of Pythia8 card."%\
-                                                                            line
+                raise MadGraph5Error("Could not read line '%s' of Pythia8 card."%\
+                                                                            line)
             # Read a subrun if detected:
             if param=='Main:subrun':
                 if read_subrun:
@@ -2117,7 +2121,7 @@ class PY8Card(ConfigFile):
             elif os.path.isfile(file_input):
                 finput = open(file_input)
             else:
-                raise Exception, "File input '%s' not found." % file_input
+                raise Exception("File input '%s' not found." % file_input)
         elif isinstance(file_input, (StringIO.StringIO, file)):
             finput = file_input
         else:
@@ -2142,8 +2146,8 @@ class PY8Card(ConfigFile):
                 value = value.strip()
             except ValueError:
                 line = line.replace('\n','')
-                raise MadGraph5Error, "Could not read line '%s' of Pythia8 card."%\
-                                                                          line
+                raise MadGraph5Error("Could not read line '%s' of Pythia8 card."%\
+                                                                          line)
             if '!' in value:
                 value,_ = value.split('!',1)                                                             
                                                                           
@@ -2319,7 +2323,7 @@ class RunCard(ConfigFile):
             elif os.path.isfile(finput):
                 finput = open(finput)
             else:
-                raise Exception, "No such file %s" % finput
+                raise Exception("No such file %s" % finput)
         
         for line in finput:
             line = line.split('#')[0]
@@ -2338,7 +2342,7 @@ class RunCard(ConfigFile):
         if consistency:
                 try:
                     self.check_validity()
-                except InvalidRunCard, error:
+                except InvalidRunCard as  error:
                     if consistency == 'warning':
                         logger.warning(str(error))
                     else:
@@ -3036,16 +3040,16 @@ class RunCardLO(RunCard):
         #1 (MC over hel with importance sampling). In particular, it can
         #no longer be > 1.
         if 'nhel' not in self.user_set:
-            raise InvalidRunCard, "Parameter nhel is not defined in the run_card."
+            raise InvalidRunCard("Parameter nhel is not defined in the run_card.")
         if self['nhel'] not in [1,0]:
-            raise InvalidRunCard, "Parameter nhel can only be '0' or '1', "+\
-                                                          "not %s." % self['nhel']
+            raise InvalidRunCard("Parameter nhel can only be '0' or '1', "+\
+                                                          "not %s." % self['nhel'])
         if int(self['maxjetflavor']) > 6:
-            raise InvalidRunCard, 'maxjetflavor should be lower than 5! (6 is partly supported)'
+            raise InvalidRunCard('maxjetflavor should be lower than 5! (6 is partly supported)')
   
         if len(self['pdgs_for_merging_cut']) > 1000:
-            raise InvalidRunCard, "The number of elements in "+\
-                               "'pdgs_for_merging_cut' should not exceed 1000."
+            raise InvalidRunCard("The number of elements in "+\
+                               "'pdgs_for_merging_cut' should not exceed 1000.")
   
         # some cut need to be deactivated in presence of isolation
         if self['ptgmin'] > 0:
@@ -3073,14 +3077,14 @@ class RunCardLO(RunCard):
                 import madgraph.interface.extended_cmd as basic_cmd
                 answer = basic_cmd.smart_input('Do you really want to continue', allow_arg=['y','n'], default='n')
                 if answer !='y':
-                    raise InvalidRunCard, 'ickkw>1 is still in alpha'
+                    raise InvalidRunCard('ickkw>1 is still in alpha')
             if self['use_syst']:
                 # some additional parameter need to be fixed for Syscalc + matching
                 if self['alpsfact'] != 1.0:
                     logger.warning('Since use_syst=T, We change the value of \'alpsfact\' to 1')
                     self['alpsfact'] =1.0
             if self['maxjetflavor'] == 6:
-                raise InvalidRunCard, 'maxjetflavor at 6 is NOT supported for matching!'
+                raise InvalidRunCard('maxjetflavor at 6 is NOT supported for matching!')
             if self['ickkw'] == 2:
                 # add warning if ckkw selected but the associate parameter are empty
                 self.get_default('highestmult', log_level=20)                   
@@ -3118,15 +3122,15 @@ class RunCardLO(RunCard):
         pdg_to_cut.discard('__type__')
         pdg_to_cut.discard('default')
         if len(pdg_to_cut)>25:
-            raise Exception, "Maximum 25 different pdgs are allowed for pdg specific cut"
+            raise Exception("Maximum 25 different pdgs are allowed for pdg specific cut")
         
         if any(int(pdg)<0 for pdg in pdg_to_cut):
             logger.warning('PDG specific cuts are always applied symmetrically on particle/anti-particle. Always use positve PDG codes')
-            raise MadGraph5Error, 'Some PDG specific cuts are defined with negative pdg code'
+            raise MadGraph5Error('Some PDG specific cuts are defined with negative pdg code')
         
         
         if any(pdg in pdg_to_cut for pdg in [1,2,3,4,5,21,22,11,13,15]):
-            raise Exception, "Can not use PDG related cut for light quark/b quark/lepton/gluon/photon"
+            raise Exception("Can not use PDG related cut for light quark/b quark/lepton/gluon/photon")
         
         if pdg_to_cut:
             self['pdg_cut'] = list(pdg_to_cut)
@@ -3906,7 +3910,7 @@ class RunCardNLO(RunCard):
         if any(self['reweight_pdf']):
             # check that we use lhapdf if reweighting is ON
             if self['pdlabel'] != "lhapdf":
-                raise InvalidRunCard, 'Reweight PDF option requires to use pdf sets associated to lhapdf. Please either change the pdlabel to use LHAPDF or set reweight_pdf to False.'
+                raise InvalidRunCard('Reweight PDF option requires to use pdf sets associated to lhapdf. Please either change the pdlabel to use LHAPDF or set reweight_pdf to False.')
 
         # make sure set have reweight_pdf and lhaid of length 1 when not including lhapdf
         if self['pdlabel'] != "lhapdf":
@@ -3930,23 +3934,23 @@ class RunCardNLO(RunCard):
 
         # Check that there are no identical elements in lhaid or dynamical_scale_choice
         if len(self['lhaid']) != len(set(self['lhaid'])):
-                raise InvalidRunCard, "'lhaid' has two or more identical entries. They have to be all different for the code to work correctly."
+                raise InvalidRunCard("'lhaid' has two or more identical entries. They have to be all different for the code to work correctly.")
         if len(self['dynamical_scale_choice']) != len(set(self['dynamical_scale_choice'])):
-                raise InvalidRunCard, "'dynamical_scale_choice' has two or more identical entries. They have to be all different for the code to work correctly."
+                raise InvalidRunCard("'dynamical_scale_choice' has two or more identical entries. They have to be all different for the code to work correctly.")
             
         # Check that lenght of lists are consistent
         if len(self['reweight_pdf']) != len(self['lhaid']):
-            raise InvalidRunCard, "'reweight_pdf' and 'lhaid' lists should have the same length"
+            raise InvalidRunCard("'reweight_pdf' and 'lhaid' lists should have the same length")
         if len(self['reweight_scale']) != len(self['dynamical_scale_choice']):
-            raise InvalidRunCard, "'reweight_scale' and 'dynamical_scale_choice' lists should have the same length"
+            raise InvalidRunCard("'reweight_scale' and 'dynamical_scale_choice' lists should have the same length")
         if len(self['dynamical_scale_choice']) > 10 :
-            raise InvalidRunCard, "Length of list for 'dynamical_scale_choice' too long: max is 10."
+            raise InvalidRunCard("Length of list for 'dynamical_scale_choice' too long: max is 10.")
         if len(self['lhaid']) > 25 :
-            raise InvalidRunCard, "Length of list for 'lhaid' too long: max is 25."
+            raise InvalidRunCard("Length of list for 'lhaid' too long: max is 25.")
         if len(self['rw_rscale']) > 9 :
-            raise InvalidRunCard, "Length of list for 'rw_rscale' too long: max is 9."
+            raise InvalidRunCard("Length of list for 'rw_rscale' too long: max is 9.")
         if len(self['rw_fscale']) > 9 :
-            raise InvalidRunCard, "Length of list for 'rw_fscale' too long: max is 9."
+            raise InvalidRunCard("Length of list for 'rw_fscale' too long: max is 9.")
     # make sure that the first element of rw_rscale and rw_fscale is the 1.0
         if 1.0 not in self['rw_rscale']:
             logger.warning("'1.0' has to be part of 'rw_rscale', adding it")
@@ -3962,9 +3966,9 @@ class RunCardNLO(RunCard):
             self['rw_fscale'][0],self['rw_fscale'][a]=self['rw_fscale'][a],self['rw_fscale'][0]
     # check that all elements of rw_rscale and rw_fscale are diffent.
         if len(self['rw_rscale']) != len(set(self['rw_rscale'])):
-                raise InvalidRunCard, "'rw_rscale' has two or more identical entries. They have to be all different for the code to work correctly."
+                raise InvalidRunCard("'rw_rscale' has two or more identical entries. They have to be all different for the code to work correctly.")
         if len(self['rw_fscale']) != len(set(self['rw_fscale'])):
-                raise InvalidRunCard, "'rw_fscale' has two or more identical entries. They have to be all different for the code to work correctly."
+                raise InvalidRunCard("'rw_fscale' has two or more identical entries. They have to be all different for the code to work correctly.")
 
 
     def update_system_parameter_for_include(self):
@@ -3975,16 +3979,16 @@ class RunCardNLO(RunCard):
         pdg_to_cut.discard('__type__')
         pdg_to_cut.discard('default')
         if len(pdg_to_cut)>25:
-            raise Exception, "Maximum 25 different PDGs are allowed for PDG specific cut"
+            raise Exception("Maximum 25 different PDGs are allowed for PDG specific cut")
         
         if any(int(pdg)<0 for pdg in pdg_to_cut):
             logger.warning('PDG specific cuts are always applied symmetrically on particle/anti-particle. Always use positve PDG codes')
-            raise MadGraph5Error, 'Some PDG specific cuts are defined with negative PDG codes'
+            raise MadGraph5Error('Some PDG specific cuts are defined with negative PDG codes')
         
         
         if any(pdg in pdg_to_cut for pdg in [21,22,11,13,15]+ range(self['maxjetflavor']+1)):
             # Note that this will double check in the fortran code
-            raise Exception, "Can not use PDG related cuts for massless SM particles/leptons"
+            raise Exception("Can not use PDG related cuts for massless SM particles/leptons")
         if pdg_to_cut:
             self['pdg_cut'] = list(pdg_to_cut)
             self['ptmin4pdg'] = []
@@ -4123,7 +4127,7 @@ class MadLoopParam(ConfigFile):
             elif os.path.isfile(finput):
                 finput = open(finput)
             else:
-                raise Exception, "No such file %s" % input
+                raise Exception("No such file %s" % input)
         
         previous_line= ''
         for line in finput:
@@ -4166,7 +4170,7 @@ class MadLoopParam(ConfigFile):
             elif isinstance(value, str):
                 return value
             else:
-                raise Exception, "Can not format input %s" % type(value)
+                raise Exception("Can not format input %s" % type(value))
             
         name = ''
         done = set()
diff -rupN MadGraph_pristine/madgraph/various/cluster.py ../contrib/MadGraph/madgraph/various/cluster.py
--- MadGraph_pristine/madgraph/various/cluster.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/cluster.py	2020-10-30 20:49:24.526460910 +1100
@@ -25,9 +25,9 @@ logger = logging.getLogger('madgraph.clu
 try:
     from madgraph import MadGraph5Error
     import madgraph.various.misc as misc
-except Exception, error:
+except Exception as error:
     if __debug__:
-        print  str(error)
+        print(  str(error))
     from internal import MadGraph5Error
     import internal.misc as misc
 
@@ -120,7 +120,7 @@ class Cluster(object):
     def submit(self, prog, argument=[], cwd=None, stdout=None, stderr=None, 
                log=None, required_output=[], nb_submit=0):
         """How to make one submission. Return status id on the cluster."""
-        raise NotImplemented, 'No implementation of how to submit a job to cluster \'%s\'' % self.name
+        raise NotImplemented('No implementation of how to submit a job to cluster \'%s\'' % self.name)
 
 
     @store_input()
@@ -225,7 +225,7 @@ class Cluster(object):
     def control(self, me_dir=None):
         """Check the status of job associated to directory me_dir. return (idle, run, finish, fail)"""
         if not self.submitted_ids:
-            raise NotImplemented, 'No implementation of how to control the job status to cluster \'%s\'' % self.name
+            raise NotImplemented('No implementation of how to control the job status to cluster \'%s\'' % self.name)
         idle, run, fail = 0, 0, 0
         for pid in self.submitted_ids[:]:
             status = self.control_one_job(id)
@@ -243,7 +243,7 @@ class Cluster(object):
 
     def control_one_job(self, pid):
         """ control the status of a single job with it's cluster id """
-        raise NotImplemented, 'No implementation of how to control the job status to cluster \'%s\'' % self.name
+        raise NotImplemented('No implementation of how to control the job status to cluster \'%s\'' % self.name)
 
     def get_jobs_identifier(self, path, second_path=None):
         """get a unique run_name for all the jobs helps to identify the runs 
@@ -552,7 +552,10 @@ class Packet(object):
     """
 
     def __init__(self, name, fct, args, opts={}):
-        import Queue
+        try:
+            import Queue
+        except ImportError:
+            import queue as Queue
         import threading
         self.queue = Queue.Queue()
         self.tag = name
@@ -582,9 +585,15 @@ class MultiCore(Cluster):
         
         super(MultiCore, self).__init__(self, *args, **opt)
         
-        import Queue
+        try:
+            import Queue
+        except ImportError:
+            import queue as Queue
         import threading
-        import thread
+        try:
+            import thread
+        except:
+            import _thread
         self.queue = Queue.Queue() # list of job to do
         self.done = Queue.Queue()  # list of job finisned
         self.submitted = Queue.Queue() # one entry by job submitted
@@ -619,8 +628,14 @@ class MultiCore(Cluster):
 
 
     def worker(self):
-        import Queue
-        import thread
+        try:
+            import Queue
+        except ImportError:
+            import queue as Queue
+        try:
+            import thread
+        except:
+            import _thread
         while not self.stoprequest.isSet():
             try:
                 args = self.queue.get()
@@ -661,14 +676,14 @@ class MultiCore(Cluster):
                             logger.warning("fct %s does not return 0. Stopping the code in a clean way. The error was:\n%s", exe, returncode)
                             self.stoprequest.set()
                             self.remove("fct %s does not return 0:\n %s" % (exe, returncode))
-                except Exception,error:
+                except Exception as error:
                     self.fail_msg = sys.exc_info()
                     logger.warning(str(error))
                     self.stoprequest.set()
                     self.remove(error)
                     
                     if __debug__:
-                        raise self.fail_msg[0], self.fail_msg[1],self.fail_msg[2]
+                        raise self.fail_msg[0]( self.fail_msg[1],self.fail_msg[2])
 
                 self.queue.task_done()
                 self.done.put(tag)
@@ -742,7 +757,10 @@ class MultiCore(Cluster):
         """Waiting that all the jobs are done. This function also control that
         the submission by packet are handle correctly (i.e. submit the function)"""
 
-        import Queue
+        try:
+            import Queue
+        except ImportError:
+            import queue as Queue
         import threading
 
         try: # to catch KeyBoardInterupt to see which kind of error to display 
@@ -819,10 +837,10 @@ class MultiCore(Cluster):
                 if isinstance(self.fail_msg, Exception):
                     raise self.fail_msg
                 elif isinstance(self.fail_msg, str):
-                    raise Exception, self.fail_msg
+                    raise Exception(self.fail_msg)
                 else:
                     misc.sprint(self.fail_msg)
-                    raise self.fail_msg[0], self.fail_msg[1], self.fail_msg[2]
+                    raise self.fail_msg[0](self.fail_msg[1], self.fail_msg[2])
             # reset variable for next submission
             try:
                 self.lock.clear()
@@ -841,9 +859,9 @@ class MultiCore(Cluster):
             if isinstance(self.fail_msg, Exception):
                 raise self.fail_msg
             elif isinstance(self.fail_msg, str):
-                raise Exception, self.fail_msg
+                raise Exception(self.fail_msg)
             elif self.fail_msg:
-                raise self.fail_msg[0], self.fail_msg[1], self.fail_msg[2]
+                raise self.fail_msg[0](self.fail_msg[1], self.fail_msg[2])
             # else return orignal error
             raise 
 
@@ -911,8 +929,8 @@ class CondorCluster(Cluster):
         try:
             id = pat.search(output).groups()[0]
         except:
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         self.submitted += 1
         self.submitted_ids.append(id)
         return id
@@ -998,8 +1016,8 @@ class CondorCluster(Cluster):
         try:
             id = pat.search(output).groups()[0]
         except:
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         self.submitted += 1
         self.submitted_ids.append(id)
         return id
@@ -1017,7 +1035,7 @@ class CondorCluster(Cluster):
         
         error = status.stderr.read()
         if status.returncode or error:
-            raise ClusterManagmentError, 'condor_q returns error: %s' % error
+            raise ClusterManagmentError('condor_q returns error: %s' % error)
 
         return status.stdout.readline().strip()
     
@@ -1044,7 +1062,7 @@ class CondorCluster(Cluster):
                                                              stderr=subprocess.PIPE)
             error = status.stderr.read()
             if status.returncode or error:
-                raise ClusterManagmentError, 'condor_q returns error: %s' % error
+                raise ClusterManagmentError('condor_q returns error: %s' % error)
 
             for line in status.stdout:
                 id, status = line.strip().split()
@@ -1138,8 +1156,8 @@ class PBSCluster(Cluster):
         output = a.communicate(text)[0]
         id = output.split('.')[0]
         if not id.isdigit() or a.returncode !=0:
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output)
             
         self.submitted += 1
         self.submitted_ids.append(id)
@@ -1155,7 +1173,7 @@ class PBSCluster(Cluster):
         for line in status.stdout:
             line = line.strip()
             if 'cannot connect to server' in line or 'cannot read reply' in line:
-                raise ClusterManagmentError, 'server disconnected'
+                raise ClusterManagmentError('server disconnected')
             if 'Unknown' in line:
                 return 'F'
             elif line.startswith(str(id)):
@@ -1164,7 +1182,7 @@ class PBSCluster(Cluster):
                 jobstatus=""
                         
         if status.returncode != 0 and status.returncode is not None:
-            raise ClusterManagmentError, 'server fails in someway (errorcode %s)' % status.returncode
+            raise ClusterManagmentError('server fails in someway (errorcode %s)' % status.returncode)
         if jobstatus in self.idle_tag:
             return 'I' 
         elif jobstatus in self.running_tag:                
@@ -1185,7 +1203,7 @@ class PBSCluster(Cluster):
         idle, run, fail = 0, 0, 0
         for line in status.stdout:
             if 'cannot connect to server' in line or 'cannot read reply' in line:
-                raise ClusterManagmentError, 'server disconnected'
+                raise ClusterManagmentError('server disconnected')
             if me_dir in line:
                 ongoing.append(line.split()[0].split('.')[0])
                 status2 = line.split()[4]
@@ -1200,7 +1218,7 @@ class PBSCluster(Cluster):
                     fail += 1
 
         if status.returncode != 0 and status.returncode is not None:
-            raise ClusterManagmentError, 'server fails in someway (errorcode %s)' % status.returncode
+            raise ClusterManagmentError('server fails in someway (errorcode %s)' % status.returncode)
 
         for id in list(self.submitted_ids):
             if id not in ongoing:
@@ -1301,8 +1319,8 @@ class SGECluster(Cluster):
         output = a.communicate(text)[0]
         id = output.split(' ')[2]
         if not id.isdigit():
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         self.submitted += 1
         self.submitted_ids.append(id)
         logger.debug(output)
@@ -1419,11 +1437,11 @@ class LSFCluster(Cluster):
         try:
             id = output.split('>',1)[0].split('<')[1]
         except:
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         if not id.isdigit():
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         self.submitted += 1
         self.submitted_ids.append(id)
         return id        
@@ -1550,8 +1568,8 @@ class GECluster(Cluster):
         try:
             id = pat.search(output).groups()[0]
         except:
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         self.submitted += 1
         self.submitted_ids.append(id)
         return id
@@ -1573,7 +1591,7 @@ class GECluster(Cluster):
             try:
                 groups = pat.search(line).groups()
             except:
-                raise ClusterManagmentError, 'bad syntax for stat: \n\"%s\"' % line
+                raise ClusterManagmentError('bad syntax for stat: \n\"%s\"' % line)
             if groups[0] != id: continue
             stat = groups[1]
         if not stat:
@@ -1685,8 +1703,8 @@ class SLURMCluster(Cluster):
         id = output_arr[3].rstrip()
 
         if not id.isdigit():
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                    % (output[0] + '\n' + output[1])
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                    % (output[0] + '\n' + output[1]))
 
         self.submitted += 1
         self.submitted_ids.append(id)
@@ -1786,7 +1804,7 @@ class HTCaaSCluster(Cluster):
         cwd_cp = cwd.rsplit("/",2)
 
         if not stdout is None:
-            print "stdout: %s" % stdout
+            print( "stdout: %s" % stdout)
 
         if not os.path.exists(prog):
             prog = os.path.join(cwd, prog)
@@ -1835,15 +1853,15 @@ class HTCaaSCluster(Cluster):
         nb_try=0
         nb_limit=5
         if not id.isdigit() :
-                print "[ID is not digit]:" + id
+                print( "[ID is not digit]:" + id)
 
         while not id.isdigit() :
             nb_try+=1
-            print "[fail_retry]:"+ nb_try
+            print("[fail_retry]:"+ nb_try)
             a=misc.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, cwd=cwd)
             id = a.stdout.read().strip()
             if nb_try > nb_limit :
-                raise ClusterManagementError, 'fail to submit to the HTCaaS cluster: \n %s' % id
+                raise ClusterManagementError('fail to submit to the HTCaaS cluster: \n %s' % id)
                 break
 
         self.submitted += 1
@@ -1863,7 +1881,7 @@ class HTCaaSCluster(Cluster):
                                                          stderr=subprocess.PIPE)
             error = status.stderr.read()
             if status.returncode or error:
-                raise ClusterManagmentError, 'htcaas-job-submit returns error: %s' % error
+                raise ClusterManagmentError('htcaas-job-submit returns error: %s' % error)
             status_out= status.stdout.read().strip()
             status_out= status_out.split(":",1)[1]
             if status_out == 'waiting':
@@ -2062,7 +2080,7 @@ class HTCaaS2Cluster(Cluster):
                                                          stderr=subprocess.PIPE)
             error = status.stderr.read()
             if status.returncode or error:
-                raise ClusterManagmentError, 'htcaas-job-status returns error: %s' % error
+                raise ClusterManagmentError('htcaas-job-status returns error: %s' % error)
             status_out= status.stdout.read().strip()
             status_out= status_out.split(":",1)[1]
             logger.debug("[["+str(id)+"]]"+status_out)
diff -rupN MadGraph_pristine/madgraph/various/diagram_symmetry.py ../contrib/MadGraph/madgraph/various/diagram_symmetry.py
--- MadGraph_pristine/madgraph/various/diagram_symmetry.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/diagram_symmetry.py	2020-10-30 20:49:24.530460897 +1100
@@ -355,7 +355,7 @@ class IdentifySGConfigTag(diagram_genera
             part = model.get_particle(vertex.get('legs')[-1].get('id'))
             try:
                 QCD = inter.get('orders')['QCD']
-            except Exception, error:
+            except Exception as error:
                 QCD = 0
 
             return ((part.get('color'),
diff -rupN MadGraph_pristine/madgraph/various/lhe_parser.py ../contrib/MadGraph/madgraph/various/lhe_parser.py
--- MadGraph_pristine/madgraph/various/lhe_parser.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/lhe_parser.py	2020-10-30 20:49:24.530460897 +1100
@@ -9,16 +9,17 @@ import time
 import os
 import shutil
 import sys
+from io import FileIO
 
 pjoin = os.path.join
 
 if '__main__' == __name__:
     import sys
     sys.path.append('../../')
-import misc
+from .misc import *
 import logging
 import gzip
-import banner as banner_mod
+from . import banner as banner_mod
 logger = logging.getLogger("madgraph.lhe_parser")
 
 class Particle(object):
@@ -187,9 +188,9 @@ class EventFile(object):
         else:
             try:
                 return gzip.GzipFile.__new__(EventFileGzip, path, mode, *args, **opt)
-            except IOError, error:
+            except IOError as error:
                 raise
-            except Exception, error:
+            except Exception as error:
                 if mode == 'r':
                     misc.gunzip(path)
                 return file.__new__(EventFileNoGzip, path[:-3], mode, *args, **opt)
@@ -624,7 +625,7 @@ class EventFile(object):
              
         return nb_file +1
 
-    def update_HwU(self, hwu, fct, name='lhe', keep_wgt=False, maxevents=sys.maxint):
+    def update_HwU(self, hwu, fct, name='lhe', keep_wgt=False, maxevents=sys.maxsize):
         """take a HwU and add this event file for the function fct"""
                 
         if not isinstance(hwu, list):
@@ -817,7 +818,7 @@ class EventFileGzip(EventFile, gzip.Gzip
             currpos = self.size
         return currpos
         
-class EventFileNoGzip(EventFile, file):
+class EventFileNoGzip(EventFile, FileIO):
     """A way to read a standard event file"""
     
     def close(self,*args, **opts):
@@ -1393,8 +1394,8 @@ class Event(list):
                 self.reweight_data = dict([(pid, float(value)) for (pid, value) in data
                                            if not self.reweight_order.append(pid)])
                                       # the if is to create the order file on the flight
-            except ValueError, error:
-                raise Exception, 'Event File has unvalid weight. %s' % error
+            except ValueError as error:
+                raise Exception('Event File has unvalid weight. %s' % error)
             self.tag = self.tag[:start] + self.tag[stop+7:]
         return self.reweight_data
     
@@ -1461,7 +1462,7 @@ class Event(list):
             
             info = Event.loweight_pattern.search(text)
             if not info:
-                raise Exception, '%s not parsed'% text
+                raise Exception('%s not parsed'% text)
             self.loweight={}
             self.loweight['n_qcd'] = int(info.group('nqcd'))
             self.loweight['ren_scale'] = float(info.group('ren_scale'))
@@ -1588,8 +1589,8 @@ class Event(list):
                     else:
                         try:
                             setattr(new_particle, tag, self[nb_part + mother_id -1])
-                        except Exception, error:
-                            print error
+                        except Exception as error:
+                            print(error)
                             misc.sprint( self)
                             misc.sprint(nb_part + mother_id -1)
                             misc.sprint(tag)
@@ -1600,7 +1601,7 @@ class Event(list):
                 elif tag == "mother2" and isinstance(particle.mother1, Particle):
                     new_particle.mother2 = this_particle
                 else:
-                    raise Exception, "Something weird happens. Please report it for investigation"
+                    raise Exception("Something weird happens. Please report it for investigation")
         # Need to correct the color information of the particle
         # first find the first available color index
         max_color=501
@@ -1777,22 +1778,22 @@ class Event(list):
             fourmass = FourMomentum(particle).mass
             
             if particle.mass and (abs(particle.mass) - fourmass)/ abs(particle.mass) > threshold:
-                raise Exception, "Do not have correct mass lhe: %s momentum: %s" % (particle.mass, fourmass)
+                raise Exception("Do not have correct mass lhe: %s momentum: %s" % (particle.mass, fourmass))
             
                 
 
         if E/absE > threshold:
             logger.critical(self)
-            raise Exception, "Do not conserve Energy %s, %s" % (E/absE, E)
+            raise Exception("Do not conserve Energy %s, %s" % (E/absE, E))
         if px/abspx > threshold:
             logger.critical(self)
-            raise Exception, "Do not conserve Px %s, %s" % (px/abspx, px)         
+            raise Exception("Do not conserve Px %s, %s" % (px/abspx, px))         
         if py/abspy > threshold:
             logger.critical(self)
-            raise Exception, "Do not conserve Py %s, %s" % (py/abspy, py)
+            raise Exception("Do not conserve Py %s, %s" % (py/abspy, py))
         if pz/abspz > threshold:
             logger.critical(self)
-            raise Exception, "Do not conserve Pz %s, %s" % (pz/abspz, pz)
+            raise Exception("Do not conserve Pz %s, %s" % (pz/abspz, pz))
             
         #2. check the color of the event
         self.check_color_structure() 
@@ -1995,7 +1996,7 @@ class Event(list):
             if part.status == 1: #final
                 try:
                     ind = order[1].index(part.pid)
-                except ValueError, error:
+                except ValueError as error:
                     if not allow_reversed:
                         raise error
                     else:
@@ -2009,7 +2010,7 @@ class Event(list):
             elif part.status == -1:
                 try:
                     ind = order[0].index(part.pid)
-                except ValueError, error:
+                except ValueError as error:
                     if not allow_reversed:
                         raise error
                     else:
@@ -2037,18 +2038,18 @@ class Event(list):
                 if particle.color1:
                     color_index[particle.color1] +=1
                     if -7 < particle.pdg < 0:
-                        raise Exception, "anti-quark with color tag"
+                        raise Exception("anti-quark with color tag")
                 if particle.color2:
                     color_index[particle.color2] +=1     
                     if 7 > particle.pdg > 0:
-                        raise Exception, "quark with anti-color tag"                
+                        raise Exception("quark with anti-color tag")                
                 
                 
         for key,value in color_index.items():
             if value > 2:
-                print self
-                print key, value
-                raise Exception, 'Wrong color_flow'           
+                print( self)
+                print( key, value)
+                raise Exception('Wrong color_flow')           
         
         
         #2. check that each parent present have coherent color-structure
@@ -2109,21 +2110,21 @@ class Event(list):
                 #only case is a epsilon_ijk structure.
                 if len(canticolors) + len(mcolors) != 3:
                     logger.critical(str(self))
-                    raise Exception, "Wrong color flow for %s -> %s" ([m.pid for m in mothers], [c.pid for c in childs])              
+                    raise Exception("Wrong color flow for %s -> %s" ([m.pid for m in mothers], [c.pid for c in childs]))              
                 else:
                     popup_index += canticolors
             elif manticolors != []:
                 #only case is a epsilon_ijk structure.
                 if len(ccolors) + len(manticolors) != 3:
                     logger.critical(str(self))
-                    raise Exception, "Wrong color flow for %s -> %s" ([m.pid for m in mothers], [c.pid for c in childs])              
+                    raise Exception("Wrong color flow for %s -> %s" ([m.pid for m in mothers], [c.pid for c in childs]))              
                 else:
                     popup_index += ccolors
 
             # Check that color popup (from epsilon_ijk) are raised only once
             if len(popup_index) != len(set(popup_index)):
                 logger.critical(self)
-                raise Exception, "Wrong color flow: identical poping-up index, %s" % (popup_index)
+                raise Exception("Wrong color flow: identical poping-up index, %s" % (popup_index))
                
     def __eq__(self, other):
         """two event are the same if they have the same momentum. other info are ignored"""
@@ -2229,7 +2230,7 @@ class Event(list):
             if part.status == 1: #final
                 try:
                     ind = order[1].index(part.pid)
-                except ValueError, error:
+                except ValueError as error:
                     if not allow_reversed:
                         raise error
                     else:
@@ -2243,7 +2244,7 @@ class Event(list):
             elif part.status == -1:
                 try:
                     ind = order[0].index(part.pid)
-                except ValueError, error:
+                except ValueError as error:
                     if not allow_reversed:
                         raise error
                     else:
@@ -2340,9 +2341,9 @@ class WeightFile(EventFile):
         if  path.endswith(".gz"):
             try:
                 return gzip.GzipFile.__new__(WeightFileGzip, path, mode, *args, **opt)
-            except IOError, error:
+            except IOError as error:
                 raise
-            except Exception, error:
+            except Exception as error:
                 if mode == 'r':
                     misc.gunzip(path)
                 return file.__new__(WeightFileNoGzip, path[:-3], mode, *args, **opt)
@@ -2881,7 +2882,7 @@ class NLO_PARTIALWEIGHT(object):
                 if pos < len(get_order[0]): #initial
                     try:
                         ind = order[0].index(pdgs[pos])
-                    except ValueError, error:
+                    except ValueError as error:
                         if not allow_reversed:
                             raise error
                         else:
@@ -2897,7 +2898,7 @@ class NLO_PARTIALWEIGHT(object):
                 else: #final   
                     try:
                         ind = order[1].index(pdgs[pos])
-                    except ValueError, error:
+                    except ValueError as error:
                         if not allow_reversed:
                             raise error
                         else:
@@ -3098,13 +3099,13 @@ if '__main__' == __name__:
         start = time.time()
         for event in lhe:
             event.parse_lo_weight()
-        print 'old method -> ', time.time()-start
+        print( 'old method -> ', time.time()-start)
         lhe = EventFile('unweighted_events.lhe.gz')
         #lhe.parsing = False
         start = time.time()
         for event in lhe:
             event.parse_lo_weight_test()
-        print 'new method -> ', time.time()-start    
+        print( 'new method -> ', time.time()-start)  
     
 
     # Example 1: adding some missing information to the event (here distance travelled)
@@ -3149,7 +3150,7 @@ if '__main__' == __name__:
                 nb_pass +=1     
 
                         
-        print nb_pass
+        print( nb_pass)
         gs1 = gridspec.GridSpec(2, 1, height_ratios=[5,1])
         gs1.update(wspace=0, hspace=0) # set the spacing between axes. 
         ax = plt.subplot(gs1[0])
@@ -3161,8 +3162,8 @@ if '__main__' == __name__:
         ax_c.set_yticks(ax.get_yticks())
         ax_c.set_yticklabels([])
         ax.set_xlim([-4,4])
-        print "bin value:", n
-        print "start/end point of bins", bins
+        print( "bin value:", n)
+        print( "start/end point of bins", bins)
         plt.axis('on')
         plt.xlabel('weight ratio')
         plt.show()
diff -rupN MadGraph_pristine/madgraph/various/misc.py ../contrib/MadGraph/madgraph/various/misc.py
--- MadGraph_pristine/madgraph/various/misc.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/misc.py	2020-10-30 20:49:24.530460897 +1100
@@ -22,7 +22,13 @@ import re
 import signal
 import subprocess
 import sys
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+from io import FileIO
+
 import sys
 import optparse
 import time
@@ -34,7 +40,7 @@ from distutils.version import LooseVersi
 try:
     # Use in MadGraph
     import madgraph
-except Exception, error:
+except Exception as error:
     # Use in MadEvent
     import internal
     from internal import MadGraph5Error, InvalidCmd
@@ -63,11 +69,11 @@ def parse_info_str(fsock):
     for entry in fsock:
         entry = entry.strip()
         if len(entry) == 0: continue
-        m = pattern.match(entry)
+        m = pattern.match(entry.decode('utf-8'))
         if m is not None:
             info_dict[m.group('name')] = m.group('value')
         else:
-            raise IOError, "String %s is not a valid info string" % entry
+            raise IOError("String %s is not a valid info string" % entry)
 
     return info_dict
 
@@ -293,7 +299,7 @@ def deactivate_dependence(dependency, cm
     
     def tell(msg):
         if log == 'stdout':
-            print msg
+            print(msg)
         elif callable(log):
             log(msg)
     
@@ -309,7 +315,7 @@ def activate_dependence(dependency, cmd=
     
     def tell(msg):
         if log == 'stdout':
-            print msg
+            print(msg)
         elif callable(log):
             log(msg)
 
@@ -331,7 +337,7 @@ def activate_dependence(dependency, cmd=
             cmd.do_install('Golem95')
     
     if dependency=='samurai':
-        raise MadGraph5Error, 'Samurai cannot yet be automatically installed.' 
+        raise MadGraph5Error( 'Samurai cannot yet be automatically installed.') 
 
     if dependency=='ninja':
         if cmd.options['ninja'] in ['None',None,''] or\
@@ -407,7 +413,7 @@ def multiple_try(nb_try=5, sleep=20):
                     return f(*args, **opt)
                 except KeyboardInterrupt:
                     raise
-                except Exception, error:
+                except Exception as error:
                     global wait_once
                     if not wait_once:
                         text = """Start waiting for update. (more info in debug mode)"""
@@ -421,7 +427,7 @@ def multiple_try(nb_try=5, sleep=20):
 
             if __debug__:
                 raise
-            raise error.__class__, '[Fail %i times] \n %s ' % (i+1, error)
+            raise error.__class__( '[Fail %i times] \n %s ' % (i+1, error))
         return deco_f_retry
     return deco_retry
 
@@ -478,9 +484,9 @@ def compile(arg=[], cwd=None, mode='fort
         p = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                              stderr=subprocess.STDOUT, cwd=cwd, **opt)
         (out, err) = p.communicate()
-    except OSError, error:
+    except OSError as error:
         if cwd and not os.path.exists(cwd):
-            raise OSError, 'Directory %s doesn\'t exists. Impossible to run make' % cwd
+            raise OSError('Directory %s doesn\'t exists. Impossible to run make' % cwd)
         else:
             error_text = "Impossible to compile %s directory\n" % cwd
             error_text += "Trying to launch make command returns:\n"
@@ -489,7 +495,7 @@ def compile(arg=[], cwd=None, mode='fort
             if sys.platform == "darwin":
                 error_text += "Note that MacOSX doesn\'t have gmake/gfortan install by default.\n"
                 error_text += "Xcode3 contains those required programs"
-            raise MadGraph5Error, error_text
+            raise MadGraph5Error(error_text)
 
     if p.returncode:
         # Check that makefile exists
@@ -497,24 +503,24 @@ def compile(arg=[], cwd=None, mode='fort
             cwd = os.getcwd()
         all_file = [f.lower() for f in os.listdir(cwd)]
         if 'makefile' not in all_file and '-f' not in arg:
-            raise OSError, 'no makefile present in %s' % os.path.realpath(cwd)
+            raise OSError('no makefile present in %s' % os.path.realpath(cwd))
 
         if mode == 'fortran' and  not (which('g77') or which('gfortran')):
             error_msg = 'A fortran compiler (g77 or gfortran) is required to create this output.\n'
             error_msg += 'Please install g77 or gfortran on your computer and retry.'
-            raise MadGraph5Error, error_msg
+            raise MadGraph5Error(error_msg)
         elif mode == 'cpp' and not which('g++'):            
             error_msg ='A C++ compiler (g++) is required to create this output.\n'
             error_msg += 'Please install g++ (which is part of the gcc package)  on your computer and retry.'
-            raise MadGraph5Error, error_msg
+            raise MadGraph5Error(error_msg)
 
         # Check if this is due to the need of gfortran 4.6 for quadruple precision
         if any(tag.upper() in out.upper() for tag in ['real(kind=16)','real*16',
             'complex*32']) and mode == 'fortran' and not \
                              ''.join(get_gfortran_version().split('.')) >= '46':
             if not which('gfortran'):
-                raise MadGraph5Error, 'The fortran compiler gfortran v4.6 or later '+\
-                  'is required to compile %s.\nPlease install it and retry.'%cwd
+                raise MadGraph5Error('The fortran compiler gfortran v4.6 or later '+\
+                  'is required to compile %s.\nPlease install it and retry.'%cwd)
             else:
                 logger_stderr.error('ERROR, you could not compile %s because'%cwd+\
              ' your version of gfortran is older than 4.6. MadGraph5_aMC@NLO will carry on,'+\
@@ -529,7 +535,7 @@ def compile(arg=[], cwd=None, mode='fort
         error_text += 'Please try to fix this compilations issue and retry.\n'
         error_text += 'Help might be found at https://answers.launchpad.net/mg5amcnlo.\n'
         error_text += 'If you think that this is a bug, you can report this at https://bugs.launchpad.net/mg5amcnlo'
-        raise MadGraph5Error, error_text
+        raise MadGraph5Error(error_text)
     return p.returncode
 
 def get_gfortran_version(compiler='gfortran'):
@@ -664,7 +670,7 @@ class MuteLogger(object):
         for logname in lognames:
             try:
                 os.remove(path)
-            except Exception, error:
+            except Exception as error:
                 pass
             my_logger = logging.getLogger(logname)
             hdlr = logging.FileHandler(path)            
@@ -689,7 +695,7 @@ class MuteLogger(object):
             if path:
                 try:
                     os.remove(path)
-                except Exception, error:
+                except Exception as error:
                     pass
             my_logger = logging.getLogger(logname)
             if logname in self.logger_saved_info:
@@ -753,7 +759,7 @@ def detect_if_cpp_compiler_is_clang(cpp_
         p = Popen([cpp_compiler, '--version'], stdout=subprocess.PIPE, 
                     stderr=subprocess.PIPE)
         output, error = p.communicate()
-    except Exception, error:
+    except Exception as error:
         # Cannot probe the compiler, assume not clang then
         return False
     return 'LLVM' in output
@@ -870,7 +876,7 @@ def check_system_error(value=1):
         def deco_f(arg, *args, **opt):
             try:
                 return f(arg, *args, **opt)
-            except OSError, error:
+            except OSError as error:
                 logger.debug('try to recover from %s' % error)
                 if isinstance(arg, (list,tuple)):
                     prog =  arg[0]
@@ -888,8 +894,8 @@ def check_system_error(value=1):
                 # NO such file or directory
                 elif error.errno == 2:
                     # raise a more meaningfull error message
-                    raise Exception, '%s fails with no such file or directory' \
-                                                                           % arg            
+                    raise Exception('%s fails with no such file or directory' \
+                                                                           % arg)            
                 else:
                     raise
         return deco_f
@@ -971,7 +977,7 @@ def get_last_line(fsock):
     
     return tail(fsock, 1)[0]
 
-class BackRead(file):
+class BackRead(FileIO):
     """read a file returning the lines in reverse order for each call of readline()
 This actually just reads blocks (4096 bytes by default) of data from the end of
 the file and returns last line in an internal buffer."""
@@ -1006,7 +1012,7 @@ the file and returns last line in an int
         self.blksize = blksize
         # how many blocks we've read
         self.blkcount = 1
-        file.__init__(self, filepos, 'rb')
+        FileIO.__init__(self, filepos, 'rb')
         # if the file is smaller than the blocksize, read a block,
         # otherwise, read the whole thing...
         if self.size > self.blksize:
@@ -1037,8 +1043,8 @@ def write_PS_input(filePath, PS):
                                                              for p in PS])+'\n')
         PSfile.close()
     except Exception:
-        raise MadGraph5Error, 'Could not write out the PS point to file %s.'\
-                                                                  %str(filePath)
+        raise MadGraph5Error('Could not write out the PS point to file %s.'\
+                                                                  %str(filePath))
 
 def format_timer(running_time):
     """ return a nicely string representing the time elapsed."""
@@ -1125,8 +1131,8 @@ def gunzip(path, keep=False, stdout=None
         if os.path.exists("%s.gz" % path):
             path = "%s.gz" % path
         else:
-            raise Exception, "%(path)s does not finish by .gz and the file %(path)s.gz does not exists" %\
-                              {"path": path}         
+            raise Exception("%(path)s does not finish by .gz and the file %(path)s.gz does not exists" %\
+                              {"path": path})         
 
     
     #for large file (>1G) it is faster and safer to use a separate thread
@@ -1263,7 +1269,7 @@ class open_file(object):
                         cls.text_editor = configuration[key]
                         continue
                 #Need to find a valid default
-                if os.environ.has_key('EDITOR'):
+                if 'EDITOR' in os.environ:
                     cls.text_editor = os.environ['EDITOR']
                 else:
                     cls.text_editor = cls.find_valid(
@@ -1376,7 +1382,7 @@ class OptionParser(optparse.OptionParser
     
     def exit(self, status=0, msg=None):
         if msg:
-            raise InvalidCmd, msg
+            raise InvalidCmd(msg)
         else:
             raise InvalidCmd
 
@@ -1442,8 +1448,8 @@ def sprint(*args, **opt):
         log.log(level, ' '.join([intro]+[str(a) for a in args]) + \
                    ' \033[1;30m[%s at line %s]\033[0m' % (os.path.basename(filename), lineno))
     else:
-        print ' '.join([intro]+[str(a) for a in args]) + \
-                   ' \033[1;30m[%s at line %s]\033[0m' % (os.path.basename(filename), lineno)
+        print(' '.join([intro]+[str(a) for a in args]) + \
+                   ' \033[1;30m[%s at line %s]\033[0m' % (os.path.basename(filename), lineno))
 
     if wait:
         raw_input('press_enter to continue')
@@ -1508,8 +1514,8 @@ def timeout(func, args=(), kwargs={}, ti
         def run(self):
             try:
                 self.result = func(*args, **kwargs)
-            except Exception,error:
-                print error
+            except Exception as error:
+                print(error)
                 self.result = default
     it = InterruptableThread()
     it.start()
@@ -1786,7 +1792,7 @@ class EasterEgg(object):
                 self.call_apple(msg)
             else:
                 self.call_linux(msg)
-        except Exception, error:
+        except Exception as error:
             sprint(error)
             pass
     
@@ -1955,7 +1961,7 @@ def plugin_import(module, error_msg, fct
         try:
             _temp = __import__('MG5aMC_PLUGIN.%s' % module, globals(), locals(), fcts, -1)
         except ImportError:
-            raise MadGraph5Error, error_msg
+            raise MadGraph5Error(error_msg)
     
     if not fcts:
         return _temp
@@ -1977,7 +1983,7 @@ def from_plugin_import(plugin_path, targ
                 try:
                     with stdchannel_redirected(sys.stdout, os.devnull):
                         __import__('%s.%s' % (plugindirname,plug))
-                except Exception, error:
+                except Exception as error:
                     if warning:
                         logger.warning("error detected in plugin: %s.", plug)
                         logger.warning("%s", error)
@@ -2058,7 +2064,7 @@ def import_python_lhapdf(lhapdfconfig):
                 import lhapdf
                 use_lhapdf=True
             except ImportError:
-                print 'fail'
+                print('fail')
                 logger.warning("Failed to access python version of LHAPDF: "\
                                    "If the python interface to LHAPDF is available on your system, try "\
                                    "adding its location to the PYTHONPATH environment variable and the"\
diff -rupN MadGraph_pristine/madgraph/various/process_checks.py ../contrib/MadGraph/madgraph/various/process_checks.py
--- MadGraph_pristine/madgraph/various/process_checks.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/process_checks.py	2020-10-30 20:49:24.530460897 +1100
@@ -73,7 +73,11 @@ from madgraph import MG5DIR, InvalidCmd,
 
 from madgraph.iolibs.files import cp
 
-import StringIO
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import models.model_reader as model_reader
 import aloha.template_files.wavefunctions as wavefunctions
 from aloha.template_files.wavefunctions import \
@@ -298,7 +302,7 @@ class MatrixElementEvaluator(object):
             matrix_methods = exporter.get_python_matrix_methods(\
                 gauge_check=gauge_check)
 #            print "I got matrix_methods=",str(matrix_methods.items()[0][1])
-        except helas_call_writers.HelasWriterError, error:
+        except helas_call_writers.HelasWriterError as error:
             logger.info(error)
             return None
         # If one wants to output the python code generated for the computation
@@ -379,7 +383,7 @@ class MatrixElementEvaluator(object):
             
         if not (isinstance(process, base_objects.Process) and \
                 isinstance(energy, (float,int))):
-            raise rambo.RAMBOError, "Not correct type for arguments to get_momenta"
+            raise rambo.RAMBOError("Not correct type for arguments to get_momenta")
 
 
         sorted_legs = sorted(process.get('legs'), lambda l1, l2:\
@@ -403,7 +407,7 @@ class MatrixElementEvaluator(object):
                     if skip > to_skip:
                         break
             else:
-                raise MadGraph5Error, 'No compatible events for %s' % ids
+                raise MadGraph5Error('No compatible events for %s' % ids)
             p = []
             for part in event.values():
                 m = part['momentum']
@@ -423,8 +427,8 @@ class MatrixElementEvaluator(object):
                 if isinstance(special_mass, float):
                     mass.append(special_mass)
                 else:
-                    raise Exception, "A 'special_mass' option must be specified"+\
-                 " in get_momenta when a leg with id=-10 is present (for CMS check)"
+                    raise Exception("A 'special_mass' option must be specified"+\
+                 " in get_momenta when a leg with id=-10 is present (for CMS check)")
         #mass = [math.sqrt(m.real) for m in mass]
 
 
@@ -694,9 +698,9 @@ class LoopMatrixElementEvaluator(MatrixE
                 elif isinstance(value, int):
                     ml_reds = str(value)
                 else:
-                    raise MadGraph5Error, 'The argument %s '%str(value)+\
+                    raise MadGraph5Error('The argument %s '%str(value)+\
                       ' in fix_MadLoopParamCard must be a string, integer'+\
-                      ' or a list.'
+                      ' or a list.')
                 MLCard.set("MLReductionLib",ml_reds)      
             elif key == 'ImprovePS':
                 MLCard.set('ImprovePSPoint',2 if value else -1)
@@ -705,9 +709,9 @@ class LoopMatrixElementEvaluator(MatrixE
             elif key in MLCard:
                 MLCard.set(key,value)
             else:
-                raise Exception, 'The MadLoop options %s specified in function'%key+\
+                raise Exception('The MadLoop options %s specified in function'%key+\
                   ' fix_MadLoopParamCard does not correspond to an option defined'+\
-                  ' MadLoop nor is it specially handled in this function.'
+                  ' MadLoop nor is it specially handled in this function.')
         if not mode is None:
             MLCard.set('CTModeRun',mode)
             MLCard.set('CTModeInit',mode)
@@ -816,8 +820,8 @@ class LoopMatrixElementEvaluator(MatrixE
         elif isinstance(output,str):
             text=output.split('\n')
         else:
-            raise MadGraph5Error, 'Type for argument output not supported in'+\
-                                                          ' parse_check_output.'
+            raise MadGraph5Error('Type for argument output not supported in'+\
+                                                          ' parse_check_output.')
         for line in text:
             splitline=line.split()
             if len(splitline)==0:
@@ -884,14 +888,14 @@ class LoopMatrixElementEvaluator(MatrixE
         if directories and os.path.isdir(directories[0]):
             exe_path = directories[0]
         else:
-            raise MadGraph5Error, 'Could not find a process executable '+\
-                                                      'directory in %s'%proc_dir
+            raise MadGraph5Error('Could not find a process executable '+\
+                                                      'directory in %s'%proc_dir)
         bu_path = pjoin(model_path, 'model_functions.f__backUp__')
         
         if mode=='default':
             # Restore the default source file model_function.f
             if not os.path.isfile(bu_path):
-                raise MadGraph5Error, 'Back up file %s could not be found.'%bu_path
+                raise MadGraph5Error('Back up file %s could not be found.'%bu_path)
             shutil.move(bu_path, pjoin(model_path, 'model_functions.f'))
             return
 
@@ -1002,7 +1006,7 @@ class LoopMatrixElementEvaluator(MatrixE
                                                               file_names[ind])):
             ind += 1
         if ind==len(file_names):
-            raise Exception, "No helas calls output file found."
+            raise Exception("No helas calls output file found.")
         
         helas_file_name=pjoin(dir_name,file_names[ind])
         file = open(pjoin(dir_name,helas_file_name), 'r')
@@ -1746,7 +1750,7 @@ class LoopMatrixElementTimer(LoopMatrixE
                 except KeyboardInterrupt:
                     interrupted = True
                     break
-                except IOError, e:
+                except IOError as e:
                     if e.errno == errno.EINTR:
                         if retry==100:
                             logger.error("Failed hundred times consecutively because"+
@@ -1843,9 +1847,9 @@ class LoopMatrixElementTimer(LoopMatrixE
                     if output != '':
                         last_non_empty = output
                     error = StabChecker.stderr.readline()
-                    raise MadGraph5Error, \
+                    raise MadGraph5Error( \
  "The MadLoop stability checker crashed with return code = %d, and last output:\n\nstdout: %s\nstderr: %s\n"%\
-                                               (ret_code, last_non_empty, error)
+                                               (ret_code, last_non_empty, error))
                     
             res = ""
             while True:
@@ -1862,9 +1866,9 @@ class LoopMatrixElementTimer(LoopMatrixE
                     if output != '':
                         last_non_empty = output
                     error = StabChecker.stderr.readline()
-                    raise MadGraph5Error, \
+                    raise MadGraph5Error( \
  "The MadLoop stability checker crashed with return code = %d, and last output:\n\nstdout: %s\nstderr: %s\n"%\
-                                               (ret_code, last_non_empty, error)
+                                               (ret_code, last_non_empty, error))
 
             return cls.parse_check_output(res,format='tuple')[0][0]
         except IOError as e:
@@ -3709,7 +3713,7 @@ def check_complex_mass_scheme(process_li
     # Add useful entries
     run_options['param_card'] = param_card
     if isinstance(cmd, FakeInterface):
-        raise MadGraph5Error, "Check CMS cannot be run with a FakeInterface."
+        raise MadGraph5Error("Check CMS cannot be run with a FakeInterface.")
     run_options['cmd']        = cmd
     run_options['MLOptions']  = MLOptions
     if output_path:
@@ -3921,8 +3925,8 @@ def check_complex_mass_scheme_process(pr
                                 new_resonance['FSMothersNumbers'].extend(
                                             replacement_dict[leg.get('number')])
                             except KeyError:
-                                raise Exception, 'The following diagram '+\
-                                              'is malformed:'+diag.nice_string()
+                                raise Exception('The following diagram '+\
+                                              'is malformed:'+diag.nice_string())
                                                
                     replacement_dict[s_channel.get('legs')[-1].get('number')] = \
                                                new_resonance['FSMothersNumbers']
@@ -4181,7 +4185,7 @@ def check_complex_mass_scheme_process(pr
             if options['offshellness']<0.0:
                 err_msg +='Try with a positive offshellness instead (or a '+\
                                        'negative one of smaller absolute value)'
-            raise InvalidCmd, err_msg
+            raise InvalidCmd(err_msg)
         else:
 #            misc.sprint('PS point found in %s trials.'%N_trials)
 #            misc.sprint(PS_point_found)
@@ -4285,9 +4289,9 @@ def check_complex_mass_scheme_process(pr
         else:
             # Crash if we are doing CMS and the width was not found and recycled above
             if aloha.complex_mass:
-                raise MadGraph5Error, "The width for particle with PDG %d and"%PDG+\
+                raise MadGraph5Error("The width for particle with PDG %d and"%PDG+\
                   " lambdaCMS=%f should have already been "%lambdaCMS+\
-                  "computed during the NWA run."
+                  "computed during the NWA run.")
 
         # Use MadWith
         if options['recompute_width'] in ['always','first_time']:
@@ -4318,8 +4322,8 @@ def check_complex_mass_scheme_process(pr
                 try:
                     tmp_param_card = check_param_card.ParamCard(pjoin(path,'tmp.dat'))
                 except:
-                    raise MadGraph5Error, 'Error occured during width '+\
-                       'computation with command:\n   compute_widths %s'%command                   
+                    raise MadGraph5Error('Error occured during width '+\
+                       'computation with command:\n   compute_widths %s'%command)                   
                 width = tmp_param_card['decay'].get(PDG).value
 #                misc.sprint('lambdaCMS checked is', lambdaCMS,
 #                                                   'for particle',particle_name)
@@ -4363,7 +4367,7 @@ def check_complex_mass_scheme_process(pr
             try:
                 new_seed = int(tweak[4:])
             except ValueError:
-                raise MadGraph5Error, "Seed '%s' is not of the right format 'seed<int>'."%tweak
+                raise MadGraph5Error("Seed '%s' is not of the right format 'seed<int>'."%tweak)
             random.seed(new_seed)
                 
     mode = 'CMS' if aloha.complex_mass else 'NWA'
@@ -4455,8 +4459,8 @@ def check_complex_mass_scheme_process(pr
                 retcode = subprocess.call(['make','check'],
                                    cwd=dir, stdout=devnull, stderr=devnull)                     
             if retcode != 0:
-                raise MadGraph5Error, "Compilation error with "+\
-                                                        "'make check' in %s"%dir
+                raise MadGraph5Error("Compilation error with "+\
+                                                        "'make check' in %s"%dir)
 
         # Now find all the resonances of the ME, if not saved from a previous run
         pkl_path = pjoin(proc_dir,'resonance_specs.pkl')
@@ -4550,8 +4554,8 @@ def check_complex_mass_scheme_process(pr
 
     # Already add the coupling order for this sqaured ME.
     if loop_order != -1 and (loop_order+born_order)%2 != 0:
-        raise MadGraph5Error, 'The summed squared matrix element '+\
-                              " order '%d' is not even."%(loop_order+born_order)
+        raise MadGraph5Error('The summed squared matrix element '+\
+                              " order '%d' is not even."%(loop_order+born_order))
     result = {'born_order':born_order, 
               'loop_order': (-1 if loop_order==-1 else (loop_order+born_order)/2),
               'resonances_result':[]}
@@ -4573,14 +4577,14 @@ def check_complex_mass_scheme_process(pr
             try:
                 logstart, logend = tweak.split('->')
             except:
-                raise Madgraph5Error, "Tweak '%s' not reckognized."%tweak
+                raise Madgraph5Error("Tweak '%s' not reckognized."%tweak)
             if logstart in ['logp','logm', 'log'] and \
                logend in ['logp','logm', 'log']:
                 if NLO:
                     evaluator.apply_log_tweak(proc_dir, [logstart, logend])
                     had_log_tweaks = True
             else:
-                raise Madgraph5Error, "Tweak '%s' not reckognized."%tweak
+                raise Madgraph5Error("Tweak '%s' not reckognized."%tweak)
         if had_log_tweaks:
             evaluator.apply_log_tweak(proc_dir, 'recompile')
 
@@ -5708,15 +5712,15 @@ minimum value of lambda to be considered
             nwa_born=nwa_res['born']
             if len(cms_born) != len(lambdaCMS_list) or\
                  len(nwa_born) != len(lambdaCMS_list):
-                raise MadGraph5Error, 'Inconsistent list of results w.r.t. the'+\
-                                ' lambdaCMS values specified for process %s'%process
+                raise MadGraph5Error('Inconsistent list of results w.r.t. the'+\
+                                ' lambdaCMS values specified for process %s'%process)
             if pert_orders:
                 cms_finite=cms_res['finite'] 
                 nwa_finite=nwa_res['finite']
                 if len(cms_finite) != len(lambdaCMS_list) or\
                     len(nwa_finite) != len(lambdaCMS_list):
-                    raise MadGraph5Error, 'Inconsistent list of results w.r.t. the'+\
-                                ' lambdaCMS values specified for process %s'%process
+                    raise MadGraph5Error('Inconsistent list of results w.r.t. the'+\
+                                ' lambdaCMS values specified for process %s'%process)
         
             bpower = guess_lambdaorder(nwa_born,lambdaCMS_list,
                     expected=proc_res['born_order'], proc=process, res=resonance)
diff -rupN MadGraph_pristine/madgraph/various/q_polynomial.py ../contrib/MadGraph/madgraph/various/q_polynomial.py
--- MadGraph_pristine/madgraph/various/q_polynomial.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/q_polynomial.py	2020-10-30 20:49:24.530460897 +1100
@@ -107,8 +107,8 @@ class Polynomial_naive_ordering(object):
         try:
             return self.coef_list.index(array.array('i',new_indices_list))
         except ValueError:
-            raise PolynomialError,\
-                "The index %s looked for could not be found"%str(indices_list)   
+            raise PolynomialError(\
+                "The index %s looked for could not be found"%str(indices_list))   
 
     def get_coef_at_position(self, pos):
         """ Returns the coefficient at position pos in the one dimensional
@@ -131,8 +131,8 @@ class PolynomialRoutines(object):
             self.updater_max_rank = max_rank
         else:
             if updater_max_rank > max_rank:
-                raise PolynomialError, "The updater max rank must be at most"+\
-                                                " equal to the overall max rank"
+                raise PolynomialError( "The updater max rank must be at most"+\
+                                                " equal to the overall max rank")
             else:
                 self.updater_max_rank = updater_max_rank            
         if coef_format=='complex*16':
@@ -146,8 +146,8 @@ class PolynomialRoutines(object):
             self.czero='(0.0e0,0.0e0)'
         self.line_split=line_split
         if max_rank<0:
-            raise PolynomialError, \
-                            "The rank of a q-polynomial should be 0 or positive"
+            raise PolynomialError( \
+                            "The rank of a q-polynomial should be 0 or positive")
         self.max_rank=max_rank
         self.pq=Polynomial(max_rank)
         
@@ -747,8 +747,8 @@ class FromIREGIFortranCodeGenerator():
         try:
             return self.coef_list.index(array.array('i',new_indices_list))
         except ValueError:
-            raise PolynomialError,\
-                "The index %s looked for could not be found"%str(indices_list)   
+            raise PolynomialError(\
+                "The index %s looked for could not be found"%str(indices_list))   
 
     def get_coef_at_position(self, pos):
         """ Returns the coefficient at position pos in the one dimensional
@@ -870,7 +870,7 @@ class FromGolem95FortranCodeGenerator():
         for num_eq in range(l):
             q = map(lambda i: cls.PRIMES[i], lst[num_eq])
             coeffs = [
-                reduce(lambda x,y: x*y, map(lambda (b,e): b**e, zip(q, term)), 1)
+                reduce(lambda x,y: x*y, map(lambda b,e: b**e, zip(q, term)), 1)
                 for term in lst]
             LHS.append(coeffs)
             RHS.append(q)
@@ -906,16 +906,16 @@ if __name__ == '__main__':
     """I test here the write_golem95_mapping function"""
     
     P=Polynomial(7)
-    print "Coef (6,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0])
-    print "Coef (1,1,2,2) is at pos %s"%P.get_coef_position([0,1,2,2,3,3])
-    print "Coef (7,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0,0])
-    print "Coef (1,2,2,2) is at pos %s"%P.get_coef_position([0,1,1,2,2,3,3])
+    print( "Coef (6,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0]))
+    print( "Coef (1,1,2,2) is at pos %s"%P.get_coef_position([0,1,2,2,3,3]))
+    print( "Coef (7,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0,0]))
+    print( "Coef (1,2,2,2) is at pos %s"%P.get_coef_position([0,1,1,2,2,3,3]))
     
     sys.exit(0)
 
     max_rank=6
     FPR=FortranPolynomialRoutines(max_rank)
-    print "Output of write_golem95_mapping function for max_rank=%d:\n\n"%max_rank
+    print( "Output of write_golem95_mapping function for max_rank=%d:\n\n"%max_rank)
 
     import os
     import sys
diff -rupN MadGraph_pristine/madgraph/various/rambo.py ../contrib/MadGraph/madgraph/various/rambo.py
--- MadGraph_pristine/madgraph/various/rambo.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/rambo.py	2020-10-30 20:49:24.530460897 +1100
@@ -116,7 +116,7 @@ def RAMBO(N,ET,XM):
         xmt += abs(XM[i])
         
     if xmt > ET:
-        raise RAMBOError, ' Not enough energy in this case'
+        raise RAMBOError(' Not enough energy in this case')
 
 #                                                                                                                                          
 # THE PARAMETER VALUES ARE NOW ACCEPTED                                                                                                    
@@ -159,10 +159,10 @@ def RAMBO(N,ET,XM):
     if N != 2:
         wt = (2 * N-4) * math.log(ET) + Z[N]
     if wt < -180 and iwarn[1] < 5:
-        print "RAMBO WARNS: WEIGHT = EXP(%f20.9) MAY UNDERFLOW" % wt
+        print("RAMBO WARNS: WEIGHT = EXP(%f20.9) MAY UNDERFLOW" % wt)
         iwarn[1] += 1
     if wt > 174 and iwarn[2] < 5:      
-        print " RAMBO WARNS: WEIGHT = EXP(%f20.9) MAY  OVERFLOW" % wt
+        print(" RAMBO WARNS: WEIGHT = EXP(%f20.9) MAY  OVERFLOW" % wt)
         iwarn[2] += 1
 
                                                                                                                                           
@@ -192,8 +192,8 @@ def RAMBO(N,ET,XM):
             break
         n_iter  += 1
         if n_iter  > itmax:
-            print "RAMBO WARNS: %s ITERATIONS DID NOT GIVE THE DESIRED ACCURACY = %s" \
-                    %(n_iter , f0)
+            print("RAMBO WARNS: %s ITERATIONS DID NOT GIVE THE DESIRED ACCURACY = %s" \
+                    %(n_iter , f0))
             break
         x=x-f0/(x*g0)
     for i in range(1, N+1):
@@ -213,10 +213,10 @@ def RAMBO(N,ET,XM):
 # RETURN FOR  WEIGHTED MASSIVE MOMENTA                                                                                                     
     wt += wtm
     if(wt < -180 and iwarn[3] < 5):
-        print " RAMBO WARNS: WEIGHT = EXP(%s) MAY UNDERFLOW" % wt
+        print(" RAMBO WARNS: WEIGHT = EXP(%s) MAY UNDERFLOW" % wt)
         iwarn[3] += 1
     if(wt > 174  and iwarn[4] > 5):
-        print " RAMBO WARNS: WEIGHT = EXP(%s) MAY OVERFLOW" % wt
+        print(" RAMBO WARNS: WEIGHT = EXP(%s) MAY OVERFLOW" % wt)
         iwarn[4] += 1
 
 # RETURN
diff -rupN MadGraph_pristine/madgraph/various/shower_card.py ../contrib/MadGraph/madgraph/various/shower_card.py
--- MadGraph_pristine/madgraph/various/shower_card.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/shower_card.py	2020-10-30 20:49:24.530460897 +1100
@@ -130,7 +130,7 @@ class ShowerCard(dict):
         if key in self.logical_vars:
             try:
                 self[key] = banner.ConfigFile.format_variable(value, bool, key)
-            except InvalidCmd, error:
+            except InvalidCmd as error:
                 raise ShowerCardError(str(error))
         elif key in self.string_vars:
             if value.lower() == 'none':
@@ -140,12 +140,12 @@ class ShowerCard(dict):
         elif key in self.int_vars:
             try:
                 self[key] = banner.ConfigFile.format_variable(value, int, key)
-            except InvalidCmd, error:
+            except InvalidCmd as error:
                 raise ShowerCardError(str(error))
         elif key in self.float_vars:
             try:
                 self[key] =  banner.ConfigFile.format_variable(value, float, key)
-            except InvalidCmd, error:
+            except InvalidCmd as error:
                 raise ShowerCardError(str(error))
         else:
             raise ShowerCardError('Unknown entry: %s = %s' % (key, value))
diff -rupN MadGraph_pristine/mg5decay/decay_objects.py ../contrib/MadGraph/mg5decay/decay_objects.py
--- MadGraph_pristine/mg5decay/decay_objects.py	2020-10-27 21:41:37.773088362 +1100
+++ ../contrib/MadGraph/mg5decay/decay_objects.py	2020-10-30 20:49:24.534460884 +1100
@@ -177,29 +177,29 @@ class DecayParticle(base_objects.Particl
 
         #Check if partnum is an integer.
         if not isinstance(partnum, int):
-            raise self.PhysicsObjectError, \
-                "Final particle number %s must be an integer." % str(partnum)
+            raise self.PhysicsObjectError( \
+                "Final particle number %s must be an integer." % str(partnum))
 
         #Check if onshell condition is Boolean number.
         if not isinstance(onshell, bool):
-            raise self.PhysicsObjectError, \
-                "%s must be a Boolean number" % str(onshell)
+            raise self.PhysicsObjectError( \
+                "%s must be a Boolean number" % str(onshell))
                 
         #Check if the value is a Vertexlist(in base_objects) or a list of vertex
         if not isinstance(value, base_objects.VertexList):
-            raise self.PhysicsObjectError, \
-                "%s must be VertexList type." % str(value)
+            raise self.PhysicsObjectError( \
+                "%s must be VertexList type." % str(value))
                     
         #Check if the model is a valid object.
         if not (isinstance(model, base_objects.Model) or model == {}):
-            raise self.PhysicsObjectError, \
-                "%s must be a Model" % str(model)
+            raise self.PhysicsObjectError( \
+                "%s must be a Model" % str(model))
         elif model:
             #Check if the mother particle is in the 'model'
             if not (self.get_pdg_code() in model.get('particle_dict').keys()):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "The model, %s, does not contain particle %s." \
-                    %(model.get('name'), self.get_name())
+                    %(model.get('name'), self.get_name()))
 
                             
     def check_vertexlist(self, partnum, onshell, value, model = {}):
@@ -219,8 +219,8 @@ class DecayParticle(base_objects.Particl
         #Check onshell condition if the model is given.
         if model:
             if (abs(eval(self.get('mass')) == 0.)) and (len(value) != 0):
-                raise self.PhysicsObjectError, \
-                    "Massless particle %s cannot decay." % self['name']
+                raise self.PhysicsObjectError( \
+                    "Massless particle %s cannot decay." % self['name'])
 
         for vert in value:
             # Reset the number of initial/final particles,
@@ -236,14 +236,14 @@ class DecayParticle(base_objects.Particl
                 
                 # Check the onshell condition
                 if (ini_mass.real > (total_mass.real - ini_mass.real))!=onshell:
-                    raise self.PhysicsObjectError, \
-                        "The on-shell condition is not satisfied."
+                    raise self.PhysicsObjectError( \
+                        "The on-shell condition is not satisfied.")
 
             for leg in vert.get('legs'):
                 # Check if all legs are label by true
                 if not leg.get('state'):
-                    raise self.PhysicsObjectError, \
-                        "The state of leg should all be true"
+                    raise self.PhysicsObjectError( \
+                        "The state of leg should all be true")
 
                 # Identify the initial particle
                 if leg.get('id') == self.get_pdg_code():
@@ -260,21 +260,21 @@ class DecayParticle(base_objects.Particl
 
             # Check the number of final particles is the same as partnum
             if num_final != partnum:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "The vertex is a %s -body decay, not a %s -body one."\
-                    % (str(num_final), str(partnum))
+                    % (str(num_final), str(partnum)))
 
             # Check if there is any appropriate leg as initial particle.
             if num_ini == 0:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "There is no leg satisfied the mother particle %s"\
-                    % str(self.get_pdg_code())
+                    % str(self.get_pdg_code()))
 
             # Check if the vertex is radiation
             if radiation:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "The vertex is radiactive for mother particle %s"\
-                    % str(self.get_pdg_code())
+                    % str(self.get_pdg_code()))
 
         return True
 
@@ -288,47 +288,47 @@ class DecayParticle(base_objects.Particl
 
         # Check if partnum is an integer.
         if not isinstance(partnum, int):
-            raise self.PhysicsObjectError, \
-                "Final particle number %s must be an integer." % str(partnum)
+            raise self.PhysicsObjectError( \
+                "Final particle number %s must be an integer." % str(partnum))
         
         # Check if onshell condition is Boolean number.
         if not isinstance(onshell, bool):
-            raise self.PhysicsObjectError, \
-                "%s must be a Boolean number" % str(onshell)
+            raise self.PhysicsObjectError( \
+                "%s must be a Boolean number" % str(onshell))
                 
         # Check if the value is a ChannelList
         if (not isinstance(value, ChannelList) and value):
-            raise self.PhysicsObjectError, \
-                "%s must be ChannelList type." % str(value)
+            raise self.PhysicsObjectError( \
+                "%s must be ChannelList type." % str(value))
                 
 
         # Check if the partnum is correct for all channels in value
         if any(ch for ch in value if \
                    len(ch.get_final_legs()) != partnum):
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                 "The final particle number of channel should be %d."\
-                % partnum
+                % partnum)
         
         # Check if the initial particle in all channels are as self.
         if any(ch for ch in value if \
                    abs(ch.get_anti_initial_id()) != abs(self.get('pdg_code'))):
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                 "The initial particle is not %d or its antipart." \
-                % self.get('pdg_code')
+                % self.get('pdg_code'))
 
         # Check if the onshell condition is right
         if not (isinstance(model, base_objects.Model) or model == {}):
-            raise self.PhysicsObjectError, \
-                "%s must be a Model" % str(model)
+            raise self.PhysicsObjectError( \
+                "%s must be a Model" % str(model))
         elif model:
             # Check if the mother particle is in the 'model'
             if not (self.get_pdg_code() in model.get('particle_dict').keys()):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "The model, %s, does not contain particle %s." \
-                    %(model.get('name'), self.get_name())
+                    %(model.get('name'), self.get_name()))
             if any([ch for ch in value if onshell != ch.get_onshell(model)]):
-                raise self.PhysicsObjectError, \
-                    "The onshell condition is not consistent with the model."
+                raise self.PhysicsObjectError( \
+                    "The onshell condition is not consistent with the model.")
         return True
 
 
@@ -340,13 +340,13 @@ class DecayParticle(base_objects.Particl
         """
         # Check if partnum is an integer.
         if not isinstance(partnum, int):
-            raise self.PhysicsObjectError, \
-                "Final particle number %s must be an integer." % str(partnum)
+            raise self.PhysicsObjectError( \
+                "Final particle number %s must be an integer." % str(partnum))
         
         # Check if the value is a DecayAmplitudeList
         if (not isinstance(value, DecayAmplitudeList) and value):
-            raise self.PhysicsObjectError, \
-                "%s must be DecayAmplitudeList type." % str(value)
+            raise self.PhysicsObjectError( \
+                "%s must be DecayAmplitudeList type." % str(value))
                 
         return True
 
@@ -356,18 +356,18 @@ class DecayParticle(base_objects.Particl
         if name == 'decay_vertexlist' or name == 'decay_channels':
             #Value must be a dictionary.
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Decay_vertexlist or decay_channels %s must be a dictionary." % str(value)
+                raise self.PhysicsObjectError( \
+                    "Decay_vertexlist or decay_channels %s must be a dictionary." % str(value))
 
             # key must be two element tuple
             for key, item in value.items():
                 if not isinstance(key, tuple):
-                    raise self.PhysicsObjectError,\
-                        "Key %s must be a tuple." % str(key)
+                    raise self.PhysicsObjectError(\
+                        "Key %s must be a tuple." % str(key))
                 
                 if len(key) != 2:
-                    raise self.PhysicsObjectError,\
-                        "Key %s must have two elements." % str(key)
+                    raise self.PhysicsObjectError(\
+                        "Key %s must have two elements." % str(key))
                 
                 if name == 'decay_vertexlist':
                     self.check_vertexlist(key[0], key[1], item)
@@ -378,8 +378,8 @@ class DecayParticle(base_objects.Particl
 
             #Value must be a dictionary.
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Decay_amplitudes %s must be a dictionary." % str(value)
+                raise self.PhysicsObjectError( \
+                    "Decay_amplitudes %s must be a dictionary." % str(value))
 
             # For each key and item, check them with check_amplitudes
             for key, item in value.items():                
@@ -387,20 +387,20 @@ class DecayParticle(base_objects.Particl
                     
         if name == 'vertexlist_found' or name == 'is_stable':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "Propery %s should be Boolean type." % name
+                raise self.PhysicsObjectError( \
+                    "Propery %s should be Boolean type." % name)
 
         if name == 'max_vertexorder':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Property %s should be int type." % name
+                raise self.PhysicsObjectError( \
+                    "Property %s should be int type." % name)
 
         # Check apx_decaywidth and apx_decaywidth_err
         if name == 'apx_decaywidth' or name == 'apx_decaywidth_err' \
                 or name == '2body_massdiff':
             if not isinstance(value, float) and not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Property %s must be float type." % str(value)
+                raise self.PhysicsObjectError( \
+                    "Property %s must be float type." % str(value))
 
         super(DecayParticle, self).filter(name, value)
 
@@ -576,14 +576,14 @@ class DecayParticle(base_objects.Particl
         
         #Raise error if self is not in model.
         if not (self.get_pdg_code() in model.get('particle_dict').keys()):
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                     "The parent particle %s is not in the model %s." \
-                        % (self.get('name'), model.get('name'))
+                        % (self.get('name'), model.get('name')))
 
         #Raise error if option is not Boolean value
         if not isinstance(option, bool):
-            raise self.PhysicsObjectError, \
-                    "The option %s must be True or False." % str(option)
+            raise self.PhysicsObjectError( \
+                    "The option %s must be True or False." % str(option))
         
         #If 'vertexlist_found' is true and option is false,
         #no action is proceed.
@@ -692,8 +692,8 @@ class DecayParticle(base_objects.Particl
             if self.check_channels(partnum, onshell, value_transform, model):
                 self['decay_channels'][(partnum, onshell)] = value_transform
         else:
-            raise self.PhysicsObjectError, \
-                "The input must be a list of diagrams."
+            raise self.PhysicsObjectError( \
+                "The input must be a list of diagrams.")
 
     def get_max_level(self):
         """ Get the max channel level that the particle have so far. """
@@ -713,14 +713,14 @@ class DecayParticle(base_objects.Particl
            If no suitable amplitude is found, retun None.
         """
         if not isinstance(final_ids, list):
-            raise self.PhysicsObjectError,\
+            raise self.PhysicsObjectError(\
                 "The final particle ids %s must be a list of integer." \
-                %str(final_ids)
+                %str(final_ids))
 
         if any([not isinstance(i, int) for i in final_ids]):
-            raise self.PhysicsObjectError,\
+            raise self.PhysicsObjectError(\
                 "The final particle ids %s must be a list of integer." \
-                %str(final_ids)
+                %str(final_ids))
 
         # Sort the given id list first
         final_ids.sort()
@@ -742,8 +742,8 @@ class DecayParticle(base_objects.Particl
         """
         #check the validity of arguments
         if not isinstance(partnum, int):
-            raise self.PhysicsObjectError, \
-                "The particle number %s must be an integer."  %str(partnum)
+            raise self.PhysicsObjectError( \
+                "The particle number %s must be an integer."  %str(partnum))
 
         try:
             return self.get('decay_amplitudes')[partnum]
@@ -767,8 +767,8 @@ class DecayParticle(base_objects.Particl
             if self.check_amplitudes(partnum, new_value):
                 self.decay_amplitudes[partnum] = new_value
         else:
-            raise self.PhysicsObjectError, \
-                "The input must be a list of decay amplitudes."
+            raise self.PhysicsObjectError( \
+                "The input must be a list of decay amplitudes.")
         
               
     def find_channels(self, partnum, model, min_br=0):
@@ -796,16 +796,16 @@ class DecayParticle(base_objects.Particl
 
         # Check validity of argument
         if not isinstance(partnum, int):
-            raise self.PhysicsObjectError, \
-                "Max final particle number %s should be integer." % str(partnum)
+            raise self.PhysicsObjectError( \
+                "Max final particle number %s should be integer." % str(partnum))
         if not isinstance(model, DecayModel):
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                 "The second argument %s should be a DecayModel object." \
-                % str(model)            
+                % str(model))            
         if not self in model['particles']:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                 "The model %s does not contain particle %s" \
-                % (model.get('name'), self.get('name'))
+                % (model.get('name'), self.get('name')))
 
         # If vertexlist has not been found before, run model.find_vertexlist
         if not model['vertexlist_found']:
@@ -1180,12 +1180,12 @@ class DecayParticle(base_objects.Particl
         """
 
         if not isinstance(clevel, int):
-            raise self.PhysicsObjectError, \
-                "The channel level %s must be an integer." % str(clevel)
+            raise self.PhysicsObjectError( \
+                "The channel level %s must be an integer." % str(clevel))
 
         if not isinstance(model, DecayModel):
-            raise self.PhysicsObjectError, \
-                "The model must be an DecayModel object."
+            raise self.PhysicsObjectError( \
+                "The model must be an DecayModel object.")
 
         # Reset the value of decay_amplitudes
         self.set_amplitudes(clevel, DecayAmplitudeList())
@@ -1414,24 +1414,24 @@ class DecayModel(model_reader.ModelReade
     def filter(self, name, value):
         if name == 'vertexlist_found':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "Property %s should be bool type." % name
+                raise self.PhysicsObjectError( \
+                    "Property %s should be bool type." % name)
         if name == 'max_vertexorder':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError,\
-                    "Property %s should be int type." % name
+                raise self.PhysicsObjectError(\
+                    "Property %s should be int type." % name)
         if name == 'stable_particles' or name == 'decay_groups':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError,\
-                    "Property %s should be a list contains several particle list." % name
+                raise self.PhysicsObjectError(\
+                    "Property %s should be a list contains several particle list." % name)
             for plist in value:                
                 if not isinstance(plist, list):
-                    raise self.PhysicsObjectError,\
-                    "Property %s should be a list contains several particle list." % name
+                    raise self.PhysicsObjectError(\
+                    "Property %s should be a list contains several particle list." % name)
                 for p in plist:
                     if not isinstance(p, DecayParticle):
-                        raise self.PhysicsObjectError,\
-                            "Property %s should be a list contains several particle list." % name
+                        raise self.PhysicsObjectError(\
+                            "Property %s should be a list contains several particle list." % name)
 
         super(DecayModel, self).filter(name, value)
         
@@ -1532,8 +1532,8 @@ class DecayModel(model_reader.ModelReade
             
         
         if not isinstance(number, int) or not isinstance(part, DecayParticle):
-            raise self.PhysicsObjectError, \
-                "Wrong argument types."
+            raise self.PhysicsObjectError( \
+                "Wrong argument types.")
 
         amps = part.get_amplitudes(number)
         diagrams = sum([[d for d in amp['diagrams']] for amp in amps],[])
@@ -1545,8 +1545,8 @@ class DecayModel(model_reader.ModelReade
             found = False
             for num, call in enumerate(calls):
                 if not call['helastag']:
-                    raise self.PhysicsObjectError, \
-                        "The helastag of helascalls should exist."
+                    raise self.PhysicsObjectError( \
+                        "The helastag of helascalls should exist.")
                 if call['helastag'] == helastag:
                     found = True
                     d['helas_number'] = num
@@ -1736,9 +1736,9 @@ class DecayModel(model_reader.ModelReade
                     # (indication of mother appears in final state)
                     if temp_vertex in self.get_particle(pid)['decay_vertexlist'][(partnum, onshell)] and not force:
 
-                        raise self.PhysicsObjectError,\
+                        raise self.PhysicsObjectError(\
                             "found duplicated %d-point vertices in %s" \
-                            % (partnum+1, self.get_particle(pid)['name'])
+                            % (partnum+1, self.get_particle(pid)['name']))
 
                     self.get_particle(pid)['decay_vertexlist'][(\
                             partnum, onshell)].append(temp_vertex)
@@ -1928,12 +1928,12 @@ class DecayModel(model_reader.ModelReade
         
         # Raise error if the colorlist is not the right format.
         if not isinstance(colorlist, list):
-            raise self.PhysicsObjectError,\
-                "The argument must be a list."
+            raise self.PhysicsObjectError(\
+                "The argument must be a list.")
 
         if any([not isinstance(i, int) for i in colorlist]):
-            raise self.PhysicsObjectError,\
-                "The argument must be a list of integer elements."
+            raise self.PhysicsObjectError(\
+                "The argument must be a list of integer elements.")
 
         # Sort the colorlist and 
         colorlist.sort()
@@ -1998,8 +1998,8 @@ class DecayModel(model_reader.ModelReade
         # Raise error for wrong type of q
         if not isinstance(q, int) and not isinstance(q, long) and \
                 not isinstance(q, float):
-            raise self.PhysicsObjectError, \
-                "The argument %s should be numerical type." %str(q)
+            raise self.PhysicsObjectError( \
+                "The argument %s should be numerical type." %str(q))
 
         # Declare global value. amZ0 is the alpha_s at Z pole
         global aS, amZ0, mdl_amZ0
@@ -2892,8 +2892,8 @@ class DecayModel(model_reader.ModelReade
 
         # Raise error if precision is not a float
         if not isinstance(precision, float):
-            raise self.PhysicsObjectError, \
-                "The precision %s should be float type." % str(precision)
+            raise self.PhysicsObjectError( \
+                "The precision %s should be float type." % str(precision))
 
         # If vertexlist has not been found before, run model.find_vertexlist
         if not self['vertexlist_found']:
@@ -2990,8 +2990,8 @@ class DecayModel(model_reader.ModelReade
                             % str(os.path.join(path, name)))
 
         else:
-            raise PhysicsObjectError,\
-                "The file name of the decay table must be str." % str(name)
+            raise PhysicsObjectError(\
+                "The file name of the decay table must be str." % str(name))
 
         summary_chart = ''
         summary_chart = (str('# DECAY WIDTH COMPARISON \n') +\
@@ -3100,8 +3100,8 @@ class DecayModel(model_reader.ModelReade
                                                name))))
 
         else:
-            raise PhysicsObjectError,\
-                "The file name of the decay table must be str." % str(name)
+            raise PhysicsObjectError(\
+                "The file name of the decay table must be str." % str(name))
 
         # Write the param_card used first
         fdata0 = open(mother_card_path, 'r')
@@ -3235,8 +3235,8 @@ class DecayModel(model_reader.ModelReade
                                                name))))
 
         else:
-            raise PhysicsObjectError,\
-                "The file name of the decay table must be str." % str(name)
+            raise PhysicsObjectError(\
+                "The file name of the decay table must be str." % str(name))
 
 
         collection = ''
@@ -3269,8 +3269,8 @@ class DecayModel(model_reader.ModelReade
            compare the width with our estimation."""
 
         if not os.path.isfile(param_card):
-            raise MadGraph5Error, \
-                "No such file %s" % param_card
+            raise MadGraph5Error( \
+                "No such file %s" % param_card)
     
         # Read in param_card
         logger.info("\nRead MG4 param_card: %s \n" % str(param_card))
@@ -3430,14 +3430,14 @@ class Channel(base_objects.Diagram):
                     'apx_decaywidth', 'apx_br',
                     'apx_decaywidth_nextlevel']:
             if not isinstance(value, float):
-                raise self.PhysicsObjectError, \
-                    "Value %s is not a float" % str(value)
+                raise self.PhysicsObjectError( \
+                    "Value %s is not a float" % str(value))
         
         if name == 'onshell' or name == 'has_idpart' or \
                 name == 'apx_width_calculated':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid onshell condition." % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid onshell condition." % str(value))
 
         return super(Channel, self).filter(name, value)
     
@@ -3523,7 +3523,7 @@ class Channel(base_objects.Diagram):
             self['ini_pid'] = model.get_particle(self.get_anti_initial_id()).get_anti_pdg_code()
             return self['ini_pid']
         else:
-            raise self.PhysicsObjectError, "No model is provided to get initial id."
+            raise self.PhysicsObjectError("No model is provided to get initial id.")
 
     def check_gauge_dependence(self, model):
         """ compare the vertex ids to see if anyone of them may be illed."""
@@ -3569,8 +3569,8 @@ class Channel(base_objects.Diagram):
         if not isinstance(self['onshell'], bool):
             # Check if model is valid
             if not isinstance(model, base_objects.Model):
-                raise self.PhysicsObjectError, \
-                    "The argument %s must be a model." % str(model)
+                raise self.PhysicsObjectError( \
+                    "The argument %s must be a model." % str(model))
 
             self['final_mass_list'] =sorted([abs(eval(model.get_particle(l.get('id')).get('mass'))) \
                                                 for l in self.get_final_legs()])
@@ -3647,8 +3647,8 @@ class Channel(base_objects.Diagram):
 
                 # Check if this vertex has the right order
                 if fermion_mother['id'] != mother_code:
-                    raise PhysicsObjectError, \
-                        "The order of particle in interaction is not standard."
+                    raise PhysicsObjectError( \
+                        "The order of particle in interaction is not standard.")
 
             # Refind the fermion_order except for initial vertex
             if i != len(self['vertices'])-2:
@@ -3999,7 +3999,7 @@ class Channel(base_objects.Diagram):
         
     @classmethod
     def init_regular_expression(cls):
-        dico = dict((`i`, '%s' % ','.join(["\s*-?'?[\w\s]*'?\s*"]*i)) for i in range(1,6))
+        dico = dict((repr(i), '%s' % ','.join(["\s*-?'?[\w\s]*'?\s*"]*i)) for i in range(1,6))
         cls.lor_pattern = re.compile("""(?<![a-zA-Z])(?P<var>PSlash\(%(3)s\)|
                                         Gamma\(%(3)s\)|
                                         Sigma\(%(4)s\)|
@@ -4170,7 +4170,7 @@ class Channel(base_objects.Diagram):
 
                     try:                    
                         lor_value = eval(new_structure % q_dict_lor)
-                    except NameError , error:
+                    except NameError as error:
                         ufo_struct = model.lorentz_dict[vertex['lorentz'][key[1]]]
 
                         for obj in ufo_struct.formfactors:
@@ -4179,7 +4179,7 @@ class Channel(base_objects.Diagram):
                             while True:
                                 try:
                                     exec('%s=%s' % (obj.name, val % q_dict_lor))
-                                except NameError, error:
+                                except NameError as error:
                                     failname = str(error).split("'")[1]
                                     exec('%s=mdl_%s' % (failname, failname))
                                 else:
@@ -4594,27 +4594,27 @@ class DecayAmplitude(diagram_generation.
 
         if name == 'process':
             if not isinstance(value, base_objects.Process):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Process object." % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid Process object." % str(value))
             # Reset the width and br
             self.reset_width_br()
 
         if name == 'diagrams':
             if not isinstance(value, ChannelList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ChannelList object." % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ChannelList object." % str(value))
             # Reset the width and br
             self.reset_width_br()
 
         if name == 'apx_decaywidth' and name == 'apx_br':
             if not isinstance(value, float):
-                raise self.PhysicsObjectError, \
-                        "%s is not a float." % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a float." % str(value))
 
         if name == 'exa_decaywidth':
             if not isinstance(value, float) and not isinstance(value,bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a float." % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a float." % str(value))
 
         return True
 
@@ -4653,8 +4653,8 @@ class DecayAmplitude(diagram_generation.
 
         # Check the number of initial leg is 1
         if dia['vertices'][-1]['legs'][-1]['number'] != 1:
-            raise self.PhysicsObjectError, \
-                "The number of initial leg should be setted as 1."
+            raise self.PhysicsObjectError( \
+                "The number of initial leg should be setted as 1.")
 
         # Append the initial leg.
         leglist = base_objects.LegList([base_objects.Leg({'id': dia.get_initial_id(model),
@@ -4675,14 +4675,14 @@ class DecayAmplitude(diagram_generation.
             of outgoing legs are consistent with the process."""
 
         if not isinstance(new_dia, Channel):
-            raise self.PhysicsObjectError,\
-                "The argument should be Channel object."
+            raise self.PhysicsObjectError(\
+                "The argument should be Channel object.")
 
         # Model must be provided in argument or in self['process']
         if not model:
             if not self['process']['model']:
-                raise self.PhysicsObjectError,\
-                    "No model is given either in argument or in process."
+                raise self.PhysicsObjectError(\
+                    "No model is given either in argument or in process.")
             else:
                 model = self['process']['model']
 
@@ -4819,8 +4819,8 @@ class DecayAmplitude(diagram_generation.
 
         # Raise error if format is wrong
         else:
-            raise self.PhysicsObjectError,\
-                "Format %s must be \'normal\' or \'full\'." % str(format)
+            raise self.PhysicsObjectError(\
+                "Format %s must be \'normal\' or \'full\'." % str(format))
 
         # Return output for full format case.
         return output
@@ -5003,8 +5003,8 @@ class AbstractModel(base_objects.Model):
             else:
                 return self['particle_type_dict'][abs(part)][1]
         else:
-            raise self.PhysicsObjectError, \
-                "Input should be Particle type or pdg_code(int)."
+            raise self.PhysicsObjectError( \
+                "Input should be Particle type or pdg_code(int).")
 
 
     def get_particle_type_code(self, part):
@@ -5032,8 +5032,8 @@ class AbstractModel(base_objects.Model):
 
         # Check argument type
         if not force and not isinstance(pdg_code, int):
-            raise self.PhysicsObjectError,\
-                "Argument must be a pdg_code."
+            raise self.PhysicsObjectError(\
+                "Argument must be a pdg_code.")
 
         # To ensure pdg_code is positive
         pdg_code = abs(pdg_code)
@@ -5113,8 +5113,8 @@ class AbstractModel(base_objects.Model):
 
         # Check argument type
         if not force and not isinstance(part, base_objects.Particle):
-            raise self.PhysicsObjectError,\
-                "Argument must be a Particle object."
+            raise self.PhysicsObjectError(\
+                "Argument must be a Particle object.")
 
         # Setup the particle_type_dict for all particle
         self['particle_type_dict'][part['pdg_code']] = \
@@ -5133,8 +5133,8 @@ class AbstractModel(base_objects.Model):
 
         # Check argument type
         if not force and not isinstance(part_list, base_objects.ParticleList):
-            raise self.PhysicsObjectError,\
-                "Argument must be a ParticleList."
+            raise self.PhysicsObjectError(\
+                "Argument must be a ParticleList.")
 
         # Call add_particle for each particle
         for part in part_list:
@@ -5179,7 +5179,7 @@ class AbstractModel(base_objects.Model):
             try:
                 input_pdgcode_list, original_order = zip(*temp)
             except:
-                print original_order, pdgcode_list
+                print(original_order, pdgcode_list)
 
         # Construct the abstract pid list
         for i, pdg_code in enumerate(input_pdgcode_list):
@@ -5276,9 +5276,9 @@ class AbstractModel(base_objects.Model):
         try:
             return self['interaction_type_dict'][inter_id]
         except KeyError:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                 "Interaction #%d has not been imported into AbstractModel." \
-                % inter_id
+                % inter_id)
 
 
     def add_ab_interaction(self, inter_id, force=False, color = None):
@@ -5289,8 +5289,8 @@ class AbstractModel(base_objects.Model):
 
         # Check argument type
         if not force and not isinstance(inter_id, int):
-            raise self.PhysicsObjectError,\
-                "Argument must be an Interaction id."
+            raise self.PhysicsObjectError(\
+                "Argument must be an Interaction id.")
         
         # Setup new interaction
         ab_inter = base_objects.Interaction()
@@ -5335,8 +5335,8 @@ class AbstractModel(base_objects.Model):
             ab_inter['color'] = \
                 self['abstract_interactions_dict'][inter_type][0]['color']
         else:
-            raise self.PhysicsObjectError,\
-                "Error to add interaction. No color information available."
+            raise self.PhysicsObjectError(\
+                "Error to add interaction. No color information available.")
 
         # couplings = G###cl##
         #              |  || |-> the serial number
@@ -5372,8 +5372,8 @@ class AbstractModel(base_objects.Model):
         # Check argument type
         if not force and not isinstance(inter_list, 
                                         base_objects.InteractionList):
-            raise self.PhysicsObjectError,\
-                "Argument must be an InteractionList."
+            raise self.PhysicsObjectError(\
+                "Argument must be an InteractionList.")
 
         # Add all interactions except for
         # 1. radiation interaction, 2. interaction with all stable particles
@@ -5643,11 +5643,11 @@ class AbstractModel(base_objects.Model):
         """
 
         if not isinstance(ab_dia, Channel) or not isinstance(real_dia, Channel):
-            raise self.PhysicsObjectError,\
-                "The first two argument are not Channel objects."
+            raise self.PhysicsObjectError(\
+                "The first two argument are not Channel objects.")
         if ab2realdict != None and not isinstance(ab2realdict, Ab2RealDict):
-            raise self.PhysicsObjectError,\
-                "The final argument should be Ab2RealDict, otherwise should be omitted."
+            raise self.PhysicsObjectError(\
+                "The final argument should be Ab2RealDict, otherwise should be omitted.")
             
 
         # Interaction id list
@@ -5718,11 +5718,11 @@ class AbstractModel(base_objects.Model):
         The abstract_type of abstract diagram is constructed. """
 
         if not isinstance(ab_amp, DecayAmplitude):
-            raise self.PhysicsObjectError,\
-                "The first argument  is not DecayAmplitude object."
+            raise self.PhysicsObjectError(\
+                "The first argument  is not DecayAmplitude object.")
         if not isinstance(real_dia, Channel):
-            raise self.PhysicsObjectError,\
-                "The second argument is not Channel object."
+            raise self.PhysicsObjectError(\
+                "The second argument is not Channel object.")
 
         ab_dia = Channel({'onshell': True})
         ab_dia['vertices'] = copy.deepcopy(real_dia['vertices'])
@@ -5949,8 +5949,8 @@ class Ab2RealDict(base_objects.PhysicsOb
         elif isinstance(ab_object, AbstractModel):
             ab_pids = ab_object.get_particlelist_type(real_pids, sn_dict = {ab_object.get_particle_type(ini_pid): 1})[0]
         else:
-            raise self.PhysicsObjectError, \
-                "The first argument is not necessary, otherwise it should be AbstractModel."
+            raise self.PhysicsObjectError( \
+                "The first argument is not necessary, otherwise it should be AbstractModel.")
 
         # Reset final_legs_dict
         self['final_legs_dict'] = {}
diff -rupN MadGraph_pristine/models/check_param_card.py ../contrib/MadGraph/models/check_param_card.py
--- MadGraph_pristine/models/check_param_card.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/check_param_card.py	2020-10-30 20:49:24.534460884 +1100
@@ -3,7 +3,12 @@ from __future__ import division
 import itertools
 import xml.etree.ElementTree as ET
 import math
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import os
 import re
 import shutil
@@ -174,7 +179,7 @@ class Block(list):
             return self.param_dict[tuple(lhacode)]
         except KeyError:
             if default is None:
-                raise KeyError, 'id %s is not in %s' % (tuple(lhacode), self.name)
+                raise KeyError('id %s is not in %s' % (tuple(lhacode), self.name))
             else:
                 return Parameter(block=self, lhacode=lhacode, value=default,
                                                            comment='not define')
@@ -227,8 +232,8 @@ class Block(list):
             
         if tuple(obj.lhacode) in self.param_dict:
             if self.param_dict[tuple(obj.lhacode)].value != obj.value:
-                raise InvalidParamCard, '%s %s is already define to %s impossible to assign %s' % \
-                    (self.name, obj.lhacode, self.param_dict[tuple(obj.lhacode)].value, obj.value)
+                raise InvalidParamCard('%s %s is already define to %s impossible to assign %s' % \
+                    (self.name, obj.lhacode, self.param_dict[tuple(obj.lhacode)].value, obj.value))
             return
         list.append(self, obj)
         # update the dictionary of key
@@ -486,7 +491,7 @@ class ParamCard(dict):
                 model_value = parameters[particle.get('mass')]
                 if isinstance(model_value, complex):
                     if model_value.imag > 1e-5 * model_value.real:
-                        raise Exception, "Mass should be real number: particle %s (%s) has mass: %s"  % (lhacode, particle.get('name'), model_value)
+                        raise Exception("Mass should be real number: particle %s (%s) has mass: %s"  % (lhacode, particle.get('name'), model_value))
                     model_value = model_value.real
                     
                 if not misc.equal(model_value, param_value, 4):
@@ -510,7 +515,7 @@ class ParamCard(dict):
                 model_value = parameters[particle.get('width')]
                 if isinstance(model_value, complex):
                     if model_value.imag > 1e-5 * model_value.real:
-                        raise Exception, "Width should be real number: particle %s (%s) has mass: %s" 
+                        raise Exception("Width should be real number: particle %s (%s) has mass: %s" )
                     model_value = model_value.real
                 if not misc.equal(abs(model_value), param_value, 4):
                     modify = True
@@ -683,14 +688,14 @@ class ParamCard(dict):
             return
         
         if len(internal_param)!=1:
-            raise InvalidParamCard,' The specified EW inputs has more than one'+\
-                ' unknown: [%s]'%(','.join([str(elem) for elem in internal_param]))
+            raise InvalidParamCard(' The specified EW inputs has more than one'+\
+                ' unknown: [%s]'%(','.join([str(elem) for elem in internal_param])))
         
         
         if not internal_param[0] in [('mass',(24,)), ('sminputs',(2,)),
                                                              ('sminputs',(1,))]:
-            raise InvalidParamCard, ' The only EW input scheme currently supported'+\
-                        ' are those with either the W mass or GF left internal.'
+            raise InvalidParamCard(' The only EW input scheme currently supported'+\
+                        ' are those with either the W mass or GF left internal.')
         
         # Now if the Wmass is internal, then we must change the scheme
         if internal_param[0] == ('mass',(24,)):
@@ -784,13 +789,13 @@ class ParamCard(dict):
         
         if not lhacode:
             logger.info("Information on block parameter %s:" % block, '$MG:color:BLUE')
-            print  str(self[block])
+            print(str(self[block]))
         elif default:
             pname2block, restricted = default.analyze_param_card()
             if (block, lhacode) in restricted:
                 logger.warning("This parameter will not be consider by MG5_aMC")
                 print( "    MadGraph will use the following formula:")
-                print restricted[(block, lhacode)]
+                prin(restricted[(block, lhacode)])
                 print( "     Note that some code (MadSpin/Pythia/...) will read directly the value")  
             else:
                 for name, values in pname2block.items():
@@ -856,7 +861,7 @@ class ParamCard(dict):
             if param.value != value:
                 error_msg = 'This card is not suitable to be convert to SLAH1\n'
                 error_msg += 'Parameter %s %s should be %s' % (block, lhacode, value)
-                raise InvalidParamCard, error_msg   
+                raise InvalidParamCard(error_ms)   
             self.remove_param(block, lhacode)
 
 
@@ -942,15 +947,15 @@ class ParamCardIterator(ParamCard):
                     try:
                         key, def_list = pattern.findall(param.value)[0]
                     except:
-                        raise Exception, "Fail to handle scanning tag: Please check that the syntax is valid"
+                        raise Exception("Fail to handle scanning tag: Please check that the syntax is valid")
                     if key == '': 
                         key = -1 * len(all_iterators)
                     if key not in all_iterators:
                         all_iterators[key] = []
                     try:
                         all_iterators[key].append( (param, eval(def_list)))
-                    except SyntaxError, error:
-                        raise Exception, "Fail to handle your scan definition. Please check your syntax:\n entry: %s \n Error reported: %s" %(def_list, error)
+                    except SyntaxError as error:
+                        raise Exception("Fail to handle your scan definition. Please check your syntax:\n entry: %s \n Error reported: %s" %(def_list, error))
                 elif isinstance(param.value, str) and param.value.strip().lower().startswith('auto'):
                     self.autowidth.append(param)
         keys = all_iterators.keys() # need to fix an order for the scan
@@ -958,7 +963,7 @@ class ParamCardIterator(ParamCard):
         #store the type of parameter
         for key in keys:
             for param, values in all_iterators[key]:
-                self.param_order.append("%s#%s" % (param.lhablock, '_'.join(`i` for i in param.lhacode)))
+                self.param_order.append("%s#%s" % (param.lhablock, '_'.join(repr(i) for i in param.lhacode)))
             
         # do the loop
         lengths = [range(len(all_iterators[key][0][1])) for key in keys]
@@ -1276,8 +1281,8 @@ class ParamCardRule(object):
             else:
                 if value != 0:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not at zero' % \
-                                    (block, ' '.join([str(i) for i in id])) 
+                        raise InvalidParamCard('parameter %s: %s is not at zero' % \
+                                    (block, ' '.join([str(i) for i in id])) )
                     else:
                         param = card[block].get(id) 
                         param.value = 0.0
@@ -1307,8 +1312,8 @@ class ParamCardRule(object):
             else:   
                 if value != 1:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not at one but at %s' % \
-                                    (block, ' '.join([str(i) for i in id]), value)         
+                        raise InvalidParamCard('parameter %s: %s is not at one but at %s' % \
+                                    (block, ' '.join([str(i) for i in id]), value))         
                     else:
                         param = card[block].get(id) 
                         param.value = 1.0
@@ -1343,9 +1348,9 @@ class ParamCardRule(object):
 
                 if value1 != value2:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not to identical to parameter  %s' % \
+                        raise InvalidParamCard('parameter %s: %s is not to identical to parameter  %s' % \
                                     (block, ' '.join([str(i) for i in id1]),
-                                            ' '.join([str(i) for i in id2]))         
+                                            ' '.join([str(i) for i in id2])))         
                     else:
                         param = card[block].get(id1) 
                         param.value = value2
@@ -1372,9 +1377,9 @@ class ParamCardRule(object):
 
                 if value1 != -value2:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not to opposite to parameter  %s' % \
+                        raise InvalidParamCard('parameter %s: %s is not to opposite to parameter  %s' % \
                                     (block, ' '.join([str(i) for i in id1]),
-                                            ' '.join([str(i) for i in id2]))         
+                                            ' '.join([str(i) for i in id2])))         
                     else:
                         param = card[block].get(id1) 
                         param.value = -value2
@@ -1648,8 +1653,8 @@ def convert_to_mg5card(path, outputpath=
     ae = card['ae'].get([1, 1], default=0).value
     card.mod_param('ae', [1,1], 'te', [1,1], value= ae * ye, comment='T_e(Q) DRbar')
     if ae * ye:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ae [1, 1] times ye [1,1] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ae [1, 1] times ye [1,1] should be 0''')
     card.remove_param('ae', [1,1])
     #2
     ye = card['ye'].get([2, 2], default=0).value
@@ -1657,8 +1662,8 @@ Parameter ae [1, 1] times ye [1,1] shoul
     ae = card['ae'].get([2, 2], default=0).value
     card.mod_param('ae', [2,2], 'te', [2,2], value= ae * ye, comment='T_mu(Q) DRbar')
     if ae * ye:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ae [2, 2] times ye [2,2] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ae [2, 2] times ye [2,2] should be 0''')
     card.remove_param('ae', [2,2])
     #3
     ye = card['ye'].get([3, 3], default=0).value
@@ -1670,8 +1675,8 @@ Parameter ae [2, 2] times ye [2,2] shoul
     au = card['au'].get([1, 1], default=0).value
     card.mod_param('au', [1,1], 'tu', [1,1], value= au * yu, comment='T_u(Q) DRbar')
     if au * yu:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter au [1, 1] times yu [1,1] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter au [1, 1] times yu [1,1] should be 0''')
     card.remove_param('au', [1,1])
     #2
     ye = card['yu'].get([2, 2], default=0).value
@@ -1679,8 +1684,8 @@ Parameter au [1, 1] times yu [1,1] shoul
     ae = card['au'].get([2, 2], default=0).value
     card.mod_param('au', [2,2], 'tu', [2,2], value= au * yu, comment='T_c(Q) DRbar')
     if au * yu:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter au [2, 2] times yu [2,2] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter au [2, 2] times yu [2,2] should be 0''')
     card.remove_param('au', [2,2])
     #3
     yu = card['yu'].get([3, 3]).value
@@ -1692,8 +1697,8 @@ Parameter au [2, 2] times yu [2,2] shoul
     ad = card['ad'].get([1, 1], default=0).value
     card.mod_param('ad', [1,1], 'td', [1,1], value= ad * yd, comment='T_d(Q) DRbar')
     if ad * yd:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ad [1, 1] times yd [1,1] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ad [1, 1] times yd [1,1] should be 0''')
     card.remove_param('ad', [1,1])
     #2
     ye = card['yd'].get([2, 2], default=0).value
@@ -1701,8 +1706,8 @@ Parameter ad [1, 1] times yd [1,1] shoul
     ae = card['ad'].get([2, 2], default=0).value
     card.mod_param('ad', [2,2], 'td', [2,2], value= ad * yd, comment='T_s(Q) DRbar')
     if ad * yd:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ad [2, 2] times yd [2,2] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ad [2, 2] times yd [2,2] should be 0''')
     card.remove_param('ad', [2,2])
     #3
     yd = card['yd'].get([3, 3]).value
diff -rupN MadGraph_pristine/models/import_ufo.py ../contrib/MadGraph/models/import_ufo.py
--- MadGraph_pristine/models/import_ufo.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/import_ufo.py	2020-10-30 20:49:24.534460884 +1100
@@ -121,8 +121,8 @@ def get_model_db():
             continue
         break
     else:
-        raise MadGraph5Error, '''Model not found locally and Impossible to connect any of us servers.
-        Please check your internet connection or retry later'''
+        raise MadGraph5Error('''Model not found locally and Impossible to connect any of us servers.
+        Please check your internet connection or retry later''')
     return data
 
 def import_model_from_db(model_name, local_dir=False):
@@ -153,7 +153,7 @@ def import_model_from_db(model_name, loc
         try:
             import pwd
             username =pwd.getpwuid( os.getuid() )[ 0 ]  
-        except Exception, error:
+        except Exception as error:
             misc.sprint(str(error))
             username = ''
     if username in ['omatt', 'mattelaer', 'olivier'] and target is None and \
@@ -189,7 +189,7 @@ def import_model_from_db(model_name, loc
         except:
             proc = misc.call('tar -xzpvf tmp.tgz', shell=True, cwd=target)#, stdout=devnull, stderr=devnull)
     if proc:
-        raise Exception, "Impossible to unpack the model. Please install it manually"
+        raise Exception("Impossible to unpack the model. Please install it manually")
     return True
 
 def import_model(model_name, decay=False, restrict=True, prefix='mdl_',
@@ -233,7 +233,7 @@ def import_model(model_name, decay=False
             elif os.path.exists(restrict):
                 restrict_file = restrict
             else:
-                raise Exception, "%s is not a valid path for restrict file" % restrict
+                raise Exception("%s is not a valid path for restrict file" % restrict)
     
     #import the FULL model
     model = import_full_model(model_path, decay, prefix)
@@ -326,8 +326,8 @@ def import_full_model(model_path, decay=
         filepath = os.path.join(model_path, filename)
         if not os.path.isfile(filepath):
             if filename not in ['propagators.py', 'decays.py', 'coupling_orders.py']:
-                raise UFOImportError,  "%s directory is not a valid UFO model: \n %s is missing" % \
-                                                         (model_path, filename)
+                raise UFOImportError("%s directory is not a valid UFO model: \n %s is missing" % \
+                                                         (model_path, filename))
         files_list.append(filepath)
     # use pickle files if defined and up-to-date
     if aloha.unitary_gauge: 
@@ -343,7 +343,7 @@ def import_full_model(model_path, decay=
         try:
             model = save_load_object.load_from_file( \
                                           os.path.join(model_path, pickle_name))
-        except Exception, error:
+        except Exception as error:
             logger.info('failed to load model from pickle file. Try importing UFO from File')
         else:
             # We don't care about the restrict_card for this comparison
@@ -377,7 +377,7 @@ def import_full_model(model_path, decay=
                 logger.info('reload from .py file')
 
     if (model_path, aloha.unitary_gauge, prefix, decay) in _import_once and not allow_reload:
-        raise MadGraph5Error, 'This model %s is modified on disk. To reload it you need to quit/relaunch MG5_aMC ' % model_path
+        raise MadGraph5Error('This model %s is modified on disk. To reload it you need to quit/relaunch MG5_aMC ' % model_path)
      
     # Load basic information
     ufo_model = ufomodels.load_model(model_path, decay)
@@ -456,7 +456,7 @@ class UFOMG5Converter(object):
             for order in model.all_orders:
                 if(order.perturbative_expansion>0):
                     self.perturbation_couplings[order.name]=order.perturbative_expansion
-        except AttributeError,error:
+        except AttributeError as error:
             pass
 
         if self.perturbation_couplings!={}:
@@ -483,11 +483,11 @@ class UFOMG5Converter(object):
         for param in self.ufomodel.all_parameters:
             if param.nature == "external":
                 if len(param.lhablock.split())>1:
-                    raise InvalidModel, '''LHABlock should be single word which is not the case for
-    \'%s\' parameter with lhablock \'%s\' ''' % (param.name, param.lhablock)
+                    raise InvalidModel('''LHABlock should be single word which is not the case for
+    \'%s\' parameter with lhablock \'%s\' ''' % (param.name, param.lhablock))
             if param.name in def_name:
-                raise InvalidModel, "name %s define multiple time. Please correct the UFO model!" \
-                                                                  % (param.name)
+                raise InvalidModel("name %s define multiple time. Please correct the UFO model!" \
+                                                                  % (param.name))
             else:
                 def_name.append(param.name)
                                                                   
@@ -499,8 +499,8 @@ class UFOMG5Converter(object):
                     if CTparam.pole(pole)!='ZERO':
                         new_param_name = '%s_%s_'%(CTparam.name,pole_dict[pole])
                         if new_param_name in def_name:
-                            raise InvalidModel, "CT name %s"% (new_param_name)+\
-                                           " the model. Please change its name."
+                            raise InvalidModel("CT name %s"% (new_param_name)+\
+                                           " the model. Please change its name.")
 
         if hasattr(self.ufomodel, 'gauge'):    
             self.model.set('gauge', self.ufomodel.gauge)
@@ -558,7 +558,7 @@ class UFOMG5Converter(object):
         if self.perturbation_couplings:
             try:
                 self.ufomodel.add_NLO()
-            except Exception, error:
+            except Exception as error:
                 pass 
 
             for interaction_info in self.ufomodel.all_CTvertices:
@@ -581,7 +581,7 @@ class UFOMG5Converter(object):
             all_orders = self.ufomodel.all_orders
         except AttributeError:
             if self.perturbation_couplings:
-                raise MadGraph5Error, "The loop model MG5 attemps to import does not specify the attribute 'all_order'." 
+                raise MadGraph5Error("The loop model MG5 attemps to import does not specify the attribute 'all_order'." )
             else:
                 pass            
 
@@ -591,7 +591,7 @@ class UFOMG5Converter(object):
                 hierarchy[order.name]=order.hierarchy
         except AttributeError:
             if self.perturbation_couplings:
-                raise MadGraph5Error, 'The loop model MG5 attemps to import does not specify an order hierarchy.' 
+                raise MadGraph5Error('The loop model MG5 attemps to import does not specify an order hierarchy.' )
             else:
                 pass
         else:
@@ -607,7 +607,7 @@ class UFOMG5Converter(object):
                 coupling_order_counterterms[order.name]=order.expansion_order                
         except AttributeError:
             if self.perturbation_couplings:
-                raise MadGraph5Error, 'The loop model MG5 attemps to import does not specify an expansion_order for all coupling orders.' 
+                raise MadGraph5Error('The loop model MG5 attemps to import does not specify an expansion_order for all coupling orders.' )
             else:
                 pass
         else:
@@ -945,8 +945,8 @@ class UFOMG5Converter(object):
                 return None
             start = expr.rfind('(',0,end+1)
             if start ==-1:
-                raise InvalidModel,\
-                               'Parenthesis of expression %s are malformed'%expr
+                raise InvalidModel(\
+                               'Parenthesis of expression %s are malformed'%expr)
             return [expr[:start],expr[start+1:end],expr[end+1:]]
         
         start_parenthesis = re.compile(r".*\s*[\+\-\*\/\)\(]\s*$")
@@ -1067,8 +1067,8 @@ class UFOMG5Converter(object):
         
         intType=''
         if interaction_info.type not in ['UV','UVloop','UVtree','UVmass','R2']:
-            raise MadGraph5Error, 'MG5 only supports the following types of'+\
-              ' vertices, R2, UV and UVmass. %s is not in this list.'%interaction_info.type
+            raise MadGraph5Error('MG5 only supports the following types of'+\
+              ' vertices, R2, UV and UVmass. %s is not in this list.'%interaction_info.type)
         else:
             intType=interaction_info.type
             # If not specified and simply set to UV, guess the appropriate type
@@ -1113,12 +1113,12 @@ class UFOMG5Converter(object):
                     expression = coupling.pole(poleOrder)
                     if expression!='ZERO':
                         if poleOrder==2:
-                            raise InvalidModel, """
+                            raise InvalidModel("""
     The CT coupling %s was found with a contribution to the double pole. 
     This is either an error in the model or a parsing error in the function 'is_value_zero'.
     The expression of the non-zero double pole coupling is:
     %s
-    """%(coupling.name,str(coupling.value))
+    """%(coupling.name,str(coupling.value)))
                         # It is actually safer that the new coupling associated to
                         # the interaction added is not a reference to an original 
                         # coupling in the ufo model. So copy.copy is right here.   
@@ -1235,16 +1235,16 @@ class UFOMG5Converter(object):
             # Check/assign for the color particle
             if color.pdg_code in output: 
                 if output[color.pdg_code] == -3:
-                    raise InvalidModel, 'Particles %s is sometimes in the 3 and sometimes in the 3bar representations' \
-                                    % color.name
+                    raise InvalidModel('Particles %s is sometimes in the 3 and sometimes in the 3bar representations' \
+                                    % color.name)
             else:
                 output[color.pdg_code] = 3
             
             # Check/assign for the anticolor particle
             if anticolor.pdg_code in output: 
                 if output[anticolor.pdg_code] == 3:
-                    raise InvalidModel, 'Particles %s is sometimes set as in the 3 and sometimes in the 3bar representations' \
-                                    % anticolor.name
+                    raise InvalidModel('Particles %s is sometimes set as in the 3 and sometimes in the 3bar representations' \
+                                    % anticolor.name)
             else:
                 output[anticolor.pdg_code] = -3
         
@@ -1260,12 +1260,12 @@ class UFOMG5Converter(object):
             # check if the interaction meet requirements:
             pdg = [p.pdg_code for p in interaction_info.particles if p.spin in [2,4]]
             if len(pdg) % 2:
-                raise InvalidModel, 'Odd number of fermion in vertex: %s' % [p.pdg_code for p in interaction_info.particles]
+                raise InvalidModel('Odd number of fermion in vertex: %s' % [p.pdg_code for p in interaction_info.particles])
             for i in range(0, len(pdg),2):
                 if pdg[i] == - pdg[i+1]:
                     if pdg[i] in self.outcoming:
-                        raise InvalidModel, '%s has not coherent incoming/outcoming status between interactions' %\
-                            [p for p in interaction_info.particles if p.spin in [2,4]][i].name
+                        raise InvalidModel('%s has not coherent incoming/outcoming status between interactions' %\
+                            [p for p in interaction_info.particles if p.spin in [2,4]][i].name)
                             
                     elif not pdg[i] in self.incoming:
                         self.incoming.append(pdg[i])
@@ -1297,12 +1297,12 @@ class UFOMG5Converter(object):
             elif nb_fermion:
                 if any(p.selfconjugate for p in interaction_info.particles if p.spin % 2 == 0):
                     text = "Majorana can not be dealt in 4/6/... fermion interactions"
-                    raise InvalidModel, text
-        except aloha_fct.WrongFermionFlow, error:
+                    raise InvalidModel(text)
+        except aloha_fct.WrongFermionFlow as error:
             text = 'Fermion Flow error for interactions %s: %s: %s\n %s' % \
              (', '.join([p.name for p in interaction_info.particles]), 
                                              helas.name, helas.structure, error)
-            raise InvalidModel, text
+            raise InvalidModel(text)
         
      
         
@@ -1332,9 +1332,9 @@ class UFOMG5Converter(object):
                 order = tuple(coupling.order.items())
 
                 if '1' in coupling.order:
-                    raise InvalidModel, '''Some couplings have \'1\' order. 
+                    raise InvalidModel('''Some couplings have \'1\' order. 
                     This is not allowed in MG. 
-                    Please defines an additional coupling to your model''' 
+                    Please defines an additional coupling to your model''' )
                 # check that gluon emission from quark are QCD tagged
                 if 21 in [particle.pdg_code for particle in interaction_info.particles] and\
                     'QCD' not in  coupling.order:
@@ -1458,14 +1458,14 @@ class UFOMG5Converter(object):
                     error_msg = 'UFO model have inconsistency in the format:\n'
                     error_msg += 'interactions for  particles %s has color information %s\n'
                     error_msg += ' but both fermion are in the same representation %s'
-                    raise InvalidModel, error_msg % (', '.join([p.name for p in interaction_info.particles]),data_string, particle.color)
+                    raise InvalidModel(error_msg % (', '.join([p.name for p in interaction_info.particles]),data_string, particle.color))
                 if particle.color == particle2.color and particle.color in [-3, 3]:
                     if particle.pdg_code in color_info and particle2.pdg_code in color_info:
                       if color_info[particle.pdg_code] == color_info[particle2.pdg_code]:
                         error_msg = 'UFO model have inconsistency in the format:\n'
                         error_msg += 'interactions for  particles %s has color information %s\n'
                         error_msg += ' but both fermion are in the same representation %s'
-                        raise InvalidModel, error_msg % (', '.join([p.name for p in interaction_info.particles]),data_string, particle.color)
+                        raise InvalidModel(error_msg % (', '.join([p.name for p in interaction_info.particles]),data_string, particle.color))
                     elif particle.pdg_code in color_info:
                         color_info[particle2.pdg_code] = -particle.pdg_code
                     elif particle2.pdg_code in color_info:
@@ -1474,7 +1474,7 @@ class UFOMG5Converter(object):
                         error_msg = 'UFO model have inconsistency in the format:\n'
                         error_msg += 'interactions for  particles %s has color information %s\n'
                         error_msg += ' but both fermion are in the same representation %s'
-                        raise InvalidModel, error_msg % (', '.join([p.name for p in interaction_info.particles]),data_string, particle.color)
+                        raise InvalidModel(error_msg % (', '.join([p.name for p in interaction_info.particles]),data_string, particle.color))
                 
                 
                 if particle.color == 6:
@@ -1509,9 +1509,9 @@ class UFOMG5Converter(object):
                     elif color_info[particle.pdg_code] == -3:
                         output.append(self._pat_id.sub('color.T(\g<first>,\g<second>)', term))
                 else:
-                    raise MadGraph5Error, \
+                    raise MadGraph5Error( \
                           "Unknown use of Identity for particle with color %d" \
-                          % particle.color
+                          % particle.color)
             else:
                 output.append(term)
         data_string = '*'.join(output)
diff -rupN MadGraph_pristine/models/__init__.py ../contrib/MadGraph/models/__init__.py
--- MadGraph_pristine/models/__init__.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/__init__.py	2020-10-30 20:49:24.534460884 +1100
@@ -44,10 +44,18 @@ def load_model(name, decay=False):
         model_path = os.path.realpath(os.sep.join(path_split))
         sys_path = os.path.realpath(os.path.dirname(sys.modules[path_split[-1]].__file__))
         if sys_path != model_path:
-            raise Exception, 'name %s already consider as a python library cann\'t be reassigned(%s!=%s)' % \
-                (path_split[-1], model_path, sys_path) 
+            raise Exception('name %s already consider as a python library cann\'t be reassigned(%s!=%s)' % \
+                (path_split[-1], model_path, sys_path) )
 
     with misc.TMP_variable(sys, 'path', [os.sep.join(path_split[:-1])]):
+        import subprocess
+        if os.path.isfile(name + '/__init__.py') : subprocess.call(["sed -i -re 's/import (.*)/from .\\1 import */g' " + name + "/__init__.py"], shell=True)
+        files = ['particles', 'parameters', 'propagators', 'couplings', 'lorentz', 'coupling_orders', 'decays', 'vertices', 'function_library', 'CT_couplings', 'object_library']
+        for f in files:
+            for f2 in files:
+                if os.path.isfile(name + '/' + f + '.py') : subprocess.call(["sed -i -e 's/from " + f2 + "/from ." + f2 + "/g' " + name + "/" + f + ".py"], shell=True)
+                if os.path.isfile(name + '/' + f + '.py') : subprocess.call(["sed -i -e 's/import " + f2 + "/from . import " + f2 + "/g' " + name + "/" + f + ".py"], shell=True)
+        if os.path.isfile(name + '/object_library.py') : subprocess.call(["sed -i -ri 's/raise ([^,]*),(.*)/raise \\1(\\2)/g' " + name + "/object_library.py"], shell=True)
         __import__(path_split[-1])
     output = sys.modules[path_split[-1]]
     if decay:
diff -rupN MadGraph_pristine/models/model_reader.py ../contrib/MadGraph/models/model_reader.py
--- MadGraph_pristine/models/model_reader.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/model_reader.py	2020-10-30 20:49:24.534460884 +1100
@@ -79,7 +79,7 @@ class ModelReader(loop_base_objects.Loop
             if isinstance(param_card, basestring):
                 # Check that param_card exists
                 if not os.path.isfile(param_card):
-                    raise MadGraph5Error, "No such file %s" % param_card
+                    raise MadGraph5Error("No such file %s" % param_card)
                 param_card_text = param_card
                 param_card = card_reader.ParamCard(param_card)
             #misc.sprint(type(param_card), card_reader.ParamCard,  isinstance(param_card, card_reader.ParamCard))
@@ -155,11 +155,11 @@ class ModelReader(loop_base_objects.Loop
                                 fail = False
                     except Exception:
                         raise
-                        raise MadGraph5Error, msg
+                        raise MadGraph5Error(msg)
                         
                 
                 if fail:
-                    raise MadGraph5Error, msg
+                    raise MadGraph5Error(msg)
 
             for block in key:
                 if block not in parameter_dict:
@@ -168,7 +168,7 @@ class ModelReader(loop_base_objects.Loop
                     try:
                         value = param_card[block].get(pid).value
                     except:
-                        raise MadGraph5Error, '%s %s not define' % (block, pid)
+                        raise MadGraph5Error('%s %s not define' % (block, pid))
                     else:
                         if isinstance(value, str) and value.lower() == 'auto':
                             value = '0.0' 
@@ -176,7 +176,7 @@ class ModelReader(loop_base_objects.Loop
                             runner = Alphas_Runner(value, nloop=2)
                             try:
                                 value = runner(scale)
-                            except ValueError, err:
+                            except ValueError as err:
                                 if str(err) == 'math domain error' and scale < 1:
                                     value = 0.0
                                 else:
@@ -214,7 +214,7 @@ class ModelReader(loop_base_objects.Loop
                 exec("locals()[\'%s\'] = %s" % (param.name, param.expr))
             except Exception as error:
                 msg = 'Unable to evaluate %s = %s: raise error: %s' % (param.name,param.expr, error)
-                raise MadGraph5Error, msg
+                raise MadGraph5Error(msg)
             param.value = complex(eval(param.name))
             if not eval(param.name) and eval(param.name) != 0:
                 logger.warning("%s has no expression: %s" % (param.name,
diff -rupN MadGraph_pristine/models/write_param_card.py ../contrib/MadGraph/models/write_param_card.py
--- MadGraph_pristine/models/write_param_card.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/write_param_card.py	2020-10-30 20:49:24.534460884 +1100
@@ -219,7 +219,7 @@ class ParamCardWriter(object):
             info = info[4:]
     
         if param.value.imag != 0:
-            raise ParamCardWriterError, 'All External Parameter should be real (not the case for %s)'%param.name
+            raise ParamCardWriterError('All External Parameter should be real (not the case for %s)'%param.name)
     
 
         # avoid to keep special value used to avoid restriction
@@ -265,7 +265,7 @@ class ParamCardWriter(object):
             if part["type"] == "ghost":
                 continue
             if self.model['parameter_dict'][param.name].imag:
-                raise ParamCardWriterError, 'All Mass/Width Parameter should be real (not the case for %s)'%param.name
+                raise ParamCardWriterError('All Mass/Width Parameter should be real (not the case for %s)'%param.name)
             value = complex(self.model['parameter_dict'][param.name]).real
             text += """%s %s %e # %s : %s \n""" %(prefix, part["pdg_code"], 
                         value, part["name"], param.expr.replace('mdl_',''))  
@@ -280,7 +280,7 @@ class ParamCardWriter(object):
     
         for part, param in data:
             if self.model['parameter_dict'][param.name].imag:
-                raise ParamCardWriterError, 'All Mass/Width Parameter should be real'
+                raise ParamCardWriterError('All Mass/Width Parameter should be real')
             value = complex(self.model['parameter_dict'][param.name]).real
             text += """%s %s %e # %s : %s \n""" %(prefix, part["pdg_code"], 
                         value, part["name"], part[name].replace('mdl_',''))
@@ -336,5 +336,5 @@ class ParamCardWriter(object):
             
 if '__main__' == __name__:
     ParamCardWriter('./param_card.dat', generic=True)
-    print 'write ./param_card.dat'
+    print('write ./param_card.dat')
     
diff -rupN MadGraph_pristine/vendor/ply/yacc.py ../contrib/MadGraph/vendor/ply/yacc.py
--- MadGraph_pristine/vendor/ply/yacc.py	2020-10-27 21:41:37.909090533 +1100
+++ ../contrib/MadGraph/vendor/ply/yacc.py	2020-10-30 20:49:24.534460884 +1100
@@ -89,7 +89,12 @@ resultlimit = 40               # Size li
 pickle_protocol = 0            # Protocol to use when writing pickle files
 
 import re, types, sys, os.path
-from cStringIO import StringIO
+
+try:
+    from cStringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 
 # Compatibility function for python 2.6/3.0
 if sys.version_info[0] < 3:
