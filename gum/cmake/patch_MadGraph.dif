diff -rupN MadGraph_pristine/aloha/aloha_fct.py ../contrib/MadGraph/aloha/aloha_fct.py
--- MadGraph_pristine/aloha/aloha_fct.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_fct.py	2020-10-29 20:31:26.810384777 +1100
@@ -29,7 +29,7 @@ def get_fermion_flow(expression, nb_ferm
     try:
         expr = eval(expression)
     except Exception as error:
-        print error
+        print(error)
         return
     expr = expr.simplify()
     #expr is now a valid AddVariable object if they are a sum or
@@ -40,7 +40,7 @@ def get_fermion_flow(expression, nb_ferm
     for term in expr:
         if term.vartype == 0: # Single object
             if not term.spin_ind in [[1,2], [2,1]]:
-                raise WrongFermionFlow, 'Fermion should be the first particles of any interactions'
+                raise WrongFermionFlow('Fermion should be the first particles of any interactions')
             if isinstance(term, (Gamma, Gamma5, Sigma)):
                 if term.spin_ind == [2,1]:
                     out[1] = 2
@@ -59,11 +59,11 @@ def get_fermion_flow(expression, nb_ferm
                 if ind1 not in link.keys():
                     link[ind1] = ind2
                 else:
-                    raise WrongFermionFlow, 'a spin indices should appear only once on the left indices of an object: %s' % expr
+                    raise WrongFermionFlow('a spin indices should appear only once on the left indices of an object: %s' % expr)
                 if ind2 not in rlink.keys():
                     rlink[ind2] = ind1
                 else: 
-                    raise WrongFermionFlow, 'a spin indices should appear only once on the left indices of an object: %s' % expr             
+                    raise WrongFermionFlow('a spin indices should appear only once on the left indices of an object: %s' % expr)             
              
             for i in range(1, nb_fermion):
                 if i in out.keys() or i in out.values():
@@ -84,9 +84,9 @@ def get_fermion_flow(expression, nb_ferm
                             out[pos] = i
                             break
                         else:
-                            raise WrongFermionFlow,  'incoherent IO state: %s' % expr
+                            raise WrongFermionFlow('incoherent IO state: %s' % expr)
     if not len(out) == nb_fermion //2:
-        raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+        raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
     return out
 
 
@@ -112,10 +112,10 @@ def check_flow_validity(expression, nb_f
     for term in expr:
         if term.vartype == 0: # Single object
             if not term.spin_ind in [[1,2], [2,1]]:
-                raise WrongFermionFlow, 'Fermion should be the first particles of any interactions'
+                raise WrongFermionFlow('Fermion should be the first particles of any interactions')
             if isinstance(term, (Gamma, Gamma5, Sigma)):
                 if not term.spin_ind == [2,1]:
-                    raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+                    raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
         
         elif term.vartype == 2: # product of object
             link, rlink = {}, {}
@@ -127,7 +127,7 @@ def check_flow_validity(expression, nb_f
                 if isinstance(obj, (Gamma, Sigma)):
                     if (ind1 in range(1, nb_fermion+1) and ind1 % 2 == 1) or \
                        (ind2 in range(2, nb_fermion+1) and ind2 % 2 == 0 ):
-                        raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+                        raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
                 if ind1 not in link.keys():
                     link[ind1] = ind2
                 else:
@@ -146,7 +146,7 @@ def check_flow_validity(expression, nb_f
                     elif pos in rlink.keys() and rlink[pos] not in old:
                         pos = rlink[pos]
                     elif pos != i+1:
-                        raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+                        raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
                     elif pos == i+1:
                         break
    
diff -rupN MadGraph_pristine/aloha/aloha_lib.py ../contrib/MadGraph/aloha/aloha_lib.py
--- MadGraph_pristine/aloha/aloha_lib.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_lib.py	2020-10-29 20:31:26.814384756 +1100
@@ -143,13 +143,13 @@ class Computation(dict):
             if isinstance(expression, (MultLorentz, AddVariable, LorentzObject)):
                 try:
                     expr = expression.expand().get_rep([0])
-                except KeyError, error:
+                except KeyError as error:
                     if error.args != ((0,),):
                         raise
                     else:
-                        raise aloha.ALOHAERROR, '''Error in input format. 
+                        raise aloha.ALOHAERROR( '''Error in input format. 
     Argument of function (or denominator) should be scalar.
-    We found %s''' % expression
+    We found %s''' % expression)
                 new = expr.simplify()
                 if not isinstance(new, numbers.Number):
                     new = new.factorize()
@@ -171,10 +171,10 @@ class Computation(dict):
             else:
                 module = 'cmath.'
             try:
-                return str(eval("%s%s(%s)" % (module,fct_tag, ','.join(`x` for x in argument))))
-            except Exception, error:
-                print error
-                print "cmath.%s(%s)" % (fct_tag, ','.join(`x` for x in argument))
+                return str(eval("%s%s(%s)" % (module,fct_tag, ','.join(repr(x) for x in argument))))
+            except Exception as error:
+                print(error)
+                print("cmath.%s(%s)" % (fct_tag, ','.join(repr(x) for x in argument)))
         if str(fct_tag)+str(argument) in self.inverted_fct:
             tag = self.inverted_fct[str(fct_tag)+str(argument)]
             v = tag.split('(')[1][:-1]
@@ -684,7 +684,7 @@ class MultVariable(array):
 #                    self.append(new_id)
 #            return self
         else:
-            raise Exception, 'Cann\'t replace a Variable by %s' % type(expression)
+            raise Exception( 'Cann\'t replace a Variable by %s' % type(expression))
         
     
     def get_all_var_names(self):
diff -rupN MadGraph_pristine/aloha/aloha_parsers.py ../contrib/MadGraph/aloha/aloha_parsers.py
--- MadGraph_pristine/aloha/aloha_parsers.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_parsers.py	2020-10-29 20:31:26.814384756 +1100
@@ -29,17 +29,14 @@ import sys
 root_path = os.path.split(os.path.dirname(os.path.realpath( __file__ )))[0]
 sys.path.append(os.path.join(root_path))
 
-import aloha_lib
-from aloha_object import *
+import aloha.aloha_lib
+from aloha.aloha_object import *
 import vendor.ply.lex as lex
 import vendor.ply.yacc as yacc
 from aloha.aloha_lib import KERNEL
 logger = logging.getLogger('aloha.parsers')
 
-try:
-    import madgraph.various.misc as misc
-except Exception:
-    import aloha.misc as misc
+import madgraph.various.misc as misc
 
 
 # PLY lexer class
@@ -193,7 +190,7 @@ class UFOExpressionParser(object):
 
     def p_error(self, p):
         if p:
-            print p[:]
+            print(p[:])
             raise Exception("Syntax error at '%s' in '%s'" % (p.value, self.f))
         else:
             logger.error("Syntax error at EOF")
diff -rupN MadGraph_pristine/aloha/aloha_writers.py ../contrib/MadGraph/aloha/aloha_writers.py
--- MadGraph_pristine/aloha/aloha_writers.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_writers.py	2020-10-29 20:31:26.814384756 +1100
@@ -1,11 +1,11 @@
-try:
-    import madgraph.iolibs.file_writers as writers 
-    import madgraph.various.q_polynomial as q_polynomial
-    import madgraph.various.misc as misc
-except Exception:
-    import aloha.file_writers as writers
-    import aloha.q_polynomial as q_polynomial
-    import aloha.misc as misc
+#try:
+import madgraph.iolibs.file_writers as writers 
+import madgraph.various.q_polynomial as q_polynomial
+import madgraph.various.misc as misc
+#except Exception:
+#    import aloha.file_writers as writers
+#    import aloha.q_polynomial as q_polynomial
+#    import aloha.misc as misc
 
 import aloha
 import aloha.aloha_lib as aloha_lib
@@ -16,7 +16,12 @@ from numbers import Number
 from collections import defaultdict
 from fractions import Fraction
 # fast way to deal with string
-from cStringIO import StringIO
+
+try:
+    from cStringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 # Look at http://www.skymind.com/~ocrow/python_string/ 
 # For knowing how to deal with long strings efficiently.
 import itertools
@@ -92,12 +97,12 @@ class WriteALOHA:
         elif len(indices) == 2: 
             return  4 * indices[0] + indices[1] + start + self.momentum_size
         else:
-            raise Exception, 'WRONG CONTRACTION OF LORENTZ OBJECT for routine %s: %s' \
-                    % (self.name, ind_name)                                 
+            raise Exception('WRONG CONTRACTION OF LORENTZ OBJECT for routine %s: %s' \
+                    % (self.name, ind_name))                                 
                                  
     def get_header_txt(self,mode=''): 
         """ Prototype for language specific header""" 
-        raise Exception, 'THis function should be overwritten'
+        raise Exception('THis function should be overwritten')
         return ''
     
     def get_declaration_txt(self):
@@ -110,7 +115,7 @@ class WriteALOHA:
 
     def get_momenta_txt(self):
         """ Prototype for the definition of the momenta"""
-        raise Exception, 'THis function should be overwritten'
+        raise Exception('THis function should be overwritten')
 
     def get_momentum_conservation_sign(self):
         """find the sign associated to the momentum conservation"""
@@ -785,7 +790,7 @@ class ALOHAWriterForFortran(WriteALOHA):
                                   {'i': self.outgoing, 'COUP': coup_name})
                 else:
                     if self.routine.denominator:
-                        raise Exception, 'modify denominator are not compatible with complex mass scheme'                
+                        raise Exception('modify denominator are not compatible with complex mass scheme')                
 
                     out.write('    denom = %(COUP)s/(P%(i)s(0)**2-P%(i)s(1)**2-P%(i)s(2)**2-P%(i)s(3)**2 - M%(i)s**2)\n' % \
                       {'i': self.outgoing, 'COUP': coup_name})
@@ -1587,7 +1592,7 @@ class ALOHAWriterForCPP(WriteALOHA):
                       {'i': self.outgoing, 'coup': coup_name})
                 else:
                     if self.routine.denominator:
-                        raise Exception, 'modify denominator are not compatible with complex mass scheme'                
+                        raise Exception('modify denominator are not compatible with complex mass scheme')                
 
                     out.write('    denom = %(coup)s/((P%(i)s[0]*P%(i)s[0])-(P%(i)s[1]*P%(i)s[1])-(P%(i)s[2]*P%(i)s[2])-(P%(i)s[3]*P%(i)s[3]) - (M%(i)s*M%(i)s));\n' % \
                       {'i': self.outgoing, 'coup': coup_name})
@@ -1909,7 +1914,7 @@ class ALOHAWriterForPython(WriteALOHA):
             self.declaration.add(('fct', fct))
             return 'cmath.{0}(%s)'.format(fct)
         else:
-            raise Exception, "Unable to handle function name %s (no special rule defined and not in cmath)" % fct
+            raise Exception("Unable to handle function name %s (no special rule defined and not in cmath)" % fct)
     
     def define_expression(self):
         """Define the functions in a 100% way """
@@ -1970,7 +1975,7 @@ class ALOHAWriterForPython(WriteALOHA):
                           {'i': self.outgoing,'coup':coup_name})
                 else:
                     if self.routine.denominator:
-                        raise Exception, 'modify denominator are not compatible with complex mass scheme'                
+                        raise Exception('modify denominator are not compatible with complex mass scheme')                
                     
                     out.write('    denom = %(coup)s/(P%(i)s[0]**2-P%(i)s[1]**2-P%(i)s[2]**2-P%(i)s[3]**2 - M%(i)s**2)\n' % 
                           {'i': self.outgoing,'coup':coup_name})                    
@@ -2218,7 +2223,7 @@ class WriterFactory(object):
         elif language == 'gpu':
             return ALOHAWriterForGPU(data, outputdir)
         else:
-            raise Exception, 'Unknown output format'
+            raise Exception('Unknown output format')
 
 
     
diff -rupN MadGraph_pristine/aloha/create_aloha.py ../contrib/MadGraph/aloha/create_aloha.py
--- MadGraph_pristine/aloha/create_aloha.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/create_aloha.py	2020-10-29 20:31:26.814384756 +1100
@@ -15,7 +15,12 @@
 from __future__ import division
 import cmath
 import copy
-import cPickle
+
+try:
+    import cPickle ## for Python 2
+except ImportError:
+    import _pickle as cPickle ## for Python 3
+
 import glob
 import logging
 import numbers
@@ -110,7 +115,7 @@ class AbstractRoutine(object):
                 rank = max(sum(coeff), rank)
             return rank -1 # due to the coefficient associate to the wavefunctions
         else:
-            raise ALOHAERROR, '%s is not a valid information that can be computed' % info
+            raise ALOHAERROR( '%s is not a valid information that can be computed' % info)
 
 
 class AbstractRoutineBuilder(object):
@@ -206,7 +211,7 @@ class AbstractRoutineBuilder(object):
             if not data == target:
                 text = """Unable to deal with 4(or more) point interactions
 in presence of majorana particle/flow violation"""
-                raise ALOHAERROR, text
+                raise ALOHAERROR( text)
         
         old_id = 2 * pair - 1
         new_id = _conjugate_gap + old_id
@@ -286,7 +291,7 @@ in presence of majorana particle/flow vi
                 lorentz = eval(lorentz)
             except NameError as error:
                 logger.error('unknow type in Lorentz Evaluation:%s'%str(error))
-                raise ALOHAERROR, 'unknow type in Lorentz Evaluation: %s ' % str(error) 
+                raise ALOHAERROR( 'unknow type in Lorentz Evaluation: %s ' % str(error) )
             else:
                 self.kernel_tag = set(aloha_lib.KERNEL.use_tag)
         elif isinstance(self.routine_kernel,str):
@@ -837,7 +842,7 @@ class AbstractALOHAModel(dict):
                                 realname = conjg_builder.name + ''.join(['C%s' % pair for pair in conjg_builder.conjg])
                                 try:
                                     self[(realname, outgoing)].add_combine(m)
-                                except Exception,error:
+                                except Exception as error:
                                     self[(realname, self.symmetries[lorentz.name][outgoing])].add_combine(m)          
                        
         if save:
@@ -1059,8 +1064,8 @@ class AbstractALOHAModel(dict):
                 break
         else: 
 
-            raise ALOHAERROR, 'No external routine \"%s.%s\" in directories\n %s' % \
-                        (name, ext, '\n'.join(paths))
+            raise ALOHAERROR( 'No external routine \"%s.%s\" in directories\n %s' % \
+                        (name, ext, '\n'.join(paths)))
        
         if output_dir:
             for filepath in ext_files:
diff -rupN MadGraph_pristine/input/mg5_configuration.txt ../contrib/MadGraph/input/mg5_configuration.txt
--- MadGraph_pristine/input/mg5_configuration.txt	2020-10-27 21:41:37.769088298 +1100
+++ ../contrib/MadGraph/input/mg5_configuration.txt	2020-10-29 20:31:26.814384756 +1100
@@ -49,7 +49,7 @@
 
 #! Prefered PS viewer
 #!  If None: try to find one available on the system
-# eps_viewer = None
+eps_viewer = true
 
 #! Time allowed to answer question (if no answer takes default value)
 #!  0: No time limit
diff -rupN MadGraph_pristine/madgraph/core/base_objects.py ../contrib/MadGraph/madgraph/core/base_objects.py
--- MadGraph_pristine/madgraph/core/base_objects.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/base_objects.py	2020-10-29 20:31:26.814384756 +1100
@@ -22,7 +22,12 @@ import math
 import numbers
 import os
 import re
-import StringIO
+
+try:
+    from StringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import madgraph.core.color_algebra as color
 from madgraph import MadGraph5Error, MG5DIR, InvalidCmd
 import madgraph.various.misc as misc 
@@ -81,9 +86,9 @@ class PhysicsObject(dict):
                                  "Property name %s is not a string" % repr(name)
 
         if name not in self.keys():
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                         """%s is not a valid property for this object: %s\n
-    Valid property are %s""" % (name,self.__class__.__name__, self.keys())
+    Valid property are %s""" % (name,self.__class__.__name__, self.keys()))
         return True
 
     def get(self, name):
@@ -104,7 +109,7 @@ class PhysicsObject(dict):
                 self.filter(name, value)
                 self[name] = value
                 return True
-            except self.PhysicsObjectError, why:
+            except self.PhysicsObjectError as why:
                 logger.warning("Property " + name + " cannot be changed:" + \
                                 str(why))
                 return False
@@ -272,100 +277,100 @@ class Particle(PhysicsObject):
             # Forbid special character but +-~_
             p=re.compile('''^[\w\-\+~_]+$''')
             if not p.match(value):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid particle name" % value
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid particle name" % value)
 
         if name is 'ghost':
             if not isinstance(value,bool):
-                raise self.PhysicsObjectError, \
-                 "%s is not a valid bool for the 'ghost' attribute" % str(value)
+                raise self.PhysicsObjectError( \
+                 "%s is not a valid bool for the 'ghost' attribute" % str(value))
     
         if name is 'counterterm':
             if not isinstance(value,dict):
-                raise self.PhysicsObjectError, \
-                    "counterterm %s is not a valid dictionary" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "counterterm %s is not a valid dictionary" % repr(value))
             for key, val in value.items():
                 if not isinstance(key,tuple):
-                    raise self.PhysicsObjectError, \
-                        "key %s is not a valid tuple for counterterm key" % repr(key)
+                    raise self.PhysicsObjectError( \
+                        "key %s is not a valid tuple for counterterm key" % repr(key))
                 if not isinstance(key[0],str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % repr(key[0])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % repr(key[0]))
                 if not isinstance(key[1],tuple):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % repr(key[1])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % repr(key[1]))
                 for elem in key[1]:
                     if not isinstance(elem,tuple):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid list" % repr(elem)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid list" % repr(elem))
                     for partPDG in elem:
                         if not isinstance(partPDG,int):
-                            raise self.PhysicsObjectError, \
-                                "%s is not a valid integer for PDG" % repr(partPDG)
+                            raise self.PhysicsObjectError( \
+                                "%s is not a valid integer for PDG" % repr(partPDG))
                         if partPDG<=0:
-                            raise self.PhysicsObjectError, \
-                                "%s is not a valid positive PDG" % repr(partPDG)
+                            raise self.PhysicsObjectError( \
+                                "%s is not a valid positive PDG" % repr(partPDG))
                 if not isinstance(val,dict):
-                    raise self.PhysicsObjectError, \
-                        "value %s is not a valid dictionary for counterterm value" % repr(val)
+                    raise self.PhysicsObjectError( \
+                        "value %s is not a valid dictionary for counterterm value" % repr(val))
                 for vkey, vvalue in val.items():
                     if vkey not in [0,-1,-2]:
-                        raise self.PhysicsObjectError, \
-                            "Key %s is not a valid laurent serie order" % repr(vkey)
+                        raise self.PhysicsObjectError( \
+                            "Key %s is not a valid laurent serie order" % repr(vkey))
                     if not isinstance(vvalue,str):
-                        raise self.PhysicsObjectError, \
-                            "Coupling %s is not a valid string" % repr(vvalue)
+                        raise self.PhysicsObjectError( \
+                            "Coupling %s is not a valid string" % repr(vvalue))
         if name is 'spin':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Spin %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Spin %s is not an integer" % repr(value))
             if (value < 1 or value > 5) and value != 99:
-                raise self.PhysicsObjectError, \
-                   "Spin %i not valid" % value
+                raise self.PhysicsObjectError( \
+                   "Spin %i not valid" % value)
 
         if name is 'color':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Color %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Color %s is not an integer" % repr(value))
             if value not in [1, 3, 6, 8]:
-                raise self.PhysicsObjectError, \
-                   "Color %i is not valid" % value
+                raise self.PhysicsObjectError( \
+                   "Color %i is not valid" % value)
 
         if name in ['mass', 'width']:
             # Must start with a letter, followed by letters, digits or _
             p = re.compile('\A[a-zA-Z]+[\w\_]*\Z')
             if not p.match(value):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid name for mass/width variable" % \
-                        value
+                        value)
 
         if name is 'pdg_code':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "PDG code %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "PDG code %s is not an integer" % repr(value))
 
         if name is 'line':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                    "Line type %s is not a string" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Line type %s is not a string" % repr(value))
             if value not in ['None','dashed', 'straight', 'wavy', 'curly', 'double','swavy','scurly','dotted']:
-                raise self.PhysicsObjectError, \
-                   "Line type %s is unknown" % value
+                raise self.PhysicsObjectError( \
+                   "Line type %s is unknown" % value)
 
         if name is 'charge':
             if not isinstance(value, float):
-                raise self.PhysicsObjectError, \
-                    "Charge %s is not a float" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Charge %s is not a float" % repr(value))
 
         if name is 'propagating':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "Propagating tag %s is not a boolean" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Propagating tag %s is not a boolean" % repr(value))
 
         if name in ['is_part', 'self_antipart']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "%s tag %s is not a boolean" % (name, repr(value))
+                raise self.PhysicsObjectError( \
+                    "%s tag %s is not a boolean" % (name, repr(value)))
 
         return True
 
@@ -486,8 +491,8 @@ class Particle(PhysicsObject):
             # Massive tensor
             res = [-2, -1, 0, 1, 2]
         else:
-            raise self.PhysicsObjectError, \
-              "No helicity state assignment for spin %d particles" % spin
+            raise self.PhysicsObjectError( \
+              "No helicity state assignment for spin %d particles" % spin)
                   
         if allow_reverse and not self.get('is_part'):
             res.reverse()
@@ -689,91 +694,91 @@ class Interaction(PhysicsObject):
         if name == 'id':
             #Should be an integer
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
 
         if name == 'particles':
             #Should be a list of valid particle names
             if not isinstance(value, ParticleList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of particles" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of particles" % str(value))
 
         if name == 'perturbation_type':
             if value!=None and not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)            
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))            
 
         if name == 'type':
             #Should be a string
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
         if name == 'loop_particles':
             if isinstance(value,list):
                 for l in value:
                     if isinstance(l,list):
                         for part in l:
                             if not isinstance(part,int):
-                                raise self.PhysicsObjectError, \
-                                    "%s is not a valid integer" % str(part)
+                                raise self.PhysicsObjectError( \
+                                    "%s is not a valid integer" % str(part))
                             if part<0:
-                                raise self.PhysicsObjectError, \
-                                    "%s is not a valid positive integer" % str(part)
+                                raise self.PhysicsObjectError( \
+                                    "%s is not a valid positive integer" % str(part))
 
         if name == 'orders':
             #Should be a dict with valid order names ask keys and int as values
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dict for coupling orders" % \
-                                                                    str(value)
+                                                                    str(value))
             for order in value.keys():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(order)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(order))
                 if not isinstance(value[order], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value[order])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value[order]))
 
         if name in ['color']:
             #Should be a list of list strings
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of Color Strings" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of Color Strings" % str(value))
             for mycolstring in value:
                 if not isinstance(mycolstring, color.ColorString):
-                    raise self.PhysicsObjectError, \
-                            "%s is not a valid list of Color Strings" % str(value)
+                    raise self.PhysicsObjectError( \
+                            "%s is not a valid list of Color Strings" % str(value))
 
         if name in ['lorentz']:
             #Should be a list of list strings
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of strings" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of strings" % str(value))
             for mystr in value:
                 if not isinstance(mystr, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(mystr))
 
         if name == 'couplings':
             #Should be a dictionary of strings with (i,j) keys
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dictionary for couplings" % \
-                                                                str(value)
+                                                                str(value))
 
             for key in value.keys():
                 if not isinstance(key, tuple):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid tuple" % str(key)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid tuple" % str(key))
                 if len(key) != 2:
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid tuple with 2 elements" % str(key)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid tuple with 2 elements" % str(key))
                 if not isinstance(key[0], int) or not isinstance(key[1], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid tuple of integer" % str(key)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid tuple of integer" % str(key))
                 if not isinstance(value[key], str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % value[key]
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % value[key])
 
         return True
 
@@ -1070,73 +1075,73 @@ class Model(PhysicsObject):
 
         if name in ['name']:
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a string" %type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a string" %type(value))
 
         elif name == 'particles':
             if not isinstance(value, ParticleList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a ParticleList object" % \
-                                                            type(value)
+                                                            type(value))
         elif name == 'interactions':
             if not isinstance(value, InteractionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a InteractionList object" % \
-                                                            type(value)
+                                                            type(value))
         elif name == 'particle_dict':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a dictionary" % \
-                                                        type(value)
+                                                        type(value))
         elif name == 'interaction_dict':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a dictionary" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a dictionary" % type(value))
 
         elif name == 'ref_dict_to0':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a dictionary" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a dictionary" % type(value))
                     
         elif name == 'ref_dict_to1':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a dictionary" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a dictionary" % type(value))
 
         elif name == 'got_majoranas':
             if not (isinstance(value, bool) or value == None):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a boolean" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a boolean" % type(value))
 
         elif name == 'conserved_charge':
             if not (isinstance(value, set)):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a set" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a set" % type(value))
 
         elif name == 'version_tag':
             if not (isinstance(value, str)):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a string" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a string" % type(value))
 
         elif name == 'order_hierarchy':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a dictionary" % \
-                                                            type(value)
+                                                            type(value))
             for key in value.keys():
                 if not isinstance(value[key],int):
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                         "Object of type %s is not an integer" % \
-                                                            type(value[key])
+                                                            type(value[key]))
         elif name == 'gauge':
             if not (isinstance(value, list)):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a list" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a list" % type(value))
 
         elif name == 'case_sensitive':
             if not value in [True ,False]:
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a boolean" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a boolean" % type(value))
             
 
         return True
@@ -1164,7 +1169,7 @@ class Model(PhysicsObject):
                 modeldir = os.path.expanduser(modeldir)
                 return modeldir
             else:
-                raise Exception, "path %s not valid anymore." % modeldir
+                raise Exception( "path %s not valid anymore." % modeldir)
             #modeldir = os.path.join(os.path.dirname(modeldir),
             #                        os.path.basename(modeldir).rsplit("-",1)[0])
             #if os.path.exists(modeldir):
@@ -1174,7 +1179,7 @@ class Model(PhysicsObject):
             modeldir = self.get('version_tag').rsplit('##',1)[0]
             modelname = self['name']            
             if not  os.path.exists(modeldir):
-                raise Exception, "path %s not valid anymore" % modeldir
+                raise Exception( "path %s not valid anymore" % modeldir)
             modeldir = os.path.dirname(modeldir)
             modeldir = pjoin(modeldir, modelname)
             modeldir = os.path.expanduser(modeldir)
@@ -1274,7 +1279,7 @@ class Model(PhysicsObject):
             if isinstance(id, int):
                 try:
                     return self.get("particle_dict")[id]
-                except Exception, error:
+                except Exception as error:
                     return None
             else:
                 if not hasattr(self, 'name2part'):
@@ -1468,8 +1473,8 @@ class Model(PhysicsObject):
                 'to use the particles name defined in the model and not the ' + \
                 'MadGraph5_aMC@NLO convention'
                 
-                raise MadGraph5Error, error_text % \
-                                     (part.get_name(), part.get_pdg_code(), pdg)                
+                raise MadGraph5Error( error_text % \
+                                     (part.get_name(), part.get_pdg_code(), pdg))                
 
         default = self.load_default_name()
 
@@ -1974,32 +1979,32 @@ class Leg(PhysicsObject):
 
         if name in ['id', 'number']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer for leg id" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer for leg id" % str(value))
 
         if name == 'state':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid leg state (True|False)" % \
-                                                                    str(value)
+                                                                    str(value))
 
         if name == 'from_group':
             if not isinstance(value, bool) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid boolean for leg flag from_group" % \
-                                                                    str(value)
+                                                                    str(value))
 
         if name == 'loop_line':
             if not isinstance(value, bool) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "%s is not a valid boolean for leg flag loop_line" % \
-                                                                    str(value)
+                                                                    str(value))
 
         if name == 'onshell':
             if not isinstance(value, bool) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid boolean for leg flag onshell" % \
-                                                                    str(value)
+                                                                    str(value))
         return True
 
     def get_sorted_keys(self):
@@ -2171,18 +2176,18 @@ class MultiLeg(PhysicsObject):
 
         if name == 'ids':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for i in value:
                 if not isinstance(i, int):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of integers" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of integers" % str(value))
 
         if name == 'state':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid leg state (initial|final)" % \
-                                                                    str(value)
+                                                                    str(value))
 
         return True
 
@@ -2250,13 +2255,13 @@ class Vertex(PhysicsObject):
 
         if name == 'id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer for vertex id" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer for vertex id" % str(value))
 
         if name == 'legs':
             if not isinstance(value, LegList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid LegList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid LegList object" % str(value))
 
         return True
 
@@ -2373,20 +2378,20 @@ class ContractedVertex(Vertex):
             if isinstance(value, list):
                 for elem in value:
                     if not isinstance(elem,int):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid integer for leg PDG" % str(elem)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid integer for leg PDG" % str(elem))
             else:
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list for contracted vertex PDGs"%str(value)                
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list for contracted vertex PDGs"%str(value))                
         if name == 'loop_tag':
             if isinstance(value, tuple):
                 for elem in value:
                     if not (isinstance(elem,int) or isinstance(elem,tuple)):
-                        raise self.PhysicsObjectError, \
-                          "%s is not a valid int or tuple for loop tag element"%str(elem)
+                        raise self.PhysicsObjectError( \
+                          "%s is not a valid int or tuple for loop tag element"%str(elem))
             else:
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid tuple for a contracted vertex loop_tag."%str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid tuple for a contracted vertex loop_tag."%str(value))
         if name == 'loop_orders':
             Interaction.filter(Interaction(), 'orders', value)
         else:
@@ -2417,8 +2422,8 @@ class Diagram(PhysicsObject):
 
         if name == 'vertices':
             if not isinstance(value, VertexList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid VertexList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid VertexList object" % str(value))
 
         if name == 'orders':
             Interaction.filter(Interaction(), 'orders', value)
@@ -2457,7 +2462,7 @@ class Diagram(PhysicsObject):
                                      for key in sorted(self['orders'].keys())]))
             
             if not pass_sanity:
-                raise Exception, "invalid diagram: %s. vert_id: %s" % (mystr, responsible) 
+                raise Exception( "invalid diagram: %s. vert_id: %s" % (mystr, responsible)) 
                 
             return mystr
         else:
@@ -2627,7 +2632,7 @@ class Diagram(PhysicsObject):
             security =0
             while not vcurrent.is_external():
                 if security > 1000:
-                    raise Exception, 'wrong diagram'
+                    raise Exception('wrong diagram')
                 next_l = [l for l in vcurrent.lines if l is not l_last and l.is_fermion()][0]
                 next_v = next_l.end
                 if next_v == vcurrent:
@@ -2818,113 +2823,113 @@ class Process(PhysicsObject):
 
         if name in ['legs', 'legs_with_decays'] :
             if not isinstance(value, LegList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid LegList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid LegList object" % str(value))
 
         if name in ['orders', 'overall_orders','squared_orders']:
             Interaction.filter(Interaction(), 'orders', value)
 
         if name == 'constrained_orders':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)            
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))            
 
         if name == 'sqorders_types':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))
             for order in value.keys()+value.values():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid string" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid string" % str(value))
 
         if name == 'split_orders':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for order in value:
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid string" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid string" % str(value))
 
         if name == 'model':
             if not isinstance(value, Model):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Model object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid Model object" % str(value))
         if name in ['id', 'uid']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Process %s %s is not an integer" % (name, repr(value))
+                raise self.PhysicsObjectError( \
+                    "Process %s %s is not an integer" % (name, repr(value)))
 
         if name == 'required_s_channels':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for l in value:
                 if not isinstance(l, list):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of lists" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of lists" % str(value))
                 for i in l:
                     if not isinstance(i, int):
-                        raise self.PhysicsObjectError, \
-                              "%s is not a valid list of integers" % str(l)
+                        raise self.PhysicsObjectError( \
+                              "%s is not a valid list of integers" % str(l))
                     if i == 0:
-                        raise self.PhysicsObjectError, \
-                          "Not valid PDG code %d for s-channel particle" % i
+                        raise self.PhysicsObjectError( \
+                          "Not valid PDG code %d for s-channel particle" % i)
 
         if name in ['forbidden_onsh_s_channels', 'forbidden_s_channels']:
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for i in value:
                 if not isinstance(i, int):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of integers" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of integers" % str(value))
                 if i == 0:
-                    raise self.PhysicsObjectError, \
-                      "Not valid PDG code %d for s-channel particle" % str(value)
+                    raise self.PhysicsObjectError( \
+                      "Not valid PDG code %d for s-channel particle" % str(value))
 
         if name == 'forbidden_particles':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for i in value:
                 if not isinstance(i, int):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of integers" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of integers" % str(value))
                 if i <= 0:
-                    raise self.PhysicsObjectError, \
-                      "Forbidden particles should have a positive PDG code" % str(value)
+                    raise self.PhysicsObjectError( \
+                      "Forbidden particles should have a positive PDG code" % str(value))
 
         if name == 'perturbation_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for order in value:
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid string" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid string" % str(value))
 
         if name == 'is_decay_chain':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
 
         if name == 'has_born':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
 
         if name == 'decay_chains':
             if not isinstance(value, ProcessList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessList" % str(value))
 
         if name == 'NLO_mode':
             import madgraph.interface.madgraph_interface as mg
             if value not in mg.MadGraphCmd._valid_nlo_modes:
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid NLO_mode" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid NLO_mode" % str(value))
         return True
 
     def has_multiparticle_label(self):
@@ -3608,12 +3613,12 @@ class ProcessDefinition(Process):
 
         if name == 'legs':
             if not isinstance(value, MultiLegList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid MultiLegList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid MultiLegList object" % str(value))
         elif name == 'decay_chains':
             if not isinstance(value, ProcessDefinitionList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessDefinitionList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessDefinitionList" % str(value))
 
         else:
             return super(ProcessDefinition, self).filter(name, value)
diff -rupN MadGraph_pristine/madgraph/core/color_algebra.py ../contrib/MadGraph/madgraph/core/color_algebra.py
--- MadGraph_pristine/madgraph/core/color_algebra.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/color_algebra.py	2020-10-29 20:31:26.814384756 +1100
@@ -833,8 +833,8 @@ class ColorString(list):
         are still non trivial color objects."""
 
         if self:
-            raise ValueError, \
-                "String %s cannot be simplified to a number!" % str(self)
+            raise ValueError( \
+                "String %s cannot be simplified to a number!" % str(self))
 
         if self.Nc_power >= 0:
             return (self.coeff * fractions.Fraction(\
diff -rupN MadGraph_pristine/madgraph/core/color_amp.py ../contrib/MadGraph/madgraph/core/color_amp.py
--- MadGraph_pristine/madgraph/core/color_amp.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/color_amp.py	2020-10-29 20:31:26.814384756 +1100
@@ -413,8 +413,8 @@ class ColorBasis(dict):
         # If more than one string at leading N...
         if len(res_cs) > 1 and any([not cs.near_equivalent(res_cs[0]) \
                                     for cs in res_cs]):
-            raise ColorBasis.ColorBasisError, \
-             "More than one color string with leading N coeff: %s" % str(res_cs)
+            raise ColorBasis.ColorBasisError( \
+             "More than one color string with leading N coeff: %s" % str(res_cs))
 
         res_cs = res_cs[0]
 
@@ -423,13 +423,13 @@ class ColorBasis(dict):
         for col_obj in res_cs:
             if not isinstance(col_obj, color_algebra.T) and \
                    not col_obj.__class__.__name__.startswith('Epsilon'):
-                raise ColorBasis.ColorBasisError, \
+                raise ColorBasis.ColorBasisError( \
                   "Color flow decomposition %s contains non T/Epsilon elements" % \
-                                                                    str(res_cs)
+                                                                    str(res_cs))
             if isinstance(col_obj, color_algebra.T) and len(col_obj) != 2:
-                raise ColorBasis.ColorBasisError, \
+                raise ColorBasis.ColorBasisError( \
                   "Color flow decomposition %s contains T's w/o 2 indices" % \
-                                                                    str(res_cs)
+                                                                    str(res_cs))
 
         return res_cs
 
@@ -463,8 +463,8 @@ class ColorBasis(dict):
 
                 # Raise an error if external legs contain non supported repr
                 if abs(leg_repr) not in [1, 3, 6, 8]:
-                    raise ColorBasis.ColorBasisError, \
-        "Particle ID=%i has an unsupported color representation" % leg_repr
+                    raise ColorBasis.ColorBasisError( \
+        "Particle ID=%i has an unsupported color representation" % leg_repr)
 
                 # Build the fake indices replacements for octets
                 if abs(leg_repr) == 8:
diff -rupN MadGraph_pristine/madgraph/core/diagram_generation.py ../contrib/MadGraph/madgraph/core/diagram_generation.py
--- MadGraph_pristine/madgraph/core/diagram_generation.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/diagram_generation.py	2020-10-29 20:31:26.814384756 +1100
@@ -439,16 +439,13 @@ class Amplitude(base_objects.PhysicsObje
 
         if name == 'process':
             if not isinstance(value, base_objects.Process):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Process object" % str(value)
+                raise self.PhysicsObjectError("%s is not a valid Process object" % str(value))
         if name == 'diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList object" % str(value)
+                raise self.PhysicsObjectError("%s is not a valid DiagramList object" % str(value))
         if name == 'has_mirror_process':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid boolean" % str(value)
+                raise self.PhysicsObjectError("%s is not a valid boolean" % str(value))
         return True
 
     def get(self, name):
@@ -568,7 +565,7 @@ class Amplitude(base_objects.PhysicsObje
                         leg.get('id')].is_fermion(), legs)) % 2 == 1:
             if not returndiag:
                 self['diagrams'] = res
-                raise InvalidCmd, 'The number of fermion is odd'
+                raise InvalidCmd('The number of fermion is odd')
             else:
                 return False, res
 
@@ -579,7 +576,7 @@ class Amplitude(base_objects.PhysicsObje
            len(filter(lambda leg: leg.is_outgoing_fermion(model), legs)):
             if not returndiag:
                 self['diagrams'] = res
-                raise InvalidCmd, 'The number of of incoming/outcoming fermions are different'
+                raise InvalidCmd('The number of of incoming/outcoming fermions are different')
             else:
                 return False, res
 
@@ -605,10 +602,10 @@ class Amplitude(base_objects.PhysicsObje
             if abs(total) > 1e-10:
                 if not returndiag:
                     self['diagrams'] = res
-                    raise InvalidCmd, 'No %s conservation for this process ' % charge
+                    raise InvalidCmd('No %s conservation for this process ' % charge)
                     return res
                 else:
-                    raise InvalidCmd, 'No %s conservation for this process ' % charge
+                    raise InvalidCmd( 'No %s conservation for this process ' % charge)
                     return res, res
 
         if not returndiag:
@@ -1362,15 +1359,14 @@ class DecayChainAmplitude(Amplitude):
 
             for process in argument.get('decay_chains'):
                 if process.get('perturbation_couplings'):
-                    raise MadGraph5Error,\
-                          "Decay processes can not be perturbed"
+                    raise MadGraph5Error(\
+                          "Decay processes can not be perturbed")
                 process.set('overall_orders', argument.get('overall_orders'))
                 if not process.get('is_decay_chain'):
                     process.set('is_decay_chain',True)
                 if not process.get_ninitial() == 1:
-                    raise InvalidCmd,\
-                          "Decay chain process must have exactly one" + \
-                          " incoming particle"
+                    raise InvalidCmd("Decay chain process must have exactly one" + \
+                          " incoming particle")
                 self['decay_chains'].append(\
                     DecayChainAmplitude(process, collect_mirror_procs,
                                         ignore_six_quark_processes,
@@ -1443,13 +1439,13 @@ class DecayChainAmplitude(Amplitude):
 
         if name == 'amplitudes':
             if not isinstance(value, AmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid AmplitudeList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid AmplitudeList" % str(value))
         if name == 'decay_chains':
             if not isinstance(value, DecayChainAmplitudeList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid DecayChainAmplitudeList object" % \
-                        str(value)
+                        str(value))
         return True
 
     def get_sorted_keys(self):
@@ -1601,23 +1597,23 @@ class MultiProcess(base_objects.PhysicsO
 
         if name == 'process_definitions':
             if not isinstance(value, base_objects.ProcessDefinitionList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessDefinitionList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessDefinitionList object" % str(value))
 
         if name == 'amplitudes':
             if not isinstance(value, AmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid AmplitudeList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid AmplitudeList object" % str(value))
 
         if name in ['collect_mirror_procs']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid boolean" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid boolean" % str(value))
 
         if name == 'ignore_six_quark_processes':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
 
         return True
 
@@ -1834,9 +1830,9 @@ class MultiProcess(base_objects.PhysicsO
             if len(failed_procs) == 1 and 'error' in locals():
                 raise error
             else:
-                raise NoDiagramException, \
+                raise NoDiagramException( \
             "No amplitudes generated from process %s. Please enter a valid process" % \
-                  process_definition.nice_string()
+                  process_definition.nice_string())
         
 
         # Return the produced amplitudes
@@ -2025,7 +2021,7 @@ class MultiProcess(base_objects.PhysicsO
                     amplitude = Amplitude({'process': process})
                     try:
                         amplitude.generate_diagrams(diagram_filter=diagram_filter)
-                    except InvalidCmd, error:
+                    except InvalidCmd as error:
                         failed_procs.append(tuple(sorted_legs))
                     else:
                         if amplitude.get('diagrams'):
diff -rupN MadGraph_pristine/madgraph/core/drawing.py ../contrib/MadGraph/madgraph/core/drawing.py
--- MadGraph_pristine/madgraph/core/drawing.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/drawing.py	2020-10-29 20:31:26.814384756 +1100
@@ -412,8 +412,8 @@ class FeynmanLine(object):
             self.begin.pos_x
             self.end.pos_y
         except Exception:
-            raise self.FeynmanLineError, 'No vertex in begin-end position ' + \
-                        ' or no position attach at one of those vertex '
+            raise self.FeynmanLineError('No vertex in begin-end position ' + \
+                        ' or no position attach at one of those vertex ')
         return True
 
     def has_ordinate(self, x):
@@ -431,10 +431,10 @@ class FeynmanLine(object):
                 min, max = max, min
 
             if min == max:
-                raise self.FeynmanLineError, 'Vertical line: no unique solution'
+                raise self.FeynmanLineError('Vertical line: no unique solution')
             if(not(min <= x <= max)):
-                raise self.FeynmanLineError, 'point outside interval invalid ' + \
-                    'invalid order {0:3}<={1:3}<={2:3}'.format(min, x, max)
+                raise self.FeynmanLineError('point outside interval invalid ' + \
+                    'invalid order {0:3}<={1:3}<={2:3}'.format(min, x, max))
 
         return self._has_ordinate(x)
 
@@ -548,8 +548,8 @@ class VertexPoint(object):
                 del self.lines[i]
                 return # only one data to remove!
 
-        raise self.VertexPointError, 'trying to remove in a ' + \
-                            'Vertex_Point a non present Feynman_Line'
+        raise self.VertexPointError( 'trying to remove in a ' + \
+                            'Vertex_Point a non present Feynman_Line')
 
 
     def def_level(self, level):
@@ -1060,9 +1060,9 @@ class FeynmanDiagram(object):
             # Associate position to level 2 and following (auto-recursive fct)
             self.find_vertex_position_at_level([init_line.end], 2)
         else:
-            raise self.FeynamDiagramError, \
+            raise self.FeynamDiagramError( \
                                 'only for one or two initial particles not %s' \
-                                % (len(self.initial_vertex))
+                                % (len(self.initial_vertex)))
 
 
     def find_vertex_position_tchannel(self):
@@ -1937,8 +1937,8 @@ class DiagramDrawer(object):
         straight is an example and can be replace by other type of line as 
         dashed, wavy, curly, ..."""
 
-        raise self.DrawDiagramError, 'DrawDiagram.draw_straight should be ' + \
-                'overwritten by Inherited Class'
+        raise self.DrawDiagramError( 'DrawDiagram.draw_straight should be ' + \
+                'overwritten by Inherited Class')
 
     draw_curved_straight = draw_straight
 
diff -rupN MadGraph_pristine/madgraph/core/helas_objects.py ../contrib/MadGraph/madgraph/core/helas_objects.py
--- MadGraph_pristine/madgraph/core/helas_objects.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/helas_objects.py	2020-10-29 20:31:26.818384734 +1100
@@ -300,8 +300,8 @@ class CanonicalConfigTag(diagram_generat
                         right_num = num
             if right_num == -1:
                 # This should never happen
-                raise diagram_generation.DiagramTag.DiagramTagError, \
-                    "Error in CanonicalConfigTag, no link with number 1 or 2."
+                raise diagram_generation.DiagramTag.DiagramTagError( \
+                    "Error in CanonicalConfigTag, no link with number 1 or 2.")
 
             # Now move one step in the direction of right_link
             right_link = self.tag.links[right_num]
@@ -492,8 +492,8 @@ class CanonicalConfigTag(diagram_generat
             return (old_vertex[0], (new_vertex[1][0], min_number), new_vertex[2])
 
         # We should not get here
-        raise diagram_generation.DiagramTag.DiagramTagError, \
-              "Error in CanonicalConfigTag, wrong setup of vertices in link."
+        raise diagram_generation.DiagramTag.DiagramTagError( \
+              "Error in CanonicalConfigTag, wrong setup of vertices in link.")
         
     @staticmethod
     def leg_from_link(link):
@@ -559,7 +559,7 @@ class HelasWavefunction(base_objects.Phy
         try:
             return sizes[abs(spin)]
         except KeyError:
-            raise MadGraph5Error, "L-cut particle has spin %d which is not supported."%spin
+            raise MadGraph5Error("L-cut particle has spin %d which is not supported."%spin)
 
     def default_setup(self):
         """Default values for all properties"""
@@ -695,149 +695,149 @@ class HelasWavefunction(base_objects.Phy
 
         if name in ['particle', 'antiparticle']:
             if not isinstance(value, base_objects.Particle):
-                raise self.PhysicsObjectError, \
-                    "%s tag %s is not a particle" % (name, repr(value))            
+                raise self.PhysicsObjectError( \
+                    "%s tag %s is not a particle" % (name, repr(value)))            
 
         if name == 'is_part':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "%s tag %s is not a boolean" % (name, repr(value))
+                raise self.PhysicsObjectError( \
+                    "%s tag %s is not a boolean" % (name, repr(value)))
 
         if name == 'interaction_id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer " % str(value) + \
-                        " for wavefunction interaction id"
+                        " for wavefunction interaction id")
 
         if name == 'pdg_codes':
             #Should be a list of strings
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of integers" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of integers" % str(value))
             for mystr in value:
                 if not isinstance(mystr, int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(mystr))
 
         if name == 'orders':
             #Should be a dict with valid order names ask keys and int as values
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dict for coupling orders" % \
-                                                                    str(value)
+                                                                    str(value))
             for order in value.keys():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(order)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(order))
                 if not isinstance(value[order], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value[order])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value[order]))
 
 
         if name == 'inter_color':
             # Should be None or a color string
             if value and not isinstance(value, color.ColorString):
-                    raise self.PhysicsObjectError, \
-                            "%s is not a valid Color String" % str(value)
+                    raise self.PhysicsObjectError( \
+                            "%s is not a valid Color String" % str(value))
 
         if name == 'lorentz':
             #Should be a list of string
             if not isinstance(value, list):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
 
         if name == 'coupling':
             #Should be a list of string
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid coupling string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid coupling string" % str(value))
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
             if len(value) == 0:
-                raise self.PhysicsObjectError, \
-                        "%s should have at least one value" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s should have at least one value" % str(value))
 
         if name == 'color_key':
             if value and not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                      "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                      "%s is not a valid integer" % str(value))
 
         if name == 'state':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid string for wavefunction state" % \
-                                                                    str(value)
+                                                                    str(value))
             if value not in ['incoming', 'outgoing',
                              'intermediate', 'initial', 'final']:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid wavefunction " % str(value) + \
-                        "state (incoming|outgoing|intermediate)"
+                        "state (incoming|outgoing|intermediate)")
         if name == 'leg_state':
             if value not in [False, True]:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid wavefunction " % str(value) + \
-                        "state (incoming|outgoing|intermediate)"
+                        "state (incoming|outgoing|intermediate)")
         if name in ['fermionflow']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
             if not value in [-1, 1]:
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid sign (must be -1 or 1)" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid sign (must be -1 or 1)" % str(value))
 
         if name in ['number_external', 'number']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer" % str(value) + \
-                        " for wavefunction number"
+                        " for wavefunction number")
 
         if name == 'mothers':
             if not isinstance(value, HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                       "%s is not a valid list of mothers for wavefunction" % \
-                      str(value)
+                      str(value))
 
         if name in ['decay']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid bool" % str(value) + \
-                        " for decay"
+                        " for decay")
         
         if name in ['onshell']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid bool" % str(value) + \
-                        " for onshell"
+                        " for onshell")
 
         if name in ['is_loop']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid bool" % str(value) + \
-                        " for is_loop"
+                        " for is_loop")
                         
         if name == 'conjugate_indices':
             if not isinstance(value, tuple) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid tuple" % str(value) + \
-                        " for conjugate_indices"
+                        " for conjugate_indices")
 
         if name == 'rank':
             if not isinstance(value, int) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid int" % str(value) + \
-                        " for the rank"
+                        " for the rank")
 
         if name == 'lcut_size':
             if not isinstance(value, int) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid int" % str(value) + \
-                        " for the lcut_size"
+                        " for the lcut_size")
 
         return True
 
@@ -914,8 +914,8 @@ class HelasWavefunction(base_objects.Phy
                     self.set('antiparticle', model.get('particle_dict')[-value])
                 return True
             else:
-                raise self.PhysicsObjectError, \
-                      "%s not allowed name for 3-argument set", name
+                raise self.PhysicsObjectError( \
+                      "%s not allowed name for 3-argument set", name)
         else:
             return super(HelasWavefunction, self).set(name, value)
 
@@ -973,10 +973,10 @@ class HelasWavefunction(base_objects.Phy
         except KeyError:
             # It then need be computed and for this, an alohaModel is necessary
             if alohaModel is None:
-                raise MadGraph5Error,"The analytic information %s has"%info+\
+                raise MadGraph5Error("The analytic information %s has"%info+\
                 " not been computed yet for this wavefunction and an"+\
                 " alohaModel was not specified, so that the information"+\
-                " cannot be retrieved."
+                " cannot be retrieved.")
         result = None
         
         if info=="interaction_rank" and len(self['mothers'])==0:
@@ -1011,8 +1011,8 @@ class HelasWavefunction(base_objects.Phy
                 result = result+self.get_analytic_info('interaction_rank',
                                                                      alohaModel)
             else:
-                raise MadGraph5Error, "A loop wavefunction has more than one loop"+\
-                    " mothers."
+                raise MadGraph5Error("A loop wavefunction has more than one loop"+\
+                    " mothers.")
                     
         # Now cache the resulting analytic info
         self['analytic_info'][info] = result
@@ -1472,8 +1472,8 @@ class HelasWavefunction(base_objects.Phy
         helas call """
         
         if self['mothers']:
-            raise MadGraph5Error, "This function should be called only for"+\
-                                                    " external wavefunctions."
+            raise MadGraph5Error("This function should be called only for"+\
+                                                    " external wavefunctions.")
         return_dict = {}
         if self.get('is_loop'):
             return_dict['conjugate'] = ('C' if self.needs_hermitian_conjugate() \
@@ -1795,7 +1795,7 @@ class HelasWavefunction(base_objects.Phy
             if self.get('spin') == 3:
                 return 'V'
             else:
-                raise MadGraph5Error,'L-cut particle type not supported'
+                raise MadGraph5Error('L-cut particle type not supported')
         else:
             return ''
 
@@ -1967,8 +1967,8 @@ class HelasWavefunction(base_objects.Phy
             loop_wf_index=\
                        [wf['is_loop'] for wf in self.get('mothers')].index(True)
         except ValueError:
-            raise MadGraph5Error, "The loop wavefunctions should have exactly"+\
-                                                " one loop wavefunction mother."
+            raise MadGraph5Error("The loop wavefunctions should have exactly"+\
+                                                " one loop wavefunction mother.")
 
         if self.find_outgoing_number()-1<=loop_wf_index:
             # If the incoming loop leg is placed after the outgoing one we
@@ -2009,8 +2009,8 @@ class HelasWavefunction(base_objects.Phy
             if len(loop_wfs)==1:
                 return loop_wfs[0]
             else:
-                raise MadGraph5Error, "The loop wavefunction must have either"+\
-                  " no mothers, or exactly one mother with type 'loop'."
+                raise MadGraph5Error("The loop wavefunction must have either"+\
+                  " no mothers, or exactly one mother with type 'loop'.")
         else:
             return None
         
@@ -2389,11 +2389,11 @@ class HelasWavefunctionList(base_objects
             return True
     
         def RaiseError():
-            raise self.PhysicsObjectListError, \
+            raise self.PhysicsObjectListError( \
       "This wavefunction list does not have a consistent wavefunction ordering."+\
       "\n  Wf numbers: %s"%str([wf['number'] for wf in diag_wfs])+\
       "\n  Wf mothers: %s"%str([[mother['number'] for mother in wf['mothers']] \
-                                                  for wf in diag_wfs])
+                                                  for wf in diag_wfs]))
     
         # We want to work on a local copy of the wavefunction list attribute
         diag_wfs = copy.copy(self)
@@ -2508,106 +2508,106 @@ class HelasAmplitude(base_objects.Physic
 
         if name == 'interaction_id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer for interaction id" % \
-                        str(value)
+                        str(value))
 
         if name == 'pdg_codes':
             #Should be a list of integers
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of integers" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of integers" % str(value))
             for mystr in value:
                 if not isinstance(mystr, int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(mystr))
 
         if name == 'orders':
             #Should be a dict with valid order names ask keys and int as values
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dict for coupling orders" % \
-                                                                    str(value)
+                                                                    str(value))
             for order in value.keys():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(order)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(order))
                 if not isinstance(value[order], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value[order])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value[order]))
 
         if name == 'inter_color':
             # Should be None or a color string
             if value and not isinstance(value, color.ColorString):
-                    raise self.PhysicsObjectError, \
-                            "%s is not a valid Color String" % str(value)
+                    raise self.PhysicsObjectError( \
+                            "%s is not a valid Color String" % str(value))
 
         if name == 'lorentz':
             #Should be a list of string
             if not isinstance(value, list):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid list of string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid list of string" % str(value))
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
                         
         if name == 'coupling':
             #Should be a list of string
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                      "%s is not a valid coupling (list of string)" % str(value)
+                raise self.PhysicsObjectError( \
+                      "%s is not a valid coupling (list of string)" % str(value))
             
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
             if not len(value):
-                raise self.PhysicsObjectError, \
-                                      'coupling should have at least one value'
+                raise self.PhysicsObjectError( \
+                                      'coupling should have at least one value')
 
         if name == 'color_key':
             if value and not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                      "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                      "%s is not a valid integer" % str(value))
 
         if name == 'number':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer for amplitude number" % \
-                        str(value)
+                        str(value))
 
         if name == 'fermionfactor':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer for fermionfactor" % \
-                        str(value)
+                        str(value))
             if not value in [-1, 0, 1]:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid fermion factor (-1, 0 or 1)" % \
-                        str(value)
+                        str(value))
 
         if name == 'color_indices':
             #Should be a list of integers
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of integers" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of integers" % str(value))
             for mystr in value:
                 if not isinstance(mystr, int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(mystr))
 
         if name == 'mothers':
             if not isinstance(value, HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                       "%s is not a valid list of mothers for amplitude" % \
-                      str(value)
+                      str(value))
 
         if name == 'conjugate_indices':
             if not isinstance(value, tuple) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid tuple" % str(value) + \
-                        " for conjugate_indices"
+                        " for conjugate_indices")
 
         return True
 
@@ -2719,8 +2719,8 @@ class HelasAmplitude(base_objects.Physic
                         self.set('coupling', [inter.get('couplings').values()[0]])
                 return True
             else:
-                raise self.PhysicsObjectError, \
-                      "%s not allowed name for 3-argument set", name
+                raise self.PhysicsObjectError( \
+                      "%s not allowed name for 3-argument set", name)
         else:
             return super(HelasAmplitude, self).set(name, value)
 
@@ -3208,15 +3208,15 @@ class HelasDiagram(base_objects.PhysicsO
 
         if name == 'wavefunctions' or name == 'loop_wavefunctions':
             if not isinstance(value, HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid HelasWavefunctionList object" % \
-                        str(value)
+                        str(value))
       
         if name == 'amplitudes':
             if not isinstance(value, HelasAmplitudeList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid HelasAmplitudeList object" % \
-                        str(value)
+                        str(value))
 
         return True
                 
@@ -3316,33 +3316,33 @@ class HelasMatrixElement(base_objects.Ph
 
         if name == 'processes':
             if not isinstance(value, base_objects.ProcessList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessList object" % str(value))
         if name == 'diagrams':
             if not isinstance(value, HelasDiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid HelasDiagramList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid HelasDiagramList object" % str(value))
         if name == 'identical_particle_factor':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid int object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid int object" % str(value))
         if name == 'color_basis':
             if not isinstance(value, color_amp.ColorBasis):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ColorBasis object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ColorBasis object" % str(value))
         if name == 'color_matrix':
             if not isinstance(value, color_amp.ColorMatrix):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ColorMatrix object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ColorMatrix object" % str(value))
         if name == 'base_amplitude':
             if value != None and not \
                    isinstance(value, diagram_generation.Amplitude):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Amplitude object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid Amplitude object" % str(value))
         if name == 'has_mirror_process':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid boolean" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid boolean" % str(value))
         return True
 
     def get_sorted_keys(self):
@@ -3578,7 +3578,7 @@ class HelasMatrixElement(base_objects.Ph
                         try:
                             wf = diagram_wavefunctions[\
                                     diagram_wavefunctions.index(wf)]
-                        except ValueError, error:
+                        except ValueError as error:
                             # Update wf number
                             wf_number = wf_number + 1
                             wf.set('number', wf_number)
@@ -4079,8 +4079,8 @@ class HelasMatrixElement(base_objects.Ph
 
                 # Ignore possibility for unoptimizated generation for now
                 if len(my_diagrams) > 1:
-                    raise self.PhysicsObjectError, \
-                          "Decay chains not yet prepared for GPU"
+                    raise self.PhysicsObjectError( \
+                          "Decay chains not yet prepared for GPU")
 
                 for diagram in my_diagrams:
 
@@ -4391,8 +4391,8 @@ class HelasMatrixElement(base_objects.Ph
                                  diagrams)
 
             if len(wf_diagrams) > 1:
-                raise self.PhysicsObjectError, \
-                      "Decay chains not yet prepared for GPU"
+                raise self.PhysicsObjectError( \
+                      "Decay chains not yet prepared for GPU")
 
             for diagram in wf_diagrams:
 
@@ -4749,12 +4749,12 @@ class HelasMatrixElement(base_objects.Ph
                           tuple(amp.get('color_indices')) == diag_tuple[1],
                           diagrams[diag_tuple[0]].get('amplitudes'))
                 if not res_amps:
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                           """No amplitude found for color structure
                             %s and color index chain (%s) (diagram %i)""" % \
                             (col_basis_elem,
                              str(diag_tuple[1]),
-                             diag_tuple[0])
+                             diag_tuple[0]))
 
                 for res_amp in res_amps:
                     col_amp.append(((res_amp.get('fermionfactor'),
@@ -5150,15 +5150,15 @@ class HelasDecayChainProcess(base_object
 
         if name == 'core_processes':
             if not isinstance(value, HelasMatrixElementList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid HelasMatrixElementList object" % \
-                        str(value)
+                        str(value))
 
         if name == 'decay_chains':
             if not isinstance(value, HelasDecayChainProcessList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                      "%s is not a valid HelasDecayChainProcessList object" % \
-                     str(value)
+                     str(value))
 
         return True
 
@@ -5441,8 +5441,8 @@ class HelasMultiProcess(base_objects.Phy
 
         if name == 'matrix_elements':
             if not isinstance(value, HelasMatrixElementList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid HelasMatrixElementList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid HelasMatrixElementList object" % str(value))
         return True
 
     def get_sorted_keys(self):
@@ -5522,8 +5522,8 @@ class HelasMultiProcess(base_objects.Phy
         tree-level Nc and present for structural reasons only."""
         
         if compute_loop_nc:
-            raise MadGraph5Error, "The tree-level function 'process_color' "+\
-             " of class HelasMultiProcess cannot be called with a value for compute_loop_nc"
+            raise MadGraph5Error( "The tree-level function 'process_color' "+\
+             " of class HelasMultiProcess cannot be called with a value for compute_loop_nc")
         
         # Define the objects stored in the contained color_information
         for key in color_information:
@@ -5741,8 +5741,8 @@ class HelasMultiProcess(base_objects.Phy
                                                 compute_loop_nc=compute_loop_nc)                    
 
         if not matrix_elements:
-            raise InvalidCmd, \
-                  "No matrix elements generated, check overall coupling orders"
+            raise InvalidCmd( \
+                  "No matrix elements generated, check overall coupling orders")
 
         return matrix_elements
 
diff -rupN MadGraph_pristine/madgraph/__init__.py ../contrib/MadGraph/madgraph/__init__.py
--- MadGraph_pristine/madgraph/__init__.py	2020-10-27 21:41:37.889090214 +1100
+++ ../contrib/MadGraph/madgraph/__init__.py	2020-10-29 20:31:26.818384734 +1100
@@ -46,5 +46,5 @@ if ReadWrite:
             os.remove(tmp_path)
             shutil.copy(pjoin(MG5DIR, 'Template','LO','Source','.make_opts'),
                     pjoin(MG5DIR, 'Template','LO','Source','make_opts'))
-    except Exception,error:
+    except Exception as error:
         pass
diff -rupN MadGraph_pristine/madgraph/interface/extended_cmd.py ../contrib/MadGraph/madgraph/interface/extended_cmd.py
--- MadGraph_pristine/madgraph/interface/extended_cmd.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/extended_cmd.py	2020-10-29 20:31:26.818384734 +1100
@@ -15,6 +15,7 @@
 """  A file containing different extension of the cmd basic python library"""
 
 
+from io import IOBase
 import logging
 import math
 import os
@@ -41,7 +42,7 @@ try:
     import madgraph.various.misc as misc
     from madgraph import MG5DIR, MadGraph5Error
     MADEVENT = False
-except ImportError, error:
+except ImportError as error:
     try:
         import internal.misc as misc
     except:
@@ -65,7 +66,7 @@ def debug(debug_only=True):
         def deco_f(*args, **opt):
             try:
                 return f(*args, **opt)
-            except Exception, error:
+            except Exception as error:
                 logger.error(error)
                 logger.error(traceback.print_exc(file=sys.stdout))
                 return
@@ -391,7 +392,7 @@ class OriginalCmd(object):
         nonstrings = [i for i in range(len(list))
                         if not isinstance(list[i], str)]
         if nonstrings:
-            raise TypeError, ("list[i] not a string for i in %s" %
+            raise TypeError("list[i] not a string for i in %s" %
                               ", ".join(map(str, nonstrings)))
         size = len(list)
         if size == 1:
@@ -541,7 +542,7 @@ class BasicCmd(OriginalCmd):
     
             self.stdout.write(self.prompt+readline.get_line_buffer())
             self.stdout.flush()
-        except Exception, error:
+        except Exception as error:
             if __debug__:
                 logger.error(error)
             
@@ -596,9 +597,9 @@ class BasicCmd(OriginalCmd):
                 else:
                     try:
                         compfunc = getattr(self, 'complete_' + cmd)
-                    except AttributeError, error:
+                    except AttributeError as error:
                         compfunc = self.completedefault
-                    except Exception, error:
+                    except Exception as error:
                         misc.sprint(error)
             else:
                 compfunc = self.completenames
@@ -623,8 +624,8 @@ class BasicCmd(OriginalCmd):
                 data = compfunc(Ntext, line, Nbegidx, endidx)
                 self.completion_matches = [p[to_rm:] for p in data 
                                               if len(p)>to_rm]
-             except Exception, error:
-                 print error                
+             except Exception as error:
+                 print(error)                
             else:
                 self.completion_prefix = ''
                 self.completion_matches = compfunc(text, line, begidx, endidx)
@@ -635,7 +636,7 @@ class BasicCmd(OriginalCmd):
         
         try:
             return self.completion_matches[state]
-        except IndexError, error:
+        except IndexError as error:
             # if __debug__:
             #    logger.error('\n Completion ERROR:')
             #    logger.error( error)
@@ -754,13 +755,13 @@ class CheckCmd(object):
         
         if len(args) > 2:
             self.help_save()
-            raise self.InvalidCmd, 'too many arguments for save command.'
+            raise self.InvalidCmd('too many arguments for save command.')
         
         if len(args) == 2:
             if args[0] != 'options':
                 self.help_save()
-                raise self.InvalidCmd, '\'%s\' is not recognized as first argument.' % \
-                                                args[0]
+                raise self.InvalidCmd('\'%s\' is not recognized as first argument.' % \
+                                                args[0])
             else:
                 args.pop(0)           
 
@@ -921,7 +922,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         if intro is not None:
             self.intro = intro
         if self.intro:
-            print self.intro
+            print(self.intro)
         stop = None
         while not stop:
             if self.cmdqueue:
@@ -944,7 +945,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
             try:
                 line = self.precmd(line)
                 stop = self.onecmd(line)
-            except BaseException, error:
+            except BaseException as error:
                 self.error_handling(error, line)
                 if isinstance(error, KeyboardInterrupt):
                     stop = True
@@ -1285,7 +1286,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
             os.remove(self.debug_output)
         try:
             super(Cmd,self).onecmd('history %s' % self.debug_output.replace(' ', '\ '))
-        except Exception, error:
+        except Exception as error:
             logger.error(error)
 
         debug_file = open(self.debug_output, 'a')
@@ -1309,7 +1310,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         # Add options status to the debug file
         try:
             self.do_display('options', debug_file)
-        except Exception, error:
+        except Exception as error:
             debug_file.write('Fail to write options with error %s' % error)
         
         #add the cards:
@@ -1403,7 +1404,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         # Add options status to the debug file
         try:
             self.do_display('options', debug_file)
-        except Exception, error:
+        except Exception as error:
             debug_file.write('Fail to write options with error %s' % error)
             
         if hasattr(self, 'options') and 'crash_on_error' in self.options:
@@ -1512,7 +1513,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
            
         try:
             return self.onecmd_orig(line, **opt)
-        except BaseException, error: 
+        except BaseException as error: 
             return self.error_handling(error, line)
             
     
@@ -1865,7 +1866,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         
         if len(args) == 0:
             self.help_display()
-            raise self.InvalidCmd, 'display require at least one argument'
+            raise self.InvalidCmd('display require at least one argument')
         
         if args[0] == "options":
             outstr = "Value of current Options:\n" 
@@ -1898,7 +1899,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
                 except ImportError:
                     try:
                         var = eval(args[1])
-                    except Exception, error:
+                    except Exception as error:
                         outstr += 'EXTERNAL:\nVariable %s is not a external variable\n' % args[1]
                         break
                     else:
@@ -2085,7 +2086,7 @@ class SmartQuestion(BasicCmd):
         for key,value in opts:
             setattr(self, key, value)
         if reprint_opt:
-            print question
+            print(question)
             logger_tuto.info("Need help here? type 'help'", '$MG:BOLD')
             logger_plugin.info("Need help here? type 'help'" , '$MG:BOLD')
         return self.cmdloop()
@@ -2104,8 +2105,8 @@ class SmartQuestion(BasicCmd):
             out[' Recognized command'] = super(SmartQuestion, self).completenames(text,line, *ignored)
             
             return self.deal_multiple_categories(out)
-        except Exception, error:
-            print error
+        except Exception as error:
+            print(error)
     
     completedefault = completenames
 
@@ -2158,7 +2159,7 @@ class SmartQuestion(BasicCmd):
         if reprint_opt:
             if not prev_timer:
                 self.question = pat.sub('',self.question)
-            print self.question.encode('utf8')
+            print(self.question.encode('utf8'))
 
         if self.mother_interface:
             answer = self.mother_interface.check_answer_in_input_file(self, 'EOF', 
@@ -2244,7 +2245,7 @@ class SmartQuestion(BasicCmd):
                 
             else: 
                 raise Exception
-        except Exception,error:
+        except Exception as error:
             if self.wrong_answer < 100:
                 self.wrong_answer += 1
                 logger.warning("""%s not valid argument. Valid argument are in (%s).""" \
@@ -2261,7 +2262,7 @@ class SmartQuestion(BasicCmd):
     
 # a function helper
 def smart_input(input_text, allow_arg=[], default=None):
-    print input_text
+    print(input_text)
     obj = SmartQuestion(allow_arg=allow_arg, default=default)
     return obj.cmdloop()
 
@@ -2289,8 +2290,8 @@ class OneLinePathCompletion(SmartQuestio
             out[' Recognized command'] = BasicCmd.completenames(self, text, line, begidx, endidx)
             
             return self.deal_multiple_categories(out, formatting)
-        except Exception, error:
-            print error
+        except Exception as error:
+            print(error)
             
     def precmd(self, *args):
         """ """
@@ -2307,8 +2308,8 @@ class OneLinePathCompletion(SmartQuestio
             self.stdout.flush()
         try:
             args = Cmd.split_arg(line[0:begidx])
-        except Exception, error:
-            print error
+        except Exception as error:
+            print(error)
 
         # Directory continuation                 
         if args[-1].endswith(os.path.sep):
@@ -2336,10 +2337,10 @@ class OneLinePathCompletion(SmartQuestio
                 reprint_opt = True         
             else:
                 raise Exception
-        except Exception, error:  
-            print """not valid argument. Valid argument are file path or value in (%s).""" \
-                          % ','.join(self.allow_arg)
-            print 'please retry'
+        except Exception as error:  
+            print("""not valid argument. Valid argument are file path or value in (%s).""" \
+                          % ','.join(self.allow_arg))
+            print('please retry')
             reprint_opt = False 
 
         if line != 'EOF':
@@ -2348,7 +2349,7 @@ class OneLinePathCompletion(SmartQuestio
             
 # a function helper
 def raw_path_input(input_text, allow_arg=[], default=None):
-    print input_text
+    print(input_text)
     obj = OneLinePathCompletion(allow_arg=allow_arg, default=default )
     return obj.cmdloop()
 
@@ -2416,7 +2417,7 @@ class ControlSwitch(SmartQuestion):
         question = self.create_question()
         
         #check all default for auto-completion
-        allowed_args = [ `i`+';' for i in range(1, 1+len(self.to_control))] 
+        allowed_args = [ repr(i)+';' for i in range(1, 1+len(self.to_control))] 
         for key in self.switch:
             allowed_args += ['%s=%s;' % (key,s) for s in self.get_allowed(key)]
         # adding special mode
@@ -2552,7 +2553,7 @@ class ControlSwitch(SmartQuestion):
             base, value = line.split(' ', 1)
         elif hasattr(self, 'ans_%s' % line.lower()):
             base, value = line.lower(), None
-        elif line.isdigit() and line in [`i` for i in range(1, len(self.to_control)+1)]:
+        elif line.isdigit() and line in [repr(i) for i in range(1, len(self.to_control)+1)]:
             # go from one valid option to the next in the get_allowed for that option
             base = self.to_control[int(line)-1][0].lower()
             return self.default(base) # just recall this function with the associate name
@@ -2865,7 +2866,7 @@ class ControlSwitch(SmartQuestion):
         #re-order the options in order to have those in cycling order    
         try:
             ind =  self.get_allowed(key).index(self.switch[key])
-        except Exception, err:
+        except Exception as err:
             options = self.get_allowed(key)
         else:
             options = self.get_allowed(key)[ind:]+ self.get_allowed(key)[:ind] 
@@ -3101,7 +3102,7 @@ class ControlSwitch(SmartQuestion):
         try:
             nb_rows, nb_col = os.popen('stty size', 'r').read().split()
             nb_rows, nb_col = int(nb_rows), int(nb_col)
-        except Exception,error:
+        except Exception as error:
             nb_rows, nb_col = 20, 80
         
         #compute information on the length of element to display
@@ -3210,13 +3211,13 @@ class ControlSwitch(SmartQuestion):
 #===============================================================================
 # 
 #===============================================================================
-class CmdFile(file):
+class CmdFile(IOBase):
     """ a class for command input file -in order to debug cmd \n problem"""
     
     def __init__(self, name, opt='rU'):
         
-        file.__init__(self, name, opt)
-        self.text = file.read(self)
+        IOBase.__init__(self, name, opt)
+        self.text = IOBase.read(self)
         self.close()
         self.lines = self.text.split('\n')
     
diff -rupN MadGraph_pristine/madgraph/interface/madgraph_interface.py ../contrib/MadGraph/madgraph/interface/madgraph_interface.py
--- MadGraph_pristine/madgraph/interface/madgraph_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/madgraph_interface.py	2020-10-29 20:31:26.818384734 +1100
@@ -24,6 +24,7 @@ import glob
 import logging
 import optparse
 import os
+import stat
 import pydoc
 import random
 import re
@@ -32,7 +33,12 @@ import subprocess
 import copy
 import sys
 import shutil
-import StringIO
+
+try:
+    from StringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import traceback
 import time
 import inspect
@@ -844,10 +850,10 @@ class CheckValidForCmd(cmd.CheckCmd):
 
         if len(args) < 1:
             self.help_display()
-            raise self.InvalidCmd, 'display requires an argument specifying what to display'
+            raise self.InvalidCmd('display requires an argument specifying what to display')
         if args[0] not in self._display_opts + ['model_list']:
             self.help_display()
-            raise self.InvalidCmd, 'Invalid arguments for display command: %s' % args[0]
+            raise self.InvalidCmd('Invalid arguments for display command: %s' % args[0])
 
         if not self._curr_model:
             raise self.InvalidCmd("No model currently active, please import a model!")
@@ -981,7 +987,7 @@ class CheckValidForCmd(cmd.CheckCmd):
                 parsed = arg.split('=')
                 key, value = parsed[0],'='.join(parsed[1:])
                 if key not in user_options:
-                    raise self.InvalidCmd, "unknown option %s" % key
+                    raise self.InvalidCmd("unknown option %s" % key)
                 user_options[key] = value
                 args.remove(arg)
 
@@ -1221,8 +1227,8 @@ This will take effect only in a NEW term
                     args.append(self._done_export[1])
                     args.append(self._done_export[0])
                 else:
-                    raise self.InvalidCmd, \
-                          '%s not valid directory for launch' % self._done_export[0]
+                    raise self.InvalidCmd( \
+                          '%s not valid directory for launch' % self._done_export[0])
                 return
             else:
                 logger.warning('output command missing, run it automatically (with default argument)')
@@ -1242,7 +1248,7 @@ This will take effect only in a NEW term
         elif  MG4DIR and os.path.isdir(pjoin(MG4DIR,args[0])):
             path = pjoin(MG4DIR,args[0])
         else:
-            raise self.InvalidCmd, '%s is not a valid directory' % args[0]
+            raise self.InvalidCmd('%s is not a valid directory' % args[0])
 
         mode = self.find_output_type(path)
 
@@ -1303,7 +1309,7 @@ This will take effect only in a NEW term
             os.path.isfile(pjoin(include_path, 'Pythia8', 'Pythia.h')):
             return 'pythia8'
         elif not os.path.isdir(os.path.join(path, 'SubProcesses')):
-            raise self.InvalidCmd, '%s : Not a valid directory' % path
+            raise self.InvalidCmd('%s : Not a valid directory' % path)
 
         if os.path.isdir(src_path):
             return 'standalone_cpp'
@@ -1316,7 +1322,7 @@ This will take effect only in a NEW term
         elif os.path.isdir(card_path):
             return 'standalone'
 
-        raise self.InvalidCmd, '%s : Not a valid directory' % path
+        raise self.InvalidCmd('%s : Not a valid directory' % path)
 
     def check_load(self, args):
         """ check the validity of the line"""
@@ -1579,7 +1585,7 @@ This will take effect only in a NEW term
             elif path != 'auto':
                 if path in ['HELAS', 'tests', 'MadSpin', 'madgraph', 'mg5decay', 'vendor']:
                     if os.getcwd() == MG5DIR:
-                        raise self.InvalidCmd, "This name correspond to a buildin MG5 directory. Please choose another name"
+                        raise self.InvalidCmd("This name correspond to a buildin MG5 directory. Please choose another name")
                 self._export_dir = path
             elif path == 'auto':
                 if self.options['pythia8_path']:
@@ -1709,7 +1715,7 @@ This will take effect only in a NEW term
             elif self.stdin != sys.stdin:
                 #Check for position defined by the input files
                 input_path = os.path.realpath(self.stdin.name).split(os.path.sep)
-                print "Not standard stdin, use input path"
+                print("Not standard stdin, use input path")
                 if input_path[-2] == 'Cards':
                     self._export_dir = os.path.sep.join(input_path[:-2])
                     if 'TemplateVersion.txt' in self._export_dir:
@@ -1815,7 +1821,7 @@ class CheckValidForCmdWeb(CheckValidForC
         No Path authorize for the Web"""
 
         if not args:
-            raise self.WebRestriction, 'import requires at least one option'
+            raise self.WebRestriction('import requires at least one option')
 
         if args[0] not in self._import_formats:
             args[:] = ['command', './proc_card_mg5.dat']
@@ -1866,7 +1872,7 @@ class CheckValidForCmdWeb(CheckValidForC
         self._export_dir = os.path.realpath(os.getcwd())
         # Check that we output madevent
         if 'madevent' != self._export_format:
-                raise self.WebRestriction, 'only available output format is madevent (at current stage)'
+                raise self.WebRestriction('only available output format is madevent (at current stage)')
 
 #===============================================================================
 # CompleteForCmd
@@ -2043,7 +2049,7 @@ class CompleteForCmd(cmd.CompleteCmd):
         try:
             return self.model_completion(text, ' '.join(args[1:]),line, formatting)
         except Exception as error:
-            print error
+            print(error)
 
         #if len(args) > 1 and args[-1] != '>':
         #    couplings = ['>']
@@ -2398,8 +2404,8 @@ class CompleteForCmd(cmd.CompleteCmd):
             if len(args) > 1 and args[1] == 'aloha':
                 try:
                     return self.aloha_complete_output(text, line, begidx, endidx)
-                except Exception, error:
-                    print error
+                except Exception as error:
+                    print(error)
             # Directory continuation
             if args[-1].endswith(os.path.sep):
                 return [name for name in self.path_completion(text,
@@ -2567,7 +2573,7 @@ class CompleteForCmd(cmd.CompleteCmd):
                 try:
                     cur_path = pjoin(*[a for a in args \
                                                    if a.endswith(os.path.sep)])
-                except Exception, error:
+                except Exception as error:
                     pass
                 else:
                     all_dir = self.path_completion(text, cur_path, only_dirs = True)
@@ -3117,8 +3123,8 @@ This implies that with decay chains:
                 if amp not in self._curr_amps:
                     self._curr_amps.append(amp)
                 elif warning_duplicate:
-                    raise self.InvalidCmd, "Duplicate process %s found. Please check your processes." % \
-                                                amp.nice_string_processes()
+                    raise self.InvalidCmd("Duplicate process %s found. Please check your processes." % \
+                                                amp.nice_string_processes())
 
             # Reset _done_export, since we have new process
             self._done_export = False
@@ -3170,7 +3176,7 @@ This implies that with decay chains:
                 try:
                     self.exec_cmd('import model %s' % new_model_name, errorhandling=False, 
                               printcmd=False, precmd=True, postcmd=True)
-                except Exception, error:
+                except Exception as error:
                     logger.debug('fail to load model %s with error:\n %s' % (output_dir, error))
                     logger.warning('Fail to load the model. Restore previous model')
                     self.exec_cmd('import model %s' % oldmodel, errorhandling=False, 
@@ -3262,21 +3268,21 @@ This implies that with decay chains:
                 else:
                     nb_unpropagating += 1
 
-            print "Current model contains %i particles:" % \
-                    len(propagating_particle)
+            print("Current model contains %i particles:" % \
+                    len(propagating_particle))
             part_antipart = [part for part in propagating_particle \
                              if not part['self_antipart']]
             part_self = [part for part in propagating_particle \
                              if part['self_antipart']]
             for part in part_antipart:
-                print part['name'] + '/' + part['antiname'],
-            print ''
+                print(part['name'] + '/' + part['antiname'],)
+            print('')
             for part in part_self:
-                print part['name'],
-            print ''
+                print(part['name'],)
+            print('')
             if nb_unpropagating:
-                print 'In addition of %s un-physical particle mediating new interactions.' \
-                                     % nb_unpropagating
+                print('In addition of %s un-physical particle mediating new interactions.' \
+                                     % nb_unpropagating)
 
         elif args[0] == 'particles':
             for arg in args[1:]:
@@ -3285,10 +3291,10 @@ This implies that with decay chains:
                 else:
                     particle = self._curr_model['particles'].find_name(arg)
                 if not particle:
-                    raise self.InvalidCmd, 'no particle %s in current model' % arg
+                    raise self.InvalidCmd('no particle %s in current model' % arg)
 
-                print "Particle %s has the following properties:" % particle.get_name()
-                print str(particle)
+                print("Particle %s has the following properties:" % particle.get_name())
+                print(str(particle))
 
         elif args[0] == 'interactions' and len(args) == 1:
             text = "Current model contains %i interactions\n" % \
@@ -3309,12 +3315,12 @@ This implies that with decay chains:
         elif args[0] == 'interactions' and len(args)==2 and args[1].isdigit():
             for arg in args[1:]:
                 if int(arg) > len(self._curr_model['interactions']):
-                    raise self.InvalidCmd, 'no interaction %s in current model' % arg
+                    raise self.InvalidCmd('no interaction %s in current model' % arg)
                 if int(arg) == 0:
-                    print 'Special interactions which identify two particles'
+                    print('Special interactions which identify two particles')
                 else:
-                    print "Interactions %s has the following property:" % arg
-                    print self._curr_model['interactions'][int(arg)-1]
+                    print("Interactions %s has the following property:" % arg)
+                    print( self._curr_model['interactions'][int(arg)-1])
 
         elif args[0] == 'interactions':
             request_part = args[1:]
@@ -3346,7 +3352,7 @@ This implies that with decay chains:
                 text += str(self._curr_model['interactions'][i])
 
                 text += '\n'
-                print name
+                print(name)
             if text =='':
                 text += 'No matching for any interactions'
             pydoc.pager(text)
@@ -3385,16 +3391,16 @@ This implies that with decay chains:
 
         elif args[0] == 'processes':
             for amp in self._curr_amps:
-                print amp.nice_string_processes()
+                print( amp.nice_string_processes())
 
         elif args[0] == 'diagrams_text':
             text = "\n".join([amp.nice_string() for amp in self._curr_amps])
             pydoc.pager(text)
 
         elif args[0] == 'multiparticles':
-            print 'Multiparticle labels:'
+            print( 'Multiparticle labels:')
             for key in self._multiparticles:
-                print self.multiparticle_string(key)
+                print( self.multiparticle_string(key))
 
         elif args[0] == 'coupling_order':
             hierarchy = self._curr_model['order_hierarchy'].items()
@@ -3406,11 +3412,11 @@ This implies that with decay chains:
                     return 1
             hierarchy.sort(order)
             for order in hierarchy:
-                print ' %s : weight = %s' % order
+                print( ' %s : weight = %s' % order)
 
         elif args[0] == 'couplings' and len(args) == 1:
             if self._model_v4_path:
-                print 'No couplings information available in V4 model'
+                print( 'No couplings information available in V4 model')
                 return
             text = ''
             text = "Current model contains %i couplings\n" % \
@@ -3440,34 +3446,34 @@ This implies that with decay chains:
 
         elif args[0] == 'couplings':
             if self._model_v4_path:
-                print 'No couplings information available in V4 model'
+                print('No couplings information available in V4 model')
                 return
 
             try:
                 ufomodel = ufomodels.load_model(self._curr_model.get('name'))
-                print 'Note that this is the UFO informations.'
-                print ' "display couplings" present the actual definition'
-                print 'prints the current states of mode'
-                print eval('ufomodel.couplings.%s.nice_string()'%args[1])
+                print('Note that this is the UFO informations.')
+                print(' "display couplings" present the actual definition')
+                print('prints the current states of mode')
+                print(eval('ufomodel.couplings.%s.nice_string()'%args[1]))
             except Exception:
-                raise self.InvalidCmd, 'no couplings %s in current model' % args[1]
+                raise self.InvalidCmd('no couplings %s in current model' % args[1])
 
         elif args[0] == 'lorentz':
-            print 'in lorentz'
+            print('in lorentz')
             if self._model_v4_path:
-                print 'No lorentz information available in V4 model'
+                print('No lorentz information available in V4 model')
                 return
             elif len(args) == 1:
                 ufomodel = ufomodels.load_model(self._curr_model.get('name'))
-                print dir(ufomodel.lorentz)
+                print(dir(ufomodel.lorentz))
                 return
             try:
                 ufomodel = ufomodels.load_model(self._curr_model.get('name'))
-                print getattr(ufomodel.lorentz, args[1]).nice_string()
-            except Exception, error:
+                print(getattr(ufomodel.lorentz, args[1]).nice_string())
+            except Exception as error:
                 raise
                 logger.info(str(error))
-                raise self.InvalidCmd, 'no lorentz %s in current model' % args[1]
+                raise self.InvalidCmd('no lorentz %s in current model' % args[1])
 
         elif args[0] == 'checks':
             outstr = ''
@@ -4319,8 +4325,8 @@ This implies that with decay chains:
                 if key not in options:
                     options[key] = value
                 else:
-                    raise MadGraph5Error,"Option '%s' is both in the option"%key+\
-                                                   " and CMS_option dictionary." 
+                    raise MadGraph5Error("Option '%s' is both in the option"%key+\
+                                                   " and CMS_option dictionary." )
             
             if options['analyze']=='None':
                 cms_results = []
@@ -4544,8 +4550,8 @@ This implies that with decay chains:
                     elif option=='noborn':
                         HasBorn=False
                 else:
-                    raise self.InvalidCmd, "NLO mode %s is not valid. "%option+\
-                       "Valid modes are %s. "%str(self._valid_nlo_modes)
+                    raise self.InvalidCmd("NLO mode %s is not valid. "%option+\
+                       "Valid modes are %s. "%str(self._valid_nlo_modes))
             else:
                 LoopOption='all'
 
@@ -4569,8 +4575,8 @@ This implies that with decay chains:
             type = order_re.group('type')
             if order_re.group('name').endswith('^2'):
                 if type not in self._valid_sqso_types:
-                    raise self.InvalidCmd, "Type of squared order "+\
-                                 "constraint '%s'"% type+" is not supported."
+                    raise self.InvalidCmd("Type of squared order "+\
+                                 "constraint '%s'"% type+" is not supported.")
                 if type == '=':
                     name =  order_re.group('name')
                     value = order_re.group('value')
@@ -4581,9 +4587,9 @@ This implies that with decay chains:
                                          (int(order_re.group('value')),type)
             else:
                 if type not in self._valid_amp_so_types:
-                    raise self.InvalidCmd, \
+                    raise self.InvalidCmd( \
                       "Amplitude order constraints can only be of type %s"%\
-                    (', '.join(self._valid_amp_so_types))+", not '%s'."%type
+                    (', '.join(self._valid_amp_so_types))+", not '%s'."%type)
                 name = order_re.group('name')
                 value = int(order_re.group('value'))
                 if type in ['=', '<=']:
@@ -4620,9 +4626,9 @@ This implies that with decay chains:
         
         #only allow amplitue restrctions >/ == for LO/tree level
         if constrained_orders and LoopOption != 'tree':
-            raise self.InvalidCmd, \
+            raise self.InvalidCmd( \
                           "Amplitude order constraints (for not LO processes) can only be of type %s"%\
-                        (', '.join(['<=']))+", not '%s'."%type
+                        (', '.join(['<=']))+", not '%s'."%type)
 
         # If the squared orders are defined but not the orders, assume 
         # orders=sq_orders. In case the squared order has a negative value or is
@@ -4686,23 +4692,23 @@ This implies that with decay chains:
         for part_name in args:
             if part_name == '>':
                 if not myleglist:
-                    raise self.InvalidCmd, "No final state particles"
+                    raise self.InvalidCmd("No final state particles")
                 state = True
                 continue
 
             mylegids = []
             if part_name in self._multiparticles:
                 if isinstance(self._multiparticles[part_name][0], list):
-                    raise self.InvalidCmd,\
+                    raise self.InvalidCmd(\
                           "Multiparticle %s is or-multiparticle" % part_name + \
-                          " which can be used only for required s-channels"
+                          " which can be used only for required s-channels")
                 mylegids.extend(self._multiparticles[part_name])
             elif part_name.isdigit() or part_name.startswith('-') and part_name[1:].isdigit():
                 if int(part_name) in self._curr_model.get('particle_dict'):
                     mylegids.append(int(part_name))
                 else:
-                    raise self.InvalidCmd, \
-                      "No pdg_code %s in model" % part_name
+                    raise self.InvalidCmd( \
+                      "No pdg_code %s in model" % part_name)
             else:
                 mypart = self._curr_model['particles'].get_copy(part_name)
                 if mypart:
@@ -4712,7 +4718,7 @@ This implies that with decay chains:
                 myleglist.append(base_objects.MultiLeg({'ids':mylegids,
                                                         'state':state}))
             else:
-                raise self.InvalidCmd, "No particle %s in model" % part_name
+                raise self.InvalidCmd("No particle %s in model" % part_name)
 
         # Apply the keyword 'all' for perturbed coupling orders.
         if perturbation_couplings.lower() in ['all', 'loonly']:
@@ -4735,10 +4741,10 @@ This implies that with decay chains:
                                        self._curr_model.get('order_hierarchy')
                                        [elem if not elem.endswith('.sqrt') else elem[:-5]])
             except KeyError:
-                raise self.InvalidCmd, "The loaded model does not defined a "+\
+                raise self.InvalidCmd("The loaded model does not defined a "+\
                     " coupling order hierarchy for these couplings: %s"%\
                       str([so for so in split_orders if so!='WEIGHTED' and so not 
-                                 in self._curr_model['order_hierarchy'].keys()])
+                                 in self._curr_model['order_hierarchy'].keys()]))
 
             # If the loopOption is 'tree' then the user used the syntax 
             # [tree= Orders] for the sole purpose of setting split_orders. We
@@ -4777,14 +4783,14 @@ This implies that with decay chains:
                               self.extract_particle_ids(forbidden_schannels)
             if forbidden_onsh_schannel_ids and \
                isinstance(forbidden_onsh_schannel_ids[0], list):
-                raise self.InvalidCmd,\
+                raise self.InvalidCmd(\
                       "Multiparticle %s is or-multiparticle" % part_name + \
-                      " which can be used only for required s-channels"
+                      " which can be used only for required s-channels")
             if forbidden_schannel_ids and \
                isinstance(forbidden_schannel_ids[0], list):
-                raise self.InvalidCmd,\
+                raise self.InvalidCmd(\
                       "Multiparticle %s is or-multiparticle" % part_name + \
-                      " which can be used only for required s-channels"
+                      " which can be used only for required s-channels")
             required_schannel_ids = \
                                self.extract_particle_ids(required_schannels)
             if required_schannel_ids and not \
@@ -4908,8 +4914,8 @@ This implies that with decay chains:
                 if amp['has_born']:
                     raise Exception
             elif warning_duplicate:
-                raise self.InvalidCmd, "Duplicate process %s found. Please check your processes." % \
-                                            amp.nice_string_processes()
+                raise self.InvalidCmd("Duplicate process %s found. Please check your processes." % \
+                                            amp.nice_string_processes())
 
         # Reset _done_export, since we have new process
         self._done_export = False
@@ -5027,7 +5033,7 @@ This implies that with decay chains:
                 elif first in self._multiparticles:
                     pid = set(self._multiparticles[first])
                 else:
-                    raise Exception, 'invalid particle name: %s. ' % first
+                    raise Exception('invalid particle name: %s. ' % first)
                 core_final.difference_update(pid)
                 core_final.update(self.get_final_part(one_decay))
 
@@ -5179,8 +5185,8 @@ This implies that with decay chains:
 
             if level_down:
                 if index_par == -1:
-                    raise self.InvalidCmd, \
-                      "Missing ending parenthesis for decay process"
+                    raise self.InvalidCmd(\
+                      "Missing ending parenthesis for decay process")
 
                 if index_par < index_comma:
                     line = line[index_par + 1:]
@@ -5190,8 +5196,8 @@ This implies that with decay chains:
         if level_down:
             index_par = line.find(')')
             if index_par == -1:
-                raise self.InvalidCmd, \
-                      "Missing ending parenthesis for decay process"
+                raise self.InvalidCmd( \
+                      "Missing ending parenthesis for decay process")
             line = line[index_par + 1:]
 
         # Return the core process (ends recursion when there are no
@@ -5289,7 +5295,7 @@ This implies that with decay chains:
         elif args[0] == 'banner':
             type = madevent_interface.MadEventCmd.detect_card_type(args[1])
             if type != 'banner':
-                raise self.InvalidCmd, 'The File should be a valid banner'
+                raise self.InvalidCmd('The File should be a valid banner')
             ban = banner_module.Banner(args[1])
             # Check that this is MG5 banner
             if 'mg5proccard' in ban:
@@ -5298,7 +5304,7 @@ This implies that with decay chains:
                         continue
                     self.exec_cmd(line)
             else:
-                raise self.InvalidCmd, 'Only MG5 banner are supported'
+                raise self.InvalidCmd('Only MG5 banner are supported')
 
             if not self._done_export:
                 self.exec_cmd('output . -f')
@@ -5451,7 +5457,7 @@ This implies that with decay chains:
                 if multipart_name not in self._multiparticles:
                     #self.do_define(line)
                     self.exec_cmd('define %s' % line, printcmd=False, precmd=True)
-            except self.InvalidCmd, why:
+            except self.InvalidCmd as why:
                 logger_stderr.warning('impossible to set default multiparticles %s because %s' %
                                         (line.split()[0],why))
                 if self.history[-1] == 'define %s' % line.strip():
@@ -5484,7 +5490,7 @@ This implies that with decay chains:
                 if container in defined_multiparticles:
                     defined_multiparticles.remove(container)
             self.history.append("define p = %s # pass to %s flavors" % \
-                                (' ' .join([`i` for i in self._multiparticles['p']]), 
+                                (' ' .join([repr(i) for i in self._multiparticles['p']]), 
                                  scheme) 
                                )
             self.history.append("define j = p")
@@ -5524,9 +5530,9 @@ This implies that with decay chains:
         # Always refresh the installer if already present
         if not os.path.isdir(pjoin(MG5DIR,'HEPTools','HEPToolsInstallers')):
             if HepToolsInstaller_web_address is None:
-                raise MadGraph5Error, "The option 'HepToolsInstaller_web_address'"+\
+                raise MadGraph5Error("The option 'HepToolsInstaller_web_address'"+\
                              " must be specified in function advanced_install"+\
-                                " if the installers are not already downloaded."
+                                " if the installers are not already downloaded.")
             if not os.path.isdir(pjoin(MG5DIR,'HEPTools')):
                 os.mkdir(pjoin(MG5DIR,'HEPTools'))
         elif not HepToolsInstaller_web_address is None:
@@ -5930,7 +5936,7 @@ MG5aMC that supports quadruple precision
                 cluster_path = data_path[index]
                 try:
                     data = urllib.urlopen(cluster_path)
-                except Exception, error:
+                except Exception as error:
                     misc.sprint(str(error), cluster_path)
                     continue
                 if data.getcode() != 200:
@@ -5939,8 +5945,8 @@ MG5aMC that supports quadruple precision
                 break
                 
             else:
-                raise MadGraph5Error, '''Impossible to connect any of us servers.
-                Please check your internet connection or retry later'''
+                raise MadGraph5Error('''Impossible to connect any of us servers.
+                Please check your internet connection or retry later''')
             for wwwline in data:
                 split = wwwline.split()
                 if len(split)!=2:
@@ -6018,7 +6024,7 @@ MG5aMC that supports quadruple precision
                 if 'xxx' in advertisements[name][0]:
                     logger.warning("Program not yet released. Please try later")
                 else:
-                    raise Exception, "Online server are corrupted. No tarball available for %s" % name
+                    raise Exception("Online server are corrupted. No tarball available for %s" % name)
                 return
             
         # Load that path
@@ -6030,7 +6036,7 @@ MG5aMC that supports quadruple precision
                                      stdout=open(os.devnull, 'w'))
 
         if returncode:
-            raise MadGraph5Error, 'Fail to download correctly the File. Stop'
+            raise MadGraph5Error('Fail to download correctly the File. Stop')
 
 
         # Check that the directory has the correct name
@@ -6038,7 +6044,7 @@ MG5aMC that supports quadruple precision
             created_name = [n for n in os.listdir(MG5DIR) if n.lower().startswith(
                                          name.lower()) and not n.endswith('gz')]
             if not created_name:
-                raise MadGraph5Error, 'The file was not loaded correctly. Stop'
+                raise MadGraph5Error('The file was not loaded correctly. Stop')
             else:
                 created_name = created_name[0]
             files.mv(pjoin(MG5DIR, created_name), pjoin(MG5DIR, name))
@@ -6158,10 +6164,10 @@ MG5aMC that supports quadruple precision
                 latest_validated_version = plugin.latest_validated_version
                 minimal_mg5amcnlo_version = plugin.minimal_mg5amcnlo_version
                 maximal_mg5amcnlo_version = plugin.maximal_mg5amcnlo_version
-            except Exception, error:
-                raise Exception, 'Plugin %s fail to be loaded. Please contact the author of the PLUGIN\n Error %s' % (name, error)
+            except Exception as error:
+                raise Exception('Plugin %s fail to be loaded. Please contact the author of the PLUGIN\n Error %s' % (name, error))
                 
-            logger.info('Plugin %s correctly interfaced. Latest official validition for MG5aMC version %s.' % (name, '.'.join(`i` for i in latest_validated_version)))
+            logger.info('Plugin %s correctly interfaced. Latest official validition for MG5aMC version %s.' % (name, '.'.join(repr(i) for i in latest_validated_version)))
             if new_interface:
                 ff = open(pjoin(MG5DIR, 'bin', '%s.py' % name) , 'w') 
                 if __debug__:
@@ -6245,8 +6251,8 @@ os.system('%s  -O -W ignore::Deprecation
             try:
                 os.system('rm -rf td')
                 os.mkdir(pjoin(MG5DIR, 'td'))
-            except Exception, error:
-                print error
+            except Exception as error:
+                print(error)
                 pass
 
             if sys.platform == "darwin":
@@ -6267,7 +6273,7 @@ os.system('%s  -O -W ignore::Deprecation
                     logger.info('Downloading TD for Linux 32 bit')
                     target = 'http://madgraph.phys.ucl.ac.be/Downloads/td'
                 misc.wget(target, 'td', cwd=pjoin(MG5DIR,'td'))
-            os.chmod(pjoin(MG5DIR,'td','td'), 0775)
+            os.chmod(pjoin(MG5DIR,'td','td'), stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IXOTH)
             self.options['td_path'] = pjoin(MG5DIR,'td')
 
             if not misc.which('gs'):
@@ -6345,7 +6351,7 @@ os.system('%s  -O -W ignore::Deprecation
             pattern = re.compile(r'''=== renamed file \'(?P<orig>[^\']*)\' => \'(?P<new>[^\']*)\'''')
             #=== renamed file 'Template/SubProcesses/addmothers.f' => 'madgraph/iolibs/template_files/addmothers.f'
             for orig, new in pattern.findall(text):
-                print 'move %s to %s' % (orig, new)
+                print('move %s to %s' % (orig, new))
                 try:
                     files.cp(pjoin(MG5DIR, orig), pjoin(MG5DIR, new), error=True)
                 except IOError:
@@ -6361,7 +6367,7 @@ os.system('%s  -O -W ignore::Deprecation
             #pattern = re.compile(r'''=== removed file \'(?P<new>[^\']*)\'''')
             #all_rm = pattern.findall(text)
             pattern=re.compile(r'''=== removed file \'(?P<new>[^\']*)\'(?=.*=== added file \'(?P=new)\')''',re.S)
-            print 'this step can take a few minuts. please be patient'
+            print('this step can take a few minuts. please be patient')
             all_rm_add = pattern.findall(text)
             #=== added file 'tests/input_files/full_sm/interactions.dat'
             for new in all_add:
@@ -6400,7 +6406,7 @@ os.system('%s  -O -W ignore::Deprecation
                         for i in range(1,len(split)):
                             path = '/'.join(split[:i])
                             if not os.path.exists(path):
-                                print 'mkdir', path
+                                print( 'mkdir', path)
                                 os.mkdir(path)
                     files.cp(old,new)
             #=== renamed file 'Template/bin/internal/run_delphes' => 'Template/Common/bin/internal/run_delphes'
@@ -6446,10 +6452,10 @@ os.system('%s  -O -W ignore::Deprecation
                     for i in range(1,len(split)+1):
                         path = '/'.join(split[:i])
                         if path and not os.path.exists(path):
-                            print 'mkdir', path
+                            print( 'mkdir', path)
                             os.mkdir(path)
                 if match[0] == 'file':
-                    print 'touch ', pjoin(MG5DIR, match[1])
+                    print( 'touch ', pjoin(MG5DIR, match[1]))
                     misc.call(['touch', pjoin(MG5DIR, match[1])])
             # add new symlink
             pattern=re.compile('''^=== link file \'(?P<new>[^\']*)\' \'(?P<old>[^\']*)\'''', re.M)
@@ -6566,7 +6572,7 @@ os.system('%s  -O -W ignore::Deprecation
             web_version = int(filetext.read().strip())
         except (TimeOutError, ValueError, IOError):
             signal.alarm(0)
-            print 'failed to connect server'
+            print( 'failed to connect server')
             if mode == 'mg5_end':
                 # wait 24h before next check
                 fsock = open(os.path.join(MG5DIR,'input','.autoupdate'),'w')
@@ -6606,7 +6612,7 @@ os.system('%s  -O -W ignore::Deprecation
                 try:
                     filetext = urllib.urlopen('http://madgraph.phys.ucl.ac.be/patch/build%s.patch' %(i+1))
                 except Exception:
-                    print 'fail to load patch to build #%s' % (i+1)
+                    print( 'fail to load patch to build #%s' % (i+1))
                     fail = i
                     break
                 need_binary = apply_patch(filetext)
@@ -6630,7 +6636,7 @@ os.system('%s  -O -W ignore::Deprecation
             logger.info('Checking current version. (type ctrl-c to bypass the check)')
             subprocess.call([os.path.join('tests','test_manager.py')],
                                                                   cwd=MG5DIR)            
-            print 'new version installed, please relaunch mg5'
+            print( 'new version installed, please relaunch mg5')
             try:
                 os.remove(pjoin(MG5DIR, 'Template','LO','Source','make_opts'))
                 shutil.copy(pjoin(MG5DIR, 'Template','LO','Source','.make_opts'),
@@ -6811,8 +6817,8 @@ in the MG5aMC option 'samurai' (instead
                 # Default: try to set parameter
                 try:
                     self.do_set("%s %s --no_save" % (key, self.options[key]), log=False)
-                except MadGraph5Error, error:
-                    print error
+                except MadGraph5Error as error:
+                    print(error)
                     logger.warning("Option %s from config file not understood" \
                                    % key)
                 else:
@@ -6937,7 +6943,7 @@ in the MG5aMC option 'samurai' (instead
                                                  options=self.options,**options)            
         else:
             os.chdir(start_cwd) #ensure to go to the initial path
-            raise self.InvalidCmd , '%s cannot be run from MG5 interface' % args[0]
+            raise self.InvalidCmd('%s cannot be run from MG5 interface' % args[0])
 
 
         ext_program.run()
@@ -7601,7 +7607,7 @@ in the MG5aMC option 'samurai' (instead
                 self._export_dir = pjoin(self._export_dir, 'Pythia8_proc_%i' %i)
                 logger.info('Create output in %s' % self._export_dir)
             elif not args[0] in ['.', '-f']:
-                raise self.InvalidCmd, 'Wrong path directory to create in local directory use \'.\''
+                raise self.InvalidCmd('Wrong path directory to create in local directory use \'.\'')
         elif not noclean and os.path.isdir(self._export_dir) and options['check']:
             if not force:
                 # Don't ask if user already specified force or noclean
@@ -8137,8 +8143,8 @@ in the MG5aMC option 'samurai' (instead
                                        (particle.get('name'), ' '.join([p.get('name') for p in mode]), value))
                         value = 0
                     elif value < 0:
-                        raise Exception, 'Partial width for %s > %s negative: %s' % \
-                                       (particle.get('name'), ' '.join([p.get('name') for p in mode]), value)
+                        raise Exception('Partial width for %s > %s negative: %s' % \
+                                       (particle.get('name'), ' '.join([p.get('name') for p in mode]), value))
                     elif 0 < value < 0.1 and particle['color'] !=1:
                         logger.warning("partial width of particle %s lower than QCD scale:%s. Set it to zero. (%s)" \
                                    % (particle.get('name'), value, decay_to))
@@ -8158,7 +8164,7 @@ in the MG5aMC option 'samurai' (instead
         # add info from decay module
         #
         
-        self.do_decay_diagram('%s %s' % (' '.join([`id` for id in particles]),
+        self.do_decay_diagram('%s %s' % (' '.join([repr(id) for id in particles]),
                                          ' '.join('--%s=%s' % (key,value)
                                                   for key,value in opts.items()
                                                   if key not in ['precision_channel'])
@@ -8287,7 +8293,7 @@ in the MG5aMC option 'samurai' (instead
             currmodel = model
 
         if not os.path.exists(pjoin(model_path, 'SMWidth')):
-            raise self.InvalidCmd, "Model %s is not valid for computing NLO width with SMWidth"%model_name
+            raise self.InvalidCmd("Model %s is not valid for computing NLO width with SMWidth"%model_name)
 
         # determine the EW scheme
         externparam = [(param.lhablock.lower(),param.name.lower()) for param \
@@ -8300,7 +8306,7 @@ in the MG5aMC option 'samurai' (instead
             # Gmu scheme
             arg2 = "2"
         else:
-            raise Exception, "Do not know the EW scheme in the model %s"%model_name
+            raise Exception("Do not know the EW scheme in the model %s"%model_name)
 
         #compile the code
         if not os.path.exists(pjoin(model_path, 'SMWidth','smwidth')):
@@ -8635,27 +8641,27 @@ class AskforCustomize(cmd.SmartQuestion)
     def do_help(self, line):
         '''help message'''
 
-        print 'This allows you to optimize your model to your needs.'
-        print 'Enter the number associate to the possible restriction/add-on'
-        print ' to change the status of this restriction/add-on.'
-        print ''
-        print 'In order to allow scripting of this function you can use the '
-        print 'function \'set\'. This function takes two argument:'
-        print 'set NAME VALUE'
-        print '   NAME is the description of the option where you remove all spaces'
-        print '   VALUE is either True or False'
-        print ' Example: For the question'
-        print '''     sm customization:
+        print('This allows you to optimize your model to your needs.')
+        print('Enter the number associate to the possible restriction/add-on')
+        print(' to change the status of this restriction/add-on.')
+        print('')
+        print('In order to allow scripting of this function you can use the ')
+        print('function \'set\'. This function takes two argument:')
+        print('set NAME VALUE')
+        print('   NAME is the description of the option where you remove all spaces')
+        print('   VALUE is either True or False')
+        print(' Example: For the question')
+        print('''     sm customization:
         1: diagonal ckm [True]
         2: c mass = 0 [True]
         3: b mass = 0 [False]
         4: tau mass = 0 [False]
         5: muon mass = 0 [True]
         6: electron mass = 0 [True]
-    Enter a number to change it's status or press enter to validate.'''
-        print ''' you can answer by'''
-        print '   set diagonalckm False'
-        print '   set taumass=0 True'
+    Enter a number to change it's status or press enter to validate.''')
+        print(''' you can answer by''')
+        print('   set diagonalckm False')
+        print('   set taumass=0 True')
 
     def cmdloop(self, intro=None):
         cmd.SmartQuestion.cmdloop(self, intro)
diff -rupN MadGraph_pristine/madgraph/interface/master_interface.py ../contrib/MadGraph/madgraph/interface/master_interface.py
--- MadGraph_pristine/madgraph/interface/master_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/master_interface.py	2020-10-29 20:31:26.822384713 +1100
@@ -153,7 +153,7 @@ class Switcher(object):
                     correct = False                    
                     
         if not correct:
-            raise Exception, 'The Cmd interface has dangerous features. Please see previous warnings and correct those.' 
+            raise Exception('The Cmd interface has dangerous features. Please see previous warnings and correct those.' )
 
     
 
@@ -593,7 +593,7 @@ class MasterCmd(Switcher, LoopCmd.LoopIn
             self.cmd= self.interface_names[main][1]
             self.current_interface=main
         else:
-            raise MadGraph5Error, 'Type of interface not valid: %s' % main  
+            raise MadGraph5Error('Type of interface not valid: %s' % main  )
         self.cmd.__init__(self, *args, **opt)     
         self.current_interface = main  
     
@@ -619,14 +619,14 @@ class MasterCmd(Switcher, LoopCmd.LoopIn
         if old_cmd == name:
             return
         elif not allow_switch:
-            raise InvalidCmd, "Command not compatible with previous command: Can not combine LO/NLO feature."
+            raise InvalidCmd("Command not compatible with previous command: Can not combine LO/NLO feature.")
             
         if name in self.interface_names.keys():
             self.prompt= self.interface_names[name][0]+'>'
             self.cmd= self.interface_names[name][1]
             self.current_interface=name
         else:
-            raise MadGraph5Error, 'Type of interface not valid: %s' % name  
+            raise MadGraph5Error('Type of interface not valid: %s' % name  )
         
         if self.interface_names[old_cmd][0]!=self.interface_names[name][0]:
             logger.info("Switching from interface %s to %s"\
@@ -662,7 +662,7 @@ class MasterCmdWeb(MGcmd.MadGraphCmdWeb,
         elif name == 'Loop':
             self.cmd = LoopCmd.LoopInterfaceWeb
         else:
-            raise MadGraph5Error, 'Type of interface not valid'  
+            raise MadGraph5Error('Type of interface not valid'  )
         
         if __debug__:
             self.debug_link_to_command() 
diff -rupN MadGraph_pristine/madgraph/iolibs/export_cpp.py ../contrib/MadGraph/madgraph/iolibs/export_cpp.py
--- MadGraph_pristine/madgraph/iolibs/export_cpp.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/export_cpp.py	2020-10-29 20:31:26.822384713 +1100
@@ -92,8 +92,8 @@ class OneProcessExporterCPP(object):
         elif isinstance(matrix_elements, helas_objects.HelasMatrixElementList):
             self.matrix_elements = matrix_elements
         else:
-            raise base_objects.PhysicsObject.PhysicsObjectError,\
-                  "Wrong object type for matrix_elements: %s" % type(matrix_elements)
+            raise base_objects.PhysicsObject.PhysicsObjectError(\
+                  "Wrong object type for matrix_elements: %s" % type(matrix_elements))
 
         if not self.matrix_elements:
             raise MadGraph5Error("No matrix elements to export")
@@ -127,8 +127,8 @@ class OneProcessExporterCPP(object):
         self.helas_call_writer = cpp_helas_call_writer
 
         if not isinstance(self.helas_call_writer, helas_call_writers.CPPUFOHelasCallWriter):
-            raise self.ProcessExporterCPPError, \
-                "helas_call_writer not CPPUFOHelasCallWriter"
+            raise self.ProcessExporterCPPError( \
+                "helas_call_writer not CPPUFOHelasCallWriter")
 
         self.nexternal, self.ninitial = \
                         self.matrix_elements[0].get_nexternal_ninitial()
@@ -944,7 +944,7 @@ class OneProcessExporterMatchbox(OneProc
             for match in all_matches:
                 ctype, arg = match[0], [m.strip() for m in match[1].split(',')]
                 if ctype not in ['T', 'Tr']:
-                    raise self.ProcessExporterCPPError, 'Color Structure not handle by Matchbox'
+                    raise self.ProcessExporterCPPError( 'Color Structure not handle by Matchbox')
                 tmp_color.append(arg)
             #compute the maximal size of the vector
             nb_index = sum(len(o) for o in tmp_color)
@@ -994,9 +994,9 @@ class OneProcessExporterPythia8(OneProce
         for me in self.matrix_elements:
             if me.get_nexternal_ninitial() not in [(3,2),(4,2),(5,2)]:
                 nex,nin = me.get_nexternal_ninitial()
-                raise InvalidCmd,\
+                raise InvalidCmd(\
                       "Pythia 8 can only handle 2->1,2,3 processes, not %d->%d" % \
-                      (nin,nex-nin)
+                      (nin,nex-nin))
             
         self.process_class = self.process_name
         
@@ -1371,8 +1371,8 @@ class OneProcessExporterPythia8(OneProce
 
             if final_id_list and final_mirror_id_list or \
                not final_id_list and not final_mirror_id_list:
-                raise self.ProcessExporterCPPError,\
-                      "Missing processes, or both process and mirror process"
+                raise self.ProcessExporterCPPError(\
+                      "Missing processes, or both process and mirror process")
 
 
             ncombs = len(final_id_list)+len(final_mirror_id_list)
@@ -1391,9 +1391,9 @@ class OneProcessExporterPythia8(OneProce
                                            (i, l) in items if l > 0]).\
                                  replace('*1', ''))
                 if any([l>1 for (i, l) in items]):
-                    raise self.ProcessExporterCPPError,\
+                    raise self.ProcessExporterCPPError(\
                           "More than one process with identical " + \
-                          "external particles is not supported"
+                          "external particles is not supported")
 
             for final_ids in final_mirror_id_list:
                 items = [(i, len([ p for p in me.get_mirror_processes() \
@@ -1405,9 +1405,9 @@ class OneProcessExporterPythia8(OneProce
                                            (i, l) in items if l > 0]).\
                                  replace('*1', ''))
                 if any([l>1 for (i, l) in items]):
-                    raise self.ProcessExporterCPPError,\
+                    raise self.ProcessExporterCPPError(\
                           "More than one process with identical " + \
-                          "external particles is not supported"
+                          "external particles is not supported")
 
             if final_id_list:
                 res_lines.append("int flavors[%d][%d] = {%s};" % \
diff -rupN MadGraph_pristine/madgraph/iolibs/files.py ../contrib/MadGraph/madgraph/iolibs/files.py
--- MadGraph_pristine/madgraph/iolibs/files.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/files.py	2020-10-29 20:31:26.822384713 +1100
@@ -36,11 +36,11 @@ def read_from_file(filename, myfunct, *a
             ret_value = myfunct(sock, *args)
         finally:
             sock.close()
-    except IOError, (errno, strerror):
+    except IOError as e:
         if opt.has_key('print_error'):
             if not opt['print_error']:
                 return None
-        logger.error("I/O error on file %s (%s): %s" % (filename,errno, strerror))
+        logger.error("I/O error on file %s (%s): %s" % (filename,e.errno, e.strerror))
         return None
 
     return ret_value
@@ -60,9 +60,9 @@ def write_to_file(filename, myfunct, *ar
             ret_value = myfunct(sock, *args)
         finally:
             sock.close()
-    except IOError, (errno, strerror):
+    except IOError as e:
         if 'log' not in opts or opts['log']:
-            logger.error("I/O error (%s): %s" % (errno, strerror))
+            logger.error("I/O error (%s): %s" % (e.errno, e.strerror))
         return None
 
     return ret_value
@@ -82,8 +82,8 @@ def append_to_file(filename, myfunct, *a
             ret_value = myfunct(sock, *args)
         finally:
             sock.close()
-    except IOError, (errno, strerror):
-        logger.error("I/O error (%s): %s" % (errno, strerror))
+    except IOError as e:
+        logger.error("I/O error (%s): %s" % (e.errno, e.strerror))
         return None
 
     return ret_value
@@ -136,13 +136,13 @@ def cp(path1, path2, log=True, error=Fal
     path2 = format_path(path2)
     try:
         shutil.copy(path1, path2)
-    except IOError, why:
+    except IOError as why:
         import madgraph.various.misc as misc
         try: 
             if os.path.exists(path2):
                 path2 = os.path.join(path2, os.path.split(path1)[1])
             shutil.copytree(path1, path2)
-        except IOError, why:
+        except IOError as why:
             if error:
                 raise
             if log:
@@ -228,7 +228,7 @@ def ln(file_pos, starting_dir='.', name=
 
     try:
         os.symlink(target, os.path.join(starting_dir, name))
-    except Exception, error:
+    except Exception as error:
         if log:
             logger.debug(error)
             logger.warning('Could not link %s at position: %s' % (file_pos, \
diff -rupN MadGraph_pristine/madgraph/iolibs/file_writers.py ../contrib/MadGraph/madgraph/iolibs/file_writers.py
--- MadGraph_pristine/madgraph/iolibs/file_writers.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/file_writers.py	2020-10-29 20:31:26.826384691 +1100
@@ -19,6 +19,8 @@ Fortran, C++, etc."""
 
 import re
 import collections
+from io import IOBase
+
 try:
     import madgraph
 except ImportError:
@@ -26,7 +28,7 @@ except ImportError:
 else:
     import madgraph.various.misc as misc
 
-class FileWriter(file):
+class FileWriter(IOBase):
     """Generic Writer class. All writers should inherit from this class."""
 
     supported_preprocessor_commands = ['if']
@@ -50,7 +52,7 @@ class FileWriter(file):
     def __init__(self, name, opt = 'w'):
         """Initialize file to write to"""
 
-        return file.__init__(self, name, opt)
+        return IOBase.__init__(self, name, opt)
 
     def write_line(self, line):
         """Write a line with proper indent and splitting of long lines
@@ -148,8 +150,8 @@ class FileWriter(file):
             if preproc_command is None:
                 preproc_endif = self.preprocessor_endif_re.match(line[2:])
                 if len(if_stack)==0 or preproc_endif is None:
-                    raise self.FilePreProcessingError, 'Incorrect '+\
-                             'preprocessing command %s at line %d.'%(line,i)
+                    raise self.FilePreProcessingError('Incorrect '+\
+                             'preprocessing command %s at line %d.'%(line,i))
                 if preproc_endif.group('new_block') is None:
                     if_stack.pop()
                 elif preproc_endif.group('endif')=='else':
@@ -158,15 +160,15 @@ class FileWriter(file):
             elif preproc_command.group('command')=='if':
                 try:
                     if_stack.append(eval(preproc_command.group('body'))==True)
-                except Exception, e:
-                    raise self.FilePreProcessingError, 'Could not evaluate'+\
+                except Exception as e:
+                    raise self.FilePreProcessingError('Could not evaluate'+\
                       "python expression '%s' given the context %s provided."%\
                             (preproc_command.group('body'),str(context))+\
-                                           "\nLine %d of file %s."%(i,self.name)
+                                           "\nLine %d of file %s."%(i,self.name))
         
         if len(if_stack)>0:
-            raise self.FilePreProcessingError, 'Some conditional statements are'+\
-                                                     ' not properly terminated.'
+            raise self.FilePreProcessingError('Some conditional statements are'+\
+                                                     ' not properly terminated.')
         return res
 
 #===============================================================================
@@ -441,7 +443,7 @@ class FortranWriter(FileWriter):
                 else:
                     if not line.endswith('\n'):
                         line = '%s\n' % line
-                    file.writelines(self, line)
+                    IOBase.writelines(self, line)
             else:
                 removed.append(line)
                 
@@ -967,13 +969,13 @@ class PythonWriter(FileWriter):
     
     def write_comments(self, text):
         text = '#%s\n' % text.replace('\n','\n#')
-        file.write(self, text)
+        IOBase.write(self, text)
         
 class MakefileWriter(FileWriter):
     
     def write_comments(self, text):
         text = '#%s\n' % text.replace('\n','\n#')
-        file.write(self, text)
+        IOBase.write(self, text)
         
     def writelines(self, lines):
         """Extends the regular file.writeline() function to write out
diff -rupN MadGraph_pristine/madgraph/iolibs/helas_call_writers.py ../contrib/MadGraph/madgraph/iolibs/helas_call_writers.py
--- MadGraph_pristine/madgraph/iolibs/helas_call_writers.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/helas_call_writers.py	2020-10-29 20:31:26.826384691 +1100
@@ -68,16 +68,16 @@ class HelasCallWriter(base_objects.Physi
 
         if name == 'model':
             if not isinstance(value, base_objects.Model):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a model" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a model" % type(value))
 
         if name == 'wavefunctions':
             # Should be a dictionary of functions returning strings, 
             # with keys (spins, flow state)
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dictionary for wavefunction" % \
-                                                                str(value)
+                                                                str(value))
 
             for key in value.keys():
                 self.add_wavefunction(key, value[key])
@@ -86,9 +86,9 @@ class HelasCallWriter(base_objects.Physi
             # Should be a dictionary of functions returning strings, 
             # with keys (spins, flow state)
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dictionary for amplitude" % \
-                                                                str(value)
+                                                                str(value))
 
             for key in value.keys():
                 self.add_amplitude(key, value[key])
@@ -286,7 +286,7 @@ class HelasCallWriter(base_objects.Physi
 
         try:
             call = self["amplitudes"][amplitude.get_call_key()]
-        except KeyError, error:
+        except KeyError as error:
             return ""
         else:
             return call(amplitude)
@@ -594,9 +594,9 @@ class FortranHelasCallWriter(HelasCallWr
         # If function not already existing, try to generate it.
 
         if len(wavefunction.get('mothers')) > 3:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                   """Automatic generation of Fortran wavefunctions not
-                  implemented for > 3 mothers"""
+                  implemented for > 3 mothers""")
 
         self.generate_helas_call(wavefunction)
         return super(FortranHelasCallWriter, self).get_wavefunction_call(\
@@ -615,9 +615,9 @@ class FortranHelasCallWriter(HelasCallWr
         # If function not already existing, try to generate it.
 
         if len(amplitude.get('mothers')) > 4:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                   """Automatic generation of Fortran amplitudes not
-                  implemented for > 4 mothers"""
+                  implemented for > 4 mothers""")
 
         self.generate_helas_call(amplitude)
         return super(FortranHelasCallWriter, self).get_amplitude_call(amplitude)
@@ -645,8 +645,8 @@ class FortranHelasCallWriter(HelasCallWr
         
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "get_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "get_helas_call must be called with wavefunction or amplitude")
 
         call = "CALL "
 
@@ -1085,8 +1085,8 @@ class FortranUFOHelasCallWriter(UFOHelas
 
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "generate_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "generate_helas_call must be called with wavefunction or amplitude")
         
         call = "CALL "
 
@@ -1255,8 +1255,8 @@ class FortranUFOHelasCallWriter(UFOHelas
                 elif lcutpart.get('spin')==2 or lcutpart.get('spin')==3:
                     res.append("DO I=1,4")
                 else:
-                    raise self.PhysicsObjectError, \
-                  "The L-cut particle type is not supported"
+                    raise self.PhysicsObjectError( \
+                  "The L-cut particle type is not supported")
                 # Temporarily relabel the 'me_id' attribute of the external wfs
                 # in this wavefunction's mothers so to have them matching the
                 # convention in the loop helas calls.
@@ -1495,8 +1495,8 @@ class FortranUFOHelasCallWriterOptimized
             
         if isinstance(argument, helas_objects.HelasAmplitude) and \
                                                   argument.get('type')=='loop':
-           raise MadGraph5Error, 'There should not be any helas call '+\
-                                'associated with helas amplitudes of type loop.'
+           raise MadGraph5Error( 'There should not be any helas call '+\
+                                'associated with helas amplitudes of type loop.')
 
         # Check if we need to append a charge conjugation flag
         l = [str(l) for l in argument.get('lorentz')]
@@ -1612,8 +1612,8 @@ class CPPUFOHelasCallWriter(UFOHelasCall
 
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "get_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "get_helas_call must be called with wavefunction or amplitude")
         
         call = ""
 
@@ -1742,8 +1742,8 @@ class PythonUFOHelasCallWriter(UFOHelasC
                                    and wf.get('spin') == 3 \
                                    and wf.get('mass').lower() == 'zero']
                 if not gauge_check_wfs:
-                    raise HelasWriterError, \
-                          'no massless spin one particle for gauge check'
+                    raise HelasWriterError( \
+                          'no massless spin one particle for gauge check')
                 gauge_check_wf = wfs.pop(wfs.index(gauge_check_wfs[0]))
                 res.append(self.generate_helas_call(gauge_check_wf, True)(\
                                                     gauge_check_wf))
@@ -1764,8 +1764,8 @@ class PythonUFOHelasCallWriter(UFOHelasC
 
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "get_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "get_helas_call must be called with wavefunction or amplitude")
         
         call_function = None
 
diff -rupN MadGraph_pristine/madgraph/iolibs/template_files/__init__.py ../contrib/MadGraph/madgraph/iolibs/template_files/__init__.py
--- MadGraph_pristine/madgraph/iolibs/template_files/__init__.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/template_files/__init__.py	2020-10-29 20:35:37.145139635 +1100
@@ -1,2 +1,2 @@
-import mg4_proc_card
+import .mg4_proc_card
 
diff -rupN MadGraph_pristine/madgraph/loop/loop_base_objects.py ../contrib/MadGraph/madgraph/loop/loop_base_objects.py
--- MadGraph_pristine/madgraph/loop/loop_base_objects.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_base_objects.py	2020-10-29 20:31:26.826384691 +1100
@@ -88,48 +88,48 @@ class LoopDiagram(base_objects.Diagram):
 
         if name == 'tag':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid tag" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid tag" % str(value))
             else:
                 for item in value:
                     if (len(item)!=3 or \
                       not isinstance(item[0],base_objects.Leg) or \
                       not isinstance(item[1],list)) or \
                       not isinstance(item[2],base_objects.Vertex):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid tag" % str(value)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid tag" % str(value))
 
         if name == 'canonical_tag':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid tag" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid tag" % str(value))
             else:
                 for item in value:
                     if (len(item)!=3 or not isinstance(item[0],int) or \
                       not isinstance(item[1],list)) or \
                       not isinstance(item[2],int):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid canonical_tag" % str(value)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid canonical_tag" % str(value))
 
         if name == 'CT_vertices':
             if not isinstance(value, base_objects.VertexList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid VertexList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid VertexList object" % str(value))
 
         if name == 'type':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
 
         if name == 'multiplier':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
 
         if name == 'contracted_diagram':
             if not isinstance(value, base_objects.Diagram):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Diagram." % str(value)                            
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid Diagram." % str(value))                            
 
         else:
             super(LoopDiagram, self).filter(name, value)
@@ -206,9 +206,9 @@ class LoopDiagram(base_objects.Diagram):
         # Without the tagging information we will have to reconstruct the
         # contracted diagrams with the unordered vertices
         if len(self.get('vertices'))==0:
-            raise MadGraph5Error, "Function get_contracted_loop_diagram()"+\
+            raise MadGraph5Error("Function get_contracted_loop_diagram()"+\
                 "called for the first time without specifying struct_rep "+\
-                                            "for a diagram already tagged."
+                                            "for a diagram already tagged.")
                                 
         # The leg below will be the outgoing one 
         contracted_vertex_last_loop_leg = None
@@ -635,8 +635,8 @@ class LoopDiagram(base_objects.Diagram):
             start=start_in.get('number')
             end=end_in.get('number')
         else:
-            raise MadGraph5Error, "In the diagram tag function, 'start' and "+\
-                " 'end' must be either integers or Leg objects." 
+            raise MadGraph5Error("In the diagram tag function, 'start' and "+\
+                " 'end' must be either integers or Leg objects." )
         
         if self.process_next_loop_leg(struct_rep,-1,-1,start,end,\
                                           loopVertexList, model, external_legs):
@@ -657,8 +657,8 @@ class LoopDiagram(base_objects.Diagram):
                 canonical_tag=self.choose_optimal_lcut(self['tag'],struct_rep, 
                                                            model, external_legs)
             else:
-                raise MadGraph5Error, 'The cutting method %s is not implemented.'\
-                                                            %self.cutting_method
+                raise MadGraph5Error('The cutting method %s is not implemented.'\
+                                                            %self.cutting_method)
             # The tag of the diagram is now updated with the canonical tag
             self['tag']=canonical_tag
             # We assign here the loopVertexList to the list of vertices 
@@ -674,8 +674,8 @@ class LoopDiagram(base_objects.Diagram):
             self['canonical_tag']=[[t[0]['id'],t[1],t[2]] for t in canonical_tag]
             return True
         else:
-            raise self.PhysicsObjectError, \
-                  "Loop diagram tagging failed."
+            raise self.PhysicsObjectError( \
+                  "Loop diagram tagging failed.")
             return False
 
 
@@ -717,9 +717,9 @@ class LoopDiagram(base_objects.Diagram):
                     # Now we can add the corresponding vertex
                     return base_objects.Vertex({'legs':myleglist,'id':vertID})
         else:
-            raise cls.PhysicsObjectError, \
+            raise cls.PhysicsObjectError( \
             "An interaction from the original L-cut diagram could"+\
-            " not be found when reconstructing the loop vertices."
+            " not be found when reconstructing the loop vertices.")
 
     def process_next_loop_leg(self, structRep, fromVert, fromPos, currLeg, \
                                   endLeg, loopVertexList, model, external_legs):
@@ -748,8 +748,8 @@ class LoopDiagram(base_objects.Diagram):
                                self['vertices'][i].get('legs')[k],FDStruct)
 
             if not canonical:
-                raise self.PhysicsObjectError, \
-                      "Failed to reconstruct a FDStructure."
+                raise self.PhysicsObjectError( \
+                      "Failed to reconstruct a FDStructure.")
             
             # The branch was directly an external leg, so it the canonical
             # repr of this struct is simply ((legID),0).
@@ -758,8 +758,8 @@ class LoopDiagram(base_objects.Diagram):
             elif isinstance(canonical,tuple):
                 FDStruct.set('canonical',canonical)
             else:                                      
-                raise self.PhysicsObjectError, \
-                "Non-proper behavior of the construct_FDStructure function"
+                raise self.PhysicsObjectError( \
+                "Non-proper behavior of the construct_FDStructure function")
             
             # First check if this structure exists in the dictionary of the
             # structures already obtained in the diagrams for this process
@@ -858,8 +858,8 @@ class LoopDiagram(base_objects.Diagram):
                                 nextLoopLeg=self['vertices'][i].get('legs')[k]
                                 legPos=pos
                             else:
-                                raise self.PhysicsObjectError, \
-                                  " An interaction has more than two loop legs."
+                                raise self.PhysicsObjectError( \
+                                  " An interaction has more than two loop legs.")
                         else:
                             process_loop_interaction(i,j,k,pos)
                     # Now that we have found loop leg curr_leg, we can get out 
@@ -1135,8 +1135,8 @@ class LoopDiagram(base_objects.Diagram):
                 branch=self.construct_FDStructure(i, legPos, \
                               self['vertices'][vertID].get('legs')[k], FDStruct)
                 if not branch:
-                    raise self.PhysicsObjectError, \
-                          "Failed to reconstruct a FDStructure."
+                    raise self.PhysicsObjectError( \
+                          "Failed to reconstruct a FDStructure.")
                 # That means that this branch was an external leg. 
                 if isinstance(branch,int):
                     parentBuffer[0].append(branch)
@@ -1146,8 +1146,8 @@ class LoopDiagram(base_objects.Diagram):
                     parentBuffer[0]+=list(branch[0][0])
                     vertBuffer.append(branch)
                 else:
-                    raise self.PhysicsObjectError, \
-                    "Non-proper behavior of the construct_FDStructure function"
+                    raise self.PhysicsObjectError( \
+                    "Non-proper behavior of the construct_FDStructure function")
             return legPos
 
         # == Beginning of the code ==
@@ -1193,8 +1193,8 @@ class LoopDiagram(base_objects.Diagram):
                 FDStruct.get('external_legs').append(copy.copy(currLeg))
                 return currLeg.get('number')
             else:
-                raise self.PhysicsObjectError, \
-                                  " A structure is malformed."
+                raise self.PhysicsObjectError( \
+                                  " A structure is malformed.")
         else:
             # In this case a vertex with currLeg has been found and we must
             # return the list of tuple described above. First let's sort the 
@@ -1360,23 +1360,23 @@ class LoopUVCTDiagram(base_objects.Diagr
 
         if name == 'UVCT_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             else:
                 for elem in value:
                     if not isinstance(elem, str) and not isinstance(elem, int):
-                        raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                        raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
         
         if name == 'UVCT_orders':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))
 
         if name == 'type':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
         
         else:
             super(LoopUVCTDiagram, self).filter(name, value)
@@ -1474,14 +1474,14 @@ class LoopModel(base_objects.Model):
 
         if name == 'perturbation_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a list" % \
-                                                            type(value)
+                                                            type(value))
             for order in value:
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                         "Object of type %s is not a string" % \
-                                                            type(order)
+                                                            type(order))
         else:
             super(LoopModel,self).filter(name,value)
         
@@ -1534,9 +1534,9 @@ class DGLoopLeg(base_objects.Leg):
 
         if name == 'depth':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a int" % \
-                                                            type(value)
+                                                            type(value))
         else:
             super(DGLoopLeg,self).filter(name,value)
         
@@ -1587,33 +1587,33 @@ class FDStructure(base_objects.PhysicsOb
 
         if name == 'vertices':
             if not isinstance(value, base_objects.VertexList):
-                raise self.PhysicsObjectError, \
-        "%s is not a valid VertexList object" % str(value)
+                raise self.PhysicsObjectError( \
+        "%s is not a valid VertexList object" % str(value))
 
         if name == 'id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-        "id %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+        "id %s is not an integer" % repr(value))
 
         if name == 'weight':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-        "weight %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+        "weight %s is not an integer" % repr(value))
 
         if name == 'external_legs':
             if not isinstance(value, base_objects.LegList):
-                raise self.PhysicsObjectError, \
-        "external_legs %s is not a valid Leg List" % str(value)
+                raise self.PhysicsObjectError( \
+        "external_legs %s is not a valid Leg List" % str(value))
 
         if name == 'binding_leg':
             if not isinstance(value, base_objects.Leg):
-                raise self.PhysicsObjectError, \
-        "binding_leg %s is not a valid Leg" % str(value)
+                raise self.PhysicsObjectError( \
+        "binding_leg %s is not a valid Leg" % str(value))
 
         if name == 'canonical':
             if not isinstance(value, tuple):
-                raise self.PhysicsObjectError, \
-        "canonical %s is not a valid tuple" % str(value)
+                raise self.PhysicsObjectError( \
+        "canonical %s is not a valid tuple" % str(value))
 
         return True
     
@@ -1693,9 +1693,9 @@ class FDStructure(base_objects.PhysicsOb
         ref_dict_to1 = model.get('ref_dict_to1')
 
         if not tag:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
         "The canonical tag of the FD structure is not set yet, so that the "+\
-        "reconstruction of the vertices cannot be performed."
+        "reconstruction of the vertices cannot be performed.")
 
         # Create a local copy of the external legs
         leglist = copy.deepcopy(external_legs)
@@ -1783,9 +1783,9 @@ class FDStructure(base_objects.PhysicsOb
                 tag.pop(0)
 
             else:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
         "The canonical tag of the FD structure is corrupted because one "+\
-        "interaction does not exist."
+        "interaction does not exist.")
 
 #===============================================================================
 # FDStructureList
@@ -1814,9 +1814,9 @@ class FDStructureList(base_objects.Physi
                     return FDStruct
             return None
         else:
-            raise self.PhysicsObjectListError, \
+            raise self.PhysicsObjectListError( \
               "The ID %s specified for get_struct is not an integer or tuple"%\
-                                                                    repr(object)
+                                                                    repr(object))
 
     def nice_string(self):
         """Returns a nicely formatted string"""
diff -rupN MadGraph_pristine/madgraph/loop/loop_color_amp.py ../contrib/MadGraph/madgraph/loop/loop_color_amp.py
--- MadGraph_pristine/madgraph/loop/loop_color_amp.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_color_amp.py	2020-10-29 20:31:26.826384691 +1100
@@ -67,8 +67,8 @@ class LoopColorBasis(color_amp.ColorBasi
               [color_algebra.Tr(lcut_numbers[1],lcut_numbers[0])],
               fractions.Fraction(2, 1))
         else:
-            raise color_amp.ColorBasis.ColorBasisError, \
-        "L-cut particle has an unsupported color representation %s" % lcut_charge
+            raise color_amp.ColorBasis.ColorBasisError( \
+        "L-cut particle has an unsupported color representation %s" % lcut_charge)
 
         # Append it to all color strings for this diagram.
         for CS in colorize_dict.values():
@@ -110,8 +110,8 @@ class LoopColorBasis(color_amp.ColorBasi
         list_color_dict = []
         
         if not isinstance(amplitude,loop_diagram_generation.LoopAmplitude):
-            raise color_amp.ColorBasis.ColorBasisError, \
-              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude'
+            raise color_amp.ColorBasis.ColorBasisError( \
+              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude')
         for diagram in amplitude.get('loop_diagrams'):
 
             colorize_dict = self.colorize(diagram,
@@ -147,8 +147,8 @@ class LoopColorBasis(color_amp.ColorBasi
         list_color_dict = []
 
         if not isinstance(amplitude,loop_diagram_generation.LoopAmplitude):
-            raise color_amp.ColorBasis.ColorBasisError, \
-              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude'
+            raise color_amp.ColorBasis.ColorBasisError( \
+              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude')
 
         for diagram in amplitude.get('born_diagrams'):
             colorize_dict = self.colorize(diagram,
diff -rupN MadGraph_pristine/madgraph/loop/loop_diagram_generation.py ../contrib/MadGraph/madgraph/loop/loop_diagram_generation.py
--- MadGraph_pristine/madgraph/loop/loop_diagram_generation.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_diagram_generation.py	2020-10-29 20:31:26.826384691 +1100
@@ -104,37 +104,37 @@ class LoopAmplitude(diagram_generation.A
 
         if name == 'diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DiagramList" % str(value))
             for diag in value:
                 if not isinstance(diag,loop_base_objects.LoopDiagram) and \
                    not isinstance(diag,loop_base_objects.LoopUVCTDiagram):
-                    raise self.PhysicsObjectError, \
-                        "%s contains a diagram which is not an NLODiagrams." % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s contains a diagram which is not an NLODiagrams." % str(value))
         if name == 'born_diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DiagramList" % str(value))
             for diag in value:
                 if not isinstance(diag,loop_base_objects.LoopDiagram):
-                    raise self.PhysicsObjectError, \
-                        "%s contains a diagram which is not an NLODiagrams." % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s contains a diagram which is not an NLODiagrams." % str(value))
         if name == 'loop_diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DiagramList" % str(value))
             for diag in value:
                 if not isinstance(diag,loop_base_objects.LoopDiagram):
-                    raise self.PhysicsObjectError, \
-                        "%s contains a diagram which is not an NLODiagrams." % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s contains a diagram which is not an NLODiagrams." % str(value))
         if name == 'has_born':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
         if name == 'structure_repository':
             if not isinstance(value, loop_base_objects.FDStructureList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
 
         else:
             super(LoopAmplitude, self).filter(name, value)
@@ -329,8 +329,8 @@ class LoopAmplitude(diagram_generation.A
         n_discarded = 0
         for diag in self['loop_diagrams']:
             if diag.get('tag')==[]:
-                raise MadGraph5Error, "The loop diagrams should have been tagged"+\
-                  " before going through the Furry filter."
+                raise MadGraph5Error("The loop diagrams should have been tagged"+\
+                  " before going through the Furry filter.")
             
             loop_line_pdgs = diag.get_loop_lines_pdgs()
             attached_pdgs   = diag.get_pdgs_attached_to_loop(structs)
@@ -402,8 +402,8 @@ class LoopAmplitude(diagram_generation.A
         i=0
         for diag in self['loop_diagrams']:
             if diag.get('tag')==[]:
-                raise MadGraph5Error, "Before using the user_filter, please "+\
-                       "make sure that the loop diagrams have been tagged first."
+                raise MadGraph5Error("Before using the user_filter, please "+\
+                       "make sure that the loop diagrams have been tagged first.")
             valid_diag = True
             i=i+1
     
diff -rupN MadGraph_pristine/madgraph/loop/loop_helas_objects.py ../contrib/MadGraph/madgraph/loop/loop_helas_objects.py
--- MadGraph_pristine/madgraph/loop/loop_helas_objects.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_helas_objects.py	2020-10-29 20:31:26.826384691 +1100
@@ -79,22 +79,22 @@ class LoopHelasUVCTAmplitude(helas_objec
 
         if name=='UVCT_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list for UVCT_couplings" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list for UVCT_couplings" % str(value))
             for id in value:
                 if not isinstance(id, str) and not isinstance(id, int):
-                    raise self.PhysicsObjectError, \
-                      "%s is not a valid string or integer for UVCT_couplings" % str(value)
+                    raise self.PhysicsObjectError( \
+                      "%s is not a valid string or integer for UVCT_couplings" % str(value))
                       
         if name == 'UVCT_orders':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))
 
         if name == 'type':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
 
         else:
             return super(LoopHelasUVCTAmplitude,self).filter(name, value)
@@ -279,22 +279,22 @@ class LoopHelasAmplitude(helas_objects.H
 
         if name=='wavefunctions':
             if not isinstance(value, helas_objects.HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list of HelasWaveFunctions" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list of HelasWaveFunctions" % str(value))
             for wf in value:
                 if not wf['is_loop']:
-                    raise self.PhysicsObjectError, \
-                      "Wavefunctions from a LoopHelasAmplitude must be from a loop."
+                    raise self.PhysicsObjectError( \
+                      "Wavefunctions from a LoopHelasAmplitude must be from a loop.")
         
         elif name=='amplitudes':
             if not isinstance(value, helas_objects.HelasAmplitudeList):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list of HelasAmplitudes" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list of HelasAmplitudes" % str(value))
 
         elif name in ['type','loop_group_id','multiplier','loopsymmetryfactor']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid integer for the attribute '%s'" %(str(value),name)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid integer for the attribute '%s'" %(str(value),name))
 
         else:
             return super(LoopHelasAmplitude,self).filter(name, value)
@@ -332,9 +332,9 @@ class LoopHelasAmplitude(helas_objects.H
         final_lwf=[lwf for lwf in self.get('amplitudes')[0].get('mothers') if \
                    lwf.get('mothers')]
         if len(final_lwf)!=1:
-            raise MadGraph5Error, 'The helas amplitude building the helas loop'+\
+            raise MadGraph5Error( 'The helas amplitude building the helas loop'+\
                 ' amplitude should be made of exactly one loop wavefunctions'+\
-                ' with mothers.'
+                ' with mothers.')
         return final_lwf[0]
 
     def get_base_diagram(self, wf_dict, vx_list = [], optimization = 1):
@@ -628,19 +628,19 @@ class LoopHelasMatrixElement(helas_objec
         
         if name=='born_color_basis' or name=='loop_color_basis':
             if not isinstance(value,color_amp.ColorBasis):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid color basis" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid color basis" % str(value))
         elif name=='loop_groups':
             if not isinstance(value,list):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list"%str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list"%str(value))
             for (dkey, dvalue) in value:
                 if not isinstance(dvalue,helas_objects.HelasAmplitudeList):
-                    raise self.PhysicsObjectError, \
-                      "%s is not a valid HelasAmplitudeList."%str(dvalue)
+                    raise self.PhysicsObjectError( \
+                      "%s is not a valid HelasAmplitudeList."%str(dvalue))
                 if not isinstance(dkey,tuple):
-                    raise self.PhysicsObjectError, \
-                      "%s is not a valid tuple."%str(dkey)
+                    raise self.PhysicsObjectError( \
+                      "%s is not a valid tuple."%str(dkey))
         else:
             return super(LoopHelasMatrixElement,self).filter(name, value)
 
@@ -1465,9 +1465,9 @@ class LoopHelasMatrixElement(helas_objec
                 for last_loop_wf, color_list in zip(last_loop_wfs,color_lists):
                     # Now generate HelasAmplitudes from the last vertex.
                     if lastvx.get('id')!=-1:
-                        raise self.PhysicsObjectError, \
+                        raise self.PhysicsObjectError( \
                           "The amplitude vertex of a loop diagram must be a "+\
-                          "two point vertex with id=-1" 
+                          "two point vertex with id=-1") 
                     # skip the boson and Dirac fermions
                     # adjust the fermion flow of external majorana loop wfs
                     if other_external_loop_wf.is_majorana():
@@ -1543,21 +1543,21 @@ class LoopHelasMatrixElement(helas_objec
                 if lcut_wf1.is_boson():
                     if lcut_wf1.get('state')!='final' or\
                             lcut_wf2.get('state')!='final':
-                        raise MadGraph5Error,\
-                            "Inconsistent flow in L-cut bosons."
+                        raise MadGraph5Error(\
+                            "Inconsistent flow in L-cut bosons.")
                 elif not lcut_wf1.is_majorana():
                     for lcut_wf in [lcut_wf1,lcut_wf2]:
                         if not ((lcut_wf.get('is_part') and \
                                      lcut_wf.get('state')=='outgoing') or\
                                     (not lcut_wf.get('is_part') and\
                                          lcut_wf.get('state')=='incoming')):
-                            raise MadGraph5Error,\
-                                "Inconsistent flow in L-cut Dirac fermions."
+                            raise MadGraph5Error(\
+                                "Inconsistent flow in L-cut Dirac fermions.")
                 elif lcut_wf1.is_majorana():
                     if (lcut_wf1.get('state'), lcut_wf2.get('state')) not in \
                             [('incoming','outgoing'),('outgoing','incoming')]:
-                        raise MadGraph5Error,\
-                            "Inconsistent flow in L-cut Majorana fermions."
+                        raise MadGraph5Error(\
+                            "Inconsistent flow in L-cut Majorana fermions.")
                             
             def fix_lcut_majorana_fermion_flow(last_loop_wf,\
                                                other_external_loop_wf):
@@ -2388,8 +2388,8 @@ class LoopHelasMatrixElement(helas_objec
         """ Just to forbid the usage of this generic function in a
         LoopHelasMatrixElement"""
 
-        raise self.PhysicsObjectError, \
-            "Usage of get_color_amplitudes is not allowed in a LoopHelasMatrixElement"
+        raise self.PhysicsObjectError( \
+            "Usage of get_color_amplitudes is not allowed in a LoopHelasMatrixElement")
 
     def get_born_color_amplitudes(self):
         """Return a list of (coefficient, amplitude number) lists,
@@ -2456,12 +2456,12 @@ class LoopHelasMatrixElement(helas_objec
                           tuple(amp.get('color_indices')) == diag_tuple[1],
                           LoopDiagramsHelasAmplitudeList[diag_tuple[0]])
                 if not res_amps:
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                           """No amplitude found for color structure
                             %s and color index chain (%s) (diagram %i)""" % \
                             (col_basis_elem,
                              str(diag_tuple[1]),
-                             diag_tuple[0])
+                             diag_tuple[0]))
 
                 for res_amp in res_amps:
                     col_amp.append(((res_amp.get('fermionfactor'),
diff -rupN MadGraph_pristine/madgraph/various/misc.py ../contrib/MadGraph/madgraph/various/misc.py
--- MadGraph_pristine/madgraph/various/misc.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/misc.py	2020-10-29 20:31:26.830384670 +1100
@@ -22,7 +22,12 @@ import re
 import signal
 import subprocess
 import sys
-import StringIO
+
+try:
+    from StringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO, IOBase ## for Python 3
+
 import sys
 import optparse
 import time
@@ -34,7 +39,7 @@ from distutils.version import LooseVersi
 try:
     # Use in MadGraph
     import madgraph
-except Exception, error:
+except Exception as error:
     # Use in MadEvent
     import internal
     from internal import MadGraph5Error, InvalidCmd
@@ -67,7 +72,7 @@ def parse_info_str(fsock):
         if m is not None:
             info_dict[m.group('name')] = m.group('value')
         else:
-            raise IOError, "String %s is not a valid info string" % entry
+            raise IOError("String %s is not a valid info string" % entry)
 
     return info_dict
 
@@ -293,7 +298,7 @@ def deactivate_dependence(dependency, cm
     
     def tell(msg):
         if log == 'stdout':
-            print msg
+            print(msg)
         elif callable(log):
             log(msg)
     
@@ -309,7 +314,7 @@ def activate_dependence(dependency, cmd=
     
     def tell(msg):
         if log == 'stdout':
-            print msg
+            print(msg)
         elif callable(log):
             log(msg)
 
@@ -331,7 +336,7 @@ def activate_dependence(dependency, cmd=
             cmd.do_install('Golem95')
     
     if dependency=='samurai':
-        raise MadGraph5Error, 'Samurai cannot yet be automatically installed.' 
+        raise MadGraph5Error( 'Samurai cannot yet be automatically installed.') 
 
     if dependency=='ninja':
         if cmd.options['ninja'] in ['None',None,''] or\
@@ -407,7 +412,7 @@ def multiple_try(nb_try=5, sleep=20):
                     return f(*args, **opt)
                 except KeyboardInterrupt:
                     raise
-                except Exception, error:
+                except Exception as error:
                     global wait_once
                     if not wait_once:
                         text = """Start waiting for update. (more info in debug mode)"""
@@ -421,7 +426,7 @@ def multiple_try(nb_try=5, sleep=20):
 
             if __debug__:
                 raise
-            raise error.__class__, '[Fail %i times] \n %s ' % (i+1, error)
+            raise error.__class__( '[Fail %i times] \n %s ' % (i+1, error))
         return deco_f_retry
     return deco_retry
 
@@ -478,9 +483,9 @@ def compile(arg=[], cwd=None, mode='fort
         p = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                              stderr=subprocess.STDOUT, cwd=cwd, **opt)
         (out, err) = p.communicate()
-    except OSError, error:
+    except OSError as error:
         if cwd and not os.path.exists(cwd):
-            raise OSError, 'Directory %s doesn\'t exists. Impossible to run make' % cwd
+            raise OSError('Directory %s doesn\'t exists. Impossible to run make' % cwd)
         else:
             error_text = "Impossible to compile %s directory\n" % cwd
             error_text += "Trying to launch make command returns:\n"
@@ -489,7 +494,7 @@ def compile(arg=[], cwd=None, mode='fort
             if sys.platform == "darwin":
                 error_text += "Note that MacOSX doesn\'t have gmake/gfortan install by default.\n"
                 error_text += "Xcode3 contains those required programs"
-            raise MadGraph5Error, error_text
+            raise MadGraph5Error(error_text)
 
     if p.returncode:
         # Check that makefile exists
@@ -497,24 +502,24 @@ def compile(arg=[], cwd=None, mode='fort
             cwd = os.getcwd()
         all_file = [f.lower() for f in os.listdir(cwd)]
         if 'makefile' not in all_file and '-f' not in arg:
-            raise OSError, 'no makefile present in %s' % os.path.realpath(cwd)
+            raise OSError('no makefile present in %s' % os.path.realpath(cwd))
 
         if mode == 'fortran' and  not (which('g77') or which('gfortran')):
             error_msg = 'A fortran compiler (g77 or gfortran) is required to create this output.\n'
             error_msg += 'Please install g77 or gfortran on your computer and retry.'
-            raise MadGraph5Error, error_msg
+            raise MadGraph5Error(error_msg)
         elif mode == 'cpp' and not which('g++'):            
             error_msg ='A C++ compiler (g++) is required to create this output.\n'
             error_msg += 'Please install g++ (which is part of the gcc package)  on your computer and retry.'
-            raise MadGraph5Error, error_msg
+            raise MadGraph5Error(error_msg)
 
         # Check if this is due to the need of gfortran 4.6 for quadruple precision
         if any(tag.upper() in out.upper() for tag in ['real(kind=16)','real*16',
             'complex*32']) and mode == 'fortran' and not \
                              ''.join(get_gfortran_version().split('.')) >= '46':
             if not which('gfortran'):
-                raise MadGraph5Error, 'The fortran compiler gfortran v4.6 or later '+\
-                  'is required to compile %s.\nPlease install it and retry.'%cwd
+                raise MadGraph5Error('The fortran compiler gfortran v4.6 or later '+\
+                  'is required to compile %s.\nPlease install it and retry.'%cwd)
             else:
                 logger_stderr.error('ERROR, you could not compile %s because'%cwd+\
              ' your version of gfortran is older than 4.6. MadGraph5_aMC@NLO will carry on,'+\
@@ -529,7 +534,7 @@ def compile(arg=[], cwd=None, mode='fort
         error_text += 'Please try to fix this compilations issue and retry.\n'
         error_text += 'Help might be found at https://answers.launchpad.net/mg5amcnlo.\n'
         error_text += 'If you think that this is a bug, you can report this at https://bugs.launchpad.net/mg5amcnlo'
-        raise MadGraph5Error, error_text
+        raise MadGraph5Error(error_text)
     return p.returncode
 
 def get_gfortran_version(compiler='gfortran'):
@@ -664,7 +669,7 @@ class MuteLogger(object):
         for logname in lognames:
             try:
                 os.remove(path)
-            except Exception, error:
+            except Exception as error:
                 pass
             my_logger = logging.getLogger(logname)
             hdlr = logging.FileHandler(path)            
@@ -689,7 +694,7 @@ class MuteLogger(object):
             if path:
                 try:
                     os.remove(path)
-                except Exception, error:
+                except Exception as error:
                     pass
             my_logger = logging.getLogger(logname)
             if logname in self.logger_saved_info:
@@ -753,7 +758,7 @@ def detect_if_cpp_compiler_is_clang(cpp_
         p = Popen([cpp_compiler, '--version'], stdout=subprocess.PIPE, 
                     stderr=subprocess.PIPE)
         output, error = p.communicate()
-    except Exception, error:
+    except Exception as error:
         # Cannot probe the compiler, assume not clang then
         return False
     return 'LLVM' in output
@@ -870,7 +875,7 @@ def check_system_error(value=1):
         def deco_f(arg, *args, **opt):
             try:
                 return f(arg, *args, **opt)
-            except OSError, error:
+            except OSError as error:
                 logger.debug('try to recover from %s' % error)
                 if isinstance(arg, (list,tuple)):
                     prog =  arg[0]
@@ -888,8 +893,8 @@ def check_system_error(value=1):
                 # NO such file or directory
                 elif error.errno == 2:
                     # raise a more meaningfull error message
-                    raise Exception, '%s fails with no such file or directory' \
-                                                                           % arg            
+                    raise Exception('%s fails with no such file or directory' \
+                                                                           % arg)            
                 else:
                     raise
         return deco_f
@@ -971,7 +976,7 @@ def get_last_line(fsock):
     
     return tail(fsock, 1)[0]
 
-class BackRead(file):
+class BackRead(IOBase):
     """read a file returning the lines in reverse order for each call of readline()
 This actually just reads blocks (4096 bytes by default) of data from the end of
 the file and returns last line in an internal buffer."""
@@ -1006,7 +1011,7 @@ the file and returns last line in an int
         self.blksize = blksize
         # how many blocks we've read
         self.blkcount = 1
-        file.__init__(self, filepos, 'rb')
+        IOBase.__init__(self, filepos, 'rb')
         # if the file is smaller than the blocksize, read a block,
         # otherwise, read the whole thing...
         if self.size > self.blksize:
@@ -1037,8 +1042,8 @@ def write_PS_input(filePath, PS):
                                                              for p in PS])+'\n')
         PSfile.close()
     except Exception:
-        raise MadGraph5Error, 'Could not write out the PS point to file %s.'\
-                                                                  %str(filePath)
+        raise MadGraph5Error('Could not write out the PS point to file %s.'\
+                                                                  %str(filePath))
 
 def format_timer(running_time):
     """ return a nicely string representing the time elapsed."""
@@ -1125,8 +1130,8 @@ def gunzip(path, keep=False, stdout=None
         if os.path.exists("%s.gz" % path):
             path = "%s.gz" % path
         else:
-            raise Exception, "%(path)s does not finish by .gz and the file %(path)s.gz does not exists" %\
-                              {"path": path}         
+            raise Exception("%(path)s does not finish by .gz and the file %(path)s.gz does not exists" %\
+                              {"path": path})         
 
     
     #for large file (>1G) it is faster and safer to use a separate thread
@@ -1376,7 +1381,7 @@ class OptionParser(optparse.OptionParser
     
     def exit(self, status=0, msg=None):
         if msg:
-            raise InvalidCmd, msg
+            raise InvalidCmd(msg)
         else:
             raise InvalidCmd
 
@@ -1442,8 +1447,8 @@ def sprint(*args, **opt):
         log.log(level, ' '.join([intro]+[str(a) for a in args]) + \
                    ' \033[1;30m[%s at line %s]\033[0m' % (os.path.basename(filename), lineno))
     else:
-        print ' '.join([intro]+[str(a) for a in args]) + \
-                   ' \033[1;30m[%s at line %s]\033[0m' % (os.path.basename(filename), lineno)
+        print(' '.join([intro]+[str(a) for a in args]) + \
+                   ' \033[1;30m[%s at line %s]\033[0m' % (os.path.basename(filename), lineno))
 
     if wait:
         raw_input('press_enter to continue')
@@ -1508,8 +1513,8 @@ def timeout(func, args=(), kwargs={}, ti
         def run(self):
             try:
                 self.result = func(*args, **kwargs)
-            except Exception,error:
-                print error
+            except Exception as error:
+                print(error)
                 self.result = default
     it = InterruptableThread()
     it.start()
@@ -1786,7 +1791,7 @@ class EasterEgg(object):
                 self.call_apple(msg)
             else:
                 self.call_linux(msg)
-        except Exception, error:
+        except Exception as error:
             sprint(error)
             pass
     
@@ -1955,7 +1960,7 @@ def plugin_import(module, error_msg, fct
         try:
             _temp = __import__('MG5aMC_PLUGIN.%s' % module, globals(), locals(), fcts, -1)
         except ImportError:
-            raise MadGraph5Error, error_msg
+            raise MadGraph5Error(error_msg)
     
     if not fcts:
         return _temp
@@ -1977,7 +1982,7 @@ def from_plugin_import(plugin_path, targ
                 try:
                     with stdchannel_redirected(sys.stdout, os.devnull):
                         __import__('%s.%s' % (plugindirname,plug))
-                except Exception, error:
+                except Exception as error:
                     if warning:
                         logger.warning("error detected in plugin: %s.", plug)
                         logger.warning("%s", error)
@@ -2058,7 +2063,7 @@ def import_python_lhapdf(lhapdfconfig):
                 import lhapdf
                 use_lhapdf=True
             except ImportError:
-                print 'fail'
+                print('fail')
                 logger.warning("Failed to access python version of LHAPDF: "\
                                    "If the python interface to LHAPDF is available on your system, try "\
                                    "adding its location to the PYTHONPATH environment variable and the"\
diff -rupN MadGraph_pristine/madgraph/various/q_polynomial.py ../contrib/MadGraph/madgraph/various/q_polynomial.py
--- MadGraph_pristine/madgraph/various/q_polynomial.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/q_polynomial.py	2020-10-29 20:31:26.830384670 +1100
@@ -107,8 +107,8 @@ class Polynomial_naive_ordering(object):
         try:
             return self.coef_list.index(array.array('i',new_indices_list))
         except ValueError:
-            raise PolynomialError,\
-                "The index %s looked for could not be found"%str(indices_list)   
+            raise PolynomialError(\
+                "The index %s looked for could not be found"%str(indices_list))   
 
     def get_coef_at_position(self, pos):
         """ Returns the coefficient at position pos in the one dimensional
@@ -131,8 +131,8 @@ class PolynomialRoutines(object):
             self.updater_max_rank = max_rank
         else:
             if updater_max_rank > max_rank:
-                raise PolynomialError, "The updater max rank must be at most"+\
-                                                " equal to the overall max rank"
+                raise PolynomialError( "The updater max rank must be at most"+\
+                                                " equal to the overall max rank")
             else:
                 self.updater_max_rank = updater_max_rank            
         if coef_format=='complex*16':
@@ -146,8 +146,8 @@ class PolynomialRoutines(object):
             self.czero='(0.0e0,0.0e0)'
         self.line_split=line_split
         if max_rank<0:
-            raise PolynomialError, \
-                            "The rank of a q-polynomial should be 0 or positive"
+            raise PolynomialError( \
+                            "The rank of a q-polynomial should be 0 or positive")
         self.max_rank=max_rank
         self.pq=Polynomial(max_rank)
         
@@ -747,8 +747,8 @@ class FromIREGIFortranCodeGenerator():
         try:
             return self.coef_list.index(array.array('i',new_indices_list))
         except ValueError:
-            raise PolynomialError,\
-                "The index %s looked for could not be found"%str(indices_list)   
+            raise PolynomialError(\
+                "The index %s looked for could not be found"%str(indices_list))   
 
     def get_coef_at_position(self, pos):
         """ Returns the coefficient at position pos in the one dimensional
@@ -870,7 +870,7 @@ class FromGolem95FortranCodeGenerator():
         for num_eq in range(l):
             q = map(lambda i: cls.PRIMES[i], lst[num_eq])
             coeffs = [
-                reduce(lambda x,y: x*y, map(lambda (b,e): b**e, zip(q, term)), 1)
+                reduce(lambda x,y: x*y, map(lambda b,e: b**e, zip(q, term)), 1)
                 for term in lst]
             LHS.append(coeffs)
             RHS.append(q)
@@ -906,16 +906,16 @@ if __name__ == '__main__':
     """I test here the write_golem95_mapping function"""
     
     P=Polynomial(7)
-    print "Coef (6,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0])
-    print "Coef (1,1,2,2) is at pos %s"%P.get_coef_position([0,1,2,2,3,3])
-    print "Coef (7,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0,0])
-    print "Coef (1,2,2,2) is at pos %s"%P.get_coef_position([0,1,1,2,2,3,3])
+    print( "Coef (6,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0]))
+    print( "Coef (1,1,2,2) is at pos %s"%P.get_coef_position([0,1,2,2,3,3]))
+    print( "Coef (7,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0,0]))
+    print( "Coef (1,2,2,2) is at pos %s"%P.get_coef_position([0,1,1,2,2,3,3]))
     
     sys.exit(0)
 
     max_rank=6
     FPR=FortranPolynomialRoutines(max_rank)
-    print "Output of write_golem95_mapping function for max_rank=%d:\n\n"%max_rank
+    print( "Output of write_golem95_mapping function for max_rank=%d:\n\n"%max_rank)
 
     import os
     import sys
diff -rupN MadGraph_pristine/models/check_param_card.py ../contrib/MadGraph/models/check_param_card.py
--- MadGraph_pristine/models/check_param_card.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/check_param_card.py	2020-10-29 20:31:26.830384670 +1100
@@ -3,7 +3,12 @@ from __future__ import division
 import itertools
 import xml.etree.ElementTree as ET
 import math
-import StringIO
+
+try:
+    from StringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import os
 import re
 import shutil
@@ -174,7 +179,7 @@ class Block(list):
             return self.param_dict[tuple(lhacode)]
         except KeyError:
             if default is None:
-                raise KeyError, 'id %s is not in %s' % (tuple(lhacode), self.name)
+                raise KeyError('id %s is not in %s' % (tuple(lhacode), self.name))
             else:
                 return Parameter(block=self, lhacode=lhacode, value=default,
                                                            comment='not define')
@@ -227,8 +232,8 @@ class Block(list):
             
         if tuple(obj.lhacode) in self.param_dict:
             if self.param_dict[tuple(obj.lhacode)].value != obj.value:
-                raise InvalidParamCard, '%s %s is already define to %s impossible to assign %s' % \
-                    (self.name, obj.lhacode, self.param_dict[tuple(obj.lhacode)].value, obj.value)
+                raise InvalidParamCard('%s %s is already define to %s impossible to assign %s' % \
+                    (self.name, obj.lhacode, self.param_dict[tuple(obj.lhacode)].value, obj.value))
             return
         list.append(self, obj)
         # update the dictionary of key
@@ -486,7 +491,7 @@ class ParamCard(dict):
                 model_value = parameters[particle.get('mass')]
                 if isinstance(model_value, complex):
                     if model_value.imag > 1e-5 * model_value.real:
-                        raise Exception, "Mass should be real number: particle %s (%s) has mass: %s"  % (lhacode, particle.get('name'), model_value)
+                        raise Exception("Mass should be real number: particle %s (%s) has mass: %s"  % (lhacode, particle.get('name'), model_value))
                     model_value = model_value.real
                     
                 if not misc.equal(model_value, param_value, 4):
@@ -510,7 +515,7 @@ class ParamCard(dict):
                 model_value = parameters[particle.get('width')]
                 if isinstance(model_value, complex):
                     if model_value.imag > 1e-5 * model_value.real:
-                        raise Exception, "Width should be real number: particle %s (%s) has mass: %s" 
+                        raise Exception("Width should be real number: particle %s (%s) has mass: %s" )
                     model_value = model_value.real
                 if not misc.equal(abs(model_value), param_value, 4):
                     modify = True
@@ -683,14 +688,14 @@ class ParamCard(dict):
             return
         
         if len(internal_param)!=1:
-            raise InvalidParamCard,' The specified EW inputs has more than one'+\
-                ' unknown: [%s]'%(','.join([str(elem) for elem in internal_param]))
+            raise InvalidParamCard(' The specified EW inputs has more than one'+\
+                ' unknown: [%s]'%(','.join([str(elem) for elem in internal_param])))
         
         
         if not internal_param[0] in [('mass',(24,)), ('sminputs',(2,)),
                                                              ('sminputs',(1,))]:
-            raise InvalidParamCard, ' The only EW input scheme currently supported'+\
-                        ' are those with either the W mass or GF left internal.'
+            raise InvalidParamCard(' The only EW input scheme currently supported'+\
+                        ' are those with either the W mass or GF left internal.')
         
         # Now if the Wmass is internal, then we must change the scheme
         if internal_param[0] == ('mass',(24,)):
@@ -784,13 +789,13 @@ class ParamCard(dict):
         
         if not lhacode:
             logger.info("Information on block parameter %s:" % block, '$MG:color:BLUE')
-            print  str(self[block])
+            print(str(self[block]))
         elif default:
             pname2block, restricted = default.analyze_param_card()
             if (block, lhacode) in restricted:
                 logger.warning("This parameter will not be consider by MG5_aMC")
                 print( "    MadGraph will use the following formula:")
-                print restricted[(block, lhacode)]
+                prin(restricted[(block, lhacode)])
                 print( "     Note that some code (MadSpin/Pythia/...) will read directly the value")  
             else:
                 for name, values in pname2block.items():
@@ -856,7 +861,7 @@ class ParamCard(dict):
             if param.value != value:
                 error_msg = 'This card is not suitable to be convert to SLAH1\n'
                 error_msg += 'Parameter %s %s should be %s' % (block, lhacode, value)
-                raise InvalidParamCard, error_msg   
+                raise InvalidParamCard(error_ms)   
             self.remove_param(block, lhacode)
 
 
@@ -942,15 +947,15 @@ class ParamCardIterator(ParamCard):
                     try:
                         key, def_list = pattern.findall(param.value)[0]
                     except:
-                        raise Exception, "Fail to handle scanning tag: Please check that the syntax is valid"
+                        raise Exception("Fail to handle scanning tag: Please check that the syntax is valid")
                     if key == '': 
                         key = -1 * len(all_iterators)
                     if key not in all_iterators:
                         all_iterators[key] = []
                     try:
                         all_iterators[key].append( (param, eval(def_list)))
-                    except SyntaxError, error:
-                        raise Exception, "Fail to handle your scan definition. Please check your syntax:\n entry: %s \n Error reported: %s" %(def_list, error)
+                    except SyntaxError as error:
+                        raise Exception("Fail to handle your scan definition. Please check your syntax:\n entry: %s \n Error reported: %s" %(def_list, error))
                 elif isinstance(param.value, str) and param.value.strip().lower().startswith('auto'):
                     self.autowidth.append(param)
         keys = all_iterators.keys() # need to fix an order for the scan
@@ -958,7 +963,7 @@ class ParamCardIterator(ParamCard):
         #store the type of parameter
         for key in keys:
             for param, values in all_iterators[key]:
-                self.param_order.append("%s#%s" % (param.lhablock, '_'.join(`i` for i in param.lhacode)))
+                self.param_order.append("%s#%s" % (param.lhablock, '_'.join(repr(i) for i in param.lhacode)))
             
         # do the loop
         lengths = [range(len(all_iterators[key][0][1])) for key in keys]
@@ -1276,8 +1281,8 @@ class ParamCardRule(object):
             else:
                 if value != 0:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not at zero' % \
-                                    (block, ' '.join([str(i) for i in id])) 
+                        raise InvalidParamCard('parameter %s: %s is not at zero' % \
+                                    (block, ' '.join([str(i) for i in id])) )
                     else:
                         param = card[block].get(id) 
                         param.value = 0.0
@@ -1307,8 +1312,8 @@ class ParamCardRule(object):
             else:   
                 if value != 1:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not at one but at %s' % \
-                                    (block, ' '.join([str(i) for i in id]), value)         
+                        raise InvalidParamCard('parameter %s: %s is not at one but at %s' % \
+                                    (block, ' '.join([str(i) for i in id]), value))         
                     else:
                         param = card[block].get(id) 
                         param.value = 1.0
@@ -1343,9 +1348,9 @@ class ParamCardRule(object):
 
                 if value1 != value2:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not to identical to parameter  %s' % \
+                        raise InvalidParamCard('parameter %s: %s is not to identical to parameter  %s' % \
                                     (block, ' '.join([str(i) for i in id1]),
-                                            ' '.join([str(i) for i in id2]))         
+                                            ' '.join([str(i) for i in id2])))         
                     else:
                         param = card[block].get(id1) 
                         param.value = value2
@@ -1372,9 +1377,9 @@ class ParamCardRule(object):
 
                 if value1 != -value2:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not to opposite to parameter  %s' % \
+                        raise InvalidParamCard('parameter %s: %s is not to opposite to parameter  %s' % \
                                     (block, ' '.join([str(i) for i in id1]),
-                                            ' '.join([str(i) for i in id2]))         
+                                            ' '.join([str(i) for i in id2])))         
                     else:
                         param = card[block].get(id1) 
                         param.value = -value2
@@ -1648,8 +1653,8 @@ def convert_to_mg5card(path, outputpath=
     ae = card['ae'].get([1, 1], default=0).value
     card.mod_param('ae', [1,1], 'te', [1,1], value= ae * ye, comment='T_e(Q) DRbar')
     if ae * ye:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ae [1, 1] times ye [1,1] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ae [1, 1] times ye [1,1] should be 0''')
     card.remove_param('ae', [1,1])
     #2
     ye = card['ye'].get([2, 2], default=0).value
@@ -1657,8 +1662,8 @@ Parameter ae [1, 1] times ye [1,1] shoul
     ae = card['ae'].get([2, 2], default=0).value
     card.mod_param('ae', [2,2], 'te', [2,2], value= ae * ye, comment='T_mu(Q) DRbar')
     if ae * ye:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ae [2, 2] times ye [2,2] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ae [2, 2] times ye [2,2] should be 0''')
     card.remove_param('ae', [2,2])
     #3
     ye = card['ye'].get([3, 3], default=0).value
@@ -1670,8 +1675,8 @@ Parameter ae [2, 2] times ye [2,2] shoul
     au = card['au'].get([1, 1], default=0).value
     card.mod_param('au', [1,1], 'tu', [1,1], value= au * yu, comment='T_u(Q) DRbar')
     if au * yu:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter au [1, 1] times yu [1,1] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter au [1, 1] times yu [1,1] should be 0''')
     card.remove_param('au', [1,1])
     #2
     ye = card['yu'].get([2, 2], default=0).value
@@ -1679,8 +1684,8 @@ Parameter au [1, 1] times yu [1,1] shoul
     ae = card['au'].get([2, 2], default=0).value
     card.mod_param('au', [2,2], 'tu', [2,2], value= au * yu, comment='T_c(Q) DRbar')
     if au * yu:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter au [2, 2] times yu [2,2] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter au [2, 2] times yu [2,2] should be 0''')
     card.remove_param('au', [2,2])
     #3
     yu = card['yu'].get([3, 3]).value
@@ -1692,8 +1697,8 @@ Parameter au [2, 2] times yu [2,2] shoul
     ad = card['ad'].get([1, 1], default=0).value
     card.mod_param('ad', [1,1], 'td', [1,1], value= ad * yd, comment='T_d(Q) DRbar')
     if ad * yd:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ad [1, 1] times yd [1,1] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ad [1, 1] times yd [1,1] should be 0''')
     card.remove_param('ad', [1,1])
     #2
     ye = card['yd'].get([2, 2], default=0).value
@@ -1701,8 +1706,8 @@ Parameter ad [1, 1] times yd [1,1] shoul
     ae = card['ad'].get([2, 2], default=0).value
     card.mod_param('ad', [2,2], 'td', [2,2], value= ad * yd, comment='T_s(Q) DRbar')
     if ad * yd:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ad [2, 2] times yd [2,2] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ad [2, 2] times yd [2,2] should be 0''')
     card.remove_param('ad', [2,2])
     #3
     yd = card['yd'].get([3, 3]).value
diff -rupN MadGraph_pristine/models/__init__.py ../contrib/MadGraph/models/__init__.py
--- MadGraph_pristine/models/__init__.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/__init__.py	2020-10-29 20:31:26.830384670 +1100
@@ -44,8 +44,8 @@ def load_model(name, decay=False):
         model_path = os.path.realpath(os.sep.join(path_split))
         sys_path = os.path.realpath(os.path.dirname(sys.modules[path_split[-1]].__file__))
         if sys_path != model_path:
-            raise Exception, 'name %s already consider as a python library cann\'t be reassigned(%s!=%s)' % \
-                (path_split[-1], model_path, sys_path) 
+            raise Exception('name %s already consider as a python library cann\'t be reassigned(%s!=%s)' % \
+                (path_split[-1], model_path, sys_path) )
 
     with misc.TMP_variable(sys, 'path', [os.sep.join(path_split[:-1])]):
         __import__(path_split[-1])
diff -rupN MadGraph_pristine/vendor/ply/yacc.py ../contrib/MadGraph/vendor/ply/yacc.py
--- MadGraph_pristine/vendor/ply/yacc.py	2020-10-27 21:41:37.909090533 +1100
+++ ../contrib/MadGraph/vendor/ply/yacc.py	2020-10-29 20:31:26.834384648 +1100
@@ -89,7 +89,12 @@ resultlimit = 40               # Size li
 pickle_protocol = 0            # Protocol to use when writing pickle files
 
 import re, types, sys, os.path
-from cStringIO import StringIO
+
+try:
+    from cStringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 
 # Compatibility function for python 2.6/3.0
 if sys.version_info[0] < 3:
