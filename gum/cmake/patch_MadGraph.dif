diff -rupN MadGraph_pristine/aloha/aloha_fct.py ../contrib/MadGraph/aloha/aloha_fct.py
--- MadGraph_pristine/aloha/aloha_fct.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_fct.py	2020-10-29 23:48:54.788704178 +1100
@@ -29,7 +29,7 @@ def get_fermion_flow(expression, nb_ferm
     try:
         expr = eval(expression)
     except Exception as error:
-        print error
+        print(error)
         return
     expr = expr.simplify()
     #expr is now a valid AddVariable object if they are a sum or
@@ -40,7 +40,7 @@ def get_fermion_flow(expression, nb_ferm
     for term in expr:
         if term.vartype == 0: # Single object
             if not term.spin_ind in [[1,2], [2,1]]:
-                raise WrongFermionFlow, 'Fermion should be the first particles of any interactions'
+                raise WrongFermionFlow('Fermion should be the first particles of any interactions')
             if isinstance(term, (Gamma, Gamma5, Sigma)):
                 if term.spin_ind == [2,1]:
                     out[1] = 2
@@ -59,11 +59,11 @@ def get_fermion_flow(expression, nb_ferm
                 if ind1 not in link.keys():
                     link[ind1] = ind2
                 else:
-                    raise WrongFermionFlow, 'a spin indices should appear only once on the left indices of an object: %s' % expr
+                    raise WrongFermionFlow('a spin indices should appear only once on the left indices of an object: %s' % expr)
                 if ind2 not in rlink.keys():
                     rlink[ind2] = ind1
                 else: 
-                    raise WrongFermionFlow, 'a spin indices should appear only once on the left indices of an object: %s' % expr             
+                    raise WrongFermionFlow('a spin indices should appear only once on the left indices of an object: %s' % expr)             
              
             for i in range(1, nb_fermion):
                 if i in out.keys() or i in out.values():
@@ -84,9 +84,9 @@ def get_fermion_flow(expression, nb_ferm
                             out[pos] = i
                             break
                         else:
-                            raise WrongFermionFlow,  'incoherent IO state: %s' % expr
+                            raise WrongFermionFlow('incoherent IO state: %s' % expr)
     if not len(out) == nb_fermion //2:
-        raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+        raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
     return out
 
 
@@ -112,10 +112,10 @@ def check_flow_validity(expression, nb_f
     for term in expr:
         if term.vartype == 0: # Single object
             if not term.spin_ind in [[1,2], [2,1]]:
-                raise WrongFermionFlow, 'Fermion should be the first particles of any interactions'
+                raise WrongFermionFlow('Fermion should be the first particles of any interactions')
             if isinstance(term, (Gamma, Gamma5, Sigma)):
                 if not term.spin_ind == [2,1]:
-                    raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+                    raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
         
         elif term.vartype == 2: # product of object
             link, rlink = {}, {}
@@ -127,7 +127,7 @@ def check_flow_validity(expression, nb_f
                 if isinstance(obj, (Gamma, Sigma)):
                     if (ind1 in range(1, nb_fermion+1) and ind1 % 2 == 1) or \
                        (ind2 in range(2, nb_fermion+1) and ind2 % 2 == 0 ):
-                        raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+                        raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
                 if ind1 not in link.keys():
                     link[ind1] = ind2
                 else:
@@ -146,7 +146,7 @@ def check_flow_validity(expression, nb_f
                     elif pos in rlink.keys() and rlink[pos] not in old:
                         pos = rlink[pos]
                     elif pos != i+1:
-                        raise WrongFermionFlow, 'Not coherent Incoming/outcoming fermion flow'
+                        raise WrongFermionFlow('Not coherent Incoming/outcoming fermion flow')
                     elif pos == i+1:
                         break
    
diff -rupN MadGraph_pristine/aloha/aloha_lib.py ../contrib/MadGraph/aloha/aloha_lib.py
--- MadGraph_pristine/aloha/aloha_lib.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_lib.py	2020-10-29 23:48:54.788704178 +1100
@@ -143,13 +143,13 @@ class Computation(dict):
             if isinstance(expression, (MultLorentz, AddVariable, LorentzObject)):
                 try:
                     expr = expression.expand().get_rep([0])
-                except KeyError, error:
+                except KeyError as error:
                     if error.args != ((0,),):
                         raise
                     else:
-                        raise aloha.ALOHAERROR, '''Error in input format. 
+                        raise aloha.ALOHAERROR( '''Error in input format. 
     Argument of function (or denominator) should be scalar.
-    We found %s''' % expression
+    We found %s''' % expression)
                 new = expr.simplify()
                 if not isinstance(new, numbers.Number):
                     new = new.factorize()
@@ -171,10 +171,10 @@ class Computation(dict):
             else:
                 module = 'cmath.'
             try:
-                return str(eval("%s%s(%s)" % (module,fct_tag, ','.join(`x` for x in argument))))
-            except Exception, error:
-                print error
-                print "cmath.%s(%s)" % (fct_tag, ','.join(`x` for x in argument))
+                return str(eval("%s%s(%s)" % (module,fct_tag, ','.join(repr(x) for x in argument))))
+            except Exception as error:
+                print(error)
+                print("cmath.%s(%s)" % (fct_tag, ','.join(repr(x) for x in argument)))
         if str(fct_tag)+str(argument) in self.inverted_fct:
             tag = self.inverted_fct[str(fct_tag)+str(argument)]
             v = tag.split('(')[1][:-1]
@@ -684,7 +684,7 @@ class MultVariable(array):
 #                    self.append(new_id)
 #            return self
         else:
-            raise Exception, 'Cann\'t replace a Variable by %s' % type(expression)
+            raise Exception( 'Cann\'t replace a Variable by %s' % type(expression))
         
     
     def get_all_var_names(self):
diff -rupN MadGraph_pristine/aloha/aloha_parsers.py ../contrib/MadGraph/aloha/aloha_parsers.py
--- MadGraph_pristine/aloha/aloha_parsers.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_parsers.py	2020-10-29 23:48:54.788704178 +1100
@@ -29,17 +29,14 @@ import sys
 root_path = os.path.split(os.path.dirname(os.path.realpath( __file__ )))[0]
 sys.path.append(os.path.join(root_path))
 
-import aloha_lib
-from aloha_object import *
+import aloha.aloha_lib
+from aloha.aloha_object import *
 import vendor.ply.lex as lex
 import vendor.ply.yacc as yacc
 from aloha.aloha_lib import KERNEL
 logger = logging.getLogger('aloha.parsers')
 
-try:
-    import madgraph.various.misc as misc
-except Exception:
-    import aloha.misc as misc
+import madgraph.various.misc as misc
 
 
 # PLY lexer class
@@ -193,7 +190,7 @@ class UFOExpressionParser(object):
 
     def p_error(self, p):
         if p:
-            print p[:]
+            print(p[:])
             raise Exception("Syntax error at '%s' in '%s'" % (p.value, self.f))
         else:
             logger.error("Syntax error at EOF")
diff -rupN MadGraph_pristine/aloha/aloha_writers.py ../contrib/MadGraph/aloha/aloha_writers.py
--- MadGraph_pristine/aloha/aloha_writers.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/aloha_writers.py	2020-10-29 23:48:54.792704130 +1100
@@ -1,11 +1,11 @@
-try:
-    import madgraph.iolibs.file_writers as writers 
-    import madgraph.various.q_polynomial as q_polynomial
-    import madgraph.various.misc as misc
-except Exception:
-    import aloha.file_writers as writers
-    import aloha.q_polynomial as q_polynomial
-    import aloha.misc as misc
+#try:
+import madgraph.iolibs.file_writers as writers 
+import madgraph.various.q_polynomial as q_polynomial
+import madgraph.various.misc as misc
+#except Exception:
+#    import aloha.file_writers as writers
+#    import aloha.q_polynomial as q_polynomial
+#    import aloha.misc as misc
 
 import aloha
 import aloha.aloha_lib as aloha_lib
@@ -16,7 +16,12 @@ from numbers import Number
 from collections import defaultdict
 from fractions import Fraction
 # fast way to deal with string
-from cStringIO import StringIO
+
+try:
+    from cStringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 # Look at http://www.skymind.com/~ocrow/python_string/ 
 # For knowing how to deal with long strings efficiently.
 import itertools
@@ -92,12 +97,12 @@ class WriteALOHA:
         elif len(indices) == 2: 
             return  4 * indices[0] + indices[1] + start + self.momentum_size
         else:
-            raise Exception, 'WRONG CONTRACTION OF LORENTZ OBJECT for routine %s: %s' \
-                    % (self.name, ind_name)                                 
+            raise Exception('WRONG CONTRACTION OF LORENTZ OBJECT for routine %s: %s' \
+                    % (self.name, ind_name))                                 
                                  
     def get_header_txt(self,mode=''): 
         """ Prototype for language specific header""" 
-        raise Exception, 'THis function should be overwritten'
+        raise Exception('THis function should be overwritten')
         return ''
     
     def get_declaration_txt(self):
@@ -110,7 +115,7 @@ class WriteALOHA:
 
     def get_momenta_txt(self):
         """ Prototype for the definition of the momenta"""
-        raise Exception, 'THis function should be overwritten'
+        raise Exception('THis function should be overwritten')
 
     def get_momentum_conservation_sign(self):
         """find the sign associated to the momentum conservation"""
@@ -785,7 +790,7 @@ class ALOHAWriterForFortran(WriteALOHA):
                                   {'i': self.outgoing, 'COUP': coup_name})
                 else:
                     if self.routine.denominator:
-                        raise Exception, 'modify denominator are not compatible with complex mass scheme'                
+                        raise Exception('modify denominator are not compatible with complex mass scheme')                
 
                     out.write('    denom = %(COUP)s/(P%(i)s(0)**2-P%(i)s(1)**2-P%(i)s(2)**2-P%(i)s(3)**2 - M%(i)s**2)\n' % \
                       {'i': self.outgoing, 'COUP': coup_name})
@@ -1587,7 +1592,7 @@ class ALOHAWriterForCPP(WriteALOHA):
                       {'i': self.outgoing, 'coup': coup_name})
                 else:
                     if self.routine.denominator:
-                        raise Exception, 'modify denominator are not compatible with complex mass scheme'                
+                        raise Exception('modify denominator are not compatible with complex mass scheme')                
 
                     out.write('    denom = %(coup)s/((P%(i)s[0]*P%(i)s[0])-(P%(i)s[1]*P%(i)s[1])-(P%(i)s[2]*P%(i)s[2])-(P%(i)s[3]*P%(i)s[3]) - (M%(i)s*M%(i)s));\n' % \
                       {'i': self.outgoing, 'coup': coup_name})
@@ -1909,7 +1914,7 @@ class ALOHAWriterForPython(WriteALOHA):
             self.declaration.add(('fct', fct))
             return 'cmath.{0}(%s)'.format(fct)
         else:
-            raise Exception, "Unable to handle function name %s (no special rule defined and not in cmath)" % fct
+            raise Exception("Unable to handle function name %s (no special rule defined and not in cmath)" % fct)
     
     def define_expression(self):
         """Define the functions in a 100% way """
@@ -1970,7 +1975,7 @@ class ALOHAWriterForPython(WriteALOHA):
                           {'i': self.outgoing,'coup':coup_name})
                 else:
                     if self.routine.denominator:
-                        raise Exception, 'modify denominator are not compatible with complex mass scheme'                
+                        raise Exception('modify denominator are not compatible with complex mass scheme')                
                     
                     out.write('    denom = %(coup)s/(P%(i)s[0]**2-P%(i)s[1]**2-P%(i)s[2]**2-P%(i)s[3]**2 - M%(i)s**2)\n' % 
                           {'i': self.outgoing,'coup':coup_name})                    
@@ -2218,7 +2223,7 @@ class WriterFactory(object):
         elif language == 'gpu':
             return ALOHAWriterForGPU(data, outputdir)
         else:
-            raise Exception, 'Unknown output format'
+            raise Exception('Unknown output format')
 
 
     
diff -rupN MadGraph_pristine/aloha/create_aloha.py ../contrib/MadGraph/aloha/create_aloha.py
--- MadGraph_pristine/aloha/create_aloha.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/aloha/create_aloha.py	2020-10-29 23:48:54.792704130 +1100
@@ -15,7 +15,12 @@
 from __future__ import division
 import cmath
 import copy
-import cPickle
+
+try:
+    import cPickle ## for Python 2
+except ImportError:
+    import _pickle as cPickle ## for Python 3
+
 import glob
 import logging
 import numbers
@@ -110,7 +115,7 @@ class AbstractRoutine(object):
                 rank = max(sum(coeff), rank)
             return rank -1 # due to the coefficient associate to the wavefunctions
         else:
-            raise ALOHAERROR, '%s is not a valid information that can be computed' % info
+            raise ALOHAERROR( '%s is not a valid information that can be computed' % info)
 
 
 class AbstractRoutineBuilder(object):
@@ -206,7 +211,7 @@ class AbstractRoutineBuilder(object):
             if not data == target:
                 text = """Unable to deal with 4(or more) point interactions
 in presence of majorana particle/flow violation"""
-                raise ALOHAERROR, text
+                raise ALOHAERROR( text)
         
         old_id = 2 * pair - 1
         new_id = _conjugate_gap + old_id
@@ -286,7 +291,7 @@ in presence of majorana particle/flow vi
                 lorentz = eval(lorentz)
             except NameError as error:
                 logger.error('unknow type in Lorentz Evaluation:%s'%str(error))
-                raise ALOHAERROR, 'unknow type in Lorentz Evaluation: %s ' % str(error) 
+                raise ALOHAERROR( 'unknow type in Lorentz Evaluation: %s ' % str(error) )
             else:
                 self.kernel_tag = set(aloha_lib.KERNEL.use_tag)
         elif isinstance(self.routine_kernel,str):
@@ -837,7 +842,7 @@ class AbstractALOHAModel(dict):
                                 realname = conjg_builder.name + ''.join(['C%s' % pair for pair in conjg_builder.conjg])
                                 try:
                                     self[(realname, outgoing)].add_combine(m)
-                                except Exception,error:
+                                except Exception as error:
                                     self[(realname, self.symmetries[lorentz.name][outgoing])].add_combine(m)          
                        
         if save:
@@ -1059,8 +1064,8 @@ class AbstractALOHAModel(dict):
                 break
         else: 
 
-            raise ALOHAERROR, 'No external routine \"%s.%s\" in directories\n %s' % \
-                        (name, ext, '\n'.join(paths))
+            raise ALOHAERROR( 'No external routine \"%s.%s\" in directories\n %s' % \
+                        (name, ext, '\n'.join(paths)))
        
         if output_dir:
             for filepath in ext_files:
diff -rupN MadGraph_pristine/input/mg5_configuration.txt ../contrib/MadGraph/input/mg5_configuration.txt
--- MadGraph_pristine/input/mg5_configuration.txt	2020-10-27 21:41:37.769088298 +1100
+++ ../contrib/MadGraph/input/mg5_configuration.txt	2020-10-29 23:48:54.792704130 +1100
@@ -49,7 +49,7 @@
 
 #! Prefered PS viewer
 #!  If None: try to find one available on the system
-# eps_viewer = None
+eps_viewer = true
 
 #! Time allowed to answer question (if no answer takes default value)
 #!  0: No time limit
diff -rupN MadGraph_pristine/madgraph/core/base_objects.py ../contrib/MadGraph/madgraph/core/base_objects.py
--- MadGraph_pristine/madgraph/core/base_objects.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/base_objects.py	2020-10-29 23:55:54.793137991 +1100
@@ -22,7 +22,12 @@ import math
 import numbers
 import os
 import re
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import madgraph.core.color_algebra as color
 from madgraph import MadGraph5Error, MG5DIR, InvalidCmd
 import madgraph.various.misc as misc 
@@ -81,9 +86,9 @@ class PhysicsObject(dict):
                                  "Property name %s is not a string" % repr(name)
 
         if name not in self.keys():
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                         """%s is not a valid property for this object: %s\n
-    Valid property are %s""" % (name,self.__class__.__name__, self.keys())
+    Valid property are %s""" % (name,self.__class__.__name__, self.keys()))
         return True
 
     def get(self, name):
@@ -104,7 +109,7 @@ class PhysicsObject(dict):
                 self.filter(name, value)
                 self[name] = value
                 return True
-            except self.PhysicsObjectError, why:
+            except self.PhysicsObjectError as why:
                 logger.warning("Property " + name + " cannot be changed:" + \
                                 str(why))
                 return False
@@ -272,100 +277,100 @@ class Particle(PhysicsObject):
             # Forbid special character but +-~_
             p=re.compile('''^[\w\-\+~_]+$''')
             if not p.match(value):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid particle name" % value
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid particle name" % value)
 
         if name is 'ghost':
             if not isinstance(value,bool):
-                raise self.PhysicsObjectError, \
-                 "%s is not a valid bool for the 'ghost' attribute" % str(value)
+                raise self.PhysicsObjectError( \
+                 "%s is not a valid bool for the 'ghost' attribute" % str(value))
     
         if name is 'counterterm':
             if not isinstance(value,dict):
-                raise self.PhysicsObjectError, \
-                    "counterterm %s is not a valid dictionary" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "counterterm %s is not a valid dictionary" % repr(value))
             for key, val in value.items():
                 if not isinstance(key,tuple):
-                    raise self.PhysicsObjectError, \
-                        "key %s is not a valid tuple for counterterm key" % repr(key)
+                    raise self.PhysicsObjectError( \
+                        "key %s is not a valid tuple for counterterm key" % repr(key))
                 if not isinstance(key[0],str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % repr(key[0])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % repr(key[0]))
                 if not isinstance(key[1],tuple):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % repr(key[1])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % repr(key[1]))
                 for elem in key[1]:
                     if not isinstance(elem,tuple):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid list" % repr(elem)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid list" % repr(elem))
                     for partPDG in elem:
                         if not isinstance(partPDG,int):
-                            raise self.PhysicsObjectError, \
-                                "%s is not a valid integer for PDG" % repr(partPDG)
+                            raise self.PhysicsObjectError( \
+                                "%s is not a valid integer for PDG" % repr(partPDG))
                         if partPDG<=0:
-                            raise self.PhysicsObjectError, \
-                                "%s is not a valid positive PDG" % repr(partPDG)
+                            raise self.PhysicsObjectError( \
+                                "%s is not a valid positive PDG" % repr(partPDG))
                 if not isinstance(val,dict):
-                    raise self.PhysicsObjectError, \
-                        "value %s is not a valid dictionary for counterterm value" % repr(val)
+                    raise self.PhysicsObjectError( \
+                        "value %s is not a valid dictionary for counterterm value" % repr(val))
                 for vkey, vvalue in val.items():
                     if vkey not in [0,-1,-2]:
-                        raise self.PhysicsObjectError, \
-                            "Key %s is not a valid laurent serie order" % repr(vkey)
+                        raise self.PhysicsObjectError( \
+                            "Key %s is not a valid laurent serie order" % repr(vkey))
                     if not isinstance(vvalue,str):
-                        raise self.PhysicsObjectError, \
-                            "Coupling %s is not a valid string" % repr(vvalue)
+                        raise self.PhysicsObjectError( \
+                            "Coupling %s is not a valid string" % repr(vvalue))
         if name is 'spin':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Spin %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Spin %s is not an integer" % repr(value))
             if (value < 1 or value > 5) and value != 99:
-                raise self.PhysicsObjectError, \
-                   "Spin %i not valid" % value
+                raise self.PhysicsObjectError( \
+                   "Spin %i not valid" % value)
 
         if name is 'color':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Color %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Color %s is not an integer" % repr(value))
             if value not in [1, 3, 6, 8]:
-                raise self.PhysicsObjectError, \
-                   "Color %i is not valid" % value
+                raise self.PhysicsObjectError( \
+                   "Color %i is not valid" % value)
 
         if name in ['mass', 'width']:
             # Must start with a letter, followed by letters, digits or _
             p = re.compile('\A[a-zA-Z]+[\w\_]*\Z')
             if not p.match(value):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid name for mass/width variable" % \
-                        value
+                        value)
 
         if name is 'pdg_code':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "PDG code %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "PDG code %s is not an integer" % repr(value))
 
         if name is 'line':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                    "Line type %s is not a string" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Line type %s is not a string" % repr(value))
             if value not in ['None','dashed', 'straight', 'wavy', 'curly', 'double','swavy','scurly','dotted']:
-                raise self.PhysicsObjectError, \
-                   "Line type %s is unknown" % value
+                raise self.PhysicsObjectError( \
+                   "Line type %s is unknown" % value)
 
         if name is 'charge':
             if not isinstance(value, float):
-                raise self.PhysicsObjectError, \
-                    "Charge %s is not a float" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Charge %s is not a float" % repr(value))
 
         if name is 'propagating':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "Propagating tag %s is not a boolean" % repr(value)
+                raise self.PhysicsObjectError( \
+                    "Propagating tag %s is not a boolean" % repr(value))
 
         if name in ['is_part', 'self_antipart']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "%s tag %s is not a boolean" % (name, repr(value))
+                raise self.PhysicsObjectError( \
+                    "%s tag %s is not a boolean" % (name, repr(value)))
 
         return True
 
@@ -486,8 +491,8 @@ class Particle(PhysicsObject):
             # Massive tensor
             res = [-2, -1, 0, 1, 2]
         else:
-            raise self.PhysicsObjectError, \
-              "No helicity state assignment for spin %d particles" % spin
+            raise self.PhysicsObjectError( \
+              "No helicity state assignment for spin %d particles" % spin)
                   
         if allow_reverse and not self.get('is_part'):
             res.reverse()
@@ -689,91 +694,91 @@ class Interaction(PhysicsObject):
         if name == 'id':
             #Should be an integer
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
 
         if name == 'particles':
             #Should be a list of valid particle names
             if not isinstance(value, ParticleList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of particles" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of particles" % str(value))
 
         if name == 'perturbation_type':
             if value!=None and not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)            
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))            
 
         if name == 'type':
             #Should be a string
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
         if name == 'loop_particles':
             if isinstance(value,list):
                 for l in value:
                     if isinstance(l,list):
                         for part in l:
                             if not isinstance(part,int):
-                                raise self.PhysicsObjectError, \
-                                    "%s is not a valid integer" % str(part)
+                                raise self.PhysicsObjectError( \
+                                    "%s is not a valid integer" % str(part))
                             if part<0:
-                                raise self.PhysicsObjectError, \
-                                    "%s is not a valid positive integer" % str(part)
+                                raise self.PhysicsObjectError( \
+                                    "%s is not a valid positive integer" % str(part))
 
         if name == 'orders':
             #Should be a dict with valid order names ask keys and int as values
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dict for coupling orders" % \
-                                                                    str(value)
+                                                                    str(value))
             for order in value.keys():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(order)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(order))
                 if not isinstance(value[order], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value[order])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value[order]))
 
         if name in ['color']:
             #Should be a list of list strings
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of Color Strings" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of Color Strings" % str(value))
             for mycolstring in value:
                 if not isinstance(mycolstring, color.ColorString):
-                    raise self.PhysicsObjectError, \
-                            "%s is not a valid list of Color Strings" % str(value)
+                    raise self.PhysicsObjectError( \
+                            "%s is not a valid list of Color Strings" % str(value))
 
         if name in ['lorentz']:
             #Should be a list of list strings
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of strings" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of strings" % str(value))
             for mystr in value:
                 if not isinstance(mystr, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(mystr))
 
         if name == 'couplings':
             #Should be a dictionary of strings with (i,j) keys
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dictionary for couplings" % \
-                                                                str(value)
+                                                                str(value))
 
             for key in value.keys():
                 if not isinstance(key, tuple):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid tuple" % str(key)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid tuple" % str(key))
                 if len(key) != 2:
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid tuple with 2 elements" % str(key)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid tuple with 2 elements" % str(key))
                 if not isinstance(key[0], int) or not isinstance(key[1], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid tuple of integer" % str(key)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid tuple of integer" % str(key))
                 if not isinstance(value[key], str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % value[key]
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % value[key])
 
         return True
 
@@ -1070,73 +1075,73 @@ class Model(PhysicsObject):
 
         if name in ['name']:
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a string" %type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a string" %type(value))
 
         elif name == 'particles':
             if not isinstance(value, ParticleList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a ParticleList object" % \
-                                                            type(value)
+                                                            type(value))
         elif name == 'interactions':
             if not isinstance(value, InteractionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a InteractionList object" % \
-                                                            type(value)
+                                                            type(value))
         elif name == 'particle_dict':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a dictionary" % \
-                                                        type(value)
+                                                        type(value))
         elif name == 'interaction_dict':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a dictionary" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a dictionary" % type(value))
 
         elif name == 'ref_dict_to0':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a dictionary" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a dictionary" % type(value))
                     
         elif name == 'ref_dict_to1':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a dictionary" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a dictionary" % type(value))
 
         elif name == 'got_majoranas':
             if not (isinstance(value, bool) or value == None):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a boolean" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a boolean" % type(value))
 
         elif name == 'conserved_charge':
             if not (isinstance(value, set)):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a set" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a set" % type(value))
 
         elif name == 'version_tag':
             if not (isinstance(value, str)):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a string" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a string" % type(value))
 
         elif name == 'order_hierarchy':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a dictionary" % \
-                                                            type(value)
+                                                            type(value))
             for key in value.keys():
                 if not isinstance(value[key],int):
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                         "Object of type %s is not an integer" % \
-                                                            type(value[key])
+                                                            type(value[key]))
         elif name == 'gauge':
             if not (isinstance(value, list)):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a list" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a list" % type(value))
 
         elif name == 'case_sensitive':
             if not value in [True ,False]:
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a boolean" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a boolean" % type(value))
             
 
         return True
@@ -1164,7 +1169,7 @@ class Model(PhysicsObject):
                 modeldir = os.path.expanduser(modeldir)
                 return modeldir
             else:
-                raise Exception, "path %s not valid anymore." % modeldir
+                raise Exception( "path %s not valid anymore." % modeldir)
             #modeldir = os.path.join(os.path.dirname(modeldir),
             #                        os.path.basename(modeldir).rsplit("-",1)[0])
             #if os.path.exists(modeldir):
@@ -1174,7 +1179,7 @@ class Model(PhysicsObject):
             modeldir = self.get('version_tag').rsplit('##',1)[0]
             modelname = self['name']            
             if not  os.path.exists(modeldir):
-                raise Exception, "path %s not valid anymore" % modeldir
+                raise Exception( "path %s not valid anymore" % modeldir)
             modeldir = os.path.dirname(modeldir)
             modeldir = pjoin(modeldir, modelname)
             modeldir = os.path.expanduser(modeldir)
@@ -1274,7 +1279,7 @@ class Model(PhysicsObject):
             if isinstance(id, int):
                 try:
                     return self.get("particle_dict")[id]
-                except Exception, error:
+                except Exception as error:
                     return None
             else:
                 if not hasattr(self, 'name2part'):
@@ -1468,8 +1473,8 @@ class Model(PhysicsObject):
                 'to use the particles name defined in the model and not the ' + \
                 'MadGraph5_aMC@NLO convention'
                 
-                raise MadGraph5Error, error_text % \
-                                     (part.get_name(), part.get_pdg_code(), pdg)                
+                raise MadGraph5Error( error_text % \
+                                     (part.get_name(), part.get_pdg_code(), pdg))                
 
         default = self.load_default_name()
 
@@ -1974,32 +1979,32 @@ class Leg(PhysicsObject):
 
         if name in ['id', 'number']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer for leg id" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer for leg id" % str(value))
 
         if name == 'state':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid leg state (True|False)" % \
-                                                                    str(value)
+                                                                    str(value))
 
         if name == 'from_group':
             if not isinstance(value, bool) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid boolean for leg flag from_group" % \
-                                                                    str(value)
+                                                                    str(value))
 
         if name == 'loop_line':
             if not isinstance(value, bool) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "%s is not a valid boolean for leg flag loop_line" % \
-                                                                    str(value)
+                                                                    str(value))
 
         if name == 'onshell':
             if not isinstance(value, bool) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid boolean for leg flag onshell" % \
-                                                                    str(value)
+                                                                    str(value))
         return True
 
     def get_sorted_keys(self):
@@ -2171,18 +2176,18 @@ class MultiLeg(PhysicsObject):
 
         if name == 'ids':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for i in value:
                 if not isinstance(i, int):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of integers" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of integers" % str(value))
 
         if name == 'state':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid leg state (initial|final)" % \
-                                                                    str(value)
+                                                                    str(value))
 
         return True
 
@@ -2250,13 +2255,13 @@ class Vertex(PhysicsObject):
 
         if name == 'id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer for vertex id" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer for vertex id" % str(value))
 
         if name == 'legs':
             if not isinstance(value, LegList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid LegList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid LegList object" % str(value))
 
         return True
 
@@ -2373,20 +2378,20 @@ class ContractedVertex(Vertex):
             if isinstance(value, list):
                 for elem in value:
                     if not isinstance(elem,int):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid integer for leg PDG" % str(elem)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid integer for leg PDG" % str(elem))
             else:
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list for contracted vertex PDGs"%str(value)                
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list for contracted vertex PDGs"%str(value))                
         if name == 'loop_tag':
             if isinstance(value, tuple):
                 for elem in value:
                     if not (isinstance(elem,int) or isinstance(elem,tuple)):
-                        raise self.PhysicsObjectError, \
-                          "%s is not a valid int or tuple for loop tag element"%str(elem)
+                        raise self.PhysicsObjectError( \
+                          "%s is not a valid int or tuple for loop tag element"%str(elem))
             else:
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid tuple for a contracted vertex loop_tag."%str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid tuple for a contracted vertex loop_tag."%str(value))
         if name == 'loop_orders':
             Interaction.filter(Interaction(), 'orders', value)
         else:
@@ -2417,8 +2422,8 @@ class Diagram(PhysicsObject):
 
         if name == 'vertices':
             if not isinstance(value, VertexList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid VertexList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid VertexList object" % str(value))
 
         if name == 'orders':
             Interaction.filter(Interaction(), 'orders', value)
@@ -2457,7 +2462,7 @@ class Diagram(PhysicsObject):
                                      for key in sorted(self['orders'].keys())]))
             
             if not pass_sanity:
-                raise Exception, "invalid diagram: %s. vert_id: %s" % (mystr, responsible) 
+                raise Exception( "invalid diagram: %s. vert_id: %s" % (mystr, responsible)) 
                 
             return mystr
         else:
@@ -2627,7 +2632,7 @@ class Diagram(PhysicsObject):
             security =0
             while not vcurrent.is_external():
                 if security > 1000:
-                    raise Exception, 'wrong diagram'
+                    raise Exception('wrong diagram')
                 next_l = [l for l in vcurrent.lines if l is not l_last and l.is_fermion()][0]
                 next_v = next_l.end
                 if next_v == vcurrent:
@@ -2818,113 +2823,113 @@ class Process(PhysicsObject):
 
         if name in ['legs', 'legs_with_decays'] :
             if not isinstance(value, LegList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid LegList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid LegList object" % str(value))
 
         if name in ['orders', 'overall_orders','squared_orders']:
             Interaction.filter(Interaction(), 'orders', value)
 
         if name == 'constrained_orders':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)            
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))            
 
         if name == 'sqorders_types':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))
             for order in value.keys()+value.values():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid string" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid string" % str(value))
 
         if name == 'split_orders':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for order in value:
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid string" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid string" % str(value))
 
         if name == 'model':
             if not isinstance(value, Model):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Model object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid Model object" % str(value))
         if name in ['id', 'uid']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                    "Process %s %s is not an integer" % (name, repr(value))
+                raise self.PhysicsObjectError( \
+                    "Process %s %s is not an integer" % (name, repr(value)))
 
         if name == 'required_s_channels':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for l in value:
                 if not isinstance(l, list):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of lists" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of lists" % str(value))
                 for i in l:
                     if not isinstance(i, int):
-                        raise self.PhysicsObjectError, \
-                              "%s is not a valid list of integers" % str(l)
+                        raise self.PhysicsObjectError( \
+                              "%s is not a valid list of integers" % str(l))
                     if i == 0:
-                        raise self.PhysicsObjectError, \
-                          "Not valid PDG code %d for s-channel particle" % i
+                        raise self.PhysicsObjectError( \
+                          "Not valid PDG code %d for s-channel particle" % i)
 
         if name in ['forbidden_onsh_s_channels', 'forbidden_s_channels']:
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for i in value:
                 if not isinstance(i, int):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of integers" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of integers" % str(value))
                 if i == 0:
-                    raise self.PhysicsObjectError, \
-                      "Not valid PDG code %d for s-channel particle" % str(value)
+                    raise self.PhysicsObjectError( \
+                      "Not valid PDG code %d for s-channel particle" % str(value))
 
         if name == 'forbidden_particles':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for i in value:
                 if not isinstance(i, int):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid list of integers" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid list of integers" % str(value))
                 if i <= 0:
-                    raise self.PhysicsObjectError, \
-                      "Forbidden particles should have a positive PDG code" % str(value)
+                    raise self.PhysicsObjectError( \
+                      "Forbidden particles should have a positive PDG code" % str(value))
 
         if name == 'perturbation_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for order in value:
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                          "%s is not a valid string" % str(value)
+                    raise self.PhysicsObjectError( \
+                          "%s is not a valid string" % str(value))
 
         if name == 'is_decay_chain':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
 
         if name == 'has_born':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
 
         if name == 'decay_chains':
             if not isinstance(value, ProcessList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessList" % str(value))
 
         if name == 'NLO_mode':
             import madgraph.interface.madgraph_interface as mg
             if value not in mg.MadGraphCmd._valid_nlo_modes:
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid NLO_mode" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid NLO_mode" % str(value))
         return True
 
     def has_multiparticle_label(self):
@@ -3608,12 +3613,12 @@ class ProcessDefinition(Process):
 
         if name == 'legs':
             if not isinstance(value, MultiLegList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid MultiLegList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid MultiLegList object" % str(value))
         elif name == 'decay_chains':
             if not isinstance(value, ProcessDefinitionList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessDefinitionList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessDefinitionList" % str(value))
 
         else:
             return super(ProcessDefinition, self).filter(name, value)
diff -rupN MadGraph_pristine/madgraph/core/color_algebra.py ../contrib/MadGraph/madgraph/core/color_algebra.py
--- MadGraph_pristine/madgraph/core/color_algebra.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/color_algebra.py	2020-10-29 23:48:54.792704130 +1100
@@ -833,8 +833,8 @@ class ColorString(list):
         are still non trivial color objects."""
 
         if self:
-            raise ValueError, \
-                "String %s cannot be simplified to a number!" % str(self)
+            raise ValueError( \
+                "String %s cannot be simplified to a number!" % str(self))
 
         if self.Nc_power >= 0:
             return (self.coeff * fractions.Fraction(\
diff -rupN MadGraph_pristine/madgraph/core/color_amp.py ../contrib/MadGraph/madgraph/core/color_amp.py
--- MadGraph_pristine/madgraph/core/color_amp.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/color_amp.py	2020-10-29 23:48:54.796704081 +1100
@@ -413,8 +413,8 @@ class ColorBasis(dict):
         # If more than one string at leading N...
         if len(res_cs) > 1 and any([not cs.near_equivalent(res_cs[0]) \
                                     for cs in res_cs]):
-            raise ColorBasis.ColorBasisError, \
-             "More than one color string with leading N coeff: %s" % str(res_cs)
+            raise ColorBasis.ColorBasisError( \
+             "More than one color string with leading N coeff: %s" % str(res_cs))
 
         res_cs = res_cs[0]
 
@@ -423,13 +423,13 @@ class ColorBasis(dict):
         for col_obj in res_cs:
             if not isinstance(col_obj, color_algebra.T) and \
                    not col_obj.__class__.__name__.startswith('Epsilon'):
-                raise ColorBasis.ColorBasisError, \
+                raise ColorBasis.ColorBasisError( \
                   "Color flow decomposition %s contains non T/Epsilon elements" % \
-                                                                    str(res_cs)
+                                                                    str(res_cs))
             if isinstance(col_obj, color_algebra.T) and len(col_obj) != 2:
-                raise ColorBasis.ColorBasisError, \
+                raise ColorBasis.ColorBasisError( \
                   "Color flow decomposition %s contains T's w/o 2 indices" % \
-                                                                    str(res_cs)
+                                                                    str(res_cs))
 
         return res_cs
 
@@ -463,8 +463,8 @@ class ColorBasis(dict):
 
                 # Raise an error if external legs contain non supported repr
                 if abs(leg_repr) not in [1, 3, 6, 8]:
-                    raise ColorBasis.ColorBasisError, \
-        "Particle ID=%i has an unsupported color representation" % leg_repr
+                    raise ColorBasis.ColorBasisError( \
+        "Particle ID=%i has an unsupported color representation" % leg_repr)
 
                 # Build the fake indices replacements for octets
                 if abs(leg_repr) == 8:
diff -rupN MadGraph_pristine/madgraph/core/diagram_generation.py ../contrib/MadGraph/madgraph/core/diagram_generation.py
--- MadGraph_pristine/madgraph/core/diagram_generation.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/diagram_generation.py	2020-10-29 23:48:54.796704081 +1100
@@ -439,16 +439,13 @@ class Amplitude(base_objects.PhysicsObje
 
         if name == 'process':
             if not isinstance(value, base_objects.Process):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Process object" % str(value)
+                raise self.PhysicsObjectError("%s is not a valid Process object" % str(value))
         if name == 'diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList object" % str(value)
+                raise self.PhysicsObjectError("%s is not a valid DiagramList object" % str(value))
         if name == 'has_mirror_process':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid boolean" % str(value)
+                raise self.PhysicsObjectError("%s is not a valid boolean" % str(value))
         return True
 
     def get(self, name):
@@ -568,7 +565,7 @@ class Amplitude(base_objects.PhysicsObje
                         leg.get('id')].is_fermion(), legs)) % 2 == 1:
             if not returndiag:
                 self['diagrams'] = res
-                raise InvalidCmd, 'The number of fermion is odd'
+                raise InvalidCmd('The number of fermion is odd')
             else:
                 return False, res
 
@@ -579,7 +576,7 @@ class Amplitude(base_objects.PhysicsObje
            len(filter(lambda leg: leg.is_outgoing_fermion(model), legs)):
             if not returndiag:
                 self['diagrams'] = res
-                raise InvalidCmd, 'The number of of incoming/outcoming fermions are different'
+                raise InvalidCmd('The number of of incoming/outcoming fermions are different')
             else:
                 return False, res
 
@@ -605,10 +602,10 @@ class Amplitude(base_objects.PhysicsObje
             if abs(total) > 1e-10:
                 if not returndiag:
                     self['diagrams'] = res
-                    raise InvalidCmd, 'No %s conservation for this process ' % charge
+                    raise InvalidCmd('No %s conservation for this process ' % charge)
                     return res
                 else:
-                    raise InvalidCmd, 'No %s conservation for this process ' % charge
+                    raise InvalidCmd( 'No %s conservation for this process ' % charge)
                     return res, res
 
         if not returndiag:
@@ -1362,15 +1359,14 @@ class DecayChainAmplitude(Amplitude):
 
             for process in argument.get('decay_chains'):
                 if process.get('perturbation_couplings'):
-                    raise MadGraph5Error,\
-                          "Decay processes can not be perturbed"
+                    raise MadGraph5Error(\
+                          "Decay processes can not be perturbed")
                 process.set('overall_orders', argument.get('overall_orders'))
                 if not process.get('is_decay_chain'):
                     process.set('is_decay_chain',True)
                 if not process.get_ninitial() == 1:
-                    raise InvalidCmd,\
-                          "Decay chain process must have exactly one" + \
-                          " incoming particle"
+                    raise InvalidCmd("Decay chain process must have exactly one" + \
+                          " incoming particle")
                 self['decay_chains'].append(\
                     DecayChainAmplitude(process, collect_mirror_procs,
                                         ignore_six_quark_processes,
@@ -1443,13 +1439,13 @@ class DecayChainAmplitude(Amplitude):
 
         if name == 'amplitudes':
             if not isinstance(value, AmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid AmplitudeList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid AmplitudeList" % str(value))
         if name == 'decay_chains':
             if not isinstance(value, DecayChainAmplitudeList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid DecayChainAmplitudeList object" % \
-                        str(value)
+                        str(value))
         return True
 
     def get_sorted_keys(self):
@@ -1601,23 +1597,23 @@ class MultiProcess(base_objects.PhysicsO
 
         if name == 'process_definitions':
             if not isinstance(value, base_objects.ProcessDefinitionList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessDefinitionList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessDefinitionList object" % str(value))
 
         if name == 'amplitudes':
             if not isinstance(value, AmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid AmplitudeList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid AmplitudeList object" % str(value))
 
         if name in ['collect_mirror_procs']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid boolean" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid boolean" % str(value))
 
         if name == 'ignore_six_quark_processes':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
 
         return True
 
@@ -1834,9 +1830,9 @@ class MultiProcess(base_objects.PhysicsO
             if len(failed_procs) == 1 and 'error' in locals():
                 raise error
             else:
-                raise NoDiagramException, \
+                raise NoDiagramException( \
             "No amplitudes generated from process %s. Please enter a valid process" % \
-                  process_definition.nice_string()
+                  process_definition.nice_string())
         
 
         # Return the produced amplitudes
@@ -2025,7 +2021,7 @@ class MultiProcess(base_objects.PhysicsO
                     amplitude = Amplitude({'process': process})
                     try:
                         amplitude.generate_diagrams(diagram_filter=diagram_filter)
-                    except InvalidCmd, error:
+                    except InvalidCmd as error:
                         failed_procs.append(tuple(sorted_legs))
                     else:
                         if amplitude.get('diagrams'):
diff -rupN MadGraph_pristine/madgraph/core/drawing.py ../contrib/MadGraph/madgraph/core/drawing.py
--- MadGraph_pristine/madgraph/core/drawing.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/drawing.py	2020-10-29 23:48:54.796704081 +1100
@@ -412,8 +412,8 @@ class FeynmanLine(object):
             self.begin.pos_x
             self.end.pos_y
         except Exception:
-            raise self.FeynmanLineError, 'No vertex in begin-end position ' + \
-                        ' or no position attach at one of those vertex '
+            raise self.FeynmanLineError('No vertex in begin-end position ' + \
+                        ' or no position attach at one of those vertex ')
         return True
 
     def has_ordinate(self, x):
@@ -431,10 +431,10 @@ class FeynmanLine(object):
                 min, max = max, min
 
             if min == max:
-                raise self.FeynmanLineError, 'Vertical line: no unique solution'
+                raise self.FeynmanLineError('Vertical line: no unique solution')
             if(not(min <= x <= max)):
-                raise self.FeynmanLineError, 'point outside interval invalid ' + \
-                    'invalid order {0:3}<={1:3}<={2:3}'.format(min, x, max)
+                raise self.FeynmanLineError('point outside interval invalid ' + \
+                    'invalid order {0:3}<={1:3}<={2:3}'.format(min, x, max))
 
         return self._has_ordinate(x)
 
@@ -548,8 +548,8 @@ class VertexPoint(object):
                 del self.lines[i]
                 return # only one data to remove!
 
-        raise self.VertexPointError, 'trying to remove in a ' + \
-                            'Vertex_Point a non present Feynman_Line'
+        raise self.VertexPointError( 'trying to remove in a ' + \
+                            'Vertex_Point a non present Feynman_Line')
 
 
     def def_level(self, level):
@@ -1060,9 +1060,9 @@ class FeynmanDiagram(object):
             # Associate position to level 2 and following (auto-recursive fct)
             self.find_vertex_position_at_level([init_line.end], 2)
         else:
-            raise self.FeynamDiagramError, \
+            raise self.FeynamDiagramError( \
                                 'only for one or two initial particles not %s' \
-                                % (len(self.initial_vertex))
+                                % (len(self.initial_vertex)))
 
 
     def find_vertex_position_tchannel(self):
@@ -1937,8 +1937,8 @@ class DiagramDrawer(object):
         straight is an example and can be replace by other type of line as 
         dashed, wavy, curly, ..."""
 
-        raise self.DrawDiagramError, 'DrawDiagram.draw_straight should be ' + \
-                'overwritten by Inherited Class'
+        raise self.DrawDiagramError( 'DrawDiagram.draw_straight should be ' + \
+                'overwritten by Inherited Class')
 
     draw_curved_straight = draw_straight
 
diff -rupN MadGraph_pristine/madgraph/core/helas_objects.py ../contrib/MadGraph/madgraph/core/helas_objects.py
--- MadGraph_pristine/madgraph/core/helas_objects.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/core/helas_objects.py	2020-10-29 23:48:54.796704081 +1100
@@ -300,8 +300,8 @@ class CanonicalConfigTag(diagram_generat
                         right_num = num
             if right_num == -1:
                 # This should never happen
-                raise diagram_generation.DiagramTag.DiagramTagError, \
-                    "Error in CanonicalConfigTag, no link with number 1 or 2."
+                raise diagram_generation.DiagramTag.DiagramTagError( \
+                    "Error in CanonicalConfigTag, no link with number 1 or 2.")
 
             # Now move one step in the direction of right_link
             right_link = self.tag.links[right_num]
@@ -492,8 +492,8 @@ class CanonicalConfigTag(diagram_generat
             return (old_vertex[0], (new_vertex[1][0], min_number), new_vertex[2])
 
         # We should not get here
-        raise diagram_generation.DiagramTag.DiagramTagError, \
-              "Error in CanonicalConfigTag, wrong setup of vertices in link."
+        raise diagram_generation.DiagramTag.DiagramTagError( \
+              "Error in CanonicalConfigTag, wrong setup of vertices in link.")
         
     @staticmethod
     def leg_from_link(link):
@@ -559,7 +559,7 @@ class HelasWavefunction(base_objects.Phy
         try:
             return sizes[abs(spin)]
         except KeyError:
-            raise MadGraph5Error, "L-cut particle has spin %d which is not supported."%spin
+            raise MadGraph5Error("L-cut particle has spin %d which is not supported."%spin)
 
     def default_setup(self):
         """Default values for all properties"""
@@ -695,149 +695,149 @@ class HelasWavefunction(base_objects.Phy
 
         if name in ['particle', 'antiparticle']:
             if not isinstance(value, base_objects.Particle):
-                raise self.PhysicsObjectError, \
-                    "%s tag %s is not a particle" % (name, repr(value))            
+                raise self.PhysicsObjectError( \
+                    "%s tag %s is not a particle" % (name, repr(value)))            
 
         if name == 'is_part':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                    "%s tag %s is not a boolean" % (name, repr(value))
+                raise self.PhysicsObjectError( \
+                    "%s tag %s is not a boolean" % (name, repr(value)))
 
         if name == 'interaction_id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer " % str(value) + \
-                        " for wavefunction interaction id"
+                        " for wavefunction interaction id")
 
         if name == 'pdg_codes':
             #Should be a list of strings
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of integers" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of integers" % str(value))
             for mystr in value:
                 if not isinstance(mystr, int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(mystr))
 
         if name == 'orders':
             #Should be a dict with valid order names ask keys and int as values
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dict for coupling orders" % \
-                                                                    str(value)
+                                                                    str(value))
             for order in value.keys():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(order)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(order))
                 if not isinstance(value[order], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value[order])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value[order]))
 
 
         if name == 'inter_color':
             # Should be None or a color string
             if value and not isinstance(value, color.ColorString):
-                    raise self.PhysicsObjectError, \
-                            "%s is not a valid Color String" % str(value)
+                    raise self.PhysicsObjectError( \
+                            "%s is not a valid Color String" % str(value))
 
         if name == 'lorentz':
             #Should be a list of string
             if not isinstance(value, list):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
 
         if name == 'coupling':
             #Should be a list of string
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid coupling string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid coupling string" % str(value))
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
             if len(value) == 0:
-                raise self.PhysicsObjectError, \
-                        "%s should have at least one value" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s should have at least one value" % str(value))
 
         if name == 'color_key':
             if value and not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                      "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                      "%s is not a valid integer" % str(value))
 
         if name == 'state':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid string for wavefunction state" % \
-                                                                    str(value)
+                                                                    str(value))
             if value not in ['incoming', 'outgoing',
                              'intermediate', 'initial', 'final']:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid wavefunction " % str(value) + \
-                        "state (incoming|outgoing|intermediate)"
+                        "state (incoming|outgoing|intermediate)")
         if name == 'leg_state':
             if value not in [False, True]:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid wavefunction " % str(value) + \
-                        "state (incoming|outgoing|intermediate)"
+                        "state (incoming|outgoing|intermediate)")
         if name in ['fermionflow']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
             if not value in [-1, 1]:
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid sign (must be -1 or 1)" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid sign (must be -1 or 1)" % str(value))
 
         if name in ['number_external', 'number']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer" % str(value) + \
-                        " for wavefunction number"
+                        " for wavefunction number")
 
         if name == 'mothers':
             if not isinstance(value, HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                       "%s is not a valid list of mothers for wavefunction" % \
-                      str(value)
+                      str(value))
 
         if name in ['decay']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid bool" % str(value) + \
-                        " for decay"
+                        " for decay")
         
         if name in ['onshell']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid bool" % str(value) + \
-                        " for onshell"
+                        " for onshell")
 
         if name in ['is_loop']:
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid bool" % str(value) + \
-                        " for is_loop"
+                        " for is_loop")
                         
         if name == 'conjugate_indices':
             if not isinstance(value, tuple) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid tuple" % str(value) + \
-                        " for conjugate_indices"
+                        " for conjugate_indices")
 
         if name == 'rank':
             if not isinstance(value, int) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid int" % str(value) + \
-                        " for the rank"
+                        " for the rank")
 
         if name == 'lcut_size':
             if not isinstance(value, int) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid int" % str(value) + \
-                        " for the lcut_size"
+                        " for the lcut_size")
 
         return True
 
@@ -914,8 +914,8 @@ class HelasWavefunction(base_objects.Phy
                     self.set('antiparticle', model.get('particle_dict')[-value])
                 return True
             else:
-                raise self.PhysicsObjectError, \
-                      "%s not allowed name for 3-argument set", name
+                raise self.PhysicsObjectError( \
+                      "%s not allowed name for 3-argument set", name)
         else:
             return super(HelasWavefunction, self).set(name, value)
 
@@ -973,10 +973,10 @@ class HelasWavefunction(base_objects.Phy
         except KeyError:
             # It then need be computed and for this, an alohaModel is necessary
             if alohaModel is None:
-                raise MadGraph5Error,"The analytic information %s has"%info+\
+                raise MadGraph5Error("The analytic information %s has"%info+\
                 " not been computed yet for this wavefunction and an"+\
                 " alohaModel was not specified, so that the information"+\
-                " cannot be retrieved."
+                " cannot be retrieved.")
         result = None
         
         if info=="interaction_rank" and len(self['mothers'])==0:
@@ -1011,8 +1011,8 @@ class HelasWavefunction(base_objects.Phy
                 result = result+self.get_analytic_info('interaction_rank',
                                                                      alohaModel)
             else:
-                raise MadGraph5Error, "A loop wavefunction has more than one loop"+\
-                    " mothers."
+                raise MadGraph5Error("A loop wavefunction has more than one loop"+\
+                    " mothers.")
                     
         # Now cache the resulting analytic info
         self['analytic_info'][info] = result
@@ -1472,8 +1472,8 @@ class HelasWavefunction(base_objects.Phy
         helas call """
         
         if self['mothers']:
-            raise MadGraph5Error, "This function should be called only for"+\
-                                                    " external wavefunctions."
+            raise MadGraph5Error("This function should be called only for"+\
+                                                    " external wavefunctions.")
         return_dict = {}
         if self.get('is_loop'):
             return_dict['conjugate'] = ('C' if self.needs_hermitian_conjugate() \
@@ -1795,7 +1795,7 @@ class HelasWavefunction(base_objects.Phy
             if self.get('spin') == 3:
                 return 'V'
             else:
-                raise MadGraph5Error,'L-cut particle type not supported'
+                raise MadGraph5Error('L-cut particle type not supported')
         else:
             return ''
 
@@ -1967,8 +1967,8 @@ class HelasWavefunction(base_objects.Phy
             loop_wf_index=\
                        [wf['is_loop'] for wf in self.get('mothers')].index(True)
         except ValueError:
-            raise MadGraph5Error, "The loop wavefunctions should have exactly"+\
-                                                " one loop wavefunction mother."
+            raise MadGraph5Error("The loop wavefunctions should have exactly"+\
+                                                " one loop wavefunction mother.")
 
         if self.find_outgoing_number()-1<=loop_wf_index:
             # If the incoming loop leg is placed after the outgoing one we
@@ -2009,8 +2009,8 @@ class HelasWavefunction(base_objects.Phy
             if len(loop_wfs)==1:
                 return loop_wfs[0]
             else:
-                raise MadGraph5Error, "The loop wavefunction must have either"+\
-                  " no mothers, or exactly one mother with type 'loop'."
+                raise MadGraph5Error("The loop wavefunction must have either"+\
+                  " no mothers, or exactly one mother with type 'loop'.")
         else:
             return None
         
@@ -2389,11 +2389,11 @@ class HelasWavefunctionList(base_objects
             return True
     
         def RaiseError():
-            raise self.PhysicsObjectListError, \
+            raise self.PhysicsObjectListError( \
       "This wavefunction list does not have a consistent wavefunction ordering."+\
       "\n  Wf numbers: %s"%str([wf['number'] for wf in diag_wfs])+\
       "\n  Wf mothers: %s"%str([[mother['number'] for mother in wf['mothers']] \
-                                                  for wf in diag_wfs])
+                                                  for wf in diag_wfs]))
     
         # We want to work on a local copy of the wavefunction list attribute
         diag_wfs = copy.copy(self)
@@ -2508,106 +2508,106 @@ class HelasAmplitude(base_objects.Physic
 
         if name == 'interaction_id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer for interaction id" % \
-                        str(value)
+                        str(value))
 
         if name == 'pdg_codes':
             #Should be a list of integers
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of integers" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of integers" % str(value))
             for mystr in value:
                 if not isinstance(mystr, int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(mystr))
 
         if name == 'orders':
             #Should be a dict with valid order names ask keys and int as values
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dict for coupling orders" % \
-                                                                    str(value)
+                                                                    str(value))
             for order in value.keys():
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(order)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(order))
                 if not isinstance(value[order], int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value[order])
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value[order]))
 
         if name == 'inter_color':
             # Should be None or a color string
             if value and not isinstance(value, color.ColorString):
-                    raise self.PhysicsObjectError, \
-                            "%s is not a valid Color String" % str(value)
+                    raise self.PhysicsObjectError( \
+                            "%s is not a valid Color String" % str(value))
 
         if name == 'lorentz':
             #Should be a list of string
             if not isinstance(value, list):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid list of string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid list of string" % str(value))
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
                         
         if name == 'coupling':
             #Should be a list of string
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                      "%s is not a valid coupling (list of string)" % str(value)
+                raise self.PhysicsObjectError( \
+                      "%s is not a valid coupling (list of string)" % str(value))
             
             for name in value:
                 if not isinstance(name, str):
-                    raise self.PhysicsObjectError, \
-                        "%s doesn't contain only string" % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s doesn't contain only string" % str(value))
             if not len(value):
-                raise self.PhysicsObjectError, \
-                                      'coupling should have at least one value'
+                raise self.PhysicsObjectError( \
+                                      'coupling should have at least one value')
 
         if name == 'color_key':
             if value and not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                      "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                      "%s is not a valid integer" % str(value))
 
         if name == 'number':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer for amplitude number" % \
-                        str(value)
+                        str(value))
 
         if name == 'fermionfactor':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid integer for fermionfactor" % \
-                        str(value)
+                        str(value))
             if not value in [-1, 0, 1]:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid fermion factor (-1, 0 or 1)" % \
-                        str(value)
+                        str(value))
 
         if name == 'color_indices':
             #Should be a list of integers
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list of integers" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list of integers" % str(value))
             for mystr in value:
                 if not isinstance(mystr, int):
-                    raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(mystr)
+                    raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(mystr))
 
         if name == 'mothers':
             if not isinstance(value, HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                       "%s is not a valid list of mothers for amplitude" % \
-                      str(value)
+                      str(value))
 
         if name == 'conjugate_indices':
             if not isinstance(value, tuple) and value != None:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid tuple" % str(value) + \
-                        " for conjugate_indices"
+                        " for conjugate_indices")
 
         return True
 
@@ -2719,8 +2719,8 @@ class HelasAmplitude(base_objects.Physic
                         self.set('coupling', [inter.get('couplings').values()[0]])
                 return True
             else:
-                raise self.PhysicsObjectError, \
-                      "%s not allowed name for 3-argument set", name
+                raise self.PhysicsObjectError( \
+                      "%s not allowed name for 3-argument set", name)
         else:
             return super(HelasAmplitude, self).set(name, value)
 
@@ -3208,15 +3208,15 @@ class HelasDiagram(base_objects.PhysicsO
 
         if name == 'wavefunctions' or name == 'loop_wavefunctions':
             if not isinstance(value, HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid HelasWavefunctionList object" % \
-                        str(value)
+                        str(value))
       
         if name == 'amplitudes':
             if not isinstance(value, HelasAmplitudeList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid HelasAmplitudeList object" % \
-                        str(value)
+                        str(value))
 
         return True
                 
@@ -3316,33 +3316,33 @@ class HelasMatrixElement(base_objects.Ph
 
         if name == 'processes':
             if not isinstance(value, base_objects.ProcessList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ProcessList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ProcessList object" % str(value))
         if name == 'diagrams':
             if not isinstance(value, HelasDiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid HelasDiagramList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid HelasDiagramList object" % str(value))
         if name == 'identical_particle_factor':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid int object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid int object" % str(value))
         if name == 'color_basis':
             if not isinstance(value, color_amp.ColorBasis):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ColorBasis object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ColorBasis object" % str(value))
         if name == 'color_matrix':
             if not isinstance(value, color_amp.ColorMatrix):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid ColorMatrix object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid ColorMatrix object" % str(value))
         if name == 'base_amplitude':
             if value != None and not \
                    isinstance(value, diagram_generation.Amplitude):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Amplitude object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid Amplitude object" % str(value))
         if name == 'has_mirror_process':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid boolean" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid boolean" % str(value))
         return True
 
     def get_sorted_keys(self):
@@ -3578,7 +3578,7 @@ class HelasMatrixElement(base_objects.Ph
                         try:
                             wf = diagram_wavefunctions[\
                                     diagram_wavefunctions.index(wf)]
-                        except ValueError, error:
+                        except ValueError as error:
                             # Update wf number
                             wf_number = wf_number + 1
                             wf.set('number', wf_number)
@@ -4079,8 +4079,8 @@ class HelasMatrixElement(base_objects.Ph
 
                 # Ignore possibility for unoptimizated generation for now
                 if len(my_diagrams) > 1:
-                    raise self.PhysicsObjectError, \
-                          "Decay chains not yet prepared for GPU"
+                    raise self.PhysicsObjectError( \
+                          "Decay chains not yet prepared for GPU")
 
                 for diagram in my_diagrams:
 
@@ -4391,8 +4391,8 @@ class HelasMatrixElement(base_objects.Ph
                                  diagrams)
 
             if len(wf_diagrams) > 1:
-                raise self.PhysicsObjectError, \
-                      "Decay chains not yet prepared for GPU"
+                raise self.PhysicsObjectError( \
+                      "Decay chains not yet prepared for GPU")
 
             for diagram in wf_diagrams:
 
@@ -4749,12 +4749,12 @@ class HelasMatrixElement(base_objects.Ph
                           tuple(amp.get('color_indices')) == diag_tuple[1],
                           diagrams[diag_tuple[0]].get('amplitudes'))
                 if not res_amps:
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                           """No amplitude found for color structure
                             %s and color index chain (%s) (diagram %i)""" % \
                             (col_basis_elem,
                              str(diag_tuple[1]),
-                             diag_tuple[0])
+                             diag_tuple[0]))
 
                 for res_amp in res_amps:
                     col_amp.append(((res_amp.get('fermionfactor'),
@@ -5150,15 +5150,15 @@ class HelasDecayChainProcess(base_object
 
         if name == 'core_processes':
             if not isinstance(value, HelasMatrixElementList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid HelasMatrixElementList object" % \
-                        str(value)
+                        str(value))
 
         if name == 'decay_chains':
             if not isinstance(value, HelasDecayChainProcessList):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                      "%s is not a valid HelasDecayChainProcessList object" % \
-                     str(value)
+                     str(value))
 
         return True
 
@@ -5441,8 +5441,8 @@ class HelasMultiProcess(base_objects.Phy
 
         if name == 'matrix_elements':
             if not isinstance(value, HelasMatrixElementList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid HelasMatrixElementList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid HelasMatrixElementList object" % str(value))
         return True
 
     def get_sorted_keys(self):
@@ -5522,8 +5522,8 @@ class HelasMultiProcess(base_objects.Phy
         tree-level Nc and present for structural reasons only."""
         
         if compute_loop_nc:
-            raise MadGraph5Error, "The tree-level function 'process_color' "+\
-             " of class HelasMultiProcess cannot be called with a value for compute_loop_nc"
+            raise MadGraph5Error( "The tree-level function 'process_color' "+\
+             " of class HelasMultiProcess cannot be called with a value for compute_loop_nc")
         
         # Define the objects stored in the contained color_information
         for key in color_information:
@@ -5741,8 +5741,8 @@ class HelasMultiProcess(base_objects.Phy
                                                 compute_loop_nc=compute_loop_nc)                    
 
         if not matrix_elements:
-            raise InvalidCmd, \
-                  "No matrix elements generated, check overall coupling orders"
+            raise InvalidCmd( \
+                  "No matrix elements generated, check overall coupling orders")
 
         return matrix_elements
 
diff -rupN MadGraph_pristine/madgraph/__init__.py ../contrib/MadGraph/madgraph/__init__.py
--- MadGraph_pristine/madgraph/__init__.py	2020-10-27 21:41:37.889090214 +1100
+++ ../contrib/MadGraph/madgraph/__init__.py	2020-10-29 23:48:54.800704032 +1100
@@ -46,5 +46,5 @@ if ReadWrite:
             os.remove(tmp_path)
             shutil.copy(pjoin(MG5DIR, 'Template','LO','Source','.make_opts'),
                     pjoin(MG5DIR, 'Template','LO','Source','make_opts'))
-    except Exception,error:
+    except Exception as error:
         pass
diff -rupN MadGraph_pristine/madgraph/interface/common_run_interface.py ../contrib/MadGraph/madgraph/interface/common_run_interface.py
--- MadGraph_pristine/madgraph/interface/common_run_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/common_run_interface.py	2020-10-29 23:56:46.740855322 +1100
@@ -33,7 +33,11 @@ import time
 import traceback
 import urllib
 import glob
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
 
 try:
     import readline
@@ -211,16 +215,16 @@ class CheckValidForCmd(object):
         
         # Check that MG5 directory is present .
         if MADEVENT and not self.options['mg5_path']:
-            raise self.InvalidCmd, '''The automatic computations of widths requires that MG5 is installed on the system.
-            You can install it and set his path in ./Cards/me5_configuration.txt'''
+            raise self.InvalidCmd('''The automatic computations of widths requires that MG5 is installed on the system.
+            You can install it and set his path in ./Cards/me5_configuration.txt''')
         elif MADEVENT:
             sys.path.append(self.options['mg5_path'])
         try:
             import models.model_reader as model_reader
             import models.import_ufo as import_ufo
         except ImportError:
-            raise self.ConfigurationError, '''Can\'t load MG5.
-            The variable mg5_path should not be correctly configure.'''
+            raise self.ConfigurationError('''Can\'t load MG5.
+            The variable mg5_path should not be correctly configure.''')
         
 
         ufo_path = pjoin(self.me_dir,'bin','internal', 'ufomodel')
@@ -258,7 +262,7 @@ class CheckValidForCmd(object):
             if arg.startswith('--output='):
                 output_path = arg.split('=',1)[1]
                 if not os.path.exists(output_path):
-                    raise self.InvalidCmd, 'Invalid Path for the output. Please retry.'
+                    raise self.InvalidCmd('Invalid Path for the output. Please retry.')
                 if not os.path.isfile(output_path):
                     output_path = pjoin(output_path, 'param_card.dat')
                 output['output'] = output_path       
@@ -267,13 +271,13 @@ class CheckValidForCmd(object):
             elif os.path.isfile(arg):
                 ftype = self.detect_card_type(arg)
                 if ftype != 'param_card.dat':
-                    raise self.InvalidCmd , '%s is not a valid param_card.' % arg
+                    raise self.InvalidCmd('%s is not a valid param_card.' % arg)
                 output['path'] = arg
             elif arg.startswith('--path='):
                 arg = arg.split('=',1)[1]
                 ftype = self.detect_card_type(arg)
                 if ftype != 'param_card.dat':
-                    raise self.InvalidCmd , '%s is not a valid param_card.' % arg
+                    raise self.InvalidCmd('%s is not a valid param_card.' % arg)
                 output['path'] = arg
             elif arg.startswith('--'):
                 if "=" in arg:
@@ -281,7 +285,7 @@ class CheckValidForCmd(object):
                     try:
                         value = float(value)
                     except Exception:
-                        raise self.InvalidCmd, '--%s requires integer or a float' % name
+                        raise self.InvalidCmd('--%s requires integer or a float' % name)
                     output[name[2:]] = float(value)
                 elif arg == "--nlo":
                     output["nlo"] = True
@@ -294,13 +298,13 @@ class CheckValidForCmd(object):
                 output['particles'] = set(['all'])
             else:
                 self.help_compute_widths()
-                raise self.InvalidCmd, '%s is not a valid argument for compute_widths' % arg
+                raise self.InvalidCmd('%s is not a valid argument for compute_widths' % arg)
         if self.force:
             output['force'] = True
 
         if not output['particles']:
-            raise self.InvalidCmd, '''This routines requires at least one particle in order to compute
-            the related width'''
+            raise self.InvalidCmd('''This routines requires at least one particle in order to compute
+            the related width''')
             
         if output['output'] is None:
             output['output'] = output['path']
@@ -654,7 +658,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 closed. If no instance is running, you can delete the file
                 %s and try again.''' % pjoin(me_dir,'RunWeb')
                 self.stop_for_runweb = True
-                raise AlreadyRunning, message
+                raise AlreadyRunning(message)
             else:
                 self.write_RunWeb(me_dir)
 
@@ -689,7 +693,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
     def writeRunWeb(me_dir):
         pid = os.getpid()
         fsock = open(pjoin(me_dir,'RunWeb'),'w')
-        fsock.write(`pid`)
+        fsock.write(repr(pid))
         fsock.close()        
         
     class RunWebHandling(object):
@@ -719,7 +723,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 (for this exact same directory). Please wait that this is instance is 
                 closed. If no instance is running, you can delete the file
                 %s and try again.''' % (pid, pjoin(me_dir, 'RunWeb'))
-                                raise AlreadyRunning, message
+                                raise AlreadyRunning(message)
                         elif warnifpresent:
                             if isinstance( warnifpresent, bool):
                                 logger.warning("%s/RunWeb is present. Please check that only one run is running in that directory.")
@@ -811,7 +815,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             else:
                 try:                                
                     self.results.resetall(self.me_dir)
-                except Exception, error:
+                except Exception as error:
                     logger.debug(error)
                     # Maybe the format was updated -> try fresh
                     model = self.find_model_name()
@@ -845,7 +849,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
         else:   
             try:
                 self.cluster.modify_interface(self)
-            except Exception, error:
+            except Exception as error:
                 misc.sprint(str(error))
                 
         keepwidth = False
@@ -991,7 +995,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             elif path == 'MadLoopParams.dat':
                 return 'MadLoopParams'
             else:
-                raise Exception, 'Unknow cards name %s' % path
+                raise Exception('Unknow cards name %s' % path)
 
         # Ask the user if he wants to edit any of the files
         #First create the asking text
@@ -1447,7 +1451,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 if not self.options['pythia-pgs_path']:
                     return
             else:
-                raise self.InvalidCmd, 'Invalid mode %s' % mode
+                raise self.InvalidCmd('Invalid mode %s' % mode)
         elif mode == 'reweight' and not output:
                 output = pjoin(self.me_dir, 'HTML',self.run_name,
                               'plots_%s.html' % tag)
@@ -1456,7 +1460,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             if os.path.exists(event_path+'.gz'):
                 misc.gunzip('%s.gz' % event_path)
             else:
-                raise self.InvalidCmd, 'Events file %s does not exist' % event_path
+                raise self.InvalidCmd('Events file %s does not exist' % event_path)
         elif event_path.endswith(".gz"):
              misc.gunzip(event_path)
              event_path = event_path[:-3]
@@ -1503,7 +1507,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
 
             logger.info("Plots for %s level generated, see %s" % \
                          (mode, output))
-        except OSError, error:
+        except OSError as error:
             logger.error('fail to create plot: %s. Please check that MadAnalysis is correctly installed.' % error)
 
         self.update_status('End Plots for %s level' % mode, level = mode.lower(),
@@ -1515,7 +1519,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
         """Run hep2lhe on the file Events/pythia_events.hep"""
 
         if not self.options['pythia-pgs_path']:
-            raise self.InvalidCmd, 'No pythia-pgs path defined'
+            raise self.InvalidCmd('No pythia-pgs path defined')
 
         pydir = pjoin(self.options['pythia-pgs_path'], 'src')
         eradir = self.options['exrootanalysis_path']
@@ -1548,7 +1552,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                              'pythia_events.lhe',
                              pjoin(self.run_name, '%s_pythia_lhe_events.root' % self.run_tag)],
                             cwd=pjoin(self.me_dir,'Events'))
-                except Exception, error:
+                except Exception as error:
                     misc.sprint('ExRootLHEFConverter fails', str(error),
                                                                      log=logger)
                     pass
@@ -1675,14 +1679,14 @@ class CommonRunCmd(HelpToCmd, CheckValid
                                  '--remove_wgts=', '--keep_wgts','--start_id=', '--weight_format=',
                                  '--weight_info='))
                 for o in opts):
-            raise self.InvalidCmd, "command systematics called with invalid option syntax. Please retry."
+            raise self.InvalidCmd("command systematics called with invalid option syntax. Please retry.")
         
         # check that we have define the input
         if len(args) == 0:
             if self.run_name:
                 args[0] = self.run_name
             else:
-                raise self.InvalidCmd, 'no default run. Please specify the run_name'
+                raise self.InvalidCmd('no default run. Please specify the run_name')
         
         if args[0] != self.run_name:
             self.set_run_name(args[0])
@@ -1707,7 +1711,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                     args[0] = p
                     break
             else:
-                raise self.InvalidCmd, 'Invalid run name. Please retry'
+                raise self.InvalidCmd('Invalid run name. Please retry')
         elif self.options['nb_core'] != 1:
             lhe = lhe_parser.EventFile(args[0])
             nb_event = len(lhe)
@@ -1721,20 +1725,20 @@ class CommonRunCmd(HelpToCmd, CheckValid
     
         lhaid = [self.run_card.get_lhapdf_id()]
         if 'store_rwgt_info' in self.run_card and not self.run_card['store_rwgt_info']:
-            raise self.InvalidCmd,  "The events was not generated with store_rwgt_info=True. Can not evaluate systematics error on this event file."
+            raise self.InvalidCmd("The events was not generated with store_rwgt_info=True. Can not evaluate systematics error on this event file.")
         elif 'use_syst'  in self.run_card:
             if not self.run_card['use_syst']:
-                raise self.InvalidCmd,  "The events was not generated with use_syst=True. Can not evaluate systematics error on this event file."
+                raise self.InvalidCmd("The events was not generated with use_syst=True. Can not evaluate systematics error on this event file.")
             elif self.proc_characteristics['ninitial'] ==1:
                 if '--from_card' in opts:
                     logger.warning('systematics not available for decay processes. Bypass it')
                     return
                 else:
-                    raise self.InvalidCmd, 'systematics not available for decay processes.'
+                    raise self.InvalidCmd('systematics not available for decay processes.')
                 
         try:
             pdfsets_dir = self.get_lhapdf_pdfsetsdir()
-        except Exception, error:
+        except Exception as error:
             logger.debug(str(error))
             logger.warning('Systematic computation requires lhapdf to run. Bypass Systematics')
             return
@@ -1769,7 +1773,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
         # Copy all the relevant PDF sets
         try:
             [self.copy_lhapdf_set([onelha], pdfsets_dir, require_local=False) for onelha in lhaid]
-        except Exception, error:
+        except Exception as error:
             logger.debug(str(error))
             logger.warning('impossible to download all the pdfsets. Bypass systematics')
             return
@@ -1958,15 +1962,15 @@ class CommonRunCmd(HelpToCmd, CheckValid
             
         # Check that MG5 directory is present .
         if MADEVENT and not self.options['mg5_path']:
-            raise self.InvalidCmd, '''The module reweight requires that MG5 is installed on the system.
-            You can install it and set its path in ./Cards/me5_configuration.txt'''
+            raise self.InvalidCmd('''The module reweight requires that MG5 is installed on the system.
+            You can install it and set its path in ./Cards/me5_configuration.txt''')
         elif MADEVENT:
             sys.path.append(self.options['mg5_path'])
         try:
             import madgraph.interface.reweight_interface as reweight_interface
         except ImportError:
-            raise self.ConfigurationError, '''Can\'t load Reweight module.
-            The variable mg5_path might not be correctly configured.'''
+            raise self.ConfigurationError('''Can\'t load Reweight module.
+            The variable mg5_path might not be correctly configured.''')
         
 
                         
@@ -2012,7 +2016,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                     line = p.stdout.readline()
                     if any(t in line for t in ['INFO:', 'WARNING:', 'CRITICAL:', 'ERROR:', 'root:','KEEP:']) and \
                        not '***********' in line:
-                            print line[:-1].replace('INFO', 'REWEIGHT').replace('KEEP:','')
+                            print(line[:-1].replace('INFO', 'REWEIGHT').replace('KEEP:',''))
                     elif __debug__ and line:
                         logger.debug(line[:-1])
                 if p.returncode !=0:
@@ -2048,7 +2052,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 self.check_decay_events(new_args) 
                 try:
                     os.remove(pjoin(self.me_dir,'rw_me','rwgt.pkl'))
-                except Exception, error:
+                except Exception as error:
                     pass
                 # prepare multi-core  job:
                 import madgraph.various.lhe_parser as lhe_parser
@@ -2105,7 +2109,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 if any(os.path.exists('%s_%s_debug.log' % (f, self.run_tag)) for f in all_lhe):
                     for f in all_lhe:
                         if os.path.exists('%s_%s_debug.log' % (f, self.run_tag)):
-                            raise Exception, "Some of the run failed: Please read %s_%s_debug.log" % (f, self.run_tag) 
+                            raise Exception("Some of the run failed: Please read %s_%s_debug.log" % (f, self.run_tag) )
                 
                 
                 if 'event_norm' in self.run_card and self.run_card['event_norm'] in ['average','bias']:
@@ -2839,8 +2843,8 @@ class CommonRunCmd(HelpToCmd, CheckValid
                     reco_event_file = misc.glob('*.lhe.gz',pjoin(reco_output,'Output','_reco_events','lheEvents0_%d'%MA5_run_number))+\
                                        misc.glob('*.root',pjoin(reco_output,'Output','_reco_events', 'RecoEvents0_%d'%MA5_run_number))
                     if len(reco_event_file)==0:
-                        raise MadGraph5Error, "MadAnalysis5 failed to produce the "+\
-                  "reconstructed event file for reconstruction '%s'."%MA5_runtag[6:]
+                        raise MadGraph5Error("MadAnalysis5 failed to produce the "+\
+                  "reconstructed event file for reconstruction '%s'."%MA5_runtag[6:])
                     reco_event_file = reco_event_file[0]
                     # move the reconstruction output to the HTML directory
                     shutil.move(reco_output,pjoin(self.me_dir,'HTML',
@@ -2951,7 +2955,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             delphes3 = False
             prog = '../bin/internal/run_delphes'
             if filepath and '.hepmc' in filepath[:-10]:
-                raise self.InvalidCmd, 'delphes2 do not support hepmc'
+                raise self.InvalidCmd('delphes2 do not support hepmc')
         else:
             delphes3 = True
             prog =  '../bin/internal/run_delphes3'
@@ -3131,7 +3135,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 misc.mod_compilator(self.me_dir, args[1], current, 'cpp')
         elif args[0] == "run_mode":
             if not args[1] in [0,1,2,'0','1','2']:
-                raise self.InvalidCmd, 'run_mode should be 0, 1 or 2.'
+                raise self.InvalidCmd('run_mode should be 0, 1 or 2.')
             self.cluster_mode = int(args[1])
             self.options['run_mode'] =  self.cluster_mode
         elif args[0] in  ['cluster_type', 'cluster_queue', 'cluster_temp_path']:
@@ -3239,20 +3243,20 @@ class CommonRunCmd(HelpToCmd, CheckValid
             cluster_name = opt['cluster_type']
             if cluster_name in cluster.from_name:
                 self.cluster = cluster.from_name[cluster_name](**opt)
-                print "using cluster:", cluster_name
+                print("using cluster:", cluster_name)
             else:
-                print "cluster_class", cluster_name
-                print self.plugin_path
+                print("cluster_class", cluster_name)
+                print(self.plugin_path)
                 # Check if a plugin define this type of cluster
                 # check for PLUGIN format
                 cluster_class = misc.from_plugin_import(self.plugin_path, 
                                             'new_cluster', cluster_name,
                                             info = 'cluster handling will be done with PLUGIN: %(plug)s' )
-                print type(cluster_class)
+                print(type(cluster_class))
                 if cluster_class:
                     self.cluster = cluster_class(**self.options)
                 else:
-                    raise self.InvalidCmd, "%s is not recognized as a supported cluster format." % cluster_name              
+                    raise self.InvalidCmd("%s is not recognized as a supported cluster format." % cluster_name)              
     def check_param_card(self, path, run=True, dependent=False):
         """
         1) Check that no scan parameter are present
@@ -3287,7 +3291,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
         if pattern_scan.search(text):
             if not isinstance(interface, cmd.CmdShell):
                 # we are in web mode => forbid scan due to security risk
-                raise Exception, "Scan are not allowed in web mode"
+                raise Exception("Scan are not allowed in web mode")
             # at least one scan parameter found. create an iterator to go trough the cards
             main_card = iterator_class(text)
             interface.param_card_iterator = main_card
@@ -3382,7 +3386,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             
             
             
-        raise Exception, 'fail to find a way to handle Auto width'
+        raise Exception('fail to find a way to handle Auto width')
         
         
     def store_scan_result(self):
@@ -3437,7 +3441,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
 
         try:
             self.update_status('', level=None)
-        except Exception, error:
+        except Exception as error:
             pass
 
         self.gen_card_html()
@@ -3662,8 +3666,8 @@ class CommonRunCmd(HelpToCmd, CheckValid
         # First need to load MadSpin
         # Check that MG5 directory is present .
         if MADEVENT and not self.options['mg5_path']:
-            raise self.InvalidCmd, '''The module decay_events requires that MG5 is installed on the system.
-            You can install it and set its path in ./Cards/me5_configuration.txt'''
+            raise self.InvalidCmd('''The module decay_events requires that MG5 is installed on the system.
+            You can install it and set its path in ./Cards/me5_configuration.txt''')
         elif MADEVENT:
             sys.path.append(self.options['mg5_path'])
         try:
@@ -3673,8 +3677,8 @@ class CommonRunCmd(HelpToCmd, CheckValid
             if __debug__:
                 raise
             else:
-                raise self.ConfigurationError, '''Can\'t load MadSpin
-            The variable mg5_path might not be correctly configured.'''
+                raise self.ConfigurationError('''Can\'t load MadSpin
+            The variable mg5_path might not be correctly configured.''')
 
         self.update_status('Running MadSpin', level='madspin')
         if not '-from_cards' in line and '-f' not in line:
@@ -3838,15 +3842,15 @@ class CommonRunCmd(HelpToCmd, CheckValid
                 
         # Check that MG5 directory is present .
         if MADEVENT and not self.options['mg5_path']:
-            raise self.InvalidCmd, '''The module reweight requires that MG5 is installed on the system.
-            You can install it and set its path in ./Cards/me5_configuration.txt'''
+            raise self.InvalidCmd('''The module reweight requires that MG5 is installed on the system.
+            You can install it and set its path in ./Cards/me5_configuration.txt''')
         elif MADEVENT:
             sys.path.append(self.options['mg5_path'])
         try:
             import madgraph.interface.reweight_interface as reweight_interface
         except ImportError:
-            raise self.ConfigurationError, '''Can\'t load Reweight module.
-            The variable mg5_path might not be correctly configured.'''
+            raise self.ConfigurationError('''Can\'t load Reweight module.
+            The variable mg5_path might not be correctly configured.''')
               
 
         # load the name of the event file
@@ -4065,7 +4069,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                             shutil.rmtree(pjoin(self.me_dir, 'lib', 'PDFsets', name))
                         else:
                             os.remove(pjoin(self.me_dir, 'lib', 'PDFsets', name))
-                    except Exception, error:
+                    except Exception as error:
                         logger.debug('%s', error)
         
         if self.options["cluster_local_path"]:
@@ -4093,7 +4097,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
                             shutil.rmtree(pjoin(pdfsets_dir, name))
                         else:
                             os.remove(pjoin(pdfsets_dir, name))
-                    except Exception, error:
+                    except Exception as error:
                         logger.debug('%s', error)
             if not require_local and (os.path.exists(pjoin(pdfsets_dir, pdfset)) or \
                                     os.path.isdir(pjoin(pdfsets_dir, pdfset))):
@@ -4218,9 +4222,9 @@ class CommonRunCmd(HelpToCmd, CheckValid
                                                               filename, 
                                         lhapdf_version, alternate_path)
                     else:
-                        raise MadGraph5Error, \
+                        raise MadGraph5Error( \
                 'Could not download %s into %s. Please try to install it manually.' \
-                    % (filename, pdfsets_dir) 
+                    % (filename, pdfsets_dir) )
                 else:
                     return CommonRunCmd.install_lhapdf_pdfset_static(lhapdf_config, None, 
                                                               filename, 
@@ -4237,22 +4241,22 @@ class CommonRunCmd(HelpToCmd, CheckValid
                                                               filename, 
                                         lhapdf_version, alternate_path)
                     else:
-                        raise MadGraph5Error, \
+                        raise MadGraph5Error( \
                 'Could not download %s into %s. Please try to install it manually.' \
-                    % (filename, pdfsets_dir) 
+                    % (filename, pdfsets_dir) )
                 else:
                     return CommonRunCmd.install_lhapdf_pdfset_static(lhapdf_config, None, 
                                                               filename, 
                                         lhapdf_version, alternate_path)
             else:  
-                raise MadGraph5Error, \
+                raise MadGraph5Error( \
                 'Could not download %s into %s. Please try to install it manually.' \
-                    % (filename, pdfsets_dir)                          
+                    % (filename, pdfsets_dir))                          
             
         else:                    
-            raise MadGraph5Error, \
+            raise MadGraph5Error( \
                 'Could not download %s into %s. Please try to install it manually.' \
-                    % (filename, pdfsets_dir)
+                    % (filename, pdfsets_dir))
 
 
 
@@ -4270,7 +4274,7 @@ class CommonRunCmd(HelpToCmd, CheckValid
             if os.path.exists('%s.index' % pdfsets_dir):
                 indexfile = '%s.index' % pdfsets_dir
             else:
-                raise MadGraph5Error, 'index of lhapdf file not found'
+                raise MadGraph5Error('index of lhapdf file not found')
             pdfsets_lines = \
                     [l for l in open(indexfile).read().split('\n') if l.strip() and \
                         not '90cl' in l]
@@ -4308,9 +4312,9 @@ class CommonRunCmd(HelpToCmd, CheckValid
             lhapdf_version = \
                     subprocess.Popen([lhapdf_config, '--version'], 
                         stdout = subprocess.PIPE).stdout.read().strip()
-        except OSError, error:
+        except OSError as error:
             if error.errno == 2:
-                raise Exception, 'lhapdf executable (%s) is not found on your system. Please install it and/or indicate the path to the correct executable in input/mg5_configuration.txt' % self.options['lhapdf']
+                raise Exception('lhapdf executable (%s) is not found on your system. Please install it and/or indicate the path to the correct executable in input/mg5_configuration.txt' % self.options['lhapdf'])
             else:
                 raise
                 
@@ -4825,15 +4829,15 @@ class AskforEditCard(cmd.OneLinePathComp
         if len(args)==0 or (len(args) == 1 and hasattr(self, 'do_%s' % args[0])):
             out = cmd.BasicCmd.do_help(self, line)
             if len(args)==0:
-                print 'Allowed Argument'
-                print '================'
-                print '\t'.join(self.allow_arg)
-                print 
-                print 'Special shortcut: (type help <name>)'
-                print '===================================='
-                print '    syntax: set <name> <value>' 
-                print '\t'.join(self.special_shortcut)
-                print
+                print( 'Allowed Argument')
+                print( '================')
+                print( '\t'.join(self.allow_arg))
+                print( )
+                print( 'Special shortcut: (type help <name>)')
+                print( '====================================')
+                print( '    syntax: set <name> <value>' )
+                print( '\t'.join(self.special_shortcut))
+                print()
             if banner:
                 logger.info('*** END HELP ***', '$MG:BOLD')  
             return out      
@@ -4841,7 +4845,7 @@ class AskforEditCard(cmd.OneLinePathComp
         # special shortcut:
         if args[0] in self.special_shortcut:    
             if args[0] in self.special_shortcut_help:
-                print self.special_shortcut_help[args[0]]
+                print( self.special_shortcut_help[args[0]])
             if banner:
                 logger.info('*** END HELP ***', '$MG:BOLD')  
             return       
@@ -4862,23 +4866,23 @@ class AskforEditCard(cmd.OneLinePathComp
                     args[0] = 'PY8Card'              
                 if args[0] == 'param_card':
                     logger.info("Param_card information: ", '$MG:color:BLUE')
-                    print "File to define the various model parameter"
+                    print( "File to define the various model parameter")
                     logger.info("List of the Block defined:",'$MG:color:BLUE')
-                    print "\t".join(self.param_card.keys())
+                    print( "\t".join(self.param_card.keys()))
                 elif args[0].startswith('madanalysis5'):
-                    print 'This card allow to make plot with the madanalysis5 package'
-                    print 'An example card is provided. For more information about the '
-                    print 'syntax please refer to: https://madanalysis.irmp.ucl.ac.be/'
-                    print 'or to the user manual [arXiv:1206.1599]'
+                    print( 'This card allow to make plot with the madanalysis5 package')
+                    print( 'An example card is provided. For more information about the ')
+                    print( 'syntax please refer to: https://madanalysis.irmp.ucl.ac.be/')
+                    print( 'or to the user manual [arXiv:1206.1599]')
                     if args[0].startswith('madanalysis5_hadron'):
-                        print 
-                        print 'This card also allow to make recasting analysis'
-                        print 'For more detail, see: arXiv:1407.3278'                   
+                        print() 
+                        print( 'This card also allow to make recasting analysis')
+                        print( 'For more detail, see: arXiv:1407.3278')                   
                 elif hasattr(self, args[0]):
                     logger.info("%s information: " % args[0], '$MG:color:BLUE')
                     print(eval('self.%s' % args[0]).__doc__)
                     logger.info("List of parameter associated", '$MG:color:BLUE')
-                    print "\t".join(eval('self.%s' % args[0]).keys())
+                    print( "\t".join(eval('self.%s' % args[0]).keys()))
                 if banner:
                     logger.info('*** END HELP ***', '$MG:BOLD')  
                 return card
@@ -4967,11 +4971,11 @@ class AskforEditCard(cmd.OneLinePathComp
 
             self.PY8Card.do_help(args[start])
         elif card.startswith('madanalysis5'):
-            print 'MA5'
+            print( 'MA5')
             
             
         elif banner:
-            print "no help available" 
+            print( "no help available" )
           
         if banner:                      
             logger.info('*** END HELP ***', '$MG:BOLD')    
@@ -5301,7 +5305,7 @@ class AskforEditCard(cmd.OneLinePathComp
                     val = [values[str(i)] for i in range(len(values))]
                     try:
                         arg(self)(*val)
-                    except Exception, e:
+                    except Exception as e:
                         logger.warning(str(e))
             return
 
@@ -5441,7 +5445,7 @@ class AskforEditCard(cmd.OneLinePathComp
 
             if args[start] not in self.run_set:
                 if card in self.from_banner or 'run' in self.from_banner:
-                    raise Exception, "change not allowed for this card: event already generated!"
+                    raise Exception("change not allowed for this card: event already generated!")
                 args[start] = [l for l in self.run_set if l.lower() == args[start]][0]
 
             if args[start] in self.conflict and card == '':
@@ -5735,7 +5739,7 @@ class AskforEditCard(cmd.OneLinePathComp
         
         try:
             self.MLcard.set(name, value, user=True)
-        except Exception, error:
+        except Exception as error:
             logger.warning("Fail to change parameter. Please Retry. Reason: %s." % error)
             return
         logger.info('modify parameter %s of the MadLoopParam.dat to %s' % (name, value),'$MG:BOLD')
@@ -5745,7 +5749,7 @@ class AskforEditCard(cmd.OneLinePathComp
     def setPY8(self, name, value, default=False):
         try:
             self.PY8Card.userSet(name, value)
-        except Exception, error:
+        except Exception as error:
             logger.warning("Fail to change parameter. Please Retry. Reason: %s." % error)
             return
         logger.info('modify parameter %s of the pythia8_card.dat to %s' % (name, value), '$MG:BOLD')
@@ -5804,7 +5808,7 @@ class AskforEditCard(cmd.OneLinePathComp
                   (self.run_card['nb_proton1'] != self.run_card['nb_proton2'] or
                  self.run_card['nb_neutron1'] != self.run_card['nb_neutron2'] or
                  self.run_card['mass_ion1'] != self.run_card['mass_ion2']):
-                raise Exception, "Heavy ion profile for both beam are different but the symmetry used forbids it. \n Please generate your process with \"set group_subprocesses False\"."
+                raise Exception("Heavy ion profile for both beam are different but the symmetry used forbids it. \n Please generate your process with \"set group_subprocesses False\".")
             
             # check the status of small width status from LO
             for param in self.param_card['decay']:
@@ -5841,13 +5845,13 @@ class AskforEditCard(cmd.OneLinePathComp
                 
             if 'MLM' in proc_charac['limitations']:
                 if self.run_card['dynamical_scale_choice'] == -1:
-                    raise InvalidCmd, "Your model is identified as not fully supported within MG5aMC.\n" +\
+                    raise InvalidCmd("Your model is identified as not fully supported within MG5aMC.\n" +\
                         "As your process seems to be impacted by the issue,\n"+\
-                      "You can NOT run with CKKW dynamical scale for this model. Please choose another one." 
+                      "You can NOT run with CKKW dynamical scale for this model. Please choose another one." )
                 if self.run_card['ickkw']:
-                    raise InvalidCmd, "Your model is identified as not fully supported within MG5aMC.\n" +\
+                    raise InvalidCmd("Your model is identified as not fully supported within MG5aMC.\n" +\
                         "As your process seems to be impacted by the issue,\n" +\
-                      "You can NOT run with MLM matching/merging. Please check if merging outside MG5aMC are suitable or refrain to use merging with this model" 
+                      "You can NOT run with MLM matching/merging. Please check if merging outside MG5aMC are suitable or refrain to use merging with this model" )
                 
 
         ########################################################################
@@ -5863,17 +5867,17 @@ class AskforEditCard(cmd.OneLinePathComp
 
             if proc_charac and 'MLM' in proc_charac['limitations']:
                 if self.run_card['ickkw']:
-                    raise Exception, "Your model is identified as not fully supported within MG5aMC.\n" +\
-                      "You can NOT run with FxFx/UnLOPS matching/merging. Please check if merging outside MG5aMC are suitable or refrain to use merging with this model" 
+                    raise Exception("Your model is identified as not fully supported within MG5aMC.\n" +\
+                      "You can NOT run with FxFx/UnLOPS matching/merging. Please check if merging outside MG5aMC are suitable or refrain to use merging with this model" )
                             
             
             for pdg in set(self.run_card['pt_min_pdg'].keys()+self.run_card['pt_max_pdg'].keys()+
                            self.run_card['mxx_min_pdg'].keys()): 
             
                 if int(pdg)<0:
-                    raise Exception, "For PDG specific cuts, always use positive PDG codes: the cuts are applied to both particles and anti-particles"
+                    raise Exception("For PDG specific cuts, always use positive PDG codes: the cuts are applied to both particles and anti-particles")
                 if self.param_card.get_value('mass', int(pdg), default=0) ==0:
-                    raise Exception, "For NLO runs, you can use PDG specific cuts only for massive particles: (failed for %s)" % pdg
+                    raise Exception("For NLO runs, you can use PDG specific cuts only for massive particles: (failed for %s)" % pdg)
         
             # if NLO reweighting is ON: ensure that we keep the rwgt information
             if 'reweight' in self.allow_arg and 'run' in self.allow_arg and \
@@ -5912,10 +5916,10 @@ class AskforEditCard(cmd.OneLinePathComp
             if self.run_card['parton_shower'] == 'PYTHIA8':
                 # First check sanity of PY8
                 if not self.mother_interface.options['pythia8_path']:
-                    raise self.mother_interface.InvalidCmd, 'Pythia8 is not correctly specified  to MadGraph5_aMC@NLO'
+                    raise self.mother_interface.InvalidCmd('Pythia8 is not correctly specified  to MadGraph5_aMC@NLO')
                 executable = pjoin(self.mother_interface.options['pythia8_path'], 'bin', 'pythia8-config')
                 if not os.path.exists(executable):
-                    raise self.mother.InvalidCmd, 'Pythia8 is not correctly specified to MadGraph5_aMC@NLO'                
+                    raise self.mother.InvalidCmd('Pythia8 is not correctly specified to MadGraph5_aMC@NLO')                
                 
                 # 2. take the compilation flag of PY8 from pythia8-config
                 libs , paths = [], []
@@ -5986,7 +5990,7 @@ class AskforEditCard(cmd.OneLinePathComp
             if self.param_consistency:
                 try:
                     self.do_update('dependent', timer=20)
-                except MadGraph5Error, error:
+                except MadGraph5Error as error:
                     if 'Missing block:' in str(error):
                         self.fail_due_to_format +=1
                         if self.fail_due_to_format == 10:
@@ -6046,14 +6050,14 @@ class AskforEditCard(cmd.OneLinePathComp
             try:
                 param_card_mod.convert_to_mg5card(self.paths['param'])
                 logger.info('card updated')
-            except Exception, error:
+            except Exception as error:
                 logger.warning('failed to update to slha2 due to %s' % error)
             self.param_card = param_card_mod.ParamCard(self.paths['param'])
         elif args[0] == 'to_slha1':
             try:
                 param_card_mod.convert_to_slha1(self.paths['param'])
                 logger.info('card updated')
-            except Exception, error:
+            except Exception as error:
                 logger.warning('failed to update to slha1 due to %s' % error)
             self.param_card = param_card_mod.ParamCard(self.paths['param'])            
         elif args[0] == 'to_full':
@@ -6083,7 +6087,7 @@ class AskforEditCard(cmd.OneLinePathComp
             if name in self.modified_card:
                 self.modified_card.remove(name)
         else:
-            raise Exception, "Need to add the associate writter proxy for %s" % name
+            raise Exception("Need to add the associate writter proxy for %s" % name)
         
     def write_card_run(self):
         """ write the run_card """
@@ -6124,7 +6128,7 @@ class AskforEditCard(cmd.OneLinePathComp
                            'This might create trouble for external program (like MadSpin/shower/...)\n'+\
                            'The update can be forced without timer by typing \'update dependent\' at the time of the card edition')
             modify =False
-        except Exception,error:
+        except Exception as error:
             logger.debug(str(error))
             logger.warning('Failed to update dependent parameter. This might create trouble for external program (like MadSpin/shower/...)')
             signal.alarm(0)
@@ -6159,9 +6163,9 @@ class AskforEditCard(cmd.OneLinePathComp
                 if key not in input_in_block:
                     param = block.get(key)
                     if blockname != 'decay':
-                        text.append('\t%s\t%s # %s\n' % (' \t'.join([`i` for i in param.lhacode]), param.value, param.comment))
+                        text.append('\t%s\t%s # %s\n' % (' \t'.join([repr(i) for i in param.lhacode]), param.value, param.comment))
                     else: 
-                        text.append('DECAY \t%s\t%s # %s\n' % (' \t'.join([`i` for i in param.lhacode]), param.value, param.comment))
+                        text.append('DECAY \t%s\t%s # %s\n' % (' \t'.join([repr(i) for i in param.lhacode]), param.value, param.comment))
                     add_entry += 1
             if add_entry:
                 text.append('\n')
@@ -6402,7 +6406,7 @@ class AskforEditCard(cmd.OneLinePathComp
 
         try:
             out = self.mother_interface.do_compute_widths(line)
-        except InvalidCmd, error:
+        except InvalidCmd as error:
             logger.error("Invalid command: %s " % error)
         else:
             if hasattr(self, 'run_card'):
@@ -6433,11 +6437,11 @@ class AskforEditCard(cmd.OneLinePathComp
         """help for command decay which modifies MadSpin_card"""
         
         signal.alarm(0) # avoid timer if any
-        print '--syntax: decay PROC [--add]'
-        print ' '
-        print '  modify the madspin_card to modify the decay of the associate particle.'
-        print '  and define it to PROC.'
-        print '  if --add is present, just add a new decay for the associate particle.'
+        print( '--syntax: decay PROC [--add]')
+        print( ' ')
+        print( '  modify the madspin_card to modify the decay of the associate particle.')
+        print( '  and define it to PROC.')
+        print( '  if --add is present, just add a new decay for the associate particle.')
         
     def complete_compute_widths(self, text, line, begidx, endidx, **opts):
         prev_timer = signal.alarm(0) # avoid timer if any
@@ -6545,7 +6549,7 @@ class AskforEditCard(cmd.OneLinePathComp
             elif os.path.exists(pjoin(self.me_dir,'Cards',card)):
                 path = pjoin(self.me_dir,'Cards',card)
             else:
-                raise Exception, 'unknow path'
+                raise Exception('unknow path')
             
             # handling the various option on where to write the line            
             if args[1] == '--clean':
@@ -6605,7 +6609,7 @@ class AskforEditCard(cmd.OneLinePathComp
                     new_line = re.split(search_pattern,line)[-1].strip()
                     if new_line.startswith(('--before_line=','--after_line')):
                         return self.do_add('%s %s' % (args[0], new_line))   
-                    raise Exception, 'invalid regular expression: not found in file'
+                    raise Exception('invalid regular expression: not found in file')
                 # found the line position "posline"
                 # need to check if the a fail savety is present
                 new_line = re.split(search_pattern,line)[-1].strip()
@@ -6632,7 +6636,7 @@ class AskforEditCard(cmd.OneLinePathComp
                     if re.search(pattern, l):
                         break
                 else:
-                    raise Exception, 'invalid regular expression: not found in file'
+                    raise Exception('invalid regular expression: not found in file')
                 split.insert(posline, re.split(search_pattern,line)[-1])
                 ff = open(path,'w')
                 ff.write('\n'.join(split))
@@ -6673,11 +6677,11 @@ class AskforEditCard(cmd.OneLinePathComp
         """Help associated to the asperge command"""
         signal.alarm(0)
 
-        print '-- syntax: asperge [options]'
-        print '   Call ASperGe to diagonalize all mass matrices in the model.'
-        print '   This works only if the ASperGE module is part of the UFO model (a subdirectory).'
-        print '   If you specify some names after the command (i.e. asperge m1 m2) then ASperGe will only'
-        print '   diagonalize the associate mass matrices (here m1 and m2).'
+        print( '-- syntax: asperge [options]')
+        print( '   Call ASperGe to diagonalize all mass matrices in the model.')
+        print( '   This works only if the ASperGE module is part of the UFO model (a subdirectory).')
+        print( '   If you specify some names after the command (i.e. asperge m1 m2) then ASperGe will only')
+        print( '   diagonalize the associate mass matrices (here m1 and m2).')
 
     def complete_asperge(self, text, line, begidx, endidx, formatting=True):
         prev_timer = signal.alarm(0) # avoid timer if any
@@ -6715,7 +6719,7 @@ class AskforEditCard(cmd.OneLinePathComp
             logger.info('ASperGe has been detected but is not compiled. Running the compilation now.')
             try:
                 misc.compile(cwd=path,shell=True)
-            except MadGraph5Error, error:
+            except MadGraph5Error as error:
                 logger.error('''ASperGe failed to compile. Note that gsl is needed
      for this compilation to go trough. More information on how to install this package on
      http://www.gnu.org/software/gsl/
@@ -6822,7 +6826,7 @@ class AskforEditCard(cmd.OneLinePathComp
 
         try:
             self.mother_interface.exec_cmd('open %s' % path)
-        except InvalidCmd, error:
+        except InvalidCmd as error:
             if str(error) != 'No default path for this file':
                 raise
             if answer == 'transfer_card.dat':
@@ -6983,7 +6987,7 @@ def scanparamcardhandling(input_path=lam
                         set_run_name(obj)(next_name)
                         try:
                             original_fct(obj, *args, **opts)
-                        except ignoreerror, error:
+                        except ignoreerror as error:
                             param_card_iterator.store_entry(next_name, {'exception': error})
                         else:
                             param_card_iterator.store_entry(next_name, store_for_scan(obj)(), param_card_path=card_path)
diff -rupN MadGraph_pristine/madgraph/interface/extended_cmd.py ../contrib/MadGraph/madgraph/interface/extended_cmd.py
--- MadGraph_pristine/madgraph/interface/extended_cmd.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/extended_cmd.py	2020-10-29 23:48:54.804703984 +1100
@@ -15,6 +15,7 @@
 """  A file containing different extension of the cmd basic python library"""
 
 
+from io import IOBase
 import logging
 import math
 import os
@@ -41,7 +42,7 @@ try:
     import madgraph.various.misc as misc
     from madgraph import MG5DIR, MadGraph5Error
     MADEVENT = False
-except ImportError, error:
+except ImportError as error:
     try:
         import internal.misc as misc
     except:
@@ -65,7 +66,7 @@ def debug(debug_only=True):
         def deco_f(*args, **opt):
             try:
                 return f(*args, **opt)
-            except Exception, error:
+            except Exception as error:
                 logger.error(error)
                 logger.error(traceback.print_exc(file=sys.stdout))
                 return
@@ -391,7 +392,7 @@ class OriginalCmd(object):
         nonstrings = [i for i in range(len(list))
                         if not isinstance(list[i], str)]
         if nonstrings:
-            raise TypeError, ("list[i] not a string for i in %s" %
+            raise TypeError("list[i] not a string for i in %s" %
                               ", ".join(map(str, nonstrings)))
         size = len(list)
         if size == 1:
@@ -541,7 +542,7 @@ class BasicCmd(OriginalCmd):
     
             self.stdout.write(self.prompt+readline.get_line_buffer())
             self.stdout.flush()
-        except Exception, error:
+        except Exception as error:
             if __debug__:
                 logger.error(error)
             
@@ -596,9 +597,9 @@ class BasicCmd(OriginalCmd):
                 else:
                     try:
                         compfunc = getattr(self, 'complete_' + cmd)
-                    except AttributeError, error:
+                    except AttributeError as error:
                         compfunc = self.completedefault
-                    except Exception, error:
+                    except Exception as error:
                         misc.sprint(error)
             else:
                 compfunc = self.completenames
@@ -623,8 +624,8 @@ class BasicCmd(OriginalCmd):
                 data = compfunc(Ntext, line, Nbegidx, endidx)
                 self.completion_matches = [p[to_rm:] for p in data 
                                               if len(p)>to_rm]
-             except Exception, error:
-                 print error                
+             except Exception as error:
+                 print(error)                
             else:
                 self.completion_prefix = ''
                 self.completion_matches = compfunc(text, line, begidx, endidx)
@@ -635,7 +636,7 @@ class BasicCmd(OriginalCmd):
         
         try:
             return self.completion_matches[state]
-        except IndexError, error:
+        except IndexError as error:
             # if __debug__:
             #    logger.error('\n Completion ERROR:')
             #    logger.error( error)
@@ -754,13 +755,13 @@ class CheckCmd(object):
         
         if len(args) > 2:
             self.help_save()
-            raise self.InvalidCmd, 'too many arguments for save command.'
+            raise self.InvalidCmd('too many arguments for save command.')
         
         if len(args) == 2:
             if args[0] != 'options':
                 self.help_save()
-                raise self.InvalidCmd, '\'%s\' is not recognized as first argument.' % \
-                                                args[0]
+                raise self.InvalidCmd('\'%s\' is not recognized as first argument.' % \
+                                                args[0])
             else:
                 args.pop(0)           
 
@@ -921,7 +922,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         if intro is not None:
             self.intro = intro
         if self.intro:
-            print self.intro
+            print(self.intro)
         stop = None
         while not stop:
             if self.cmdqueue:
@@ -944,7 +945,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
             try:
                 line = self.precmd(line)
                 stop = self.onecmd(line)
-            except BaseException, error:
+            except BaseException as error:
                 self.error_handling(error, line)
                 if isinstance(error, KeyboardInterrupt):
                     stop = True
@@ -1285,7 +1286,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
             os.remove(self.debug_output)
         try:
             super(Cmd,self).onecmd('history %s' % self.debug_output.replace(' ', '\ '))
-        except Exception, error:
+        except Exception as error:
             logger.error(error)
 
         debug_file = open(self.debug_output, 'a')
@@ -1309,7 +1310,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         # Add options status to the debug file
         try:
             self.do_display('options', debug_file)
-        except Exception, error:
+        except Exception as error:
             debug_file.write('Fail to write options with error %s' % error)
         
         #add the cards:
@@ -1403,7 +1404,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         # Add options status to the debug file
         try:
             self.do_display('options', debug_file)
-        except Exception, error:
+        except Exception as error:
             debug_file.write('Fail to write options with error %s' % error)
             
         if hasattr(self, 'options') and 'crash_on_error' in self.options:
@@ -1512,7 +1513,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
            
         try:
             return self.onecmd_orig(line, **opt)
-        except BaseException, error: 
+        except BaseException as error: 
             return self.error_handling(error, line)
             
     
@@ -1865,7 +1866,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
         
         if len(args) == 0:
             self.help_display()
-            raise self.InvalidCmd, 'display require at least one argument'
+            raise self.InvalidCmd('display require at least one argument')
         
         if args[0] == "options":
             outstr = "Value of current Options:\n" 
@@ -1898,7 +1899,7 @@ class Cmd(CheckCmd, HelpCmd, CompleteCmd
                 except ImportError:
                     try:
                         var = eval(args[1])
-                    except Exception, error:
+                    except Exception as error:
                         outstr += 'EXTERNAL:\nVariable %s is not a external variable\n' % args[1]
                         break
                     else:
@@ -2085,7 +2086,7 @@ class SmartQuestion(BasicCmd):
         for key,value in opts:
             setattr(self, key, value)
         if reprint_opt:
-            print question
+            print(question)
             logger_tuto.info("Need help here? type 'help'", '$MG:BOLD')
             logger_plugin.info("Need help here? type 'help'" , '$MG:BOLD')
         return self.cmdloop()
@@ -2104,8 +2105,8 @@ class SmartQuestion(BasicCmd):
             out[' Recognized command'] = super(SmartQuestion, self).completenames(text,line, *ignored)
             
             return self.deal_multiple_categories(out)
-        except Exception, error:
-            print error
+        except Exception as error:
+            print(error)
     
     completedefault = completenames
 
@@ -2158,7 +2159,7 @@ class SmartQuestion(BasicCmd):
         if reprint_opt:
             if not prev_timer:
                 self.question = pat.sub('',self.question)
-            print self.question.encode('utf8')
+            print(self.question.encode('utf8'))
 
         if self.mother_interface:
             answer = self.mother_interface.check_answer_in_input_file(self, 'EOF', 
@@ -2244,7 +2245,7 @@ class SmartQuestion(BasicCmd):
                 
             else: 
                 raise Exception
-        except Exception,error:
+        except Exception as error:
             if self.wrong_answer < 100:
                 self.wrong_answer += 1
                 logger.warning("""%s not valid argument. Valid argument are in (%s).""" \
@@ -2261,7 +2262,7 @@ class SmartQuestion(BasicCmd):
     
 # a function helper
 def smart_input(input_text, allow_arg=[], default=None):
-    print input_text
+    print(input_text)
     obj = SmartQuestion(allow_arg=allow_arg, default=default)
     return obj.cmdloop()
 
@@ -2289,8 +2290,8 @@ class OneLinePathCompletion(SmartQuestio
             out[' Recognized command'] = BasicCmd.completenames(self, text, line, begidx, endidx)
             
             return self.deal_multiple_categories(out, formatting)
-        except Exception, error:
-            print error
+        except Exception as error:
+            print(error)
             
     def precmd(self, *args):
         """ """
@@ -2307,8 +2308,8 @@ class OneLinePathCompletion(SmartQuestio
             self.stdout.flush()
         try:
             args = Cmd.split_arg(line[0:begidx])
-        except Exception, error:
-            print error
+        except Exception as error:
+            print(error)
 
         # Directory continuation                 
         if args[-1].endswith(os.path.sep):
@@ -2336,10 +2337,10 @@ class OneLinePathCompletion(SmartQuestio
                 reprint_opt = True         
             else:
                 raise Exception
-        except Exception, error:  
-            print """not valid argument. Valid argument are file path or value in (%s).""" \
-                          % ','.join(self.allow_arg)
-            print 'please retry'
+        except Exception as error:  
+            print("""not valid argument. Valid argument are file path or value in (%s).""" \
+                          % ','.join(self.allow_arg))
+            print('please retry')
             reprint_opt = False 
 
         if line != 'EOF':
@@ -2348,7 +2349,7 @@ class OneLinePathCompletion(SmartQuestio
             
 # a function helper
 def raw_path_input(input_text, allow_arg=[], default=None):
-    print input_text
+    print(input_text)
     obj = OneLinePathCompletion(allow_arg=allow_arg, default=default )
     return obj.cmdloop()
 
@@ -2416,7 +2417,7 @@ class ControlSwitch(SmartQuestion):
         question = self.create_question()
         
         #check all default for auto-completion
-        allowed_args = [ `i`+';' for i in range(1, 1+len(self.to_control))] 
+        allowed_args = [ repr(i)+';' for i in range(1, 1+len(self.to_control))] 
         for key in self.switch:
             allowed_args += ['%s=%s;' % (key,s) for s in self.get_allowed(key)]
         # adding special mode
@@ -2552,7 +2553,7 @@ class ControlSwitch(SmartQuestion):
             base, value = line.split(' ', 1)
         elif hasattr(self, 'ans_%s' % line.lower()):
             base, value = line.lower(), None
-        elif line.isdigit() and line in [`i` for i in range(1, len(self.to_control)+1)]:
+        elif line.isdigit() and line in [repr(i) for i in range(1, len(self.to_control)+1)]:
             # go from one valid option to the next in the get_allowed for that option
             base = self.to_control[int(line)-1][0].lower()
             return self.default(base) # just recall this function with the associate name
@@ -2865,7 +2866,7 @@ class ControlSwitch(SmartQuestion):
         #re-order the options in order to have those in cycling order    
         try:
             ind =  self.get_allowed(key).index(self.switch[key])
-        except Exception, err:
+        except Exception as err:
             options = self.get_allowed(key)
         else:
             options = self.get_allowed(key)[ind:]+ self.get_allowed(key)[:ind] 
@@ -3101,7 +3102,7 @@ class ControlSwitch(SmartQuestion):
         try:
             nb_rows, nb_col = os.popen('stty size', 'r').read().split()
             nb_rows, nb_col = int(nb_rows), int(nb_col)
-        except Exception,error:
+        except Exception as error:
             nb_rows, nb_col = 20, 80
         
         #compute information on the length of element to display
@@ -3210,13 +3211,13 @@ class ControlSwitch(SmartQuestion):
 #===============================================================================
 # 
 #===============================================================================
-class CmdFile(file):
+class CmdFile(IOBase):
     """ a class for command input file -in order to debug cmd \n problem"""
     
     def __init__(self, name, opt='rU'):
         
-        file.__init__(self, name, opt)
-        self.text = file.read(self)
+        IOBase.__init__(self, name, opt)
+        self.text = IOBase.read(self)
         self.close()
         self.lines = self.text.split('\n')
     
diff -rupN MadGraph_pristine/madgraph/interface/madgraph_interface.py ../contrib/MadGraph/madgraph/interface/madgraph_interface.py
--- MadGraph_pristine/madgraph/interface/madgraph_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/madgraph_interface.py	2020-10-29 23:54:46.985547804 +1100
@@ -24,6 +24,7 @@ import glob
 import logging
 import optparse
 import os
+import stat
 import pydoc
 import random
 import re
@@ -32,7 +33,12 @@ import subprocess
 import copy
 import sys
 import shutil
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import traceback
 import time
 import inspect
@@ -844,10 +850,10 @@ class CheckValidForCmd(cmd.CheckCmd):
 
         if len(args) < 1:
             self.help_display()
-            raise self.InvalidCmd, 'display requires an argument specifying what to display'
+            raise self.InvalidCmd('display requires an argument specifying what to display')
         if args[0] not in self._display_opts + ['model_list']:
             self.help_display()
-            raise self.InvalidCmd, 'Invalid arguments for display command: %s' % args[0]
+            raise self.InvalidCmd('Invalid arguments for display command: %s' % args[0])
 
         if not self._curr_model:
             raise self.InvalidCmd("No model currently active, please import a model!")
@@ -981,7 +987,7 @@ class CheckValidForCmd(cmd.CheckCmd):
                 parsed = arg.split('=')
                 key, value = parsed[0],'='.join(parsed[1:])
                 if key not in user_options:
-                    raise self.InvalidCmd, "unknown option %s" % key
+                    raise self.InvalidCmd("unknown option %s" % key)
                 user_options[key] = value
                 args.remove(arg)
 
@@ -1221,8 +1227,8 @@ This will take effect only in a NEW term
                     args.append(self._done_export[1])
                     args.append(self._done_export[0])
                 else:
-                    raise self.InvalidCmd, \
-                          '%s not valid directory for launch' % self._done_export[0]
+                    raise self.InvalidCmd( \
+                          '%s not valid directory for launch' % self._done_export[0])
                 return
             else:
                 logger.warning('output command missing, run it automatically (with default argument)')
@@ -1242,7 +1248,7 @@ This will take effect only in a NEW term
         elif  MG4DIR and os.path.isdir(pjoin(MG4DIR,args[0])):
             path = pjoin(MG4DIR,args[0])
         else:
-            raise self.InvalidCmd, '%s is not a valid directory' % args[0]
+            raise self.InvalidCmd('%s is not a valid directory' % args[0])
 
         mode = self.find_output_type(path)
 
@@ -1303,7 +1309,7 @@ This will take effect only in a NEW term
             os.path.isfile(pjoin(include_path, 'Pythia8', 'Pythia.h')):
             return 'pythia8'
         elif not os.path.isdir(os.path.join(path, 'SubProcesses')):
-            raise self.InvalidCmd, '%s : Not a valid directory' % path
+            raise self.InvalidCmd('%s : Not a valid directory' % path)
 
         if os.path.isdir(src_path):
             return 'standalone_cpp'
@@ -1316,7 +1322,7 @@ This will take effect only in a NEW term
         elif os.path.isdir(card_path):
             return 'standalone'
 
-        raise self.InvalidCmd, '%s : Not a valid directory' % path
+        raise self.InvalidCmd('%s : Not a valid directory' % path)
 
     def check_load(self, args):
         """ check the validity of the line"""
@@ -1579,7 +1585,7 @@ This will take effect only in a NEW term
             elif path != 'auto':
                 if path in ['HELAS', 'tests', 'MadSpin', 'madgraph', 'mg5decay', 'vendor']:
                     if os.getcwd() == MG5DIR:
-                        raise self.InvalidCmd, "This name correspond to a buildin MG5 directory. Please choose another name"
+                        raise self.InvalidCmd("This name correspond to a buildin MG5 directory. Please choose another name")
                 self._export_dir = path
             elif path == 'auto':
                 if self.options['pythia8_path']:
@@ -1709,7 +1715,7 @@ This will take effect only in a NEW term
             elif self.stdin != sys.stdin:
                 #Check for position defined by the input files
                 input_path = os.path.realpath(self.stdin.name).split(os.path.sep)
-                print "Not standard stdin, use input path"
+                print("Not standard stdin, use input path")
                 if input_path[-2] == 'Cards':
                     self._export_dir = os.path.sep.join(input_path[:-2])
                     if 'TemplateVersion.txt' in self._export_dir:
@@ -1815,7 +1821,7 @@ class CheckValidForCmdWeb(CheckValidForC
         No Path authorize for the Web"""
 
         if not args:
-            raise self.WebRestriction, 'import requires at least one option'
+            raise self.WebRestriction('import requires at least one option')
 
         if args[0] not in self._import_formats:
             args[:] = ['command', './proc_card_mg5.dat']
@@ -1866,7 +1872,7 @@ class CheckValidForCmdWeb(CheckValidForC
         self._export_dir = os.path.realpath(os.getcwd())
         # Check that we output madevent
         if 'madevent' != self._export_format:
-                raise self.WebRestriction, 'only available output format is madevent (at current stage)'
+                raise self.WebRestriction('only available output format is madevent (at current stage)')
 
 #===============================================================================
 # CompleteForCmd
@@ -2043,7 +2049,7 @@ class CompleteForCmd(cmd.CompleteCmd):
         try:
             return self.model_completion(text, ' '.join(args[1:]),line, formatting)
         except Exception as error:
-            print error
+            print(error)
 
         #if len(args) > 1 and args[-1] != '>':
         #    couplings = ['>']
@@ -2398,8 +2404,8 @@ class CompleteForCmd(cmd.CompleteCmd):
             if len(args) > 1 and args[1] == 'aloha':
                 try:
                     return self.aloha_complete_output(text, line, begidx, endidx)
-                except Exception, error:
-                    print error
+                except Exception as error:
+                    print(error)
             # Directory continuation
             if args[-1].endswith(os.path.sep):
                 return [name for name in self.path_completion(text,
@@ -2567,7 +2573,7 @@ class CompleteForCmd(cmd.CompleteCmd):
                 try:
                     cur_path = pjoin(*[a for a in args \
                                                    if a.endswith(os.path.sep)])
-                except Exception, error:
+                except Exception as error:
                     pass
                 else:
                     all_dir = self.path_completion(text, cur_path, only_dirs = True)
@@ -3117,8 +3123,8 @@ This implies that with decay chains:
                 if amp not in self._curr_amps:
                     self._curr_amps.append(amp)
                 elif warning_duplicate:
-                    raise self.InvalidCmd, "Duplicate process %s found. Please check your processes." % \
-                                                amp.nice_string_processes()
+                    raise self.InvalidCmd("Duplicate process %s found. Please check your processes." % \
+                                                amp.nice_string_processes())
 
             # Reset _done_export, since we have new process
             self._done_export = False
@@ -3170,7 +3176,7 @@ This implies that with decay chains:
                 try:
                     self.exec_cmd('import model %s' % new_model_name, errorhandling=False, 
                               printcmd=False, precmd=True, postcmd=True)
-                except Exception, error:
+                except Exception as error:
                     logger.debug('fail to load model %s with error:\n %s' % (output_dir, error))
                     logger.warning('Fail to load the model. Restore previous model')
                     self.exec_cmd('import model %s' % oldmodel, errorhandling=False, 
@@ -3262,21 +3268,21 @@ This implies that with decay chains:
                 else:
                     nb_unpropagating += 1
 
-            print "Current model contains %i particles:" % \
-                    len(propagating_particle)
+            print("Current model contains %i particles:" % \
+                    len(propagating_particle))
             part_antipart = [part for part in propagating_particle \
                              if not part['self_antipart']]
             part_self = [part for part in propagating_particle \
                              if part['self_antipart']]
             for part in part_antipart:
-                print part['name'] + '/' + part['antiname'],
-            print ''
+                print(part['name'] + '/' + part['antiname'],)
+            print('')
             for part in part_self:
-                print part['name'],
-            print ''
+                print(part['name'],)
+            print('')
             if nb_unpropagating:
-                print 'In addition of %s un-physical particle mediating new interactions.' \
-                                     % nb_unpropagating
+                print('In addition of %s un-physical particle mediating new interactions.' \
+                                     % nb_unpropagating)
 
         elif args[0] == 'particles':
             for arg in args[1:]:
@@ -3285,10 +3291,10 @@ This implies that with decay chains:
                 else:
                     particle = self._curr_model['particles'].find_name(arg)
                 if not particle:
-                    raise self.InvalidCmd, 'no particle %s in current model' % arg
+                    raise self.InvalidCmd('no particle %s in current model' % arg)
 
-                print "Particle %s has the following properties:" % particle.get_name()
-                print str(particle)
+                print("Particle %s has the following properties:" % particle.get_name())
+                print(str(particle))
 
         elif args[0] == 'interactions' and len(args) == 1:
             text = "Current model contains %i interactions\n" % \
@@ -3309,12 +3315,12 @@ This implies that with decay chains:
         elif args[0] == 'interactions' and len(args)==2 and args[1].isdigit():
             for arg in args[1:]:
                 if int(arg) > len(self._curr_model['interactions']):
-                    raise self.InvalidCmd, 'no interaction %s in current model' % arg
+                    raise self.InvalidCmd('no interaction %s in current model' % arg)
                 if int(arg) == 0:
-                    print 'Special interactions which identify two particles'
+                    print('Special interactions which identify two particles')
                 else:
-                    print "Interactions %s has the following property:" % arg
-                    print self._curr_model['interactions'][int(arg)-1]
+                    print("Interactions %s has the following property:" % arg)
+                    print( self._curr_model['interactions'][int(arg)-1])
 
         elif args[0] == 'interactions':
             request_part = args[1:]
@@ -3346,7 +3352,7 @@ This implies that with decay chains:
                 text += str(self._curr_model['interactions'][i])
 
                 text += '\n'
-                print name
+                print(name)
             if text =='':
                 text += 'No matching for any interactions'
             pydoc.pager(text)
@@ -3385,16 +3391,16 @@ This implies that with decay chains:
 
         elif args[0] == 'processes':
             for amp in self._curr_amps:
-                print amp.nice_string_processes()
+                print( amp.nice_string_processes())
 
         elif args[0] == 'diagrams_text':
             text = "\n".join([amp.nice_string() for amp in self._curr_amps])
             pydoc.pager(text)
 
         elif args[0] == 'multiparticles':
-            print 'Multiparticle labels:'
+            print( 'Multiparticle labels:')
             for key in self._multiparticles:
-                print self.multiparticle_string(key)
+                print( self.multiparticle_string(key))
 
         elif args[0] == 'coupling_order':
             hierarchy = self._curr_model['order_hierarchy'].items()
@@ -3406,11 +3412,11 @@ This implies that with decay chains:
                     return 1
             hierarchy.sort(order)
             for order in hierarchy:
-                print ' %s : weight = %s' % order
+                print( ' %s : weight = %s' % order)
 
         elif args[0] == 'couplings' and len(args) == 1:
             if self._model_v4_path:
-                print 'No couplings information available in V4 model'
+                print( 'No couplings information available in V4 model')
                 return
             text = ''
             text = "Current model contains %i couplings\n" % \
@@ -3440,34 +3446,34 @@ This implies that with decay chains:
 
         elif args[0] == 'couplings':
             if self._model_v4_path:
-                print 'No couplings information available in V4 model'
+                print('No couplings information available in V4 model')
                 return
 
             try:
                 ufomodel = ufomodels.load_model(self._curr_model.get('name'))
-                print 'Note that this is the UFO informations.'
-                print ' "display couplings" present the actual definition'
-                print 'prints the current states of mode'
-                print eval('ufomodel.couplings.%s.nice_string()'%args[1])
+                print('Note that this is the UFO informations.')
+                print(' "display couplings" present the actual definition')
+                print('prints the current states of mode')
+                print(eval('ufomodel.couplings.%s.nice_string()'%args[1]))
             except Exception:
-                raise self.InvalidCmd, 'no couplings %s in current model' % args[1]
+                raise self.InvalidCmd('no couplings %s in current model' % args[1])
 
         elif args[0] == 'lorentz':
-            print 'in lorentz'
+            print('in lorentz')
             if self._model_v4_path:
-                print 'No lorentz information available in V4 model'
+                print('No lorentz information available in V4 model')
                 return
             elif len(args) == 1:
                 ufomodel = ufomodels.load_model(self._curr_model.get('name'))
-                print dir(ufomodel.lorentz)
+                print(dir(ufomodel.lorentz))
                 return
             try:
                 ufomodel = ufomodels.load_model(self._curr_model.get('name'))
-                print getattr(ufomodel.lorentz, args[1]).nice_string()
-            except Exception, error:
+                print(getattr(ufomodel.lorentz, args[1]).nice_string())
+            except Exception as error:
                 raise
                 logger.info(str(error))
-                raise self.InvalidCmd, 'no lorentz %s in current model' % args[1]
+                raise self.InvalidCmd('no lorentz %s in current model' % args[1])
 
         elif args[0] == 'checks':
             outstr = ''
@@ -4319,8 +4325,8 @@ This implies that with decay chains:
                 if key not in options:
                     options[key] = value
                 else:
-                    raise MadGraph5Error,"Option '%s' is both in the option"%key+\
-                                                   " and CMS_option dictionary." 
+                    raise MadGraph5Error("Option '%s' is both in the option"%key+\
+                                                   " and CMS_option dictionary." )
             
             if options['analyze']=='None':
                 cms_results = []
@@ -4544,8 +4550,8 @@ This implies that with decay chains:
                     elif option=='noborn':
                         HasBorn=False
                 else:
-                    raise self.InvalidCmd, "NLO mode %s is not valid. "%option+\
-                       "Valid modes are %s. "%str(self._valid_nlo_modes)
+                    raise self.InvalidCmd("NLO mode %s is not valid. "%option+\
+                       "Valid modes are %s. "%str(self._valid_nlo_modes))
             else:
                 LoopOption='all'
 
@@ -4569,8 +4575,8 @@ This implies that with decay chains:
             type = order_re.group('type')
             if order_re.group('name').endswith('^2'):
                 if type not in self._valid_sqso_types:
-                    raise self.InvalidCmd, "Type of squared order "+\
-                                 "constraint '%s'"% type+" is not supported."
+                    raise self.InvalidCmd("Type of squared order "+\
+                                 "constraint '%s'"% type+" is not supported.")
                 if type == '=':
                     name =  order_re.group('name')
                     value = order_re.group('value')
@@ -4581,9 +4587,9 @@ This implies that with decay chains:
                                          (int(order_re.group('value')),type)
             else:
                 if type not in self._valid_amp_so_types:
-                    raise self.InvalidCmd, \
+                    raise self.InvalidCmd( \
                       "Amplitude order constraints can only be of type %s"%\
-                    (', '.join(self._valid_amp_so_types))+", not '%s'."%type
+                    (', '.join(self._valid_amp_so_types))+", not '%s'."%type)
                 name = order_re.group('name')
                 value = int(order_re.group('value'))
                 if type in ['=', '<=']:
@@ -4620,9 +4626,9 @@ This implies that with decay chains:
         
         #only allow amplitue restrctions >/ == for LO/tree level
         if constrained_orders and LoopOption != 'tree':
-            raise self.InvalidCmd, \
+            raise self.InvalidCmd( \
                           "Amplitude order constraints (for not LO processes) can only be of type %s"%\
-                        (', '.join(['<=']))+", not '%s'."%type
+                        (', '.join(['<=']))+", not '%s'."%type)
 
         # If the squared orders are defined but not the orders, assume 
         # orders=sq_orders. In case the squared order has a negative value or is
@@ -4686,23 +4692,23 @@ This implies that with decay chains:
         for part_name in args:
             if part_name == '>':
                 if not myleglist:
-                    raise self.InvalidCmd, "No final state particles"
+                    raise self.InvalidCmd("No final state particles")
                 state = True
                 continue
 
             mylegids = []
             if part_name in self._multiparticles:
                 if isinstance(self._multiparticles[part_name][0], list):
-                    raise self.InvalidCmd,\
+                    raise self.InvalidCmd(\
                           "Multiparticle %s is or-multiparticle" % part_name + \
-                          " which can be used only for required s-channels"
+                          " which can be used only for required s-channels")
                 mylegids.extend(self._multiparticles[part_name])
             elif part_name.isdigit() or part_name.startswith('-') and part_name[1:].isdigit():
                 if int(part_name) in self._curr_model.get('particle_dict'):
                     mylegids.append(int(part_name))
                 else:
-                    raise self.InvalidCmd, \
-                      "No pdg_code %s in model" % part_name
+                    raise self.InvalidCmd( \
+                      "No pdg_code %s in model" % part_name)
             else:
                 mypart = self._curr_model['particles'].get_copy(part_name)
                 if mypart:
@@ -4712,7 +4718,7 @@ This implies that with decay chains:
                 myleglist.append(base_objects.MultiLeg({'ids':mylegids,
                                                         'state':state}))
             else:
-                raise self.InvalidCmd, "No particle %s in model" % part_name
+                raise self.InvalidCmd("No particle %s in model" % part_name)
 
         # Apply the keyword 'all' for perturbed coupling orders.
         if perturbation_couplings.lower() in ['all', 'loonly']:
@@ -4735,10 +4741,10 @@ This implies that with decay chains:
                                        self._curr_model.get('order_hierarchy')
                                        [elem if not elem.endswith('.sqrt') else elem[:-5]])
             except KeyError:
-                raise self.InvalidCmd, "The loaded model does not defined a "+\
+                raise self.InvalidCmd("The loaded model does not defined a "+\
                     " coupling order hierarchy for these couplings: %s"%\
                       str([so for so in split_orders if so!='WEIGHTED' and so not 
-                                 in self._curr_model['order_hierarchy'].keys()])
+                                 in self._curr_model['order_hierarchy'].keys()]))
 
             # If the loopOption is 'tree' then the user used the syntax 
             # [tree= Orders] for the sole purpose of setting split_orders. We
@@ -4777,14 +4783,14 @@ This implies that with decay chains:
                               self.extract_particle_ids(forbidden_schannels)
             if forbidden_onsh_schannel_ids and \
                isinstance(forbidden_onsh_schannel_ids[0], list):
-                raise self.InvalidCmd,\
+                raise self.InvalidCmd(\
                       "Multiparticle %s is or-multiparticle" % part_name + \
-                      " which can be used only for required s-channels"
+                      " which can be used only for required s-channels")
             if forbidden_schannel_ids and \
                isinstance(forbidden_schannel_ids[0], list):
-                raise self.InvalidCmd,\
+                raise self.InvalidCmd(\
                       "Multiparticle %s is or-multiparticle" % part_name + \
-                      " which can be used only for required s-channels"
+                      " which can be used only for required s-channels")
             required_schannel_ids = \
                                self.extract_particle_ids(required_schannels)
             if required_schannel_ids and not \
@@ -4908,8 +4914,8 @@ This implies that with decay chains:
                 if amp['has_born']:
                     raise Exception
             elif warning_duplicate:
-                raise self.InvalidCmd, "Duplicate process %s found. Please check your processes." % \
-                                            amp.nice_string_processes()
+                raise self.InvalidCmd("Duplicate process %s found. Please check your processes." % \
+                                            amp.nice_string_processes())
 
         # Reset _done_export, since we have new process
         self._done_export = False
@@ -5027,7 +5033,7 @@ This implies that with decay chains:
                 elif first in self._multiparticles:
                     pid = set(self._multiparticles[first])
                 else:
-                    raise Exception, 'invalid particle name: %s. ' % first
+                    raise Exception('invalid particle name: %s. ' % first)
                 core_final.difference_update(pid)
                 core_final.update(self.get_final_part(one_decay))
 
@@ -5179,8 +5185,8 @@ This implies that with decay chains:
 
             if level_down:
                 if index_par == -1:
-                    raise self.InvalidCmd, \
-                      "Missing ending parenthesis for decay process"
+                    raise self.InvalidCmd(\
+                      "Missing ending parenthesis for decay process")
 
                 if index_par < index_comma:
                     line = line[index_par + 1:]
@@ -5190,8 +5196,8 @@ This implies that with decay chains:
         if level_down:
             index_par = line.find(')')
             if index_par == -1:
-                raise self.InvalidCmd, \
-                      "Missing ending parenthesis for decay process"
+                raise self.InvalidCmd( \
+                      "Missing ending parenthesis for decay process")
             line = line[index_par + 1:]
 
         # Return the core process (ends recursion when there are no
@@ -5289,7 +5295,7 @@ This implies that with decay chains:
         elif args[0] == 'banner':
             type = madevent_interface.MadEventCmd.detect_card_type(args[1])
             if type != 'banner':
-                raise self.InvalidCmd, 'The File should be a valid banner'
+                raise self.InvalidCmd('The File should be a valid banner')
             ban = banner_module.Banner(args[1])
             # Check that this is MG5 banner
             if 'mg5proccard' in ban:
@@ -5298,7 +5304,7 @@ This implies that with decay chains:
                         continue
                     self.exec_cmd(line)
             else:
-                raise self.InvalidCmd, 'Only MG5 banner are supported'
+                raise self.InvalidCmd('Only MG5 banner are supported')
 
             if not self._done_export:
                 self.exec_cmd('output . -f')
@@ -5451,7 +5457,7 @@ This implies that with decay chains:
                 if multipart_name not in self._multiparticles:
                     #self.do_define(line)
                     self.exec_cmd('define %s' % line, printcmd=False, precmd=True)
-            except self.InvalidCmd, why:
+            except self.InvalidCmd as why:
                 logger_stderr.warning('impossible to set default multiparticles %s because %s' %
                                         (line.split()[0],why))
                 if self.history[-1] == 'define %s' % line.strip():
@@ -5484,7 +5490,7 @@ This implies that with decay chains:
                 if container in defined_multiparticles:
                     defined_multiparticles.remove(container)
             self.history.append("define p = %s # pass to %s flavors" % \
-                                (' ' .join([`i` for i in self._multiparticles['p']]), 
+                                (' ' .join([repr(i) for i in self._multiparticles['p']]), 
                                  scheme) 
                                )
             self.history.append("define j = p")
@@ -5524,9 +5530,9 @@ This implies that with decay chains:
         # Always refresh the installer if already present
         if not os.path.isdir(pjoin(MG5DIR,'HEPTools','HEPToolsInstallers')):
             if HepToolsInstaller_web_address is None:
-                raise MadGraph5Error, "The option 'HepToolsInstaller_web_address'"+\
+                raise MadGraph5Error("The option 'HepToolsInstaller_web_address'"+\
                              " must be specified in function advanced_install"+\
-                                " if the installers are not already downloaded."
+                                " if the installers are not already downloaded.")
             if not os.path.isdir(pjoin(MG5DIR,'HEPTools')):
                 os.mkdir(pjoin(MG5DIR,'HEPTools'))
         elif not HepToolsInstaller_web_address is None:
@@ -5930,7 +5936,7 @@ MG5aMC that supports quadruple precision
                 cluster_path = data_path[index]
                 try:
                     data = urllib.urlopen(cluster_path)
-                except Exception, error:
+                except Exception as error:
                     misc.sprint(str(error), cluster_path)
                     continue
                 if data.getcode() != 200:
@@ -5939,8 +5945,8 @@ MG5aMC that supports quadruple precision
                 break
                 
             else:
-                raise MadGraph5Error, '''Impossible to connect any of us servers.
-                Please check your internet connection or retry later'''
+                raise MadGraph5Error('''Impossible to connect any of us servers.
+                Please check your internet connection or retry later''')
             for wwwline in data:
                 split = wwwline.split()
                 if len(split)!=2:
@@ -6018,7 +6024,7 @@ MG5aMC that supports quadruple precision
                 if 'xxx' in advertisements[name][0]:
                     logger.warning("Program not yet released. Please try later")
                 else:
-                    raise Exception, "Online server are corrupted. No tarball available for %s" % name
+                    raise Exception("Online server are corrupted. No tarball available for %s" % name)
                 return
             
         # Load that path
@@ -6030,7 +6036,7 @@ MG5aMC that supports quadruple precision
                                      stdout=open(os.devnull, 'w'))
 
         if returncode:
-            raise MadGraph5Error, 'Fail to download correctly the File. Stop'
+            raise MadGraph5Error('Fail to download correctly the File. Stop')
 
 
         # Check that the directory has the correct name
@@ -6038,7 +6044,7 @@ MG5aMC that supports quadruple precision
             created_name = [n for n in os.listdir(MG5DIR) if n.lower().startswith(
                                          name.lower()) and not n.endswith('gz')]
             if not created_name:
-                raise MadGraph5Error, 'The file was not loaded correctly. Stop'
+                raise MadGraph5Error('The file was not loaded correctly. Stop')
             else:
                 created_name = created_name[0]
             files.mv(pjoin(MG5DIR, created_name), pjoin(MG5DIR, name))
@@ -6158,10 +6164,10 @@ MG5aMC that supports quadruple precision
                 latest_validated_version = plugin.latest_validated_version
                 minimal_mg5amcnlo_version = plugin.minimal_mg5amcnlo_version
                 maximal_mg5amcnlo_version = plugin.maximal_mg5amcnlo_version
-            except Exception, error:
-                raise Exception, 'Plugin %s fail to be loaded. Please contact the author of the PLUGIN\n Error %s' % (name, error)
+            except Exception as error:
+                raise Exception('Plugin %s fail to be loaded. Please contact the author of the PLUGIN\n Error %s' % (name, error))
                 
-            logger.info('Plugin %s correctly interfaced. Latest official validition for MG5aMC version %s.' % (name, '.'.join(`i` for i in latest_validated_version)))
+            logger.info('Plugin %s correctly interfaced. Latest official validition for MG5aMC version %s.' % (name, '.'.join(repr(i) for i in latest_validated_version)))
             if new_interface:
                 ff = open(pjoin(MG5DIR, 'bin', '%s.py' % name) , 'w') 
                 if __debug__:
@@ -6245,8 +6251,8 @@ os.system('%s  -O -W ignore::Deprecation
             try:
                 os.system('rm -rf td')
                 os.mkdir(pjoin(MG5DIR, 'td'))
-            except Exception, error:
-                print error
+            except Exception as error:
+                print(error)
                 pass
 
             if sys.platform == "darwin":
@@ -6267,7 +6273,7 @@ os.system('%s  -O -W ignore::Deprecation
                     logger.info('Downloading TD for Linux 32 bit')
                     target = 'http://madgraph.phys.ucl.ac.be/Downloads/td'
                 misc.wget(target, 'td', cwd=pjoin(MG5DIR,'td'))
-            os.chmod(pjoin(MG5DIR,'td','td'), 0775)
+            os.chmod(pjoin(MG5DIR,'td','td'), stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IXOTH)
             self.options['td_path'] = pjoin(MG5DIR,'td')
 
             if not misc.which('gs'):
@@ -6345,7 +6351,7 @@ os.system('%s  -O -W ignore::Deprecation
             pattern = re.compile(r'''=== renamed file \'(?P<orig>[^\']*)\' => \'(?P<new>[^\']*)\'''')
             #=== renamed file 'Template/SubProcesses/addmothers.f' => 'madgraph/iolibs/template_files/addmothers.f'
             for orig, new in pattern.findall(text):
-                print 'move %s to %s' % (orig, new)
+                print('move %s to %s' % (orig, new))
                 try:
                     files.cp(pjoin(MG5DIR, orig), pjoin(MG5DIR, new), error=True)
                 except IOError:
@@ -6361,7 +6367,7 @@ os.system('%s  -O -W ignore::Deprecation
             #pattern = re.compile(r'''=== removed file \'(?P<new>[^\']*)\'''')
             #all_rm = pattern.findall(text)
             pattern=re.compile(r'''=== removed file \'(?P<new>[^\']*)\'(?=.*=== added file \'(?P=new)\')''',re.S)
-            print 'this step can take a few minuts. please be patient'
+            print('this step can take a few minuts. please be patient')
             all_rm_add = pattern.findall(text)
             #=== added file 'tests/input_files/full_sm/interactions.dat'
             for new in all_add:
@@ -6400,7 +6406,7 @@ os.system('%s  -O -W ignore::Deprecation
                         for i in range(1,len(split)):
                             path = '/'.join(split[:i])
                             if not os.path.exists(path):
-                                print 'mkdir', path
+                                print( 'mkdir', path)
                                 os.mkdir(path)
                     files.cp(old,new)
             #=== renamed file 'Template/bin/internal/run_delphes' => 'Template/Common/bin/internal/run_delphes'
@@ -6446,10 +6452,10 @@ os.system('%s  -O -W ignore::Deprecation
                     for i in range(1,len(split)+1):
                         path = '/'.join(split[:i])
                         if path and not os.path.exists(path):
-                            print 'mkdir', path
+                            print( 'mkdir', path)
                             os.mkdir(path)
                 if match[0] == 'file':
-                    print 'touch ', pjoin(MG5DIR, match[1])
+                    print( 'touch ', pjoin(MG5DIR, match[1]))
                     misc.call(['touch', pjoin(MG5DIR, match[1])])
             # add new symlink
             pattern=re.compile('''^=== link file \'(?P<new>[^\']*)\' \'(?P<old>[^\']*)\'''', re.M)
@@ -6566,7 +6572,7 @@ os.system('%s  -O -W ignore::Deprecation
             web_version = int(filetext.read().strip())
         except (TimeOutError, ValueError, IOError):
             signal.alarm(0)
-            print 'failed to connect server'
+            print( 'failed to connect server')
             if mode == 'mg5_end':
                 # wait 24h before next check
                 fsock = open(os.path.join(MG5DIR,'input','.autoupdate'),'w')
@@ -6606,7 +6612,7 @@ os.system('%s  -O -W ignore::Deprecation
                 try:
                     filetext = urllib.urlopen('http://madgraph.phys.ucl.ac.be/patch/build%s.patch' %(i+1))
                 except Exception:
-                    print 'fail to load patch to build #%s' % (i+1)
+                    print( 'fail to load patch to build #%s' % (i+1))
                     fail = i
                     break
                 need_binary = apply_patch(filetext)
@@ -6630,7 +6636,7 @@ os.system('%s  -O -W ignore::Deprecation
             logger.info('Checking current version. (type ctrl-c to bypass the check)')
             subprocess.call([os.path.join('tests','test_manager.py')],
                                                                   cwd=MG5DIR)            
-            print 'new version installed, please relaunch mg5'
+            print( 'new version installed, please relaunch mg5')
             try:
                 os.remove(pjoin(MG5DIR, 'Template','LO','Source','make_opts'))
                 shutil.copy(pjoin(MG5DIR, 'Template','LO','Source','.make_opts'),
@@ -6811,8 +6817,8 @@ in the MG5aMC option 'samurai' (instead
                 # Default: try to set parameter
                 try:
                     self.do_set("%s %s --no_save" % (key, self.options[key]), log=False)
-                except MadGraph5Error, error:
-                    print error
+                except MadGraph5Error as error:
+                    print(error)
                     logger.warning("Option %s from config file not understood" \
                                    % key)
                 else:
@@ -6937,7 +6943,7 @@ in the MG5aMC option 'samurai' (instead
                                                  options=self.options,**options)            
         else:
             os.chdir(start_cwd) #ensure to go to the initial path
-            raise self.InvalidCmd , '%s cannot be run from MG5 interface' % args[0]
+            raise self.InvalidCmd('%s cannot be run from MG5 interface' % args[0])
 
 
         ext_program.run()
@@ -7601,7 +7607,7 @@ in the MG5aMC option 'samurai' (instead
                 self._export_dir = pjoin(self._export_dir, 'Pythia8_proc_%i' %i)
                 logger.info('Create output in %s' % self._export_dir)
             elif not args[0] in ['.', '-f']:
-                raise self.InvalidCmd, 'Wrong path directory to create in local directory use \'.\''
+                raise self.InvalidCmd('Wrong path directory to create in local directory use \'.\'')
         elif not noclean and os.path.isdir(self._export_dir) and options['check']:
             if not force:
                 # Don't ask if user already specified force or noclean
@@ -8137,8 +8143,8 @@ in the MG5aMC option 'samurai' (instead
                                        (particle.get('name'), ' '.join([p.get('name') for p in mode]), value))
                         value = 0
                     elif value < 0:
-                        raise Exception, 'Partial width for %s > %s negative: %s' % \
-                                       (particle.get('name'), ' '.join([p.get('name') for p in mode]), value)
+                        raise Exception('Partial width for %s > %s negative: %s' % \
+                                       (particle.get('name'), ' '.join([p.get('name') for p in mode]), value))
                     elif 0 < value < 0.1 and particle['color'] !=1:
                         logger.warning("partial width of particle %s lower than QCD scale:%s. Set it to zero. (%s)" \
                                    % (particle.get('name'), value, decay_to))
@@ -8158,7 +8164,7 @@ in the MG5aMC option 'samurai' (instead
         # add info from decay module
         #
         
-        self.do_decay_diagram('%s %s' % (' '.join([`id` for id in particles]),
+        self.do_decay_diagram('%s %s' % (' '.join([repr(id) for id in particles]),
                                          ' '.join('--%s=%s' % (key,value)
                                                   for key,value in opts.items()
                                                   if key not in ['precision_channel'])
@@ -8287,7 +8293,7 @@ in the MG5aMC option 'samurai' (instead
             currmodel = model
 
         if not os.path.exists(pjoin(model_path, 'SMWidth')):
-            raise self.InvalidCmd, "Model %s is not valid for computing NLO width with SMWidth"%model_name
+            raise self.InvalidCmd("Model %s is not valid for computing NLO width with SMWidth"%model_name)
 
         # determine the EW scheme
         externparam = [(param.lhablock.lower(),param.name.lower()) for param \
@@ -8300,7 +8306,7 @@ in the MG5aMC option 'samurai' (instead
             # Gmu scheme
             arg2 = "2"
         else:
-            raise Exception, "Do not know the EW scheme in the model %s"%model_name
+            raise Exception("Do not know the EW scheme in the model %s"%model_name)
 
         #compile the code
         if not os.path.exists(pjoin(model_path, 'SMWidth','smwidth')):
@@ -8635,27 +8641,27 @@ class AskforCustomize(cmd.SmartQuestion)
     def do_help(self, line):
         '''help message'''
 
-        print 'This allows you to optimize your model to your needs.'
-        print 'Enter the number associate to the possible restriction/add-on'
-        print ' to change the status of this restriction/add-on.'
-        print ''
-        print 'In order to allow scripting of this function you can use the '
-        print 'function \'set\'. This function takes two argument:'
-        print 'set NAME VALUE'
-        print '   NAME is the description of the option where you remove all spaces'
-        print '   VALUE is either True or False'
-        print ' Example: For the question'
-        print '''     sm customization:
+        print('This allows you to optimize your model to your needs.')
+        print('Enter the number associate to the possible restriction/add-on')
+        print(' to change the status of this restriction/add-on.')
+        print('')
+        print('In order to allow scripting of this function you can use the ')
+        print('function \'set\'. This function takes two argument:')
+        print('set NAME VALUE')
+        print('   NAME is the description of the option where you remove all spaces')
+        print('   VALUE is either True or False')
+        print(' Example: For the question')
+        print('''     sm customization:
         1: diagonal ckm [True]
         2: c mass = 0 [True]
         3: b mass = 0 [False]
         4: tau mass = 0 [False]
         5: muon mass = 0 [True]
         6: electron mass = 0 [True]
-    Enter a number to change it's status or press enter to validate.'''
-        print ''' you can answer by'''
-        print '   set diagonalckm False'
-        print '   set taumass=0 True'
+    Enter a number to change it's status or press enter to validate.''')
+        print(''' you can answer by''')
+        print('   set diagonalckm False')
+        print('   set taumass=0 True')
 
     def cmdloop(self, intro=None):
         cmd.SmartQuestion.cmdloop(self, intro)
diff -rupN MadGraph_pristine/madgraph/interface/master_interface.py ../contrib/MadGraph/madgraph/interface/master_interface.py
--- MadGraph_pristine/madgraph/interface/master_interface.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/interface/master_interface.py	2020-10-29 23:48:54.812703886 +1100
@@ -153,7 +153,7 @@ class Switcher(object):
                     correct = False                    
                     
         if not correct:
-            raise Exception, 'The Cmd interface has dangerous features. Please see previous warnings and correct those.' 
+            raise Exception('The Cmd interface has dangerous features. Please see previous warnings and correct those.' )
 
     
 
@@ -593,7 +593,7 @@ class MasterCmd(Switcher, LoopCmd.LoopIn
             self.cmd= self.interface_names[main][1]
             self.current_interface=main
         else:
-            raise MadGraph5Error, 'Type of interface not valid: %s' % main  
+            raise MadGraph5Error('Type of interface not valid: %s' % main  )
         self.cmd.__init__(self, *args, **opt)     
         self.current_interface = main  
     
@@ -619,14 +619,14 @@ class MasterCmd(Switcher, LoopCmd.LoopIn
         if old_cmd == name:
             return
         elif not allow_switch:
-            raise InvalidCmd, "Command not compatible with previous command: Can not combine LO/NLO feature."
+            raise InvalidCmd("Command not compatible with previous command: Can not combine LO/NLO feature.")
             
         if name in self.interface_names.keys():
             self.prompt= self.interface_names[name][0]+'>'
             self.cmd= self.interface_names[name][1]
             self.current_interface=name
         else:
-            raise MadGraph5Error, 'Type of interface not valid: %s' % name  
+            raise MadGraph5Error('Type of interface not valid: %s' % name  )
         
         if self.interface_names[old_cmd][0]!=self.interface_names[name][0]:
             logger.info("Switching from interface %s to %s"\
@@ -662,7 +662,7 @@ class MasterCmdWeb(MGcmd.MadGraphCmdWeb,
         elif name == 'Loop':
             self.cmd = LoopCmd.LoopInterfaceWeb
         else:
-            raise MadGraph5Error, 'Type of interface not valid'  
+            raise MadGraph5Error('Type of interface not valid'  )
         
         if __debug__:
             self.debug_link_to_command() 
diff -rupN MadGraph_pristine/madgraph/iolibs/export_cpp.py ../contrib/MadGraph/madgraph/iolibs/export_cpp.py
--- MadGraph_pristine/madgraph/iolibs/export_cpp.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/export_cpp.py	2020-10-29 23:48:54.812703886 +1100
@@ -92,8 +92,8 @@ class OneProcessExporterCPP(object):
         elif isinstance(matrix_elements, helas_objects.HelasMatrixElementList):
             self.matrix_elements = matrix_elements
         else:
-            raise base_objects.PhysicsObject.PhysicsObjectError,\
-                  "Wrong object type for matrix_elements: %s" % type(matrix_elements)
+            raise base_objects.PhysicsObject.PhysicsObjectError(\
+                  "Wrong object type for matrix_elements: %s" % type(matrix_elements))
 
         if not self.matrix_elements:
             raise MadGraph5Error("No matrix elements to export")
@@ -127,8 +127,8 @@ class OneProcessExporterCPP(object):
         self.helas_call_writer = cpp_helas_call_writer
 
         if not isinstance(self.helas_call_writer, helas_call_writers.CPPUFOHelasCallWriter):
-            raise self.ProcessExporterCPPError, \
-                "helas_call_writer not CPPUFOHelasCallWriter"
+            raise self.ProcessExporterCPPError( \
+                "helas_call_writer not CPPUFOHelasCallWriter")
 
         self.nexternal, self.ninitial = \
                         self.matrix_elements[0].get_nexternal_ninitial()
@@ -944,7 +944,7 @@ class OneProcessExporterMatchbox(OneProc
             for match in all_matches:
                 ctype, arg = match[0], [m.strip() for m in match[1].split(',')]
                 if ctype not in ['T', 'Tr']:
-                    raise self.ProcessExporterCPPError, 'Color Structure not handle by Matchbox'
+                    raise self.ProcessExporterCPPError( 'Color Structure not handle by Matchbox')
                 tmp_color.append(arg)
             #compute the maximal size of the vector
             nb_index = sum(len(o) for o in tmp_color)
@@ -994,9 +994,9 @@ class OneProcessExporterPythia8(OneProce
         for me in self.matrix_elements:
             if me.get_nexternal_ninitial() not in [(3,2),(4,2),(5,2)]:
                 nex,nin = me.get_nexternal_ninitial()
-                raise InvalidCmd,\
+                raise InvalidCmd(\
                       "Pythia 8 can only handle 2->1,2,3 processes, not %d->%d" % \
-                      (nin,nex-nin)
+                      (nin,nex-nin))
             
         self.process_class = self.process_name
         
@@ -1371,8 +1371,8 @@ class OneProcessExporterPythia8(OneProce
 
             if final_id_list and final_mirror_id_list or \
                not final_id_list and not final_mirror_id_list:
-                raise self.ProcessExporterCPPError,\
-                      "Missing processes, or both process and mirror process"
+                raise self.ProcessExporterCPPError(\
+                      "Missing processes, or both process and mirror process")
 
 
             ncombs = len(final_id_list)+len(final_mirror_id_list)
@@ -1391,9 +1391,9 @@ class OneProcessExporterPythia8(OneProce
                                            (i, l) in items if l > 0]).\
                                  replace('*1', ''))
                 if any([l>1 for (i, l) in items]):
-                    raise self.ProcessExporterCPPError,\
+                    raise self.ProcessExporterCPPError(\
                           "More than one process with identical " + \
-                          "external particles is not supported"
+                          "external particles is not supported")
 
             for final_ids in final_mirror_id_list:
                 items = [(i, len([ p for p in me.get_mirror_processes() \
@@ -1405,9 +1405,9 @@ class OneProcessExporterPythia8(OneProce
                                            (i, l) in items if l > 0]).\
                                  replace('*1', ''))
                 if any([l>1 for (i, l) in items]):
-                    raise self.ProcessExporterCPPError,\
+                    raise self.ProcessExporterCPPError(\
                           "More than one process with identical " + \
-                          "external particles is not supported"
+                          "external particles is not supported")
 
             if final_id_list:
                 res_lines.append("int flavors[%d][%d] = {%s};" % \
diff -rupN MadGraph_pristine/madgraph/iolibs/export_v4.py ../contrib/MadGraph/madgraph/iolibs/export_v4.py
--- MadGraph_pristine/madgraph/iolibs/export_v4.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/export_v4.py	2020-10-29 23:48:54.812703886 +1100
@@ -16,7 +16,12 @@ from madgraph.iolibs.helas_call_writers
 """Methods and classes to export matrix elements to v4 format."""
 
 import copy
-from cStringIO import StringIO
+
+try:
+    from cStringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 from distutils import dir_util
 import itertools
 import fractions
@@ -141,11 +146,11 @@ class VirtualExporter(object):
         return False, matrix_element
            
     def export_model_files(self, model_v4_path):
-        raise Exception, "V4 model not supported by this type of exporter. Please use UFO model"
+        raise Exception("V4 model not supported by this type of exporter. Please use UFO model")
         return
     
     def export_helas(self, HELAS_PATH):
-        raise Exception, "V4 model not supported by this type of exporter. Please use UFO model"
+        raise Exception("V4 model not supported by this type of exporter. Please use UFO model")
         return
 
 #===============================================================================
@@ -305,7 +310,7 @@ class ProcessExporterFortran(VirtualExpo
                 try:
                     misc.call([pjoin('bin', 'internal', 'clean_template')], \
                                                                        cwd=self.dir_path)
-                except Exception, why:
+                except Exception as why:
                     raise MadGraph5Error('Failed to clean correctly %s: \n %s' \
                                                 % (os.path.basename(self.dir_path),why))
 
@@ -1218,7 +1223,7 @@ param_card.inc: ../Cards/param_card.dat\
         
         if(not isinstance(color_amplitudes,list) or 
            not (color_amplitudes and isinstance(color_amplitudes[0],list))):
-                raise MadGraph5Error, "Incorrect col_amps argument passed to get_JAMP_coefs"
+                raise MadGraph5Error("Incorrect col_amps argument passed to get_JAMP_coefs")
 
         res_list = []
         my_cs = color.ColorString()
@@ -1274,36 +1279,36 @@ param_card.inc: ../Cards/param_card.dat\
             if(col_amps and isinstance(col_amps[0],list)):
                 color_amplitudes=col_amps
             else:
-                raise MadGraph5Error, error_msg%'col_amps'
+                raise MadGraph5Error(error_msg%'col_amps')
         else:
-            raise MadGraph5Error, error_msg%'col_amps'
+            raise MadGraph5Error(error_msg%'col_amps')
         
         # Verify the sanity of the split_order_amps and split_order_names args
         if isinstance(split_order_amps,list):
             for elem in split_order_amps:
                 if len(elem)!=2:
-                    raise MadGraph5Error, error_msg%'split_order_amps'
+                    raise MadGraph5Error(error_msg%'split_order_amps')
                 # Check the first element of the two lists to make sure they are
                 # integers, although in principle they should all be integers.
                 if not isinstance(elem[0],tuple) or \
                    not isinstance(elem[1],tuple) or \
                    not isinstance(elem[0][0],int) or \
                    not isinstance(elem[1][0],int):
-                    raise MadGraph5Error, error_msg%'split_order_amps'
+                    raise MadGraph5Error(error_msg%'split_order_amps')
         else:
-            raise MadGraph5Error, error_msg%'split_order_amps'
+            raise MadGraph5Error(error_msg%'split_order_amps')
         
         if not split_order_names is None:
             if isinstance(split_order_names,list):
                 # Should specify the same number of names as there are elements
                 # in the key of the split_order_amps.
                 if len(split_order_names)!=len(split_order_amps[0][0]):
-                    raise MadGraph5Error, error_msg%'split_order_names'
+                    raise MadGraph5Error(error_msg%'split_order_names')
                 # Check the first element of the list to be a string
                 if not isinstance(split_order_names[0],str):
-                    raise MadGraph5Error, error_msg%'split_order_names'                    
+                    raise MadGraph5Error(error_msg%'split_order_names')                    
             else:
-                raise MadGraph5Error, error_msg%'split_order_names'                
+                raise MadGraph5Error(error_msg%'split_order_names')                
         
         # Now scan all contributing orders to be individually computed and 
         # construct the list of color_amplitudes for JAMP to be constructed
@@ -1346,9 +1351,9 @@ param_card.inc: ../Cards/param_card.dat\
             if(col_amps and isinstance(col_amps[0],list)):
                 color_amplitudes=col_amps
             else:
-                raise MadGraph5Error, "Incorrect col_amps argument passed to get_JAMP_lines"
+                raise MadGraph5Error("Incorrect col_amps argument passed to get_JAMP_lines")
         else:
-            raise MadGraph5Error, "Incorrect col_amps argument passed to get_JAMP_lines"
+            raise MadGraph5Error("Incorrect col_amps argument passed to get_JAMP_lines")
 
 
         res_list = []
@@ -1748,7 +1753,7 @@ param_card.inc: ../Cards/param_card.dat\
             logger.warning('No Fortran Compiler detected! Please install one')
             f77_compiler = default_compiler['fortran'] # maybe misc fail so try with it
         else:
-            raise MadGraph5Error, 'No Fortran Compiler detected! Please install one'
+            raise MadGraph5Error('No Fortran Compiler detected! Please install one')
         logger.info('Use Fortran compiler ' + f77_compiler)
         
         
@@ -1810,7 +1815,7 @@ param_card.inc: ../Cards/param_card.dat\
             logger.warning('No c++ Compiler detected! Please install one')
             compiler = default_compiler # maybe misc fail so try with it
         else:
-            raise MadGraph5Error, 'No c++ Compiler detected! Please install one'
+            raise MadGraph5Error('No c++ Compiler detected! Please install one')
         logger.info('Use c++ compiler ' + compiler)
         self.replace_make_opt_c_compiler(compiler)
         # Replace also for Template but not for cluster
@@ -2254,7 +2259,7 @@ CF2PY CHARACTER*20, intent(out) :: PREFI
             elif self.cmd_options['prefix'] == 'proc':
                 proc_prefix = matrix_element.get('processes')[0].shell_string().split('_',1)[1]
             else:
-                raise Exception, '--prefix options supports only \'int\' and \'proc\''
+                raise Exception('--prefix options supports only \'int\' and \'proc\'')
             for proc in matrix_element.get('processes'):
                 ids = [l.get('id') for l in proc.get('legs_with_decays')]
                 self.prefix_info[tuple(ids)] = [proc_prefix, proc.get_tag()] 
@@ -2597,7 +2602,7 @@ class ProcessExporterFortranMatchBox(Pro
                 if ctype in ['ColorOne' ]:
                     continue
                 if ctype not in ['T', 'Tr' ]:
-                    raise MadGraph5Error, 'Color Structure not handled by Matchbox: %s'  % ctype
+                    raise MadGraph5Error('Color Structure not handled by Matchbox: %s'  % ctype)
                 tmparg += ['0']
                 arg +=tmparg
             for j, v in enumerate(arg):
@@ -2640,9 +2645,9 @@ class ProcessExporterFortranMatchBox(Pro
             if(col_amps and isinstance(col_amps[0],list)):
                 col_amps=col_amps
             else:
-                raise MadGraph5Error, error_msg % 'col_amps'
+                raise MadGraph5Error(error_msg % 'col_amps')
         else:
-            raise MadGraph5Error, error_msg % 'col_amps'
+            raise MadGraph5Error(error_msg % 'col_amps')
 
         text = super(ProcessExporterFortranMatchBox, self).get_JAMP_lines(col_amps,
                                             JAMP_format=JAMP_format,
@@ -3211,8 +3216,8 @@ c     channel position
         nexternal, ninitial = matrix_element.get_nexternal_ninitial()
 
         if ninitial < 1 or ninitial > 2:
-            raise writers.FortranWriter.FortranWriterError, \
-                  """Need ninitial = 1 or 2 to write auto_dsig file"""
+            raise writers.FortranWriter.FortranWriterError( \
+                  """Need ninitial = 1 or 2 to write auto_dsig file""")
 
         replace_dict = {}
 
@@ -3901,7 +3906,7 @@ class ProcessExporterFortranME(ProcessEx
         if makejpg:
             try:
                 os.remove(pjoin(self.dir_path,'HTML','card.jpg'))
-            except Exception, error:
+            except Exception as error:
                 pass
             
             if misc.which('gs'):
@@ -4187,8 +4192,8 @@ class ProcessExporterFortranME(ProcessEx
                                                            p.get('color')>1])))
 
         if ninitial < 1 or ninitial > 2:
-            raise writers.FortranWriter.FortranWriterError, \
-                  """Need ninitial = 1 or 2 to write auto_dsig file"""
+            raise writers.FortranWriter.FortranWriterError( \
+                  """Need ninitial = 1 or 2 to write auto_dsig file""")
 
         replace_dict = {}
 
@@ -4995,8 +5000,8 @@ class ProcessExporterFortranMEGroup(Proc
         ncomb = matrix_elements[0].get_helicity_combinations()
         for me in matrix_elements[1:]:
             if ncomb!=me.get_helicity_combinations():
-                raise MadGraph5Error, "All grouped processes must share the "+\
-                                       "same number of helicity configurations."                
+                raise MadGraph5Error("All grouped processes must share the "+\
+                                       "same number of helicity configurations.")                
 
         filename = 'driver.f'
         self.write_driver(writers.FortranWriter(filename),ncomb,
@@ -5148,7 +5153,7 @@ class ProcessExporterFortranMEGroup(Proc
                 continue
             if nqcd_list[i] != nqcd_list[abs(sym_fact)-1]:
                 misc.sprint(i, sym_fact, nqcd_list[i], nqcd_list[abs(sym_fact)])
-                raise Exception, "identical diagram with different QCD powwer" 
+                raise Exception("identical diagram with different QCD powwer") 
                                       
         
 
@@ -5519,7 +5524,7 @@ class UFO_model_to_mg4(object):
                     continue
                 try:
                     lower_dict[lower_name].append(param)
-                except KeyError,error:
+                except KeyError as error:
                     lower_dict[lower_name] = [param]
                 else:
                     duplicate.add(lower_name)
@@ -6953,7 +6958,7 @@ def ExportV4Factory(cmd, noclean, output
                     ExporterClass=loop_exporters.LoopProcessExporterFortranMatchBox
                     MadLoop_SA_options['export_format'] = 'madloop_matchbox'
                 else:
-                    raise Exception, "output_type not recognize %s" % output_type
+                    raise Exception("output_type not recognize %s" % output_type)
             return ExporterClass(cmd._export_dir, MadLoop_SA_options)
         else:
             raise MadGraph5Error('MG5_aMC cannot find the \'loop_material\' directory'+\
@@ -7046,9 +7051,9 @@ def ExportV4Factory(cmd, noclean, output
                 return cmd._export_plugin(cmd._export_dir, opt)
 
         else:
-            raise Exception, 'Wrong export_v4 format'
+            raise Exception('Wrong export_v4 format')
     else:
-        raise MadGraph5Error, 'Output type %s not reckognized in ExportV4Factory.'
+        raise MadGraph5Error('Output type %s not reckognized in ExportV4Factory.')
     
             
 
@@ -7073,8 +7078,8 @@ class ProcessExporterFortranMWGroup(Proc
         other helper files."""
 
         if not isinstance(subproc_group, group_subprocs.SubProcessGroup):
-            raise base_objects.PhysicsObject.PhysicsObjectError,\
-                  "subproc_group object not SubProcessGroup"
+            raise base_objects.PhysicsObject.PhysicsObjectError(\
+                  "subproc_group object not SubProcessGroup")
 
         if not self.model:
             self.model = subproc_group.get('matrix_elements')[0].\
diff -rupN MadGraph_pristine/madgraph/iolibs/files.py ../contrib/MadGraph/madgraph/iolibs/files.py
--- MadGraph_pristine/madgraph/iolibs/files.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/files.py	2020-10-29 23:48:54.812703886 +1100
@@ -36,11 +36,11 @@ def read_from_file(filename, myfunct, *a
             ret_value = myfunct(sock, *args)
         finally:
             sock.close()
-    except IOError, (errno, strerror):
+    except IOError as e:
         if opt.has_key('print_error'):
             if not opt['print_error']:
                 return None
-        logger.error("I/O error on file %s (%s): %s" % (filename,errno, strerror))
+        logger.error("I/O error on file %s (%s): %s" % (filename,e.errno, e.strerror))
         return None
 
     return ret_value
@@ -60,9 +60,9 @@ def write_to_file(filename, myfunct, *ar
             ret_value = myfunct(sock, *args)
         finally:
             sock.close()
-    except IOError, (errno, strerror):
+    except IOError as e:
         if 'log' not in opts or opts['log']:
-            logger.error("I/O error (%s): %s" % (errno, strerror))
+            logger.error("I/O error (%s): %s" % (e.errno, e.strerror))
         return None
 
     return ret_value
@@ -82,8 +82,8 @@ def append_to_file(filename, myfunct, *a
             ret_value = myfunct(sock, *args)
         finally:
             sock.close()
-    except IOError, (errno, strerror):
-        logger.error("I/O error (%s): %s" % (errno, strerror))
+    except IOError as e:
+        logger.error("I/O error (%s): %s" % (e.errno, e.strerror))
         return None
 
     return ret_value
@@ -136,13 +136,13 @@ def cp(path1, path2, log=True, error=Fal
     path2 = format_path(path2)
     try:
         shutil.copy(path1, path2)
-    except IOError, why:
+    except IOError as why:
         import madgraph.various.misc as misc
         try: 
             if os.path.exists(path2):
                 path2 = os.path.join(path2, os.path.split(path1)[1])
             shutil.copytree(path1, path2)
-        except IOError, why:
+        except IOError as why:
             if error:
                 raise
             if log:
@@ -228,7 +228,7 @@ def ln(file_pos, starting_dir='.', name=
 
     try:
         os.symlink(target, os.path.join(starting_dir, name))
-    except Exception, error:
+    except Exception as error:
         if log:
             logger.debug(error)
             logger.warning('Could not link %s at position: %s' % (file_pos, \
diff -rupN MadGraph_pristine/madgraph/iolibs/file_writers.py ../contrib/MadGraph/madgraph/iolibs/file_writers.py
--- MadGraph_pristine/madgraph/iolibs/file_writers.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/file_writers.py	2020-10-29 23:48:54.812703886 +1100
@@ -19,6 +19,8 @@ Fortran, C++, etc."""
 
 import re
 import collections
+from io import IOBase
+
 try:
     import madgraph
 except ImportError:
@@ -26,7 +28,7 @@ except ImportError:
 else:
     import madgraph.various.misc as misc
 
-class FileWriter(file):
+class FileWriter(IOBase):
     """Generic Writer class. All writers should inherit from this class."""
 
     supported_preprocessor_commands = ['if']
@@ -50,7 +52,7 @@ class FileWriter(file):
     def __init__(self, name, opt = 'w'):
         """Initialize file to write to"""
 
-        return file.__init__(self, name, opt)
+        return IOBase.__init__(self, name, opt)
 
     def write_line(self, line):
         """Write a line with proper indent and splitting of long lines
@@ -148,8 +150,8 @@ class FileWriter(file):
             if preproc_command is None:
                 preproc_endif = self.preprocessor_endif_re.match(line[2:])
                 if len(if_stack)==0 or preproc_endif is None:
-                    raise self.FilePreProcessingError, 'Incorrect '+\
-                             'preprocessing command %s at line %d.'%(line,i)
+                    raise self.FilePreProcessingError('Incorrect '+\
+                             'preprocessing command %s at line %d.'%(line,i))
                 if preproc_endif.group('new_block') is None:
                     if_stack.pop()
                 elif preproc_endif.group('endif')=='else':
@@ -158,15 +160,15 @@ class FileWriter(file):
             elif preproc_command.group('command')=='if':
                 try:
                     if_stack.append(eval(preproc_command.group('body'))==True)
-                except Exception, e:
-                    raise self.FilePreProcessingError, 'Could not evaluate'+\
+                except Exception as e:
+                    raise self.FilePreProcessingError('Could not evaluate'+\
                       "python expression '%s' given the context %s provided."%\
                             (preproc_command.group('body'),str(context))+\
-                                           "\nLine %d of file %s."%(i,self.name)
+                                           "\nLine %d of file %s."%(i,self.name))
         
         if len(if_stack)>0:
-            raise self.FilePreProcessingError, 'Some conditional statements are'+\
-                                                     ' not properly terminated.'
+            raise self.FilePreProcessingError('Some conditional statements are'+\
+                                                     ' not properly terminated.')
         return res
 
 #===============================================================================
@@ -441,7 +443,7 @@ class FortranWriter(FileWriter):
                 else:
                     if not line.endswith('\n'):
                         line = '%s\n' % line
-                    file.writelines(self, line)
+                    IOBase.writelines(self, line)
             else:
                 removed.append(line)
                 
@@ -967,13 +969,13 @@ class PythonWriter(FileWriter):
     
     def write_comments(self, text):
         text = '#%s\n' % text.replace('\n','\n#')
-        file.write(self, text)
+        IOBase.write(self, text)
         
 class MakefileWriter(FileWriter):
     
     def write_comments(self, text):
         text = '#%s\n' % text.replace('\n','\n#')
-        file.write(self, text)
+        IOBase.write(self, text)
         
     def writelines(self, lines):
         """Extends the regular file.writeline() function to write out
diff -rupN MadGraph_pristine/madgraph/iolibs/group_subprocs.py ../contrib/MadGraph/madgraph/iolibs/group_subprocs.py
--- MadGraph_pristine/madgraph/iolibs/group_subprocs.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/group_subprocs.py	2020-10-29 23:48:54.816703838 +1100
@@ -93,8 +93,8 @@ class IdentifyConfigTag(diagram_generati
             # We go from next-to-last link to last link - remove propagator info
             return (old_vertex[0],)
         # We should not get here
-        raise diagram_generation.DiagramTag.DiagramTagError, \
-              "Error in IdentifyConfigTag, wrong setup of vertices in link."
+        raise diagram_generation.DiagramTag.DiagramTagError( \
+              "Error in IdentifyConfigTag, wrong setup of vertices in link.")
         
 #===============================================================================
 # SubProcessGroup
@@ -122,38 +122,38 @@ class SubProcessGroup(base_objects.Physi
 
         if name == 'number':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid int object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid int object" % str(value))
         if name == 'name':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid str object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid str object" % str(value))
         if name == 'amplitudes':
             if not isinstance(value, diagram_generation.AmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid amplitudelist" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid amplitudelist" % str(value))
         if name in ['mapping_diagrams', 'diagrams_for_configs']:
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
         if name == 'diagram_maps':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dict" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dict" % str(value))
         if name == 'matrix_elements':
             if not isinstance(value, helas_objects.HelasMatrixElementList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid HelasMatrixElementList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid HelasMatrixElementList" % str(value))
 
         if name == 'amplitude_map':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dict object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dict object" % str(value))
 
         if name == 'matrix_element_opts':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary object" % str(value))
 
         return True
 
@@ -197,8 +197,8 @@ class SubProcessGroup(base_objects.Physi
         in self"""
 
         if not self.get('amplitudes'):
-            raise self.PhysicsObjectError, \
-                  "Need amplitudes to generate matrix_elements"
+            raise self.PhysicsObjectError( \
+                  "Need amplitudes to generate matrix_elements")
 
         amplitudes = copy.copy(self.get('amplitudes'))
 
@@ -549,16 +549,16 @@ class DecayChainSubProcessGroup(SubProce
 
         if name == 'core_groups':
             if not isinstance(value, SubProcessGroupList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid core_groups" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid core_groups" % str(value))
         if name == 'decay_groups':
             if not isinstance(value, DecayChainSubProcessGroupList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid decay_groups" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid decay_groups" % str(value))
         if name == 'decay_chain_amplitudes':
             if not isinstance(value, diagram_generation.DecayChainAmplitudeList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DecayChainAmplitudeList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DecayChainAmplitudeList" % str(value))
         return True
 
     def get_sorted_keys(self):
diff -rupN MadGraph_pristine/madgraph/iolibs/helas_call_writers.py ../contrib/MadGraph/madgraph/iolibs/helas_call_writers.py
--- MadGraph_pristine/madgraph/iolibs/helas_call_writers.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/helas_call_writers.py	2020-10-29 23:48:54.816703838 +1100
@@ -68,16 +68,16 @@ class HelasCallWriter(base_objects.Physi
 
         if name == 'model':
             if not isinstance(value, base_objects.Model):
-                raise self.PhysicsObjectError, \
-                    "Object of type %s is not a model" % type(value)
+                raise self.PhysicsObjectError( \
+                    "Object of type %s is not a model" % type(value))
 
         if name == 'wavefunctions':
             # Should be a dictionary of functions returning strings, 
             # with keys (spins, flow state)
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dictionary for wavefunction" % \
-                                                                str(value)
+                                                                str(value))
 
             for key in value.keys():
                 self.add_wavefunction(key, value[key])
@@ -86,9 +86,9 @@ class HelasCallWriter(base_objects.Physi
             # Should be a dictionary of functions returning strings, 
             # with keys (spins, flow state)
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                         "%s is not a valid dictionary for amplitude" % \
-                                                                str(value)
+                                                                str(value))
 
             for key in value.keys():
                 self.add_amplitude(key, value[key])
@@ -286,7 +286,7 @@ class HelasCallWriter(base_objects.Physi
 
         try:
             call = self["amplitudes"][amplitude.get_call_key()]
-        except KeyError, error:
+        except KeyError as error:
             return ""
         else:
             return call(amplitude)
@@ -594,9 +594,9 @@ class FortranHelasCallWriter(HelasCallWr
         # If function not already existing, try to generate it.
 
         if len(wavefunction.get('mothers')) > 3:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                   """Automatic generation of Fortran wavefunctions not
-                  implemented for > 3 mothers"""
+                  implemented for > 3 mothers""")
 
         self.generate_helas_call(wavefunction)
         return super(FortranHelasCallWriter, self).get_wavefunction_call(\
@@ -615,9 +615,9 @@ class FortranHelasCallWriter(HelasCallWr
         # If function not already existing, try to generate it.
 
         if len(amplitude.get('mothers')) > 4:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
                   """Automatic generation of Fortran amplitudes not
-                  implemented for > 4 mothers"""
+                  implemented for > 4 mothers""")
 
         self.generate_helas_call(amplitude)
         return super(FortranHelasCallWriter, self).get_amplitude_call(amplitude)
@@ -645,8 +645,8 @@ class FortranHelasCallWriter(HelasCallWr
         
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "get_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "get_helas_call must be called with wavefunction or amplitude")
 
         call = "CALL "
 
@@ -1085,8 +1085,8 @@ class FortranUFOHelasCallWriter(UFOHelas
 
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "generate_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "generate_helas_call must be called with wavefunction or amplitude")
         
         call = "CALL "
 
@@ -1255,8 +1255,8 @@ class FortranUFOHelasCallWriter(UFOHelas
                 elif lcutpart.get('spin')==2 or lcutpart.get('spin')==3:
                     res.append("DO I=1,4")
                 else:
-                    raise self.PhysicsObjectError, \
-                  "The L-cut particle type is not supported"
+                    raise self.PhysicsObjectError( \
+                  "The L-cut particle type is not supported")
                 # Temporarily relabel the 'me_id' attribute of the external wfs
                 # in this wavefunction's mothers so to have them matching the
                 # convention in the loop helas calls.
@@ -1495,8 +1495,8 @@ class FortranUFOHelasCallWriterOptimized
             
         if isinstance(argument, helas_objects.HelasAmplitude) and \
                                                   argument.get('type')=='loop':
-           raise MadGraph5Error, 'There should not be any helas call '+\
-                                'associated with helas amplitudes of type loop.'
+           raise MadGraph5Error( 'There should not be any helas call '+\
+                                'associated with helas amplitudes of type loop.')
 
         # Check if we need to append a charge conjugation flag
         l = [str(l) for l in argument.get('lorentz')]
@@ -1612,8 +1612,8 @@ class CPPUFOHelasCallWriter(UFOHelasCall
 
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "get_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "get_helas_call must be called with wavefunction or amplitude")
         
         call = ""
 
@@ -1742,8 +1742,8 @@ class PythonUFOHelasCallWriter(UFOHelasC
                                    and wf.get('spin') == 3 \
                                    and wf.get('mass').lower() == 'zero']
                 if not gauge_check_wfs:
-                    raise HelasWriterError, \
-                          'no massless spin one particle for gauge check'
+                    raise HelasWriterError( \
+                          'no massless spin one particle for gauge check')
                 gauge_check_wf = wfs.pop(wfs.index(gauge_check_wfs[0]))
                 res.append(self.generate_helas_call(gauge_check_wf, True)(\
                                                     gauge_check_wf))
@@ -1764,8 +1764,8 @@ class PythonUFOHelasCallWriter(UFOHelasC
 
         if not isinstance(argument, helas_objects.HelasWavefunction) and \
            not isinstance(argument, helas_objects.HelasAmplitude):
-            raise self.PhysicsObjectError, \
-                  "get_helas_call must be called with wavefunction or amplitude"
+            raise self.PhysicsObjectError( \
+                  "get_helas_call must be called with wavefunction or amplitude")
         
         call_function = None
 
diff -rupN MadGraph_pristine/madgraph/iolibs/template_files/__init__.py ../contrib/MadGraph/madgraph/iolibs/template_files/__init__.py
--- MadGraph_pristine/madgraph/iolibs/template_files/__init__.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/template_files/__init__.py	2020-10-29 23:48:54.816703838 +1100
@@ -1,2 +1,2 @@
-import mg4_proc_card
+from .mg4_proc_card import *
 
diff -rupN MadGraph_pristine/madgraph/iolibs/ufo_expression_parsers.py ../contrib/MadGraph/madgraph/iolibs/ufo_expression_parsers.py
--- MadGraph_pristine/madgraph/iolibs/ufo_expression_parsers.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/iolibs/ufo_expression_parsers.py	2020-10-29 23:48:54.816703838 +1100
@@ -924,17 +924,17 @@ class UFOExpressionParserPythonIF(UFOExp
                 try:
                     self.defined_variables = eval(args[0])
                 except:
-                    raise ModelError, 'The expression "%s"'%str(args[0])+\
+                    raise ModelError('The expression "%s"'%str(args[0])+\
                       " given as defined variables for the UFOExpressionParserPythonIF"+\
-                      " does not have a correct syntax."
+                      " does not have a correct syntax.")
                 if not isinstance(self.defined_variables, dict):
-                    raise ModelError, 'The argument "%s"'%str(args[0])+\
+                    raise ModelError('The argument "%s"'%str(args[0])+\
                       " given as defined variables for the UFOExpressionParserPythonIF"+\
-                      " is not a dictionary."
+                      " is not a dictionary.")
             else:
-                raise ModelError, "The argument %s"%str(args[0])+\
+                raise ModelError("The argument %s"%str(args[0])+\
                       " given as defined variables for the UFOExpressionParserPythonIF"+\
-                      " must be either a dictionary or a string."
+                      " must be either a dictionary or a string.")
             args = args[1:]
             for key, value in self.defined_variables.items():
                 if not isinstance(key,str) or \
@@ -1052,7 +1052,7 @@ class UFOExpressionParserPythonIF(UFOExp
 if __name__ == '__main__':
     
     if len(sys.argv) == 1:
-        print "Please specify a parser: fortran, mpfortran or c++"
+        print("Please specify a parser: fortran, mpfortran or c++")
         exit()
     if sys.argv[1] == "fortran":
         calc = UFOExpressionParserFortran()
@@ -1068,10 +1068,10 @@ if __name__ == '__main__':
         else:
             calc = UFOExpressionParserPythonIF()
     else:
-        print "Please specify a parser: fortran, mpfortran, c++ or pythonif"
-        print "You gave", sys.argv[1]
+        print("Please specify a parser: fortran, mpfortran, c++ or pythonif")
+        print("You gave", sys.argv[1])
         if len(sys.argv) > 2:
-            print "with the second argument",sys.argv[2]
+            print("with the second argument",sys.argv[2])
         exit()
 
     while 1:
@@ -1080,5 +1080,5 @@ if __name__ == '__main__':
         except EOFError:
             break
         if not s: continue
-        print calc.parse(s)
+        print(calc.parse(s))
     
diff -rupN MadGraph_pristine/madgraph/loop/loop_base_objects.py ../contrib/MadGraph/madgraph/loop/loop_base_objects.py
--- MadGraph_pristine/madgraph/loop/loop_base_objects.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_base_objects.py	2020-10-29 23:48:54.820703789 +1100
@@ -88,48 +88,48 @@ class LoopDiagram(base_objects.Diagram):
 
         if name == 'tag':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid tag" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid tag" % str(value))
             else:
                 for item in value:
                     if (len(item)!=3 or \
                       not isinstance(item[0],base_objects.Leg) or \
                       not isinstance(item[1],list)) or \
                       not isinstance(item[2],base_objects.Vertex):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid tag" % str(value)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid tag" % str(value))
 
         if name == 'canonical_tag':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid tag" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid tag" % str(value))
             else:
                 for item in value:
                     if (len(item)!=3 or not isinstance(item[0],int) or \
                       not isinstance(item[1],list)) or \
                       not isinstance(item[2],int):
-                        raise self.PhysicsObjectError, \
-                            "%s is not a valid canonical_tag" % str(value)
+                        raise self.PhysicsObjectError( \
+                            "%s is not a valid canonical_tag" % str(value))
 
         if name == 'CT_vertices':
             if not isinstance(value, base_objects.VertexList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid VertexList object" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid VertexList object" % str(value))
 
         if name == 'type':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
 
         if name == 'multiplier':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid integer" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid integer" % str(value))
 
         if name == 'contracted_diagram':
             if not isinstance(value, base_objects.Diagram):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid Diagram." % str(value)                            
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid Diagram." % str(value))                            
 
         else:
             super(LoopDiagram, self).filter(name, value)
@@ -206,9 +206,9 @@ class LoopDiagram(base_objects.Diagram):
         # Without the tagging information we will have to reconstruct the
         # contracted diagrams with the unordered vertices
         if len(self.get('vertices'))==0:
-            raise MadGraph5Error, "Function get_contracted_loop_diagram()"+\
+            raise MadGraph5Error("Function get_contracted_loop_diagram()"+\
                 "called for the first time without specifying struct_rep "+\
-                                            "for a diagram already tagged."
+                                            "for a diagram already tagged.")
                                 
         # The leg below will be the outgoing one 
         contracted_vertex_last_loop_leg = None
@@ -635,8 +635,8 @@ class LoopDiagram(base_objects.Diagram):
             start=start_in.get('number')
             end=end_in.get('number')
         else:
-            raise MadGraph5Error, "In the diagram tag function, 'start' and "+\
-                " 'end' must be either integers or Leg objects." 
+            raise MadGraph5Error("In the diagram tag function, 'start' and "+\
+                " 'end' must be either integers or Leg objects." )
         
         if self.process_next_loop_leg(struct_rep,-1,-1,start,end,\
                                           loopVertexList, model, external_legs):
@@ -657,8 +657,8 @@ class LoopDiagram(base_objects.Diagram):
                 canonical_tag=self.choose_optimal_lcut(self['tag'],struct_rep, 
                                                            model, external_legs)
             else:
-                raise MadGraph5Error, 'The cutting method %s is not implemented.'\
-                                                            %self.cutting_method
+                raise MadGraph5Error('The cutting method %s is not implemented.'\
+                                                            %self.cutting_method)
             # The tag of the diagram is now updated with the canonical tag
             self['tag']=canonical_tag
             # We assign here the loopVertexList to the list of vertices 
@@ -674,8 +674,8 @@ class LoopDiagram(base_objects.Diagram):
             self['canonical_tag']=[[t[0]['id'],t[1],t[2]] for t in canonical_tag]
             return True
         else:
-            raise self.PhysicsObjectError, \
-                  "Loop diagram tagging failed."
+            raise self.PhysicsObjectError( \
+                  "Loop diagram tagging failed.")
             return False
 
 
@@ -717,9 +717,9 @@ class LoopDiagram(base_objects.Diagram):
                     # Now we can add the corresponding vertex
                     return base_objects.Vertex({'legs':myleglist,'id':vertID})
         else:
-            raise cls.PhysicsObjectError, \
+            raise cls.PhysicsObjectError( \
             "An interaction from the original L-cut diagram could"+\
-            " not be found when reconstructing the loop vertices."
+            " not be found when reconstructing the loop vertices.")
 
     def process_next_loop_leg(self, structRep, fromVert, fromPos, currLeg, \
                                   endLeg, loopVertexList, model, external_legs):
@@ -748,8 +748,8 @@ class LoopDiagram(base_objects.Diagram):
                                self['vertices'][i].get('legs')[k],FDStruct)
 
             if not canonical:
-                raise self.PhysicsObjectError, \
-                      "Failed to reconstruct a FDStructure."
+                raise self.PhysicsObjectError( \
+                      "Failed to reconstruct a FDStructure.")
             
             # The branch was directly an external leg, so it the canonical
             # repr of this struct is simply ((legID),0).
@@ -758,8 +758,8 @@ class LoopDiagram(base_objects.Diagram):
             elif isinstance(canonical,tuple):
                 FDStruct.set('canonical',canonical)
             else:                                      
-                raise self.PhysicsObjectError, \
-                "Non-proper behavior of the construct_FDStructure function"
+                raise self.PhysicsObjectError( \
+                "Non-proper behavior of the construct_FDStructure function")
             
             # First check if this structure exists in the dictionary of the
             # structures already obtained in the diagrams for this process
@@ -858,8 +858,8 @@ class LoopDiagram(base_objects.Diagram):
                                 nextLoopLeg=self['vertices'][i].get('legs')[k]
                                 legPos=pos
                             else:
-                                raise self.PhysicsObjectError, \
-                                  " An interaction has more than two loop legs."
+                                raise self.PhysicsObjectError( \
+                                  " An interaction has more than two loop legs.")
                         else:
                             process_loop_interaction(i,j,k,pos)
                     # Now that we have found loop leg curr_leg, we can get out 
@@ -1135,8 +1135,8 @@ class LoopDiagram(base_objects.Diagram):
                 branch=self.construct_FDStructure(i, legPos, \
                               self['vertices'][vertID].get('legs')[k], FDStruct)
                 if not branch:
-                    raise self.PhysicsObjectError, \
-                          "Failed to reconstruct a FDStructure."
+                    raise self.PhysicsObjectError( \
+                          "Failed to reconstruct a FDStructure.")
                 # That means that this branch was an external leg. 
                 if isinstance(branch,int):
                     parentBuffer[0].append(branch)
@@ -1146,8 +1146,8 @@ class LoopDiagram(base_objects.Diagram):
                     parentBuffer[0]+=list(branch[0][0])
                     vertBuffer.append(branch)
                 else:
-                    raise self.PhysicsObjectError, \
-                    "Non-proper behavior of the construct_FDStructure function"
+                    raise self.PhysicsObjectError( \
+                    "Non-proper behavior of the construct_FDStructure function")
             return legPos
 
         # == Beginning of the code ==
@@ -1193,8 +1193,8 @@ class LoopDiagram(base_objects.Diagram):
                 FDStruct.get('external_legs').append(copy.copy(currLeg))
                 return currLeg.get('number')
             else:
-                raise self.PhysicsObjectError, \
-                                  " A structure is malformed."
+                raise self.PhysicsObjectError( \
+                                  " A structure is malformed.")
         else:
             # In this case a vertex with currLeg has been found and we must
             # return the list of tuple described above. First let's sort the 
@@ -1360,23 +1360,23 @@ class LoopUVCTDiagram(base_objects.Diagr
 
         if name == 'UVCT_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid list" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid list" % str(value))
             else:
                 for elem in value:
                     if not isinstance(elem, str) and not isinstance(elem, int):
-                        raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                        raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
         
         if name == 'UVCT_orders':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))
 
         if name == 'type':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
         
         else:
             super(LoopUVCTDiagram, self).filter(name, value)
@@ -1474,14 +1474,14 @@ class LoopModel(base_objects.Model):
 
         if name == 'perturbation_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a list" % \
-                                                            type(value)
+                                                            type(value))
             for order in value:
                 if not isinstance(order, str):
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                         "Object of type %s is not a string" % \
-                                                            type(order)
+                                                            type(order))
         else:
             super(LoopModel,self).filter(name,value)
         
@@ -1534,9 +1534,9 @@ class DGLoopLeg(base_objects.Leg):
 
         if name == 'depth':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
                     "Object of type %s is not a int" % \
-                                                            type(value)
+                                                            type(value))
         else:
             super(DGLoopLeg,self).filter(name,value)
         
@@ -1587,33 +1587,33 @@ class FDStructure(base_objects.PhysicsOb
 
         if name == 'vertices':
             if not isinstance(value, base_objects.VertexList):
-                raise self.PhysicsObjectError, \
-        "%s is not a valid VertexList object" % str(value)
+                raise self.PhysicsObjectError( \
+        "%s is not a valid VertexList object" % str(value))
 
         if name == 'id':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-        "id %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+        "id %s is not an integer" % repr(value))
 
         if name == 'weight':
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-        "weight %s is not an integer" % repr(value)
+                raise self.PhysicsObjectError( \
+        "weight %s is not an integer" % repr(value))
 
         if name == 'external_legs':
             if not isinstance(value, base_objects.LegList):
-                raise self.PhysicsObjectError, \
-        "external_legs %s is not a valid Leg List" % str(value)
+                raise self.PhysicsObjectError( \
+        "external_legs %s is not a valid Leg List" % str(value))
 
         if name == 'binding_leg':
             if not isinstance(value, base_objects.Leg):
-                raise self.PhysicsObjectError, \
-        "binding_leg %s is not a valid Leg" % str(value)
+                raise self.PhysicsObjectError( \
+        "binding_leg %s is not a valid Leg" % str(value))
 
         if name == 'canonical':
             if not isinstance(value, tuple):
-                raise self.PhysicsObjectError, \
-        "canonical %s is not a valid tuple" % str(value)
+                raise self.PhysicsObjectError( \
+        "canonical %s is not a valid tuple" % str(value))
 
         return True
     
@@ -1693,9 +1693,9 @@ class FDStructure(base_objects.PhysicsOb
         ref_dict_to1 = model.get('ref_dict_to1')
 
         if not tag:
-            raise self.PhysicsObjectError, \
+            raise self.PhysicsObjectError( \
         "The canonical tag of the FD structure is not set yet, so that the "+\
-        "reconstruction of the vertices cannot be performed."
+        "reconstruction of the vertices cannot be performed.")
 
         # Create a local copy of the external legs
         leglist = copy.deepcopy(external_legs)
@@ -1783,9 +1783,9 @@ class FDStructure(base_objects.PhysicsOb
                 tag.pop(0)
 
             else:
-                raise self.PhysicsObjectError, \
+                raise self.PhysicsObjectError( \
         "The canonical tag of the FD structure is corrupted because one "+\
-        "interaction does not exist."
+        "interaction does not exist.")
 
 #===============================================================================
 # FDStructureList
@@ -1814,9 +1814,9 @@ class FDStructureList(base_objects.Physi
                     return FDStruct
             return None
         else:
-            raise self.PhysicsObjectListError, \
+            raise self.PhysicsObjectListError( \
               "The ID %s specified for get_struct is not an integer or tuple"%\
-                                                                    repr(object)
+                                                                    repr(object))
 
     def nice_string(self):
         """Returns a nicely formatted string"""
diff -rupN MadGraph_pristine/madgraph/loop/loop_color_amp.py ../contrib/MadGraph/madgraph/loop/loop_color_amp.py
--- MadGraph_pristine/madgraph/loop/loop_color_amp.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_color_amp.py	2020-10-29 23:48:54.820703789 +1100
@@ -67,8 +67,8 @@ class LoopColorBasis(color_amp.ColorBasi
               [color_algebra.Tr(lcut_numbers[1],lcut_numbers[0])],
               fractions.Fraction(2, 1))
         else:
-            raise color_amp.ColorBasis.ColorBasisError, \
-        "L-cut particle has an unsupported color representation %s" % lcut_charge
+            raise color_amp.ColorBasis.ColorBasisError( \
+        "L-cut particle has an unsupported color representation %s" % lcut_charge)
 
         # Append it to all color strings for this diagram.
         for CS in colorize_dict.values():
@@ -110,8 +110,8 @@ class LoopColorBasis(color_amp.ColorBasi
         list_color_dict = []
         
         if not isinstance(amplitude,loop_diagram_generation.LoopAmplitude):
-            raise color_amp.ColorBasis.ColorBasisError, \
-              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude'
+            raise color_amp.ColorBasis.ColorBasisError( \
+              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude')
         for diagram in amplitude.get('loop_diagrams'):
 
             colorize_dict = self.colorize(diagram,
@@ -147,8 +147,8 @@ class LoopColorBasis(color_amp.ColorBasi
         list_color_dict = []
 
         if not isinstance(amplitude,loop_diagram_generation.LoopAmplitude):
-            raise color_amp.ColorBasis.ColorBasisError, \
-              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude'
+            raise color_amp.ColorBasis.ColorBasisError( \
+              'LoopColorBasis is used with an amplitude which is not a LoopAmplitude')
 
         for diagram in amplitude.get('born_diagrams'):
             colorize_dict = self.colorize(diagram,
diff -rupN MadGraph_pristine/madgraph/loop/loop_diagram_generation.py ../contrib/MadGraph/madgraph/loop/loop_diagram_generation.py
--- MadGraph_pristine/madgraph/loop/loop_diagram_generation.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_diagram_generation.py	2020-10-29 23:48:54.820703789 +1100
@@ -104,37 +104,37 @@ class LoopAmplitude(diagram_generation.A
 
         if name == 'diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DiagramList" % str(value))
             for diag in value:
                 if not isinstance(diag,loop_base_objects.LoopDiagram) and \
                    not isinstance(diag,loop_base_objects.LoopUVCTDiagram):
-                    raise self.PhysicsObjectError, \
-                        "%s contains a diagram which is not an NLODiagrams." % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s contains a diagram which is not an NLODiagrams." % str(value))
         if name == 'born_diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DiagramList" % str(value))
             for diag in value:
                 if not isinstance(diag,loop_base_objects.LoopDiagram):
-                    raise self.PhysicsObjectError, \
-                        "%s contains a diagram which is not an NLODiagrams." % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s contains a diagram which is not an NLODiagrams." % str(value))
         if name == 'loop_diagrams':
             if not isinstance(value, base_objects.DiagramList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid DiagramList" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid DiagramList" % str(value))
             for diag in value:
                 if not isinstance(diag,loop_base_objects.LoopDiagram):
-                    raise self.PhysicsObjectError, \
-                        "%s contains a diagram which is not an NLODiagrams." % str(value)
+                    raise self.PhysicsObjectError( \
+                        "%s contains a diagram which is not an NLODiagrams." % str(value))
         if name == 'has_born':
             if not isinstance(value, bool):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
         if name == 'structure_repository':
             if not isinstance(value, loop_base_objects.FDStructureList):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid bool" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid bool" % str(value))
 
         else:
             super(LoopAmplitude, self).filter(name, value)
@@ -329,8 +329,8 @@ class LoopAmplitude(diagram_generation.A
         n_discarded = 0
         for diag in self['loop_diagrams']:
             if diag.get('tag')==[]:
-                raise MadGraph5Error, "The loop diagrams should have been tagged"+\
-                  " before going through the Furry filter."
+                raise MadGraph5Error("The loop diagrams should have been tagged"+\
+                  " before going through the Furry filter.")
             
             loop_line_pdgs = diag.get_loop_lines_pdgs()
             attached_pdgs   = diag.get_pdgs_attached_to_loop(structs)
@@ -402,8 +402,8 @@ class LoopAmplitude(diagram_generation.A
         i=0
         for diag in self['loop_diagrams']:
             if diag.get('tag')==[]:
-                raise MadGraph5Error, "Before using the user_filter, please "+\
-                       "make sure that the loop diagrams have been tagged first."
+                raise MadGraph5Error("Before using the user_filter, please "+\
+                       "make sure that the loop diagrams have been tagged first.")
             valid_diag = True
             i=i+1
     
diff -rupN MadGraph_pristine/madgraph/loop/loop_helas_objects.py ../contrib/MadGraph/madgraph/loop/loop_helas_objects.py
--- MadGraph_pristine/madgraph/loop/loop_helas_objects.py	2020-10-27 21:41:37.897090342 +1100
+++ ../contrib/MadGraph/madgraph/loop/loop_helas_objects.py	2020-10-29 23:48:54.820703789 +1100
@@ -79,22 +79,22 @@ class LoopHelasUVCTAmplitude(helas_objec
 
         if name=='UVCT_couplings':
             if not isinstance(value, list):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list for UVCT_couplings" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list for UVCT_couplings" % str(value))
             for id in value:
                 if not isinstance(id, str) and not isinstance(id, int):
-                    raise self.PhysicsObjectError, \
-                      "%s is not a valid string or integer for UVCT_couplings" % str(value)
+                    raise self.PhysicsObjectError( \
+                      "%s is not a valid string or integer for UVCT_couplings" % str(value))
                       
         if name == 'UVCT_orders':
             if not isinstance(value, dict):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid dictionary" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid dictionary" % str(value))
 
         if name == 'type':
             if not isinstance(value, str):
-                raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(value)
+                raise self.PhysicsObjectError( \
+                        "%s is not a valid string" % str(value))
 
         else:
             return super(LoopHelasUVCTAmplitude,self).filter(name, value)
@@ -279,22 +279,22 @@ class LoopHelasAmplitude(helas_objects.H
 
         if name=='wavefunctions':
             if not isinstance(value, helas_objects.HelasWavefunctionList):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list of HelasWaveFunctions" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list of HelasWaveFunctions" % str(value))
             for wf in value:
                 if not wf['is_loop']:
-                    raise self.PhysicsObjectError, \
-                      "Wavefunctions from a LoopHelasAmplitude must be from a loop."
+                    raise self.PhysicsObjectError( \
+                      "Wavefunctions from a LoopHelasAmplitude must be from a loop.")
         
         elif name=='amplitudes':
             if not isinstance(value, helas_objects.HelasAmplitudeList):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list of HelasAmplitudes" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list of HelasAmplitudes" % str(value))
 
         elif name in ['type','loop_group_id','multiplier','loopsymmetryfactor']:
             if not isinstance(value, int):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid integer for the attribute '%s'" %(str(value),name)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid integer for the attribute '%s'" %(str(value),name))
 
         else:
             return super(LoopHelasAmplitude,self).filter(name, value)
@@ -332,9 +332,9 @@ class LoopHelasAmplitude(helas_objects.H
         final_lwf=[lwf for lwf in self.get('amplitudes')[0].get('mothers') if \
                    lwf.get('mothers')]
         if len(final_lwf)!=1:
-            raise MadGraph5Error, 'The helas amplitude building the helas loop'+\
+            raise MadGraph5Error( 'The helas amplitude building the helas loop'+\
                 ' amplitude should be made of exactly one loop wavefunctions'+\
-                ' with mothers.'
+                ' with mothers.')
         return final_lwf[0]
 
     def get_base_diagram(self, wf_dict, vx_list = [], optimization = 1):
@@ -628,19 +628,19 @@ class LoopHelasMatrixElement(helas_objec
         
         if name=='born_color_basis' or name=='loop_color_basis':
             if not isinstance(value,color_amp.ColorBasis):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid color basis" % str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid color basis" % str(value))
         elif name=='loop_groups':
             if not isinstance(value,list):
-                raise self.PhysicsObjectError, \
-                  "%s is not a valid list"%str(value)
+                raise self.PhysicsObjectError( \
+                  "%s is not a valid list"%str(value))
             for (dkey, dvalue) in value:
                 if not isinstance(dvalue,helas_objects.HelasAmplitudeList):
-                    raise self.PhysicsObjectError, \
-                      "%s is not a valid HelasAmplitudeList."%str(dvalue)
+                    raise self.PhysicsObjectError( \
+                      "%s is not a valid HelasAmplitudeList."%str(dvalue))
                 if not isinstance(dkey,tuple):
-                    raise self.PhysicsObjectError, \
-                      "%s is not a valid tuple."%str(dkey)
+                    raise self.PhysicsObjectError( \
+                      "%s is not a valid tuple."%str(dkey))
         else:
             return super(LoopHelasMatrixElement,self).filter(name, value)
 
@@ -1465,9 +1465,9 @@ class LoopHelasMatrixElement(helas_objec
                 for last_loop_wf, color_list in zip(last_loop_wfs,color_lists):
                     # Now generate HelasAmplitudes from the last vertex.
                     if lastvx.get('id')!=-1:
-                        raise self.PhysicsObjectError, \
+                        raise self.PhysicsObjectError( \
                           "The amplitude vertex of a loop diagram must be a "+\
-                          "two point vertex with id=-1" 
+                          "two point vertex with id=-1") 
                     # skip the boson and Dirac fermions
                     # adjust the fermion flow of external majorana loop wfs
                     if other_external_loop_wf.is_majorana():
@@ -1543,21 +1543,21 @@ class LoopHelasMatrixElement(helas_objec
                 if lcut_wf1.is_boson():
                     if lcut_wf1.get('state')!='final' or\
                             lcut_wf2.get('state')!='final':
-                        raise MadGraph5Error,\
-                            "Inconsistent flow in L-cut bosons."
+                        raise MadGraph5Error(\
+                            "Inconsistent flow in L-cut bosons.")
                 elif not lcut_wf1.is_majorana():
                     for lcut_wf in [lcut_wf1,lcut_wf2]:
                         if not ((lcut_wf.get('is_part') and \
                                      lcut_wf.get('state')=='outgoing') or\
                                     (not lcut_wf.get('is_part') and\
                                          lcut_wf.get('state')=='incoming')):
-                            raise MadGraph5Error,\
-                                "Inconsistent flow in L-cut Dirac fermions."
+                            raise MadGraph5Error(\
+                                "Inconsistent flow in L-cut Dirac fermions.")
                 elif lcut_wf1.is_majorana():
                     if (lcut_wf1.get('state'), lcut_wf2.get('state')) not in \
                             [('incoming','outgoing'),('outgoing','incoming')]:
-                        raise MadGraph5Error,\
-                            "Inconsistent flow in L-cut Majorana fermions."
+                        raise MadGraph5Error(\
+                            "Inconsistent flow in L-cut Majorana fermions.")
                             
             def fix_lcut_majorana_fermion_flow(last_loop_wf,\
                                                other_external_loop_wf):
@@ -2388,8 +2388,8 @@ class LoopHelasMatrixElement(helas_objec
         """ Just to forbid the usage of this generic function in a
         LoopHelasMatrixElement"""
 
-        raise self.PhysicsObjectError, \
-            "Usage of get_color_amplitudes is not allowed in a LoopHelasMatrixElement"
+        raise self.PhysicsObjectError( \
+            "Usage of get_color_amplitudes is not allowed in a LoopHelasMatrixElement")
 
     def get_born_color_amplitudes(self):
         """Return a list of (coefficient, amplitude number) lists,
@@ -2456,12 +2456,12 @@ class LoopHelasMatrixElement(helas_objec
                           tuple(amp.get('color_indices')) == diag_tuple[1],
                           LoopDiagramsHelasAmplitudeList[diag_tuple[0]])
                 if not res_amps:
-                    raise self.PhysicsObjectError, \
+                    raise self.PhysicsObjectError( \
                           """No amplitude found for color structure
                             %s and color index chain (%s) (diagram %i)""" % \
                             (col_basis_elem,
                              str(diag_tuple[1]),
-                             diag_tuple[0])
+                             diag_tuple[0]))
 
                 for res_amp in res_amps:
                     col_amp.append(((res_amp.get('fermionfactor'),
diff -rupN MadGraph_pristine/madgraph/various/banner.py ../contrib/MadGraph/madgraph/various/banner.py
--- MadGraph_pristine/madgraph/various/banner.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/banner.py	2020-10-29 23:53:55.605892768 +1100
@@ -22,7 +22,11 @@ import os
 import sys
 import re
 import math
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
 
 pjoin = os.path.join
 
@@ -181,7 +185,7 @@ class Banner(dict):
         if version < 3:
             version = 1
         elif version > 3:
-            raise Exception, "Not Supported version"
+            raise Exception("Not Supported version")
         self.lhe_version = version
     
     def get_cross(self, witherror=False):
@@ -306,27 +310,27 @@ class Banner(dict):
         """get the lha_strategy: how the weight have to be handle by the shower"""
         
         if not self["init"]:
-            raise Exception, "No init block define"
+            raise Exception("No init block define")
         
         data = self["init"].split('\n')[0].split()
         if len(data) != 10:
             misc.sprint(len(data), self['init'])
-            raise Exception, "init block has a wrong format"
+            raise Exception("init block has a wrong format")
         return int(float(data[-2]))
         
     def set_lha_strategy(self, value):
         """set the lha_strategy: how the weight have to be handle by the shower"""
         
         if not (-4 <= int(value) <= 4):
-            raise Exception, "wrong value for lha_strategy", value
+            raise Exception("wrong value for lha_strategy", value)
         if not self["init"]:
-            raise Exception, "No init block define"
+            raise Exception("No init block define")
         
         all_lines = self["init"].split('\n')
         data = all_lines[0].split()
         if len(data) != 10:
             misc.sprint(len(data), self['init'])
-            raise Exception, "init block has a wrong format"
+            raise Exception("init block has a wrong format")
         data[-2] = '%s' % value
         all_lines[0] = ' '.join(data)
         self['init'] = '\n'.join(all_lines)
@@ -459,7 +463,7 @@ class Banner(dict):
             elif 'madanalysis5_hadron_card' in card_name:
                 tag='MA5Card_hadron'
             else:
-                raise Exception, 'Impossible to know the type of the card'
+                raise Exception('Impossible to know the type of the card')
 
             self.add_text(tag.lower(), open(path).read())
 
@@ -566,7 +570,7 @@ class Banner(dict):
             if tag == 'mg5proccard':
                 try:
                     return card.get(arg[0])
-                except KeyError, error:
+                except KeyError as error:
                     if 'default' in opt:
                         return opt['default']
                     else:
@@ -589,7 +593,7 @@ class Banner(dict):
         elif len(arg) == 0:
             return card
         else:
-            raise Exception, "Unknow command"
+            raise Exception("Unknow command")
     
     #convenient alias
     get = get_detail
@@ -685,7 +689,7 @@ def recover_banner(results_object, level
     if not tag:
         try:    
             _tag = results_object[run].tags[-1] 
-        except Exception,error:
+        except Exception as error:
             if os.path.exists( pjoin(results_object.path,'Events','%s_banner.txt' % (run))):
                 tag = None
             else:
@@ -790,7 +794,7 @@ class ProcCard(list):
                 self.append(tmp.strip())
                 store_line = ""
         if store_line:
-            raise Exception, "WRONG CARD FORMAT"
+            raise Exception("WRONG CARD FORMAT")
         
         
     def move_to_last(self, cmd):
@@ -1185,7 +1189,7 @@ class ConfigFile(dict):
                 else:
                     dict.__getitem__(self, lower_name).update(value)
             else:
-                raise Exception, '%s should be of dict type'% lower_name
+                raise Exception('%s should be of dict type'% lower_name)
             if change_userdefine:
                 self.user_set.add(lower_name)
             return self.post_set(lower_name, None, change_userdefine, raiseerror)
@@ -1254,12 +1258,12 @@ class ConfigFile(dict):
                 targettype=typelist
                 assert typelist
             if any([targettype != type(v) for v in value]):
-                raise Exception, "All entry should have the same type"
+                raise Exception("All entry should have the same type")
             self.list_parameter[lower_name] = targettype
         elif isinstance(value, dict):
             allvalues = value.values()
             if any([type(allvalues[0]) != type(v) for v in allvalues]):
-                raise Exception, "All entry should have the same type"   
+                raise Exception("All entry should have the same type")   
             self.dict_parameter[lower_name] = type(allvalues[0])  
             if '__type__' in value:
                 del value['__type__']
@@ -1318,11 +1322,11 @@ class ConfigFile(dict):
                 if new_value == value:
                     value = new_value
                 else:
-                    raise InvalidCmd, "Wrong input type for %s found %s and expecting %s for value %s" %\
-                        (name, type(value), targettype, value)
+                    raise InvalidCmd("Wrong input type for %s found %s and expecting %s for value %s" %\
+                        (name, type(value), targettype, value))
             else:
-                raise InvalidCmd, "Wrong input type for %s found %s and expecting %s for value %s" %\
-                        (name, type(value), targettype, value)                
+                raise InvalidCmd("Wrong input type for %s found %s and expecting %s for value %s" %\
+                        (name, type(value), targettype, value))                
         else:
             # We have a string we have to format the attribute from the string
             if targettype == UnknownType:
@@ -1335,7 +1339,7 @@ class ConfigFile(dict):
                 elif value.lower() in ['1', '.true.', 't', 'true', 'on']:
                     value = True
                 else:
-                    raise InvalidCmd, "%s can not be mapped to True/False for %s" % (repr(value),name)
+                    raise InvalidCmd("%s can not be mapped to True/False for %s" % (repr(value),name))
             elif targettype == str:
                 value = value.strip()
                 if value.startswith('\'') and value.endswith('\''):
@@ -1361,25 +1365,25 @@ class ConfigFile(dict):
                                 v /=  float(split[2*i+2])
                     except:
                         v=0
-                        raise InvalidCmd, "%s can not be mapped to an integer" % value
+                        raise InvalidCmd("%s can not be mapped to an integer" % value)
                     finally:
                         value = int(v)
                         if value != v:
-                            raise InvalidCmd, "%s can not be mapped to an integer" % v
+                            raise InvalidCmd("%s can not be mapped to an integer" % v)
                 else:
                     try:
                         value = float(value.replace('d','e'))
                     except ValueError:
-                        raise InvalidCmd, "%s can not be mapped to an integer" % value                    
+                        raise InvalidCmd("%s can not be mapped to an integer" % value)                   
                     try:
                         new_value = int(value)
                     except ValueError:
-                        raise InvalidCmd, "%s can not be mapped to an integer" % value
+                        raise InvalidCmd("%s can not be mapped to an integer" % value)
                     else:
                         if value == new_value:
                             value = new_value
                         else:
-                            raise InvalidCmd, "incorect input: %s need an integer for %s" % (value,name)
+                            raise InvalidCmd("incorect input: %s need an integer for %s" % (value,name))
                      
             elif targettype == float:
                 if value.endswith(('k', 'M')) and value[:-1].isdigit():
@@ -1400,11 +1404,11 @@ class ConfigFile(dict):
                                     v /=  float(split[2*i+2])
                         except:
                             v=0
-                            raise InvalidCmd, "%s can not be mapped to a float" % value
+                            raise InvalidCmd("%s can not be mapped to a float" % value)
                         finally:
                             value = v
             else:
-                raise InvalidCmd, "type %s is not handle by the card" % targettype
+                raise InvalidCmd("type %s is not handle by the card" % targettype)
             
         return value
             
@@ -1416,8 +1420,8 @@ class ConfigFile(dict):
         if __debug__:
             if lower_name not in self:
                 if lower_name in [key.lower() for key in self] :
-                    raise Exception, "Some key are not lower case %s. Invalid use of the class!"\
-                                     % [key for key in self if key.lower() != key]
+                    raise Exception("Some key are not lower case %s. Invalid use of the class!"\
+                                     % [key for key in self if key.lower() != key])
         
         if lower_name in self.auto_set:
             return 'auto'
@@ -1475,7 +1479,7 @@ class ProcCharacteristic(ConfigFile):
             elif os.path.isfile(finput):
                 finput = open(finput)
             else:
-                raise Exception, "No such file %s" % finput
+                raise Exception("No such file %s" % finput)
             
         for line in finput:
             if '#' in line:
@@ -1525,7 +1529,7 @@ class GridpackCard(ConfigFile):
             elif os.path.isfile(finput):
                 finput = open(finput)
             else:
-                raise Exception, "No such file %s" % finput
+                raise Exception("No such file %s" % finput)
         
         for line in finput:
             line = line.split('#')[0]
@@ -1749,12 +1753,12 @@ class PY8Card(ConfigFile):
         """Add a subrun to this PY8 Card."""
         assert(isinstance(py8_subrun,PY8SubRun))
         if py8_subrun['Main:subrun']==-1:
-            raise MadGraph5Error, "Make sure to correctly set the subrun ID"+\
-                            " 'Main:subrun' *before* adding it to the PY8 Card."
+            raise MadGraph5Error("Make sure to correctly set the subrun ID"+\
+                            " 'Main:subrun' *before* adding it to the PY8 Card.")
         if py8_subrun['Main:subrun'] in self.subruns:
-            raise MadGraph5Error, "A subrun with ID '%s'"%py8_subrun['Main:subrun']+\
+            raise MadGraph5Error("A subrun with ID '%s'"%py8_subrun['Main:subrun']+\
                 " is already present in this PY8 card. Remove it first, or "+\
-                                                          " access it directly."
+                                                          " access it directly.")
         self.subruns[py8_subrun['Main:subrun']] = py8_subrun
         if not 'LHEFInputs:nSubruns' in self.user_set:
             self['LHEFInputs:nSubruns'] = max(self.subruns.keys())
@@ -1921,7 +1925,7 @@ class PY8Card(ConfigFile):
             elif '\n' in template:
                 tmpl = StringIO.StringIO(template)
             else:
-                raise Exception, "File input '%s' not found." % file_input     
+                raise Exception("File input '%s' not found." % file_input)     
         elif template is None:
             # Then use a dummy empty StringIO, hence skipping the reading
             tmpl = StringIO.StringIO()
@@ -1952,8 +1956,8 @@ class PY8Card(ConfigFile):
                 value = value_entry.strip()
             except ValueError:
                 line = line.replace('\n','')
-                raise MadGraph5Error, "Could not read line '%s' of Pythia8 card."%\
-                                                                            line
+                raise MadGraph5Error("Could not read line '%s' of Pythia8 card."%\
+                                                                            line)
             # Read a subrun if detected:
             if param=='Main:subrun':
                 if read_subrun:
@@ -2117,7 +2121,7 @@ class PY8Card(ConfigFile):
             elif os.path.isfile(file_input):
                 finput = open(file_input)
             else:
-                raise Exception, "File input '%s' not found." % file_input
+                raise Exception("File input '%s' not found." % file_input)
         elif isinstance(file_input, (StringIO.StringIO, file)):
             finput = file_input
         else:
@@ -2142,8 +2146,8 @@ class PY8Card(ConfigFile):
                 value = value.strip()
             except ValueError:
                 line = line.replace('\n','')
-                raise MadGraph5Error, "Could not read line '%s' of Pythia8 card."%\
-                                                                          line
+                raise MadGraph5Error("Could not read line '%s' of Pythia8 card."%\
+                                                                          line)
             if '!' in value:
                 value,_ = value.split('!',1)                                                             
                                                                           
@@ -2319,7 +2323,7 @@ class RunCard(ConfigFile):
             elif os.path.isfile(finput):
                 finput = open(finput)
             else:
-                raise Exception, "No such file %s" % finput
+                raise Exception("No such file %s" % finput)
         
         for line in finput:
             line = line.split('#')[0]
@@ -2338,7 +2342,7 @@ class RunCard(ConfigFile):
         if consistency:
                 try:
                     self.check_validity()
-                except InvalidRunCard, error:
+                except InvalidRunCard as  error:
                     if consistency == 'warning':
                         logger.warning(str(error))
                     else:
@@ -3036,16 +3040,16 @@ class RunCardLO(RunCard):
         #1 (MC over hel with importance sampling). In particular, it can
         #no longer be > 1.
         if 'nhel' not in self.user_set:
-            raise InvalidRunCard, "Parameter nhel is not defined in the run_card."
+            raise InvalidRunCard("Parameter nhel is not defined in the run_card.")
         if self['nhel'] not in [1,0]:
-            raise InvalidRunCard, "Parameter nhel can only be '0' or '1', "+\
-                                                          "not %s." % self['nhel']
+            raise InvalidRunCard("Parameter nhel can only be '0' or '1', "+\
+                                                          "not %s." % self['nhel'])
         if int(self['maxjetflavor']) > 6:
-            raise InvalidRunCard, 'maxjetflavor should be lower than 5! (6 is partly supported)'
+            raise InvalidRunCard('maxjetflavor should be lower than 5! (6 is partly supported)')
   
         if len(self['pdgs_for_merging_cut']) > 1000:
-            raise InvalidRunCard, "The number of elements in "+\
-                               "'pdgs_for_merging_cut' should not exceed 1000."
+            raise InvalidRunCard("The number of elements in "+\
+                               "'pdgs_for_merging_cut' should not exceed 1000.")
   
         # some cut need to be deactivated in presence of isolation
         if self['ptgmin'] > 0:
@@ -3073,14 +3077,14 @@ class RunCardLO(RunCard):
                 import madgraph.interface.extended_cmd as basic_cmd
                 answer = basic_cmd.smart_input('Do you really want to continue', allow_arg=['y','n'], default='n')
                 if answer !='y':
-                    raise InvalidRunCard, 'ickkw>1 is still in alpha'
+                    raise InvalidRunCard('ickkw>1 is still in alpha')
             if self['use_syst']:
                 # some additional parameter need to be fixed for Syscalc + matching
                 if self['alpsfact'] != 1.0:
                     logger.warning('Since use_syst=T, We change the value of \'alpsfact\' to 1')
                     self['alpsfact'] =1.0
             if self['maxjetflavor'] == 6:
-                raise InvalidRunCard, 'maxjetflavor at 6 is NOT supported for matching!'
+                raise InvalidRunCard('maxjetflavor at 6 is NOT supported for matching!')
             if self['ickkw'] == 2:
                 # add warning if ckkw selected but the associate parameter are empty
                 self.get_default('highestmult', log_level=20)                   
@@ -3118,15 +3122,15 @@ class RunCardLO(RunCard):
         pdg_to_cut.discard('__type__')
         pdg_to_cut.discard('default')
         if len(pdg_to_cut)>25:
-            raise Exception, "Maximum 25 different pdgs are allowed for pdg specific cut"
+            raise Exception("Maximum 25 different pdgs are allowed for pdg specific cut")
         
         if any(int(pdg)<0 for pdg in pdg_to_cut):
             logger.warning('PDG specific cuts are always applied symmetrically on particle/anti-particle. Always use positve PDG codes')
-            raise MadGraph5Error, 'Some PDG specific cuts are defined with negative pdg code'
+            raise MadGraph5Error('Some PDG specific cuts are defined with negative pdg code')
         
         
         if any(pdg in pdg_to_cut for pdg in [1,2,3,4,5,21,22,11,13,15]):
-            raise Exception, "Can not use PDG related cut for light quark/b quark/lepton/gluon/photon"
+            raise Exception("Can not use PDG related cut for light quark/b quark/lepton/gluon/photon")
         
         if pdg_to_cut:
             self['pdg_cut'] = list(pdg_to_cut)
@@ -3906,7 +3910,7 @@ class RunCardNLO(RunCard):
         if any(self['reweight_pdf']):
             # check that we use lhapdf if reweighting is ON
             if self['pdlabel'] != "lhapdf":
-                raise InvalidRunCard, 'Reweight PDF option requires to use pdf sets associated to lhapdf. Please either change the pdlabel to use LHAPDF or set reweight_pdf to False.'
+                raise InvalidRunCard('Reweight PDF option requires to use pdf sets associated to lhapdf. Please either change the pdlabel to use LHAPDF or set reweight_pdf to False.')
 
         # make sure set have reweight_pdf and lhaid of length 1 when not including lhapdf
         if self['pdlabel'] != "lhapdf":
@@ -3930,23 +3934,23 @@ class RunCardNLO(RunCard):
 
         # Check that there are no identical elements in lhaid or dynamical_scale_choice
         if len(self['lhaid']) != len(set(self['lhaid'])):
-                raise InvalidRunCard, "'lhaid' has two or more identical entries. They have to be all different for the code to work correctly."
+                raise InvalidRunCard("'lhaid' has two or more identical entries. They have to be all different for the code to work correctly.")
         if len(self['dynamical_scale_choice']) != len(set(self['dynamical_scale_choice'])):
-                raise InvalidRunCard, "'dynamical_scale_choice' has two or more identical entries. They have to be all different for the code to work correctly."
+                raise InvalidRunCard("'dynamical_scale_choice' has two or more identical entries. They have to be all different for the code to work correctly.")
             
         # Check that lenght of lists are consistent
         if len(self['reweight_pdf']) != len(self['lhaid']):
-            raise InvalidRunCard, "'reweight_pdf' and 'lhaid' lists should have the same length"
+            raise InvalidRunCard("'reweight_pdf' and 'lhaid' lists should have the same length")
         if len(self['reweight_scale']) != len(self['dynamical_scale_choice']):
-            raise InvalidRunCard, "'reweight_scale' and 'dynamical_scale_choice' lists should have the same length"
+            raise InvalidRunCard("'reweight_scale' and 'dynamical_scale_choice' lists should have the same length")
         if len(self['dynamical_scale_choice']) > 10 :
-            raise InvalidRunCard, "Length of list for 'dynamical_scale_choice' too long: max is 10."
+            raise InvalidRunCard("Length of list for 'dynamical_scale_choice' too long: max is 10.")
         if len(self['lhaid']) > 25 :
-            raise InvalidRunCard, "Length of list for 'lhaid' too long: max is 25."
+            raise InvalidRunCard("Length of list for 'lhaid' too long: max is 25.")
         if len(self['rw_rscale']) > 9 :
-            raise InvalidRunCard, "Length of list for 'rw_rscale' too long: max is 9."
+            raise InvalidRunCard("Length of list for 'rw_rscale' too long: max is 9.")
         if len(self['rw_fscale']) > 9 :
-            raise InvalidRunCard, "Length of list for 'rw_fscale' too long: max is 9."
+            raise InvalidRunCard("Length of list for 'rw_fscale' too long: max is 9.")
     # make sure that the first element of rw_rscale and rw_fscale is the 1.0
         if 1.0 not in self['rw_rscale']:
             logger.warning("'1.0' has to be part of 'rw_rscale', adding it")
@@ -3962,9 +3966,9 @@ class RunCardNLO(RunCard):
             self['rw_fscale'][0],self['rw_fscale'][a]=self['rw_fscale'][a],self['rw_fscale'][0]
     # check that all elements of rw_rscale and rw_fscale are diffent.
         if len(self['rw_rscale']) != len(set(self['rw_rscale'])):
-                raise InvalidRunCard, "'rw_rscale' has two or more identical entries. They have to be all different for the code to work correctly."
+                raise InvalidRunCard("'rw_rscale' has two or more identical entries. They have to be all different for the code to work correctly.")
         if len(self['rw_fscale']) != len(set(self['rw_fscale'])):
-                raise InvalidRunCard, "'rw_fscale' has two or more identical entries. They have to be all different for the code to work correctly."
+                raise InvalidRunCard("'rw_fscale' has two or more identical entries. They have to be all different for the code to work correctly.")
 
 
     def update_system_parameter_for_include(self):
@@ -3975,16 +3979,16 @@ class RunCardNLO(RunCard):
         pdg_to_cut.discard('__type__')
         pdg_to_cut.discard('default')
         if len(pdg_to_cut)>25:
-            raise Exception, "Maximum 25 different PDGs are allowed for PDG specific cut"
+            raise Exception("Maximum 25 different PDGs are allowed for PDG specific cut")
         
         if any(int(pdg)<0 for pdg in pdg_to_cut):
             logger.warning('PDG specific cuts are always applied symmetrically on particle/anti-particle. Always use positve PDG codes')
-            raise MadGraph5Error, 'Some PDG specific cuts are defined with negative PDG codes'
+            raise MadGraph5Error('Some PDG specific cuts are defined with negative PDG codes')
         
         
         if any(pdg in pdg_to_cut for pdg in [21,22,11,13,15]+ range(self['maxjetflavor']+1)):
             # Note that this will double check in the fortran code
-            raise Exception, "Can not use PDG related cuts for massless SM particles/leptons"
+            raise Exception("Can not use PDG related cuts for massless SM particles/leptons")
         if pdg_to_cut:
             self['pdg_cut'] = list(pdg_to_cut)
             self['ptmin4pdg'] = []
@@ -4123,7 +4127,7 @@ class MadLoopParam(ConfigFile):
             elif os.path.isfile(finput):
                 finput = open(finput)
             else:
-                raise Exception, "No such file %s" % input
+                raise Exception("No such file %s" % input)
         
         previous_line= ''
         for line in finput:
@@ -4166,7 +4170,7 @@ class MadLoopParam(ConfigFile):
             elif isinstance(value, str):
                 return value
             else:
-                raise Exception, "Can not format input %s" % type(value)
+                raise Exception("Can not format input %s" % type(value))
             
         name = ''
         done = set()
diff -rupN MadGraph_pristine/madgraph/various/cluster.py ../contrib/MadGraph/madgraph/various/cluster.py
--- MadGraph_pristine/madgraph/various/cluster.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/cluster.py	2020-10-29 23:48:54.824703740 +1100
@@ -25,9 +25,9 @@ logger = logging.getLogger('madgraph.clu
 try:
     from madgraph import MadGraph5Error
     import madgraph.various.misc as misc
-except Exception, error:
+except Exception as error:
     if __debug__:
-        print  str(error)
+        print(  str(error))
     from internal import MadGraph5Error
     import internal.misc as misc
 
@@ -120,7 +120,7 @@ class Cluster(object):
     def submit(self, prog, argument=[], cwd=None, stdout=None, stderr=None, 
                log=None, required_output=[], nb_submit=0):
         """How to make one submission. Return status id on the cluster."""
-        raise NotImplemented, 'No implementation of how to submit a job to cluster \'%s\'' % self.name
+        raise NotImplemented('No implementation of how to submit a job to cluster \'%s\'' % self.name)
 
 
     @store_input()
@@ -225,7 +225,7 @@ class Cluster(object):
     def control(self, me_dir=None):
         """Check the status of job associated to directory me_dir. return (idle, run, finish, fail)"""
         if not self.submitted_ids:
-            raise NotImplemented, 'No implementation of how to control the job status to cluster \'%s\'' % self.name
+            raise NotImplemented('No implementation of how to control the job status to cluster \'%s\'' % self.name)
         idle, run, fail = 0, 0, 0
         for pid in self.submitted_ids[:]:
             status = self.control_one_job(id)
@@ -243,7 +243,7 @@ class Cluster(object):
 
     def control_one_job(self, pid):
         """ control the status of a single job with it's cluster id """
-        raise NotImplemented, 'No implementation of how to control the job status to cluster \'%s\'' % self.name
+        raise NotImplemented('No implementation of how to control the job status to cluster \'%s\'' % self.name)
 
     def get_jobs_identifier(self, path, second_path=None):
         """get a unique run_name for all the jobs helps to identify the runs 
@@ -552,7 +552,10 @@ class Packet(object):
     """
 
     def __init__(self, name, fct, args, opts={}):
-        import Queue
+        try:
+            import Queue
+        except ImportError:
+            import queue as Queue
         import threading
         self.queue = Queue.Queue()
         self.tag = name
@@ -582,9 +585,15 @@ class MultiCore(Cluster):
         
         super(MultiCore, self).__init__(self, *args, **opt)
         
-        import Queue
+        try:
+            import Queue
+        except ImportError:
+            import queue as Queue
         import threading
-        import thread
+        try:
+            import thread
+        except:
+            import _thread
         self.queue = Queue.Queue() # list of job to do
         self.done = Queue.Queue()  # list of job finisned
         self.submitted = Queue.Queue() # one entry by job submitted
@@ -619,8 +628,14 @@ class MultiCore(Cluster):
 
 
     def worker(self):
-        import Queue
-        import thread
+        try:
+            import Queue
+        except ImportError:
+            import queue as Queue
+        try:
+            import thread
+        except:
+            import _thread
         while not self.stoprequest.isSet():
             try:
                 args = self.queue.get()
@@ -661,14 +676,14 @@ class MultiCore(Cluster):
                             logger.warning("fct %s does not return 0. Stopping the code in a clean way. The error was:\n%s", exe, returncode)
                             self.stoprequest.set()
                             self.remove("fct %s does not return 0:\n %s" % (exe, returncode))
-                except Exception,error:
+                except Exception as error:
                     self.fail_msg = sys.exc_info()
                     logger.warning(str(error))
                     self.stoprequest.set()
                     self.remove(error)
                     
                     if __debug__:
-                        raise self.fail_msg[0], self.fail_msg[1],self.fail_msg[2]
+                        raise self.fail_msg[0]( self.fail_msg[1],self.fail_msg[2])
 
                 self.queue.task_done()
                 self.done.put(tag)
@@ -742,7 +757,10 @@ class MultiCore(Cluster):
         """Waiting that all the jobs are done. This function also control that
         the submission by packet are handle correctly (i.e. submit the function)"""
 
-        import Queue
+        try:
+            import Queue
+        except ImportError:
+            import queue as Queue
         import threading
 
         try: # to catch KeyBoardInterupt to see which kind of error to display 
@@ -819,10 +837,10 @@ class MultiCore(Cluster):
                 if isinstance(self.fail_msg, Exception):
                     raise self.fail_msg
                 elif isinstance(self.fail_msg, str):
-                    raise Exception, self.fail_msg
+                    raise Exception(self.fail_msg)
                 else:
                     misc.sprint(self.fail_msg)
-                    raise self.fail_msg[0], self.fail_msg[1], self.fail_msg[2]
+                    raise self.fail_msg[0](self.fail_msg[1], self.fail_msg[2])
             # reset variable for next submission
             try:
                 self.lock.clear()
@@ -841,9 +859,9 @@ class MultiCore(Cluster):
             if isinstance(self.fail_msg, Exception):
                 raise self.fail_msg
             elif isinstance(self.fail_msg, str):
-                raise Exception, self.fail_msg
+                raise Exception(self.fail_msg)
             elif self.fail_msg:
-                raise self.fail_msg[0], self.fail_msg[1], self.fail_msg[2]
+                raise self.fail_msg[0](self.fail_msg[1], self.fail_msg[2])
             # else return orignal error
             raise 
 
@@ -911,8 +929,8 @@ class CondorCluster(Cluster):
         try:
             id = pat.search(output).groups()[0]
         except:
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         self.submitted += 1
         self.submitted_ids.append(id)
         return id
@@ -998,8 +1016,8 @@ class CondorCluster(Cluster):
         try:
             id = pat.search(output).groups()[0]
         except:
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         self.submitted += 1
         self.submitted_ids.append(id)
         return id
@@ -1017,7 +1035,7 @@ class CondorCluster(Cluster):
         
         error = status.stderr.read()
         if status.returncode or error:
-            raise ClusterManagmentError, 'condor_q returns error: %s' % error
+            raise ClusterManagmentError('condor_q returns error: %s' % error)
 
         return status.stdout.readline().strip()
     
@@ -1044,7 +1062,7 @@ class CondorCluster(Cluster):
                                                              stderr=subprocess.PIPE)
             error = status.stderr.read()
             if status.returncode or error:
-                raise ClusterManagmentError, 'condor_q returns error: %s' % error
+                raise ClusterManagmentError('condor_q returns error: %s' % error)
 
             for line in status.stdout:
                 id, status = line.strip().split()
@@ -1138,8 +1156,8 @@ class PBSCluster(Cluster):
         output = a.communicate(text)[0]
         id = output.split('.')[0]
         if not id.isdigit() or a.returncode !=0:
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output)
             
         self.submitted += 1
         self.submitted_ids.append(id)
@@ -1155,7 +1173,7 @@ class PBSCluster(Cluster):
         for line in status.stdout:
             line = line.strip()
             if 'cannot connect to server' in line or 'cannot read reply' in line:
-                raise ClusterManagmentError, 'server disconnected'
+                raise ClusterManagmentError('server disconnected')
             if 'Unknown' in line:
                 return 'F'
             elif line.startswith(str(id)):
@@ -1164,7 +1182,7 @@ class PBSCluster(Cluster):
                 jobstatus=""
                         
         if status.returncode != 0 and status.returncode is not None:
-            raise ClusterManagmentError, 'server fails in someway (errorcode %s)' % status.returncode
+            raise ClusterManagmentError('server fails in someway (errorcode %s)' % status.returncode)
         if jobstatus in self.idle_tag:
             return 'I' 
         elif jobstatus in self.running_tag:                
@@ -1185,7 +1203,7 @@ class PBSCluster(Cluster):
         idle, run, fail = 0, 0, 0
         for line in status.stdout:
             if 'cannot connect to server' in line or 'cannot read reply' in line:
-                raise ClusterManagmentError, 'server disconnected'
+                raise ClusterManagmentError('server disconnected')
             if me_dir in line:
                 ongoing.append(line.split()[0].split('.')[0])
                 status2 = line.split()[4]
@@ -1200,7 +1218,7 @@ class PBSCluster(Cluster):
                     fail += 1
 
         if status.returncode != 0 and status.returncode is not None:
-            raise ClusterManagmentError, 'server fails in someway (errorcode %s)' % status.returncode
+            raise ClusterManagmentError('server fails in someway (errorcode %s)' % status.returncode)
 
         for id in list(self.submitted_ids):
             if id not in ongoing:
@@ -1301,8 +1319,8 @@ class SGECluster(Cluster):
         output = a.communicate(text)[0]
         id = output.split(' ')[2]
         if not id.isdigit():
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         self.submitted += 1
         self.submitted_ids.append(id)
         logger.debug(output)
@@ -1419,11 +1437,11 @@ class LSFCluster(Cluster):
         try:
             id = output.split('>',1)[0].split('<')[1]
         except:
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         if not id.isdigit():
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         self.submitted += 1
         self.submitted_ids.append(id)
         return id        
@@ -1550,8 +1568,8 @@ class GECluster(Cluster):
         try:
             id = pat.search(output).groups()[0]
         except:
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                                                                        % output 
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                                                                        % output )
         self.submitted += 1
         self.submitted_ids.append(id)
         return id
@@ -1573,7 +1591,7 @@ class GECluster(Cluster):
             try:
                 groups = pat.search(line).groups()
             except:
-                raise ClusterManagmentError, 'bad syntax for stat: \n\"%s\"' % line
+                raise ClusterManagmentError('bad syntax for stat: \n\"%s\"' % line)
             if groups[0] != id: continue
             stat = groups[1]
         if not stat:
@@ -1685,8 +1703,8 @@ class SLURMCluster(Cluster):
         id = output_arr[3].rstrip()
 
         if not id.isdigit():
-            raise ClusterManagmentError, 'fail to submit to the cluster: \n%s' \
-                    % (output[0] + '\n' + output[1])
+            raise ClusterManagmentError('fail to submit to the cluster: \n%s' \
+                    % (output[0] + '\n' + output[1]))
 
         self.submitted += 1
         self.submitted_ids.append(id)
@@ -1786,7 +1804,7 @@ class HTCaaSCluster(Cluster):
         cwd_cp = cwd.rsplit("/",2)
 
         if not stdout is None:
-            print "stdout: %s" % stdout
+            print( "stdout: %s" % stdout)
 
         if not os.path.exists(prog):
             prog = os.path.join(cwd, prog)
@@ -1835,15 +1853,15 @@ class HTCaaSCluster(Cluster):
         nb_try=0
         nb_limit=5
         if not id.isdigit() :
-                print "[ID is not digit]:" + id
+                print( "[ID is not digit]:" + id)
 
         while not id.isdigit() :
             nb_try+=1
-            print "[fail_retry]:"+ nb_try
+            print("[fail_retry]:"+ nb_try)
             a=misc.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, cwd=cwd)
             id = a.stdout.read().strip()
             if nb_try > nb_limit :
-                raise ClusterManagementError, 'fail to submit to the HTCaaS cluster: \n %s' % id
+                raise ClusterManagementError('fail to submit to the HTCaaS cluster: \n %s' % id)
                 break
 
         self.submitted += 1
@@ -1863,7 +1881,7 @@ class HTCaaSCluster(Cluster):
                                                          stderr=subprocess.PIPE)
             error = status.stderr.read()
             if status.returncode or error:
-                raise ClusterManagmentError, 'htcaas-job-submit returns error: %s' % error
+                raise ClusterManagmentError('htcaas-job-submit returns error: %s' % error)
             status_out= status.stdout.read().strip()
             status_out= status_out.split(":",1)[1]
             if status_out == 'waiting':
@@ -2062,7 +2080,7 @@ class HTCaaS2Cluster(Cluster):
                                                          stderr=subprocess.PIPE)
             error = status.stderr.read()
             if status.returncode or error:
-                raise ClusterManagmentError, 'htcaas-job-status returns error: %s' % error
+                raise ClusterManagmentError('htcaas-job-status returns error: %s' % error)
             status_out= status.stdout.read().strip()
             status_out= status_out.split(":",1)[1]
             logger.debug("[["+str(id)+"]]"+status_out)
diff -rupN MadGraph_pristine/madgraph/various/lhe_parser.py ../contrib/MadGraph/madgraph/various/lhe_parser.py
--- MadGraph_pristine/madgraph/various/lhe_parser.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/lhe_parser.py	2020-10-29 23:53:31.710064299 +1100
@@ -187,9 +187,9 @@ class EventFile(object):
         else:
             try:
                 return gzip.GzipFile.__new__(EventFileGzip, path, mode, *args, **opt)
-            except IOError, error:
+            except IOError as error:
                 raise
-            except Exception, error:
+            except Exception as error:
                 if mode == 'r':
                     misc.gunzip(path)
                 return file.__new__(EventFileNoGzip, path[:-3], mode, *args, **opt)
@@ -1393,8 +1393,8 @@ class Event(list):
                 self.reweight_data = dict([(pid, float(value)) for (pid, value) in data
                                            if not self.reweight_order.append(pid)])
                                       # the if is to create the order file on the flight
-            except ValueError, error:
-                raise Exception, 'Event File has unvalid weight. %s' % error
+            except ValueError as error:
+                raise Exception('Event File has unvalid weight. %s' % error)
             self.tag = self.tag[:start] + self.tag[stop+7:]
         return self.reweight_data
     
@@ -1461,7 +1461,7 @@ class Event(list):
             
             info = Event.loweight_pattern.search(text)
             if not info:
-                raise Exception, '%s not parsed'% text
+                raise Exception('%s not parsed'% text)
             self.loweight={}
             self.loweight['n_qcd'] = int(info.group('nqcd'))
             self.loweight['ren_scale'] = float(info.group('ren_scale'))
@@ -1588,8 +1588,8 @@ class Event(list):
                     else:
                         try:
                             setattr(new_particle, tag, self[nb_part + mother_id -1])
-                        except Exception, error:
-                            print error
+                        except Exception as error:
+                            print(error)
                             misc.sprint( self)
                             misc.sprint(nb_part + mother_id -1)
                             misc.sprint(tag)
@@ -1600,7 +1600,7 @@ class Event(list):
                 elif tag == "mother2" and isinstance(particle.mother1, Particle):
                     new_particle.mother2 = this_particle
                 else:
-                    raise Exception, "Something weird happens. Please report it for investigation"
+                    raise Exception("Something weird happens. Please report it for investigation")
         # Need to correct the color information of the particle
         # first find the first available color index
         max_color=501
@@ -1777,22 +1777,22 @@ class Event(list):
             fourmass = FourMomentum(particle).mass
             
             if particle.mass and (abs(particle.mass) - fourmass)/ abs(particle.mass) > threshold:
-                raise Exception, "Do not have correct mass lhe: %s momentum: %s" % (particle.mass, fourmass)
+                raise Exception("Do not have correct mass lhe: %s momentum: %s" % (particle.mass, fourmass))
             
                 
 
         if E/absE > threshold:
             logger.critical(self)
-            raise Exception, "Do not conserve Energy %s, %s" % (E/absE, E)
+            raise Exception("Do not conserve Energy %s, %s" % (E/absE, E))
         if px/abspx > threshold:
             logger.critical(self)
-            raise Exception, "Do not conserve Px %s, %s" % (px/abspx, px)         
+            raise Exception("Do not conserve Px %s, %s" % (px/abspx, px))         
         if py/abspy > threshold:
             logger.critical(self)
-            raise Exception, "Do not conserve Py %s, %s" % (py/abspy, py)
+            raise Exception("Do not conserve Py %s, %s" % (py/abspy, py))
         if pz/abspz > threshold:
             logger.critical(self)
-            raise Exception, "Do not conserve Pz %s, %s" % (pz/abspz, pz)
+            raise Exception("Do not conserve Pz %s, %s" % (pz/abspz, pz))
             
         #2. check the color of the event
         self.check_color_structure() 
@@ -1995,7 +1995,7 @@ class Event(list):
             if part.status == 1: #final
                 try:
                     ind = order[1].index(part.pid)
-                except ValueError, error:
+                except ValueError as error:
                     if not allow_reversed:
                         raise error
                     else:
@@ -2009,7 +2009,7 @@ class Event(list):
             elif part.status == -1:
                 try:
                     ind = order[0].index(part.pid)
-                except ValueError, error:
+                except ValueError as error:
                     if not allow_reversed:
                         raise error
                     else:
@@ -2037,18 +2037,18 @@ class Event(list):
                 if particle.color1:
                     color_index[particle.color1] +=1
                     if -7 < particle.pdg < 0:
-                        raise Exception, "anti-quark with color tag"
+                        raise Exception("anti-quark with color tag")
                 if particle.color2:
                     color_index[particle.color2] +=1     
                     if 7 > particle.pdg > 0:
-                        raise Exception, "quark with anti-color tag"                
+                        raise Exception("quark with anti-color tag")                
                 
                 
         for key,value in color_index.items():
             if value > 2:
-                print self
-                print key, value
-                raise Exception, 'Wrong color_flow'           
+                print( self)
+                print( key, value)
+                raise Exception('Wrong color_flow')           
         
         
         #2. check that each parent present have coherent color-structure
@@ -2109,21 +2109,21 @@ class Event(list):
                 #only case is a epsilon_ijk structure.
                 if len(canticolors) + len(mcolors) != 3:
                     logger.critical(str(self))
-                    raise Exception, "Wrong color flow for %s -> %s" ([m.pid for m in mothers], [c.pid for c in childs])              
+                    raise Exception("Wrong color flow for %s -> %s" ([m.pid for m in mothers], [c.pid for c in childs]))              
                 else:
                     popup_index += canticolors
             elif manticolors != []:
                 #only case is a epsilon_ijk structure.
                 if len(ccolors) + len(manticolors) != 3:
                     logger.critical(str(self))
-                    raise Exception, "Wrong color flow for %s -> %s" ([m.pid for m in mothers], [c.pid for c in childs])              
+                    raise Exception("Wrong color flow for %s -> %s" ([m.pid for m in mothers], [c.pid for c in childs]))              
                 else:
                     popup_index += ccolors
 
             # Check that color popup (from epsilon_ijk) are raised only once
             if len(popup_index) != len(set(popup_index)):
                 logger.critical(self)
-                raise Exception, "Wrong color flow: identical poping-up index, %s" % (popup_index)
+                raise Exception("Wrong color flow: identical poping-up index, %s" % (popup_index))
                
     def __eq__(self, other):
         """two event are the same if they have the same momentum. other info are ignored"""
@@ -2229,7 +2229,7 @@ class Event(list):
             if part.status == 1: #final
                 try:
                     ind = order[1].index(part.pid)
-                except ValueError, error:
+                except ValueError as error:
                     if not allow_reversed:
                         raise error
                     else:
@@ -2243,7 +2243,7 @@ class Event(list):
             elif part.status == -1:
                 try:
                     ind = order[0].index(part.pid)
-                except ValueError, error:
+                except ValueError as error:
                     if not allow_reversed:
                         raise error
                     else:
@@ -2340,9 +2340,9 @@ class WeightFile(EventFile):
         if  path.endswith(".gz"):
             try:
                 return gzip.GzipFile.__new__(WeightFileGzip, path, mode, *args, **opt)
-            except IOError, error:
+            except IOError as error:
                 raise
-            except Exception, error:
+            except Exception as error:
                 if mode == 'r':
                     misc.gunzip(path)
                 return file.__new__(WeightFileNoGzip, path[:-3], mode, *args, **opt)
@@ -2881,7 +2881,7 @@ class NLO_PARTIALWEIGHT(object):
                 if pos < len(get_order[0]): #initial
                     try:
                         ind = order[0].index(pdgs[pos])
-                    except ValueError, error:
+                    except ValueError as error:
                         if not allow_reversed:
                             raise error
                         else:
@@ -2897,7 +2897,7 @@ class NLO_PARTIALWEIGHT(object):
                 else: #final   
                     try:
                         ind = order[1].index(pdgs[pos])
-                    except ValueError, error:
+                    except ValueError as error:
                         if not allow_reversed:
                             raise error
                         else:
@@ -3098,13 +3098,13 @@ if '__main__' == __name__:
         start = time.time()
         for event in lhe:
             event.parse_lo_weight()
-        print 'old method -> ', time.time()-start
+        print( 'old method -> ', time.time()-start)
         lhe = EventFile('unweighted_events.lhe.gz')
         #lhe.parsing = False
         start = time.time()
         for event in lhe:
             event.parse_lo_weight_test()
-        print 'new method -> ', time.time()-start    
+        print( 'new method -> ', time.time()-start)  
     
 
     # Example 1: adding some missing information to the event (here distance travelled)
@@ -3149,7 +3149,7 @@ if '__main__' == __name__:
                 nb_pass +=1     
 
                         
-        print nb_pass
+        print( nb_pass)
         gs1 = gridspec.GridSpec(2, 1, height_ratios=[5,1])
         gs1.update(wspace=0, hspace=0) # set the spacing between axes. 
         ax = plt.subplot(gs1[0])
@@ -3161,8 +3161,8 @@ if '__main__' == __name__:
         ax_c.set_yticks(ax.get_yticks())
         ax_c.set_yticklabels([])
         ax.set_xlim([-4,4])
-        print "bin value:", n
-        print "start/end point of bins", bins
+        print( "bin value:", n)
+        print( "start/end point of bins", bins)
         plt.axis('on')
         plt.xlabel('weight ratio')
         plt.show()
diff -rupN MadGraph_pristine/madgraph/various/misc.py ../contrib/MadGraph/madgraph/various/misc.py
--- MadGraph_pristine/madgraph/various/misc.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/misc.py	2020-10-29 23:56:23.852976726 +1100
@@ -22,7 +22,13 @@ import re
 import signal
 import subprocess
 import sys
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+from io import IOBase
+
 import sys
 import optparse
 import time
@@ -34,7 +40,7 @@ from distutils.version import LooseVersi
 try:
     # Use in MadGraph
     import madgraph
-except Exception, error:
+except Exception as error:
     # Use in MadEvent
     import internal
     from internal import MadGraph5Error, InvalidCmd
@@ -67,7 +73,7 @@ def parse_info_str(fsock):
         if m is not None:
             info_dict[m.group('name')] = m.group('value')
         else:
-            raise IOError, "String %s is not a valid info string" % entry
+            raise IOError("String %s is not a valid info string" % entry)
 
     return info_dict
 
@@ -293,7 +299,7 @@ def deactivate_dependence(dependency, cm
     
     def tell(msg):
         if log == 'stdout':
-            print msg
+            print(msg)
         elif callable(log):
             log(msg)
     
@@ -309,7 +315,7 @@ def activate_dependence(dependency, cmd=
     
     def tell(msg):
         if log == 'stdout':
-            print msg
+            print(msg)
         elif callable(log):
             log(msg)
 
@@ -331,7 +337,7 @@ def activate_dependence(dependency, cmd=
             cmd.do_install('Golem95')
     
     if dependency=='samurai':
-        raise MadGraph5Error, 'Samurai cannot yet be automatically installed.' 
+        raise MadGraph5Error( 'Samurai cannot yet be automatically installed.') 
 
     if dependency=='ninja':
         if cmd.options['ninja'] in ['None',None,''] or\
@@ -407,7 +413,7 @@ def multiple_try(nb_try=5, sleep=20):
                     return f(*args, **opt)
                 except KeyboardInterrupt:
                     raise
-                except Exception, error:
+                except Exception as error:
                     global wait_once
                     if not wait_once:
                         text = """Start waiting for update. (more info in debug mode)"""
@@ -421,7 +427,7 @@ def multiple_try(nb_try=5, sleep=20):
 
             if __debug__:
                 raise
-            raise error.__class__, '[Fail %i times] \n %s ' % (i+1, error)
+            raise error.__class__( '[Fail %i times] \n %s ' % (i+1, error))
         return deco_f_retry
     return deco_retry
 
@@ -478,9 +484,9 @@ def compile(arg=[], cwd=None, mode='fort
         p = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                              stderr=subprocess.STDOUT, cwd=cwd, **opt)
         (out, err) = p.communicate()
-    except OSError, error:
+    except OSError as error:
         if cwd and not os.path.exists(cwd):
-            raise OSError, 'Directory %s doesn\'t exists. Impossible to run make' % cwd
+            raise OSError('Directory %s doesn\'t exists. Impossible to run make' % cwd)
         else:
             error_text = "Impossible to compile %s directory\n" % cwd
             error_text += "Trying to launch make command returns:\n"
@@ -489,7 +495,7 @@ def compile(arg=[], cwd=None, mode='fort
             if sys.platform == "darwin":
                 error_text += "Note that MacOSX doesn\'t have gmake/gfortan install by default.\n"
                 error_text += "Xcode3 contains those required programs"
-            raise MadGraph5Error, error_text
+            raise MadGraph5Error(error_text)
 
     if p.returncode:
         # Check that makefile exists
@@ -497,24 +503,24 @@ def compile(arg=[], cwd=None, mode='fort
             cwd = os.getcwd()
         all_file = [f.lower() for f in os.listdir(cwd)]
         if 'makefile' not in all_file and '-f' not in arg:
-            raise OSError, 'no makefile present in %s' % os.path.realpath(cwd)
+            raise OSError('no makefile present in %s' % os.path.realpath(cwd))
 
         if mode == 'fortran' and  not (which('g77') or which('gfortran')):
             error_msg = 'A fortran compiler (g77 or gfortran) is required to create this output.\n'
             error_msg += 'Please install g77 or gfortran on your computer and retry.'
-            raise MadGraph5Error, error_msg
+            raise MadGraph5Error(error_msg)
         elif mode == 'cpp' and not which('g++'):            
             error_msg ='A C++ compiler (g++) is required to create this output.\n'
             error_msg += 'Please install g++ (which is part of the gcc package)  on your computer and retry.'
-            raise MadGraph5Error, error_msg
+            raise MadGraph5Error(error_msg)
 
         # Check if this is due to the need of gfortran 4.6 for quadruple precision
         if any(tag.upper() in out.upper() for tag in ['real(kind=16)','real*16',
             'complex*32']) and mode == 'fortran' and not \
                              ''.join(get_gfortran_version().split('.')) >= '46':
             if not which('gfortran'):
-                raise MadGraph5Error, 'The fortran compiler gfortran v4.6 or later '+\
-                  'is required to compile %s.\nPlease install it and retry.'%cwd
+                raise MadGraph5Error('The fortran compiler gfortran v4.6 or later '+\
+                  'is required to compile %s.\nPlease install it and retry.'%cwd)
             else:
                 logger_stderr.error('ERROR, you could not compile %s because'%cwd+\
              ' your version of gfortran is older than 4.6. MadGraph5_aMC@NLO will carry on,'+\
@@ -529,7 +535,7 @@ def compile(arg=[], cwd=None, mode='fort
         error_text += 'Please try to fix this compilations issue and retry.\n'
         error_text += 'Help might be found at https://answers.launchpad.net/mg5amcnlo.\n'
         error_text += 'If you think that this is a bug, you can report this at https://bugs.launchpad.net/mg5amcnlo'
-        raise MadGraph5Error, error_text
+        raise MadGraph5Error(error_text)
     return p.returncode
 
 def get_gfortran_version(compiler='gfortran'):
@@ -664,7 +670,7 @@ class MuteLogger(object):
         for logname in lognames:
             try:
                 os.remove(path)
-            except Exception, error:
+            except Exception as error:
                 pass
             my_logger = logging.getLogger(logname)
             hdlr = logging.FileHandler(path)            
@@ -689,7 +695,7 @@ class MuteLogger(object):
             if path:
                 try:
                     os.remove(path)
-                except Exception, error:
+                except Exception as error:
                     pass
             my_logger = logging.getLogger(logname)
             if logname in self.logger_saved_info:
@@ -753,7 +759,7 @@ def detect_if_cpp_compiler_is_clang(cpp_
         p = Popen([cpp_compiler, '--version'], stdout=subprocess.PIPE, 
                     stderr=subprocess.PIPE)
         output, error = p.communicate()
-    except Exception, error:
+    except Exception as error:
         # Cannot probe the compiler, assume not clang then
         return False
     return 'LLVM' in output
@@ -870,7 +876,7 @@ def check_system_error(value=1):
         def deco_f(arg, *args, **opt):
             try:
                 return f(arg, *args, **opt)
-            except OSError, error:
+            except OSError as error:
                 logger.debug('try to recover from %s' % error)
                 if isinstance(arg, (list,tuple)):
                     prog =  arg[0]
@@ -888,8 +894,8 @@ def check_system_error(value=1):
                 # NO such file or directory
                 elif error.errno == 2:
                     # raise a more meaningfull error message
-                    raise Exception, '%s fails with no such file or directory' \
-                                                                           % arg            
+                    raise Exception('%s fails with no such file or directory' \
+                                                                           % arg)            
                 else:
                     raise
         return deco_f
@@ -971,7 +977,7 @@ def get_last_line(fsock):
     
     return tail(fsock, 1)[0]
 
-class BackRead(file):
+class BackRead(IOBase):
     """read a file returning the lines in reverse order for each call of readline()
 This actually just reads blocks (4096 bytes by default) of data from the end of
 the file and returns last line in an internal buffer."""
@@ -1006,7 +1012,7 @@ the file and returns last line in an int
         self.blksize = blksize
         # how many blocks we've read
         self.blkcount = 1
-        file.__init__(self, filepos, 'rb')
+        IOBase.__init__(self, filepos, 'rb')
         # if the file is smaller than the blocksize, read a block,
         # otherwise, read the whole thing...
         if self.size > self.blksize:
@@ -1037,8 +1043,8 @@ def write_PS_input(filePath, PS):
                                                              for p in PS])+'\n')
         PSfile.close()
     except Exception:
-        raise MadGraph5Error, 'Could not write out the PS point to file %s.'\
-                                                                  %str(filePath)
+        raise MadGraph5Error('Could not write out the PS point to file %s.'\
+                                                                  %str(filePath))
 
 def format_timer(running_time):
     """ return a nicely string representing the time elapsed."""
@@ -1125,8 +1131,8 @@ def gunzip(path, keep=False, stdout=None
         if os.path.exists("%s.gz" % path):
             path = "%s.gz" % path
         else:
-            raise Exception, "%(path)s does not finish by .gz and the file %(path)s.gz does not exists" %\
-                              {"path": path}         
+            raise Exception("%(path)s does not finish by .gz and the file %(path)s.gz does not exists" %\
+                              {"path": path})         
 
     
     #for large file (>1G) it is faster and safer to use a separate thread
@@ -1376,7 +1382,7 @@ class OptionParser(optparse.OptionParser
     
     def exit(self, status=0, msg=None):
         if msg:
-            raise InvalidCmd, msg
+            raise InvalidCmd(msg)
         else:
             raise InvalidCmd
 
@@ -1442,8 +1448,8 @@ def sprint(*args, **opt):
         log.log(level, ' '.join([intro]+[str(a) for a in args]) + \
                    ' \033[1;30m[%s at line %s]\033[0m' % (os.path.basename(filename), lineno))
     else:
-        print ' '.join([intro]+[str(a) for a in args]) + \
-                   ' \033[1;30m[%s at line %s]\033[0m' % (os.path.basename(filename), lineno)
+        print(' '.join([intro]+[str(a) for a in args]) + \
+                   ' \033[1;30m[%s at line %s]\033[0m' % (os.path.basename(filename), lineno))
 
     if wait:
         raw_input('press_enter to continue')
@@ -1508,8 +1514,8 @@ def timeout(func, args=(), kwargs={}, ti
         def run(self):
             try:
                 self.result = func(*args, **kwargs)
-            except Exception,error:
-                print error
+            except Exception as error:
+                print(error)
                 self.result = default
     it = InterruptableThread()
     it.start()
@@ -1786,7 +1792,7 @@ class EasterEgg(object):
                 self.call_apple(msg)
             else:
                 self.call_linux(msg)
-        except Exception, error:
+        except Exception as error:
             sprint(error)
             pass
     
@@ -1955,7 +1961,7 @@ def plugin_import(module, error_msg, fct
         try:
             _temp = __import__('MG5aMC_PLUGIN.%s' % module, globals(), locals(), fcts, -1)
         except ImportError:
-            raise MadGraph5Error, error_msg
+            raise MadGraph5Error(error_msg)
     
     if not fcts:
         return _temp
@@ -1977,7 +1983,7 @@ def from_plugin_import(plugin_path, targ
                 try:
                     with stdchannel_redirected(sys.stdout, os.devnull):
                         __import__('%s.%s' % (plugindirname,plug))
-                except Exception, error:
+                except Exception as error:
                     if warning:
                         logger.warning("error detected in plugin: %s.", plug)
                         logger.warning("%s", error)
@@ -2058,7 +2064,7 @@ def import_python_lhapdf(lhapdfconfig):
                 import lhapdf
                 use_lhapdf=True
             except ImportError:
-                print 'fail'
+                print('fail')
                 logger.warning("Failed to access python version of LHAPDF: "\
                                    "If the python interface to LHAPDF is available on your system, try "\
                                    "adding its location to the PYTHONPATH environment variable and the"\
diff -rupN MadGraph_pristine/madgraph/various/q_polynomial.py ../contrib/MadGraph/madgraph/various/q_polynomial.py
--- MadGraph_pristine/madgraph/various/q_polynomial.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/q_polynomial.py	2020-10-29 23:48:54.824703740 +1100
@@ -107,8 +107,8 @@ class Polynomial_naive_ordering(object):
         try:
             return self.coef_list.index(array.array('i',new_indices_list))
         except ValueError:
-            raise PolynomialError,\
-                "The index %s looked for could not be found"%str(indices_list)   
+            raise PolynomialError(\
+                "The index %s looked for could not be found"%str(indices_list))   
 
     def get_coef_at_position(self, pos):
         """ Returns the coefficient at position pos in the one dimensional
@@ -131,8 +131,8 @@ class PolynomialRoutines(object):
             self.updater_max_rank = max_rank
         else:
             if updater_max_rank > max_rank:
-                raise PolynomialError, "The updater max rank must be at most"+\
-                                                " equal to the overall max rank"
+                raise PolynomialError( "The updater max rank must be at most"+\
+                                                " equal to the overall max rank")
             else:
                 self.updater_max_rank = updater_max_rank            
         if coef_format=='complex*16':
@@ -146,8 +146,8 @@ class PolynomialRoutines(object):
             self.czero='(0.0e0,0.0e0)'
         self.line_split=line_split
         if max_rank<0:
-            raise PolynomialError, \
-                            "The rank of a q-polynomial should be 0 or positive"
+            raise PolynomialError( \
+                            "The rank of a q-polynomial should be 0 or positive")
         self.max_rank=max_rank
         self.pq=Polynomial(max_rank)
         
@@ -747,8 +747,8 @@ class FromIREGIFortranCodeGenerator():
         try:
             return self.coef_list.index(array.array('i',new_indices_list))
         except ValueError:
-            raise PolynomialError,\
-                "The index %s looked for could not be found"%str(indices_list)   
+            raise PolynomialError(\
+                "The index %s looked for could not be found"%str(indices_list))   
 
     def get_coef_at_position(self, pos):
         """ Returns the coefficient at position pos in the one dimensional
@@ -870,7 +870,7 @@ class FromGolem95FortranCodeGenerator():
         for num_eq in range(l):
             q = map(lambda i: cls.PRIMES[i], lst[num_eq])
             coeffs = [
-                reduce(lambda x,y: x*y, map(lambda (b,e): b**e, zip(q, term)), 1)
+                reduce(lambda x,y: x*y, map(lambda b,e: b**e, zip(q, term)), 1)
                 for term in lst]
             LHS.append(coeffs)
             RHS.append(q)
@@ -906,16 +906,16 @@ if __name__ == '__main__':
     """I test here the write_golem95_mapping function"""
     
     P=Polynomial(7)
-    print "Coef (6,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0])
-    print "Coef (1,1,2,2) is at pos %s"%P.get_coef_position([0,1,2,2,3,3])
-    print "Coef (7,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0,0])
-    print "Coef (1,2,2,2) is at pos %s"%P.get_coef_position([0,1,1,2,2,3,3])
+    print( "Coef (6,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0]))
+    print( "Coef (1,1,2,2) is at pos %s"%P.get_coef_position([0,1,2,2,3,3]))
+    print( "Coef (7,0,0,0) is at pos %s"%P.get_coef_position([0,0,0,0,0,0,0]))
+    print( "Coef (1,2,2,2) is at pos %s"%P.get_coef_position([0,1,1,2,2,3,3]))
     
     sys.exit(0)
 
     max_rank=6
     FPR=FortranPolynomialRoutines(max_rank)
-    print "Output of write_golem95_mapping function for max_rank=%d:\n\n"%max_rank
+    print( "Output of write_golem95_mapping function for max_rank=%d:\n\n"%max_rank)
 
     import os
     import sys
diff -rupN MadGraph_pristine/madgraph/various/shower_card.py ../contrib/MadGraph/madgraph/various/shower_card.py
--- MadGraph_pristine/madgraph/various/shower_card.py	2020-10-27 21:41:37.893090278 +1100
+++ ../contrib/MadGraph/madgraph/various/shower_card.py	2020-10-29 23:48:54.824703740 +1100
@@ -130,7 +130,7 @@ class ShowerCard(dict):
         if key in self.logical_vars:
             try:
                 self[key] = banner.ConfigFile.format_variable(value, bool, key)
-            except InvalidCmd, error:
+            except InvalidCmd as error:
                 raise ShowerCardError(str(error))
         elif key in self.string_vars:
             if value.lower() == 'none':
@@ -140,12 +140,12 @@ class ShowerCard(dict):
         elif key in self.int_vars:
             try:
                 self[key] = banner.ConfigFile.format_variable(value, int, key)
-            except InvalidCmd, error:
+            except InvalidCmd as error:
                 raise ShowerCardError(str(error))
         elif key in self.float_vars:
             try:
                 self[key] =  banner.ConfigFile.format_variable(value, float, key)
-            except InvalidCmd, error:
+            except InvalidCmd as error:
                 raise ShowerCardError(str(error))
         else:
             raise ShowerCardError('Unknown entry: %s = %s' % (key, value))
diff -rupN MadGraph_pristine/models/check_param_card.py ../contrib/MadGraph/models/check_param_card.py
--- MadGraph_pristine/models/check_param_card.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/check_param_card.py	2020-10-29 23:55:27.753295581 +1100
@@ -3,7 +3,12 @@ from __future__ import division
 import itertools
 import xml.etree.ElementTree as ET
 import math
-import StringIO
+
+try:
+    import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 import os
 import re
 import shutil
@@ -174,7 +179,7 @@ class Block(list):
             return self.param_dict[tuple(lhacode)]
         except KeyError:
             if default is None:
-                raise KeyError, 'id %s is not in %s' % (tuple(lhacode), self.name)
+                raise KeyError('id %s is not in %s' % (tuple(lhacode), self.name))
             else:
                 return Parameter(block=self, lhacode=lhacode, value=default,
                                                            comment='not define')
@@ -227,8 +232,8 @@ class Block(list):
             
         if tuple(obj.lhacode) in self.param_dict:
             if self.param_dict[tuple(obj.lhacode)].value != obj.value:
-                raise InvalidParamCard, '%s %s is already define to %s impossible to assign %s' % \
-                    (self.name, obj.lhacode, self.param_dict[tuple(obj.lhacode)].value, obj.value)
+                raise InvalidParamCard('%s %s is already define to %s impossible to assign %s' % \
+                    (self.name, obj.lhacode, self.param_dict[tuple(obj.lhacode)].value, obj.value))
             return
         list.append(self, obj)
         # update the dictionary of key
@@ -486,7 +491,7 @@ class ParamCard(dict):
                 model_value = parameters[particle.get('mass')]
                 if isinstance(model_value, complex):
                     if model_value.imag > 1e-5 * model_value.real:
-                        raise Exception, "Mass should be real number: particle %s (%s) has mass: %s"  % (lhacode, particle.get('name'), model_value)
+                        raise Exception("Mass should be real number: particle %s (%s) has mass: %s"  % (lhacode, particle.get('name'), model_value))
                     model_value = model_value.real
                     
                 if not misc.equal(model_value, param_value, 4):
@@ -510,7 +515,7 @@ class ParamCard(dict):
                 model_value = parameters[particle.get('width')]
                 if isinstance(model_value, complex):
                     if model_value.imag > 1e-5 * model_value.real:
-                        raise Exception, "Width should be real number: particle %s (%s) has mass: %s" 
+                        raise Exception("Width should be real number: particle %s (%s) has mass: %s" )
                     model_value = model_value.real
                 if not misc.equal(abs(model_value), param_value, 4):
                     modify = True
@@ -683,14 +688,14 @@ class ParamCard(dict):
             return
         
         if len(internal_param)!=1:
-            raise InvalidParamCard,' The specified EW inputs has more than one'+\
-                ' unknown: [%s]'%(','.join([str(elem) for elem in internal_param]))
+            raise InvalidParamCard(' The specified EW inputs has more than one'+\
+                ' unknown: [%s]'%(','.join([str(elem) for elem in internal_param])))
         
         
         if not internal_param[0] in [('mass',(24,)), ('sminputs',(2,)),
                                                              ('sminputs',(1,))]:
-            raise InvalidParamCard, ' The only EW input scheme currently supported'+\
-                        ' are those with either the W mass or GF left internal.'
+            raise InvalidParamCard(' The only EW input scheme currently supported'+\
+                        ' are those with either the W mass or GF left internal.')
         
         # Now if the Wmass is internal, then we must change the scheme
         if internal_param[0] == ('mass',(24,)):
@@ -784,13 +789,13 @@ class ParamCard(dict):
         
         if not lhacode:
             logger.info("Information on block parameter %s:" % block, '$MG:color:BLUE')
-            print  str(self[block])
+            print(str(self[block]))
         elif default:
             pname2block, restricted = default.analyze_param_card()
             if (block, lhacode) in restricted:
                 logger.warning("This parameter will not be consider by MG5_aMC")
                 print( "    MadGraph will use the following formula:")
-                print restricted[(block, lhacode)]
+                prin(restricted[(block, lhacode)])
                 print( "     Note that some code (MadSpin/Pythia/...) will read directly the value")  
             else:
                 for name, values in pname2block.items():
@@ -856,7 +861,7 @@ class ParamCard(dict):
             if param.value != value:
                 error_msg = 'This card is not suitable to be convert to SLAH1\n'
                 error_msg += 'Parameter %s %s should be %s' % (block, lhacode, value)
-                raise InvalidParamCard, error_msg   
+                raise InvalidParamCard(error_ms)   
             self.remove_param(block, lhacode)
 
 
@@ -942,15 +947,15 @@ class ParamCardIterator(ParamCard):
                     try:
                         key, def_list = pattern.findall(param.value)[0]
                     except:
-                        raise Exception, "Fail to handle scanning tag: Please check that the syntax is valid"
+                        raise Exception("Fail to handle scanning tag: Please check that the syntax is valid")
                     if key == '': 
                         key = -1 * len(all_iterators)
                     if key not in all_iterators:
                         all_iterators[key] = []
                     try:
                         all_iterators[key].append( (param, eval(def_list)))
-                    except SyntaxError, error:
-                        raise Exception, "Fail to handle your scan definition. Please check your syntax:\n entry: %s \n Error reported: %s" %(def_list, error)
+                    except SyntaxError as error:
+                        raise Exception("Fail to handle your scan definition. Please check your syntax:\n entry: %s \n Error reported: %s" %(def_list, error))
                 elif isinstance(param.value, str) and param.value.strip().lower().startswith('auto'):
                     self.autowidth.append(param)
         keys = all_iterators.keys() # need to fix an order for the scan
@@ -958,7 +963,7 @@ class ParamCardIterator(ParamCard):
         #store the type of parameter
         for key in keys:
             for param, values in all_iterators[key]:
-                self.param_order.append("%s#%s" % (param.lhablock, '_'.join(`i` for i in param.lhacode)))
+                self.param_order.append("%s#%s" % (param.lhablock, '_'.join(repr(i) for i in param.lhacode)))
             
         # do the loop
         lengths = [range(len(all_iterators[key][0][1])) for key in keys]
@@ -1276,8 +1281,8 @@ class ParamCardRule(object):
             else:
                 if value != 0:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not at zero' % \
-                                    (block, ' '.join([str(i) for i in id])) 
+                        raise InvalidParamCard('parameter %s: %s is not at zero' % \
+                                    (block, ' '.join([str(i) for i in id])) )
                     else:
                         param = card[block].get(id) 
                         param.value = 0.0
@@ -1307,8 +1312,8 @@ class ParamCardRule(object):
             else:   
                 if value != 1:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not at one but at %s' % \
-                                    (block, ' '.join([str(i) for i in id]), value)         
+                        raise InvalidParamCard('parameter %s: %s is not at one but at %s' % \
+                                    (block, ' '.join([str(i) for i in id]), value))         
                     else:
                         param = card[block].get(id) 
                         param.value = 1.0
@@ -1343,9 +1348,9 @@ class ParamCardRule(object):
 
                 if value1 != value2:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not to identical to parameter  %s' % \
+                        raise InvalidParamCard('parameter %s: %s is not to identical to parameter  %s' % \
                                     (block, ' '.join([str(i) for i in id1]),
-                                            ' '.join([str(i) for i in id2]))         
+                                            ' '.join([str(i) for i in id2])))         
                     else:
                         param = card[block].get(id1) 
                         param.value = value2
@@ -1372,9 +1377,9 @@ class ParamCardRule(object):
 
                 if value1 != -value2:
                     if not modify:
-                        raise InvalidParamCard, 'parameter %s: %s is not to opposite to parameter  %s' % \
+                        raise InvalidParamCard('parameter %s: %s is not to opposite to parameter  %s' % \
                                     (block, ' '.join([str(i) for i in id1]),
-                                            ' '.join([str(i) for i in id2]))         
+                                            ' '.join([str(i) for i in id2])))         
                     else:
                         param = card[block].get(id1) 
                         param.value = -value2
@@ -1648,8 +1653,8 @@ def convert_to_mg5card(path, outputpath=
     ae = card['ae'].get([1, 1], default=0).value
     card.mod_param('ae', [1,1], 'te', [1,1], value= ae * ye, comment='T_e(Q) DRbar')
     if ae * ye:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ae [1, 1] times ye [1,1] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ae [1, 1] times ye [1,1] should be 0''')
     card.remove_param('ae', [1,1])
     #2
     ye = card['ye'].get([2, 2], default=0).value
@@ -1657,8 +1662,8 @@ Parameter ae [1, 1] times ye [1,1] shoul
     ae = card['ae'].get([2, 2], default=0).value
     card.mod_param('ae', [2,2], 'te', [2,2], value= ae * ye, comment='T_mu(Q) DRbar')
     if ae * ye:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ae [2, 2] times ye [2,2] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ae [2, 2] times ye [2,2] should be 0''')
     card.remove_param('ae', [2,2])
     #3
     ye = card['ye'].get([3, 3], default=0).value
@@ -1670,8 +1675,8 @@ Parameter ae [2, 2] times ye [2,2] shoul
     au = card['au'].get([1, 1], default=0).value
     card.mod_param('au', [1,1], 'tu', [1,1], value= au * yu, comment='T_u(Q) DRbar')
     if au * yu:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter au [1, 1] times yu [1,1] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter au [1, 1] times yu [1,1] should be 0''')
     card.remove_param('au', [1,1])
     #2
     ye = card['yu'].get([2, 2], default=0).value
@@ -1679,8 +1684,8 @@ Parameter au [1, 1] times yu [1,1] shoul
     ae = card['au'].get([2, 2], default=0).value
     card.mod_param('au', [2,2], 'tu', [2,2], value= au * yu, comment='T_c(Q) DRbar')
     if au * yu:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter au [2, 2] times yu [2,2] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter au [2, 2] times yu [2,2] should be 0''')
     card.remove_param('au', [2,2])
     #3
     yu = card['yu'].get([3, 3]).value
@@ -1692,8 +1697,8 @@ Parameter au [2, 2] times yu [2,2] shoul
     ad = card['ad'].get([1, 1], default=0).value
     card.mod_param('ad', [1,1], 'td', [1,1], value= ad * yd, comment='T_d(Q) DRbar')
     if ad * yd:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ad [1, 1] times yd [1,1] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ad [1, 1] times yd [1,1] should be 0''')
     card.remove_param('ad', [1,1])
     #2
     ye = card['yd'].get([2, 2], default=0).value
@@ -1701,8 +1706,8 @@ Parameter ad [1, 1] times yd [1,1] shoul
     ae = card['ad'].get([2, 2], default=0).value
     card.mod_param('ad', [2,2], 'td', [2,2], value= ad * yd, comment='T_s(Q) DRbar')
     if ad * yd:
-        raise InvalidParamCard, '''This card is not suitable to be converted to MSSM UFO model
-Parameter ad [2, 2] times yd [2,2] should be 0'''
+        raise InvalidParamCard('''This card is not suitable to be converted to MSSM UFO model
+Parameter ad [2, 2] times yd [2,2] should be 0''')
     card.remove_param('ad', [2,2])
     #3
     yd = card['yd'].get([3, 3]).value
diff -rupN MadGraph_pristine/models/__init__.py ../contrib/MadGraph/models/__init__.py
--- MadGraph_pristine/models/__init__.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/__init__.py	2020-10-29 23:48:54.828703692 +1100
@@ -44,8 +44,8 @@ def load_model(name, decay=False):
         model_path = os.path.realpath(os.sep.join(path_split))
         sys_path = os.path.realpath(os.path.dirname(sys.modules[path_split[-1]].__file__))
         if sys_path != model_path:
-            raise Exception, 'name %s already consider as a python library cann\'t be reassigned(%s!=%s)' % \
-                (path_split[-1], model_path, sys_path) 
+            raise Exception('name %s already consider as a python library cann\'t be reassigned(%s!=%s)' % \
+                (path_split[-1], model_path, sys_path) )
 
     with misc.TMP_variable(sys, 'path', [os.sep.join(path_split[:-1])]):
         __import__(path_split[-1])
diff -rupN MadGraph_pristine/models/model_reader.py ../contrib/MadGraph/models/model_reader.py
--- MadGraph_pristine/models/model_reader.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/model_reader.py	2020-10-29 23:48:54.828703692 +1100
@@ -79,7 +79,7 @@ class ModelReader(loop_base_objects.Loop
             if isinstance(param_card, basestring):
                 # Check that param_card exists
                 if not os.path.isfile(param_card):
-                    raise MadGraph5Error, "No such file %s" % param_card
+                    raise MadGraph5Error("No such file %s" % param_card)
                 param_card_text = param_card
                 param_card = card_reader.ParamCard(param_card)
             #misc.sprint(type(param_card), card_reader.ParamCard,  isinstance(param_card, card_reader.ParamCard))
@@ -155,11 +155,11 @@ class ModelReader(loop_base_objects.Loop
                                 fail = False
                     except Exception:
                         raise
-                        raise MadGraph5Error, msg
+                        raise MadGraph5Error(msg)
                         
                 
                 if fail:
-                    raise MadGraph5Error, msg
+                    raise MadGraph5Error(msg)
 
             for block in key:
                 if block not in parameter_dict:
@@ -168,7 +168,7 @@ class ModelReader(loop_base_objects.Loop
                     try:
                         value = param_card[block].get(pid).value
                     except:
-                        raise MadGraph5Error, '%s %s not define' % (block, pid)
+                        raise MadGraph5Error('%s %s not define' % (block, pid))
                     else:
                         if isinstance(value, str) and value.lower() == 'auto':
                             value = '0.0' 
@@ -176,7 +176,7 @@ class ModelReader(loop_base_objects.Loop
                             runner = Alphas_Runner(value, nloop=2)
                             try:
                                 value = runner(scale)
-                            except ValueError, err:
+                            except ValueError as err:
                                 if str(err) == 'math domain error' and scale < 1:
                                     value = 0.0
                                 else:
@@ -214,7 +214,7 @@ class ModelReader(loop_base_objects.Loop
                 exec("locals()[\'%s\'] = %s" % (param.name, param.expr))
             except Exception as error:
                 msg = 'Unable to evaluate %s = %s: raise error: %s' % (param.name,param.expr, error)
-                raise MadGraph5Error, msg
+                raise MadGraph5Error(msg)
             param.value = complex(eval(param.name))
             if not eval(param.name) and eval(param.name) != 0:
                 logger.warning("%s has no expression: %s" % (param.name,
diff -rupN MadGraph_pristine/models/write_param_card.py ../contrib/MadGraph/models/write_param_card.py
--- MadGraph_pristine/models/write_param_card.py	2020-10-27 21:41:37.885090150 +1100
+++ ../contrib/MadGraph/models/write_param_card.py	2020-10-29 23:48:54.828703692 +1100
@@ -219,7 +219,7 @@ class ParamCardWriter(object):
             info = info[4:]
     
         if param.value.imag != 0:
-            raise ParamCardWriterError, 'All External Parameter should be real (not the case for %s)'%param.name
+            raise ParamCardWriterError('All External Parameter should be real (not the case for %s)'%param.name)
     
 
         # avoid to keep special value used to avoid restriction
@@ -265,7 +265,7 @@ class ParamCardWriter(object):
             if part["type"] == "ghost":
                 continue
             if self.model['parameter_dict'][param.name].imag:
-                raise ParamCardWriterError, 'All Mass/Width Parameter should be real (not the case for %s)'%param.name
+                raise ParamCardWriterError('All Mass/Width Parameter should be real (not the case for %s)'%param.name)
             value = complex(self.model['parameter_dict'][param.name]).real
             text += """%s %s %e # %s : %s \n""" %(prefix, part["pdg_code"], 
                         value, part["name"], param.expr.replace('mdl_',''))  
@@ -280,7 +280,7 @@ class ParamCardWriter(object):
     
         for part, param in data:
             if self.model['parameter_dict'][param.name].imag:
-                raise ParamCardWriterError, 'All Mass/Width Parameter should be real'
+                raise ParamCardWriterError('All Mass/Width Parameter should be real')
             value = complex(self.model['parameter_dict'][param.name]).real
             text += """%s %s %e # %s : %s \n""" %(prefix, part["pdg_code"], 
                         value, part["name"], part[name].replace('mdl_',''))
@@ -336,5 +336,5 @@ class ParamCardWriter(object):
             
 if '__main__' == __name__:
     ParamCardWriter('./param_card.dat', generic=True)
-    print 'write ./param_card.dat'
+    print('write ./param_card.dat')
     
diff -rupN MadGraph_pristine/vendor/ply/yacc.py ../contrib/MadGraph/vendor/ply/yacc.py
--- MadGraph_pristine/vendor/ply/yacc.py	2020-10-27 21:41:37.909090533 +1100
+++ ../contrib/MadGraph/vendor/ply/yacc.py	2020-10-29 23:48:54.828703692 +1100
@@ -89,7 +89,12 @@ resultlimit = 40               # Size li
 pickle_protocol = 0            # Protocol to use when writing pickle files
 
 import re, types, sys, os.path
-from cStringIO import StringIO
+
+try:
+    from cStringIO import StringIO ## for Python 2
+except ImportError:
+    from io import StringIO ## for Python 3
+
 
 # Compatibility function for python 2.6/3.0
 if sys.version_info[0] < 3:
