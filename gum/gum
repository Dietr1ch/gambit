#!/usr/bin/env python

"""
GUM - GAMBIT Universal Models
"""

import sys
if not sys.version_info[0] == 2 or sys.version_info[1] < 6:
    sys.exit('Please use python 2.6 or later -- but not python 3.')

import argparse
import numpy as np

from src import *

parser = argparse.ArgumentParser(description="From Lagrangian to scans: GUM "
                                             "(GAMBIT Universal Models)")
required = parser.add_argument_group('Required arguments'  )
required.add_argument('-f', '--file', type=str,
                      help="Specify input .GUM file.", required=True)
parser.add_argument("-d", "--dryrun", action='store_true',
                    help="GUM will perform a dry run, not saving any output.")
parser._action_groups.append(required)
args = parser.parse_args()

# Input .gum file.
if args.file:

    if args.dryrun:
        print("**********************************************************")
        print("GUM called with a dry run -- will not be writing to files!")
        print("**********************************************************")

    # Parse the .gum file
    inputs = check_gum_file(args.file)
    gum, output_opts = fill_gum_object(inputs)

    # First, check the required backends are installed
    check_backends(output_opts)

    if gum.dm_pdg:
        darkbit = True
    else:
        darkbit = False
        print(("No DM candidate requested -- no DarkBit routines will "
               "be written.\n"))

    if output_opts.ch or output_opts.sph:
        decaybit = True
    else:
        decaybit = False

    # FeynRules
    if gum.math == 'feynrules':
        from lib.libfr import *
        options = FROptions("feynrules", gum.name, gum.restriction, gum.LTot)
        partlist = FRVectorOfParticles()
        paramlist = FRVectorOfParameters()
        outputs = FROutputs()
        backends = FRBackends()
        backends.extend(x for x in output_opts.bes())

        # Hit it
        all_feynrules(options, partlist, paramlist, outputs, backends)

        # Get a list of all non-SM particles
        fr_bsm = [x for x in partlist if x.SM() is False]

        # Make all BSM particles work with GUM's native Particle class.
        bsm_particle_list = fr_part_to_gum_part(fr_bsm)

    elif gum.math == 'sarah':
        from lib.libsarah import *
        options = SARAHOptions("sarah", gum.name, '')
        partlist = SARAHVectorOfParticles()
        paramlist = SARAHVectorOfParameters()
        outputs = SARAHOutputs()
        backends = SARAHBackends()
        backends.extend(x for x in output_opts.bes())

        # Hit it
        all_sarah(options, partlist, paramlist, outputs, backends)

        # Get a list of all non-SM particles
        sarah_bsm = [x for x in partlist if x.SM() is False]

        # Make all BSM particles work with GUM's native Particle class.
        bsm_particle_list = sarah_part_to_gum_part(sarah_bsm)

    # Initialise DM particle from particle list
    if darkbit:
        for i in xrange(len(partlist)):
            part = partlist[i]
            # If specified, initialise the DM candidate
            if darkbit:
                if part.pdg() == gum.dm_pdg:
                    dm = Particle(part.spinX2(), part.pdg(),
                                  part.SC(), part.mass())

    # If we haven't found the DM candidate in the particle list...
    if darkbit and not dm:
        raise GumError(("\n\nThe DM candidate specified has not been found "
                        "in the {0} file. Please check your .gum "
                        "file as well as the {0} file.").format(gum.math))

    print("Adding new model {0} to GAMBIT...\n").format(gum.name)

    # Need to know how GAMBIT refers to each particle. Scrape information
    # from particle_database.yaml.
    gambit_pdgs, decaybit_dict = get_gambit_particle_pdg_dict()

    # Check every new particle is in the database
    # TODO: Add particles to particleDB automatically
    if not (check_all_particles_present(partlist, gambit_pdgs)):
        raise GumError()

    # Clean up calchep files, then copy them to the GAMBIT backendDir
    if output_opts.ch:
        clean_calchep_model_files(outputs.get_ch(), gum.name)
        copy_calchep_files(outputs.get_ch(), gum.name)

    # Move MadGraph files to contrib/MadGraph/models
    if output_opts.ufo:
        copy_madgraph_files(outputs.get_mg(), gum.name)

    # Add the BSM masses to the model parameters

    # Initialise all of the model parameters, for writing spectra, model files..
    model_parameters = []

    # Add all new particle masses as Pole Masses... I think this is ok?
    for i in xrange(len(bsm_particle_list)):
        x = bsm_particle_list[i]
        model_parameters.append(SpectrumParameter(pdg_to_particle(x.PDG_code,
                                                                  gambit_pdgs),
                                                  "Pole_Mass",
                                                  gb_input=x.mass))

    # Todo - get this information -- properly -- from 'paramlist'
    # Same name in GAMBIT as in Backends?
    model_parameters.append(SpectrumParameter("vev", "mass1", sm=True))
    model_parameters.append(SpectrumParameter("lambda_hS", "dimensionless",fullname="lambdahs"))
    model_parameters.append(SpectrumParameter("g1", "dimensionless", "scalar", sm=True))
    model_parameters.append(SpectrumParameter("g2", "dimensionless", "scalar", sm=True))
    model_parameters.append(SpectrumParameter("g3", "dimensionless", "scalar", sm=True))
    model_parameters.append(SpectrumParameter("sinW2", "dimensionless", "scalar", sm=True))
    model_parameters.append(SpectrumParameter("Yd", "dimensionless", "m3x3", sm=True))
    model_parameters.append(SpectrumParameter("Yu", "dimensionless", "m3x3", sm=True))
    model_parameters.append(SpectrumParameter("Ye", "dimensionless", "m3x3", sm=True))

    """
    MODELS
    """

    # Will have to be extracted, somehow - from FR/SARAH/etc.
    gambit_model_params = ["mS", "lam_hS"]

    # Translation functions for model hierarchy. These will have to be
    # user specified.
    translation_functions_p = {"lam_hS": "lambda_hS*2"}
    tf_c = {}
    tf_f = {}

    ## TODO
    model_header, model_source = add_to_model_hierarchy(gum.new_spectrum,
                                                        gum.spec, gum.name,
                                                        gambit_model_params,
                                                        gum.parent,
                                                        gum.children,
                                                        gum.friends,
                                                        translation_functions_p,
                                                        tf_c, tf_f)

    spec_contents = write_spectrumcontents(gum.name, model_parameters)
    subspec_wrapper = write_subspectrum_wrapper(gum.name, model_parameters)
    reg_spec, reg_spec_num = add_to_registered_spectra(gum.name)

    """
    VERTICES
    """
    # Conditional on CalcHEP files being made.
    if output_opts.ch:
        # Obtain all model interactions from CalcHEP model files.
        interactions, calchep_pdg_codes = get_vertices(outputs.get_ch())

        # Obtain all 3-point vertices that are BSM.
        three_pi_bsm = [interaction.particles for interaction in interactions
                        if interaction.num_particles() == 3
                        and interaction.is_sm() == False]

        three_body_decays = decay_sorter(three_pi_bsm)
    else:
        calchep_pdg_codes = None

    """
    DECAYS
    """

    if decaybit:

        # CalcHEP specific decays
        if output_opts.ch:
            decaybit_src_ch = ""

            # Pass all interactions by first PDG code needed.
            for i in xrange(len(three_body_decays)):
                decaybit_src_ch += write_decaytable_entry(three_body_decays[i],
                                                          gum.name,
                                                          calchep_pdg_codes,
                                                          gambit_pdgs,
                                                          decaybit_dict)

            decay_roll, new_decays = \
                write_decaybit_rollcall_entry(gum.name, gum.spec,
                                              three_body_decays,
                                              decaybit_dict, gambit_pdgs)

            all_decays_src, all_decays_header = \
                amend_all_decays(gum.name, gum.spec, new_decays)

        # TODO - decays from SPheno

    """
    DARKBIT
    """
    if darkbit:

        pc = None
        dd = None
        mo = None
        mdm = None
        ann_products = None
        propagators = None

        # Conditional on CalcHEP files being made.
        if output_opts.ch:

            print("Writing process catalogue output in DarkBit.")

            # Write process catalogue output
            pc = True

            # Obtain all three-field vertices
            three_f = [interaction.particles for interaction in interactions
                       if interaction.num_particles() == 3]
            # And all 4-point BSM vertices
            four_f = [interaction.particles for interaction in interactions
                      if interaction.num_particles() == 4
                      and interaction.is_sm() == False]

            # Get all annihilation products and propagators involved in
            # DM + DM -> X + Y at tree-level
            ann_products, propagators = sort_annihilations(dm, three_f, four_f)

        # If micrOMEGAs requested
        if output_opts.mo:

            print("Writing micrOMEGAs interface for DarkBit.")
            # TODO: write simple frontend for MO.

        """
        # If MadDM requested
        if output_opts.mdm:

            print("Writing MadDM interface for DarkBit.")
            # TODO: backend MadDM...

        # TODO - pass over required information for direct detection
        # DirectDM?
        if output_opts.ddm:

            print("Writing direct detection interface for DarkBit.")

            # Write direct detection interface
            dd = True
        """

        darkbit_src = write_darkbit_src(dm, pc, dd, ann_products, propagators,
                                        gambit_pdgs, gum.name,
                                        calchep_pdg_codes, bsm_particle_list)
        pc_cap, dd_cap, dmid_cap = write_darkbit_rollcall(gum.name, pc, dd)

    """
    SPECBIT
    """

    # Determine when "simple_SMinputs" needed from FR/S model file
    spectrum_src = write_basic_spectrum(gum.name, model_parameters, gum.spec,
                                        simple_SMinputs = True)
    spectrum_header = write_spectrum_header(gum.name)
    spec_rollcall = write_specbit_rollcall(gum.name)

    """
    BACKENDS
    """
    # Conditional on CalcHEP files being made.
    if output_opts.ch: # If no parent
        ch_src_sl, ch_src_pl, ch_head = add_calchep_switch(gum.name, gum.spec)

    # If it's a dry run
    if args.dryrun:
        print("")
        print("Dry run finished.")
        print("")
        exit()

    print("")
    print("Everything has gone smoothly so far.")
    print("Now to write some GAMBIT code...")
    print("")

    # All file writing routines HERE, once everything has gone okay.

    # Models
    m = "Models"
    write_file("models/" + gum.name, m, model_header, True)
    write_file("models/" + gum.name, m, model_source, False) # If no parent!
    write_file("SpectrumContents/" + gum.name, m, spec_contents, False)
    write_file("SimpleSpectra/" + gum.name + "SimpleSpec", m,
               subspec_wrapper, True)

    # SpecBit
    m = "SpecBit"
    write_file("SpecBit_" + gum.name, m, spectrum_src, False)
    write_file("SpecBit_" + gum.name, m, spectrum_header, True)
    write_file("SpecBit_" + gum.name + "_rollcall", m, spectrum_header, True)
    num = find_string("SpecBit_rollcall", m, "SpecBit_tests_rollcall.hpp",
                      True)[1]
    amend_file("SpecBit_rollcall", m, spec_rollcall, num, True)

    # DecayBit
    if decaybit:
        m = "DecayBit"
        # Append to the end of DecayBit -- just before all_decays
        num = find_string("DecayBit", m, "void all_decays")[1]
        if output_opts.ch:
            amend_file("DecayBit", m, decaybit_src_ch, num-4, False)
            for i in xrange(len(decay_roll)):
                if find_capability(decay_roll[i][0], m)[0]:
                    amend_rollcall(decay_roll[i][0], m, decay_roll[i][1])
                else:
                    num = find_string("DecayBit_rollcall", m,
                                      "#define CAPABILITY decay_rates", True)[1]
                    amend_file("DecayBit_rollcall", m, decay_roll[i][1],
                               num-4, True)
            if len(new_decays) > 0:
                num = find_string("DecayBit_rollcall", m,
                                  "DEPENDENCY(omega_decay_rates", True)[1]
                amend_file("DecayBit_rollcall", m, all_decays_header, num, True)
                num = find_string("DecayBit", m, "decays(\"omega\")", False)[1]
                amend_file("DecayBit", m, all_decays_src, num, False)

    # DarkBit
    if darkbit:
        m = "DarkBit"
        write_file(gum.name, m, darkbit_src, False)
        if pc:
            amend_rollcall("TH_ProcessCatalog", m, pc_cap)
        if dd:
            amend_rollcall("DD_couplings", m, dd_cap)
        amend_rollcall("DarkMatter_ID", m, dmid_cap)

    # ColliderBit
    m = "ColliderBit"

    # Backends
    m = "Backends"
    if output_opts.ch:
        f = "frontends/CalcHEP_3_6_27"
        num = find_string(f, m, "setModel(modeltoset, 1)", False)[1]
        amend_file(f, m, ch_src_sl, num, False)
        num = find_string(f, m, "END_BE_INI_FUNCTION", False)[1]
        amend_file(f, m, ch_src_pl, num-2, False)
        num = find_string(f, m, "backend_undefs.hpp", True)[1]
        amend_file(f, m, ch_head, num-2, True)
        num = find_string(f, m, "BE_FUNCTION", True)[1]
        amend_file(f, m, "BE_ALLOW_MODELS({0})".format(gum.name), num-2, True)

    print("")
    print("GUM has finished successfully!")
    print("Please (re)compile GAMBIT.")
    print("")

else:
    raise GumError(("\n\n\tHi! You must be new here. Usage: gum -f inifile.gum"
                    "\n\tOr try gum -h for help."))
