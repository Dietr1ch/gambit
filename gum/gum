#!/usr/bin/env python

"""
GUM - GAMBIT Universal Models
"""

import argparse
import numpy as np

from setup import *
from parse import *
from files import *
from models import *
from feynrules import *
from calchep import *
from decays import *
from spectrum import *
from particledb import *
from darkbit import *

parser = argparse.ArgumentParser(description="From Lagrangian to scans: GAMBIT "
                                             "writing your papers for you.")
parser.add_argument("-f", type=str, help="Specify input .GUM file.")

args = parser.parse_args()

# Input .gum file.
if args.f:
  
    inputs = check_gum_file(args.f)
    gum = fill_gum_object(inputs) 
    
    ## TEMP
    fr_script = inputs['fr_script']
    calchep_model = inputs['calchep_model']
    ## TEMP
            
    print("Adding new model {0} to GAMBIT...\n").format(gum.name) 
    
  
    # Need to know how GAMBIT refers to each particle. Scrape information
    # from particle_database.yaml.
    gambit_pdg_codes, decaybit_dict = get_gambit_particle_pdg_dict()
  
    # Run FeynRules/SARAH -> generate the following:
    #  - CalcHEP files                                 DecayBit, DarkBit
    #  - (Basic) Spectrum object                       SpecBit
    #  - MadGraph (.ufo) files                         ColliderBit
    
    # SARAH only:
    #  - SPheno interface                              PrecisionBit, FlavBit, DecayBit
    #  - FlexibleSUSY model                            SpecBit, PrecisionBit?
    #  - VEVacious model files                         SpecBit

    # Unknown:
    #  - DirectDM interface                            DarkBit
  
    # FeynRules
    feynrules_path = '../../.Mathematica/Applications/feynrules-current/Models/SingletDM/SingletDM.fr'
  
    # if gum.math == 'FR':
    #   load_fr_model(fr_model)
    #   check_fr_model(fr_model)
    #   pdgs, params = parse_feynrules_model(fr_model)
    #   generate_output(options)
    
    # elif gum.math == 'SARAH':
    #   load_sarah_model(sarah_model)
    #   check_sarah_model(sarah_model)
    #   pdgs, params = parse_sarah_model(sarah_model)
    #   generate_output(options)   
  
    # Initialise DM as particle class.
    # This will be scraped from the FeynRules/SARAH file.
    dm = Particle(inputs['dm_candidate']['chargeX3'],
                  inputs['dm_candidate']['spinX2'],
                  gambit_pdg_codes[inputs['dm_candidate']['name']],
                  inputs['dm_candidate']['is_self_conjugate'])
    
    # Currently done from CHep, to be done from FR/SARAH
    bsm_particle_list = extract_particles(calchep_model, gum.name) 
    
    # Run CalcHEP_cleaner
    clean_calchep_model_files(calchep_model, gum.name)
  
    # Need to know how GAMBIT names each particle. (In each module, too.)
    gambit_pdg_codes, decaybit_dict = get_gambit_particle_pdg_dict()
      
    """
    MODELS
    """
    
    # Will have to be extracted, somehow - from FR/SARAH/etc.
    gambit_model_params = ["mS", "lam_hS"]
    
    # Translation functions for model hierarchy. These will have to be
    # user specified. 
    translation_functions_p = {"lam_hS": "lambda_hS*2"}
    tf_c = {}
    tf_f = {}
          
    ## TODO
    model_header, model_source = add_to_model_hierarchy(gum.new_spectrum, 
                                                        gum.spec, gum.name, 
                                                        gambit_model_params, 
                                                        gum.parent, 
                                                        gum.children, 
                                                        gum.friends, 
                                                        translation_functions_p,
                                                        tf_c, tf_f)
    
    ## Just a placeholder for now -- need to scrape these from SARAH/FeynRules files.
    model_parameters = []
    # Should be from particles
    model_parameters.append(SpectrumParameter("S", "Pole_Mass", gb_input="mS"))
    model_parameters.append(SpectrumParameter("h_01", "Pole_Mass",fullname="higgs", gb_input="mH"))
    # From parameters
    model_parameters.append(SpectrumParameter("vev", "mass1", sm=True))
    model_parameters.append(SpectrumParameter("lambda_hS", "dimensionless",fullname="lambdahs"))
    model_parameters.append(SpectrumParameter("g1", "dimensionless", "scalar", sm=True))
    model_parameters.append(SpectrumParameter("g2", "dimensionless", "scalar", sm=True))
    model_parameters.append(SpectrumParameter("g3", "dimensionless", "scalar", sm=True))
    model_parameters.append(SpectrumParameter("sinW2", "dimensionless", "scalar", sm=True))
    model_parameters.append(SpectrumParameter("Yd", "dimensionless", "m3x3", sm=True))
    model_parameters.append(SpectrumParameter("Yu", "dimensionless", "m3x3", sm=True))
    model_parameters.append(SpectrumParameter("Ye", "dimensionless", "m3x3", sm=True))
    
    spec_contents = write_spectrumcontents(gum.name, model_parameters)
    subspec_wrapper = write_subspectrum_wrapper(gum.name, model_parameters)
    reg_spec, reg_spec_num = add_to_registered_spectra(gum.name)
  
    """
    DECAYS
    """
    
    # Obtain all model interactions from CalcHEP model files.
    interactions, calchep_pdg_codes = get_vertices(calchep_model)
  
    # Obtain all 3-point vertices that are BSM.
    three_pi_bsm = [interaction.particles for interaction in interactions 
                    if interaction.num_particles() == 3
                    and interaction.is_sm() == False]
  
    three_body_decays = decay_sorter(three_pi_bsm)
      
    decaybit_src = ""
    
    # Pass all interactions by first PDG code needed.
    for i in xrange(len(three_body_decays)):
        decaybit_src += write_decaytable_entry(three_body_decays[i], gum.name,
                                               calchep_pdg_codes, 
                                               gambit_pdg_codes,
                                               decaybit_dict)
  
  
    """
    CROSS SECTIONS
    """
  
    # Obtain all three-field vertices
    three_fields = [interaction.particles for interaction in interactions 
                    if interaction.num_particles() == 3]
    # And all 4-point BSM vertices
    four_fields = [interaction.particles for interaction in interactions 
                   if interaction.num_particles() == 4
                   and interaction.is_sm() == False]
  
    ann_products, propagators = sort_annihilations(dm, three_fields,
                                                   four_fields)
                                                   
    # TODO - pass over required information for direct detection
    darkbit_src = write_darkbit_entry(dm, ann_products, propagators, 
                                      gambit_pdg_codes, gum.name, 
                                      calchep_pdg_codes, bsm_particle_list)
                                      
    pc_cap, dd_cap, dmid_cap = write_darkbit_rollcall(gum.name)
  
    """
    SPECTRA
    """
      
    spectrum_src = write_basic_spectrum(gum.name, model_parameters, gum.spec, 
                                        simple_SMinputs = True)
    ## TODO
    spectrum_header = write_spectrum_header(gum.name)
    spec_rollcall = write_specbit_rollcall(gum.name)
        
    print("")
    print("Everything has gone smoothly so far.")
    print("Now to write some GAMBIT code...")
    print("")
    
    # write to file, all code HERE 
   
    # Models
    m = "Models"
    write_file("models/" + gum.name, m, model_header, True)  
    write_file("models/" + gum.name, m, model_source, False) # If no parent!
    write_file("SpectrumContents/" + gum.name, m, spec_contents, False)
    write_file("SimpleSpectra/" + gum.name + "SimpleSpec", m, subspec_wrapper, True)
    
    # SpecBit
    m = "SpecBit"
    write_file("SpecBit_" + gum.name, m, spectrum_src, False)
    write_file("SpecBit_" + gum.name, m, spectrum_header, True)
    write_file("SpecBit_" + gum.name + "_rollcall", m, spectrum_header, True)
    num = find_string("SpecBit_rollcall", m, "SpecBit_tests_rollcall.hpp", True)[1]
    amend_file("SpecBit_rollcall", m, spec_rollcall, num, True)
    
    
    # DecayBit
    m = "DecayBit"
    num = find_string("DecayBit", m, "void all_decays")[1]
    amend_file("DecayBit", m, decaybit_src, num-4, False)
    # + rollcall
    
    # DarkBit
    m = "DarkBit"
    write_file(gum.name, m, darkbit_src, False)
    amend_rollcall("TH_ProcessCatalog", m, pc_cap)
    amend_rollcall("DD_couplings", m, dd_cap)
    amend_rollcall("DarkMatter_ID", m, dmid_cap)
    
    # ColliderBit
    m = "ColliderBit"
    
        
    print("")
    print("GUM has finished successfully!")
    print("Please (re)compile GAMBIT.")
    print("")

else:
    raise GumError(("Hi! You must be new here. Usage: ./gum -f inputfile.gum\n"
                    "Or try ./gum -h for help."))
